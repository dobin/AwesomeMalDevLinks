Title:
Exploring malicious Windows drivers (Part 2): the I/O system, IRPs, stack locations, IOCTLs and more

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post explains core Windows kernel I/O concepts that are essential for understanding and analyzing malicious (or vulnerable) Windows drivers.  
- It breaks down how the I/O Manager packages requests into IRPs, how IRPs traverse device stacks within the Plug and Play device tree, and how each driver layer uses its own I/O stack location to decide whether to process or forward a request.  
- The article connects user-mode request initiation (e.g., CreateFile/ReadFile/DeviceIoControl) to kernel-mode processing via dispatch routines and completion via IoCompleteRequest.  
- It introduces IOCTLs as driver-defined control interfaces delivered through IRP_MJ_DEVICE_CONTROL / IRP_MJ_INTERNAL_DEVICE_CONTROL, including how CTL_CODE encodes device type, function, method, and access.  
- This is useful for malware analysts, reverse engineers, and defenders hunting kernel threats, as well as red teamers assessing driver attack surface (especially IOCTL exposure and unsafe I/O handling).  
- It’s important because many real-world kernel compromises and EDR bypasses hinge on abusing driver I/O pathways, particularly poorly designed IOCTL handlers.

Technical Focus:
- Windows I/O Manager and IRP (_IRP) structure
- Device stacks/devnodes and the Plug and Play device tree (PDO/FDO/FiDO)
- IO_STACK_LOCATION and IRP major/minor function codes
- IRP dispatch routines, forwarding (IoSkipCurrentIrpStackLocation/IoCallDriver), and completion (IoCompleteRequest)
- IOCTL design and handling (IRP_MJ_DEVICE_CONTROL, CTL_CODE, DeviceIoControl)
- User-mode to kernel-mode request flow via device handles (CreateFile)

Use Cases:
- Reverse engineering a suspicious driver’s dispatch table and IRP handling logic
- Auditing IOCTL interfaces for privilege escalation primitives and unsafe buffer handling patterns
- Building a mental model for kernel telemetry/detections around driver I/O activity
- Developing or testing user-mode tooling that interacts with driver device objects via DeviceIoControl
- Understanding how filter drivers and layered stacks can intercept/modify I/O

Keywords:
Windows kernel, I/O Manager, IRP, _IRP, IO_STACK_LOCATION, device stack, devnode, device tree, Plug and Play, PnP manager, PDO, FDO, filter driver, FiDO, IRP_MJ_READ, IRP_MJ_DEVICE_CONTROL, IRP_MJ_INTERNAL_DEVICE_CONTROL, dispatch routine, IoCallDriver, IoCompleteRequest, IoSkipCurrentIrpStackLocation, IoGetCurrentIrpStackLocation, IOCTL, CTL_CODE, DeviceIoControl, CreateFile, ReadFile, DEVICE_OBJECT, wdm.h, KMDF, WDM