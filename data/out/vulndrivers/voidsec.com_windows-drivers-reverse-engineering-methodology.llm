Title:
Windows Drivers Reverse Engineering Methodology

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post documents a practical methodology for reverse engineering Windows WDM kernel drivers to identify attack surface and assess exploitability.  
- It walks through setting up a modern kernel-debugging lab (WinDbg Preview + VM debuggee) with correct symbol configuration and NET-based KD.  
- The author explains core driver concepts (DriverEntry, device objects/symlinks, IRP major functions, IRP_MJ_DEVICE_CONTROL) and how IOCTL dispatching maps user-mode DeviceIoControl calls to kernel code paths.  
- Using MSI Afterburner’s RTCore64.sys as a case study, it demonstrates static analysis in IDA to recover device names, dispatch routines, and IOCTL tables, then accelerates this with the Driver Buddy Reloaded IDA plugin.  
- Dynamic validation is shown via OSR Driver Loader and IOCTLpus to send crafted IOCTLs, rebase IDA to live kernel addresses, set breakpoints, and trace user-controlled buffers into sensitive operations.  
- It highlights dangerous primitives (wrmsr/rdmsr, MmMapIoSpace) and discusses why some apparent LPE paths are constrained (MSR blacklists, admin-only access, hypervisor MSR filtering, VBS).  
- Useful for kernel exploit dev, driver vulnerability researchers, and defenders auditing third-party signed drivers’ exposed IOCTL interfaces.

Technical Focus:
- WinDbg remote kernel debugging over NET (bcdedit /dbgsettings, symbols)
- WDM driver architecture: DriverEntry, DEVICE_OBJECT, DriverObject->MajorFunction, IRP dispatch
- IOCTL decoding (device/function/method/access) and METHOD_NEITHER vs buffered/direct I/O
- IDA-based driver RE + automation with Driver Buddy Reloaded (IOCTL extraction, API/opcode hunting)
- User↔kernel interaction via DeviceIoControl; buffer constraints and register control (x64 fastcall)
- Exploitability analysis of privileged primitives (WRMSR/LSTAR, MmMapIoSpace)

Use Cases:
- Reverse engineer third-party/signed Windows drivers to enumerate IOCTL attack surface
- Map IOCTL codes to internal handler functions for targeted auditing or fuzzing
- Build a kernel-driver debugging workflow (IDA + WinDbg) for live tracing and breakpointing
- Validate whether “interesting” primitives (MSR access, physical memory mapping) are reachable and controllable
- Create proof-of-concept IOCTL clients to reproduce crashes/bugs and assess LPE feasibility

Keywords:
Windows kernel, WDM, driver reverse engineering, WinDbg, kernel debugging, bcdedit, _NT_SYMBOL_PATH, PDB symbols, IDA Pro, DriverEntry, IRP, MajorFunction, IRP_MJ_DEVICE_CONTROL, DeviceIoControl, IOCTL, METHOD_BUFFERED, METHOD_NEITHER, DEVICE_OBJECT, IoCreateDevice, IoCreateSymbolicLink, OSR Driver Loader, RTCore64.sys, MSI Afterburner, Driver Buddy Reloaded, IOCTLpus, wrmsr, rdmsr, MSR, LSTAR, MmMapIoSpace, VBS, KASLR