# https://www.youtube.com/watch?v=39N9qJk55Ac

![Thumbnail (1920x1080)](https://i.ytimg.com/vi/39N9qJk55Ac/maxresdefault.jpg?sqp=-oaymwEmCIAKENAF8quKqQMa8AEB-AH-CYAC0AWKAgwIABABGBEgXChyMA8=&rs=AOn4CLCIakjD9Nta_ugMa4TE8TopDaS6rA)
# [Exploiting The Core: A Deep Dive Into Kernel Driver Vulnerability Hunting - Jan-Jaap Korpershoek](https://www.youtube.com/watch?v=39N9qJk55Ac)

**Visibility**: Public
**Uploaded by**: [OrangeCon](http://www.youtube.com/@OrangeCon)
**Uploaded at**: 2024-09-09T05:21:54-07:00
**Published at**: 2024-09-09T05:21:54-07:00
**Length**: 32:38
**Views**: 1460
**Likes**: 58
**Category**: People & Blogs

## Description

```

```

## Transcript

able this sorry yes my name is shap kopuk I'm a red teer and reverse engineer for North wve cyber security and in this talk I want to give you a primer into kernel driver vulnerability research uh specifically for Windows kernel drivers and my aim with this presentation is to give you the knowledge and the tools that you need to start your own research in this area um to do that I have different topics I want to discuss first I'll give a bit of context about offensive use of Kernel drivers then I'll discuss our own research at northwave and uh give some overview of that and then we'll do a deep dive into the technical details first uh about how drivers uh work and how they are used uh and then I will show you some common vulnerabilities that you might be able to find in kernal drivers if you start your own research and we'll end with some automated tools and conclusion imagine that this Castle is your computer security so you can see it has very steep walls uh it maybe has Watchers on the walls and this will pretty much keep uh an attacker out or so you think because if the whole system is actually built on a core that is instable or insecure uh an attacker that has access to the core can bypass any security measures and topple the whole system and this image also lets me show you a bit about the difference between user mode and kernel mode in user mode we have our normal user we even have our admin user um we even have uh elevated admin user as uh as time talk about in the previous talk and then we have one level lower uh the actual kernel um and on this level all security measures are basically off and um you can bypass a lot of the security measures that are normally existing we have also seen the power of Kernel drivers recently in the news um a small bug In One Security product CA a lot of computers and uh and systems on the over the whole world uh to topple and uh stop working and this shows you a bit about what an attacker can do with access to uh to Kernel driver vulnerabilities and indeed we see that attackers are also actively abusing kernel drivers in their attacks here we see a news article about a North Korean ABT and uh they use kernel drivers to uh gain more privileges on systems and also a financially motivated attacker uh that is described here they also use these kind of uh techniques to uh help their uh hacking attempts and also from the offensive security side uh the ethical hackers there are a lot of tools that uh that use kernel drivers this is an example by uh by outflank um a tool that can dump Els uh credentials uh through a kernel driver thereby bypassing some security measures in user space there's also a backstab blackout uh these tools have the same goal of disabling antivirus um by using a vulnerable kernel driver and there's also uh an initiative by security researchers called law drivers um and it contains a list of uh a lot of known drivers that are vulnerable in this way and can be used uh for malicious purposes and in a recent uh research uh published by kaspi we also see that the bring your own vulnerable driver attacks are really gaining popularity over the last years um so yeah that really shows you how important this is and um that is a nice Bridge into our own research in this area so let's first start with introducing the team I did not do this research on my own um I did it together with Alex our RS engineer at northwave uh also Ty momes the previous speaker when he still worked at northwave he also worked on this project and finally me so some statistics about our research um we we uh cre created a database of around 5,000 drivers and uh we filtered them to see which drivers have good potential for uh analysis I'll get to uh that later um and in these drivers that we manually analyzed of about 80 we found 35 vulnerabilities and 24 drivers so that gives you a bit of an indication in how large of a percentage of drivers uh are actually vulnerable if you do a bit of filtering um you can actually get get almost now well we got almost 30% uh uh vulnerable drivers uh of these 12 could be used for privilege escalation and uh for could disable the EDR in a similar way to uh backstab and uh the other prod project so some highlights of of our research we found a vulnerability in ivanti P secure um well this is a very uh well-known product and we found a way to do privilege escalation in uh the VPN client this is also posted on uh our blog um another one uh that we recently found is in macrium this is Enterprise backup software and we also found a way to do privilege escalation uh based on a a vulnerability in a driver of this software and uh a final highlight is uh log me in you might all noce from Ham muchi which used to be popular back in the day for for gaming um but it's also used in Enterprises and here we also found a privilege escalation in the remote desktop software and specifically the kernel driver used there so some highlights of what we can achieve now let's uh dive into getting you the tools to do similar research and get your own uh uh vulnerabilities so the first step to do research is to actually gather the drivers so how do you do that there are several sources that you can consider uh most obvious choice is uh the Microsoft update catalog this is um where Windows dri uh downloads drivers from if uh if you couple a certain device and it doesn't know the driver it gets it from this catalog and it's pretty to easy to to scrape this and uh extract all the all kinds of drivers from it a drawback that we found uh for this is that um because Microsoft has uh quite some strict policies for accepting drivers there is some security screening on the drivers in this catalog so we found that the amount of uh the percentage of vulnerable drivers in this catalog was lower than what we found in uh different ways so what you could also consider is going to vendor websites themselves this is just an example of a vendor but there are many uh vendors and you could scrape their pages and uh gather drivers in that way but that's obviously a lot of work and uh yeah uh um another source is driver identifier or the like there's a ton of uh of driver updator software uh in existence and you could um reverse engineer how they get their drivers and try to pull pull down their pull um the drivers out of their database and finally there's also virus total um this service is usually used to upload uh malware but a lot of people update upload also legitimate software there and it is cashed for anyone with the license to uh to download it and uh we also downloaded a lot of uh drivers from virus total for our uh research so that's also a source that uh I can recommend so once you have all these drivers there you need to do some filtering because there will be duplicates um there will be different versions of the same driver and um well in newer versions uh a vulnerability might already be fixed so it's really not worth looking into the older drivers at this point um so you want to keep only the reason most recent version um you can filter drivers uh by signature um because some vendors are known to pay close attention to their security for example Microsoft themselves um antivirus uh vendors so if you want to find easy vulnerabilities you might want to exclude uh those drivers um you want to find drivers that need no special permission so because if you have need to have special permission to interact with the device it's going to be more difficult to perform research on it and finally um you can also do some automated analysis uh at the end of the presentation I'll get to some tools that you can use for this this but if automated tools find um yeah bugs in the code or or interesting points to look at this can be a good starting point to start your manual research so once we have uh a list of our drivers the next step is to actually load them onto a test system so uh to do this uh we need to know about uh different types of drivers so there are Plug and Play drivers and there are the Legacy drivers Plug and Play basically works like this you connect a device to your computer and um the computer then loads the specific driver needed for that device um this means that if you want to analyze a driver you need to actually plug in the right device or find a way to spoof that device uh so that's a bit more tricky than looking at Legacy drivers which can manually be loaded or are just loaded at uh the system boot so for your first research I would recommend looking at the Legacy drivers because that is just uh easier and quicker um and specifically uh I would recommend looking at device drivers there are many different uh types of drivers uh and with different ways to communicate with them there's file system drivers there's network drivers um but the device drivers are the most easy to interact with there's just a simple system call that you can use to interact with it and um there's many exploitation examples for these types of uh drivers so uh this is really easy to get started for your own research so how do we actually load the drivers then well there's a very easy example um you can just download software from the vendor and run the vendor's installer to get the software but not always do you have the vendors installer so sometimes it can also be really easy to just um lose use the uh Service uh management tool from Windows to load the driver onto your system um I have put the commands here for a future reference so once the driver is loaded um we need to actually analyze the driver um so here I will dive into a bit of the technical details um I will first show you how a driver looks from a development perspective so uh in the C source code and then I will dive into how this looks in assembly from a reverse engineering perspective so uh a driver starts with the driver entry function as you may know um nor uh other software usually start from a main function well driver entry is basically the main function for the driver and it has uh a couple of tasks but the most important ones are uh creating a driver device at least that is for device drivers um well here it creates uh the device and this is actually the the object that can later be used to interact with the driver and after uh the object is created um it creates several handlers for different events that can happen with the dri so we see here create read write and device control um create is called when the user actually tries to communicate with the device um then read and write can be called when uh the user is reading reading from the driver device or writing to the driver device because it's basically a folder to or file to Windows and the final one is the most interesting to us um which is the device IO control Handler and this actually handles the uh explicit communication from the user with the driver and here we see the uh device IO control Handler it always has a specific um format um so if you do your vulnerability research uh you will definitely encounter this function um and here we see a bit of the the steps so firstly we see at the top uh it gets the uh device IO control and this contains a code that is basically an index for the type of action that the driver needs to perform so the user gives this ID and the driver does a lookup and performs the right action and then there's the system buffer and this is a buffer that the user gives to the driver with some data it can be arbitrary data um and it's good to know that it consists of an input buffer and an output buffer from the user perspective but in the kernel this is merged into a a single buffer so there are also some vulnerabilities step are uh due to this fact or at least can uh do have to do with this this fact now here we see a switch case statement for looking up the io control code and Performing the right action and important for vulnerability research is knowing where the user input is and uh in this case it this the system buffer the sizes of the system buffer and also the io control code so we will see later how this can uh affect vulnerabilities so so that's how the driver uh work looks um the next step is actually interacting with it so you have the driver loaded on your system and then you want to know what is the device call that I want to interact with there's two ways to find out you can look in the driver itself um look for the strings and usually there are some strings that immediately pop out and show you like this is the device object another way is to use uh win objects it's a sis internals tool and it also lists all the devices available on the system and usually you can find by the name that uh a certain one is the one you need to use and once you know that you uh can actually interact with it uh it's two calls the first one is create file which is the call to open a specific file and since the device object is also a file on Windows you can just open it in that way and uh then you can interact with it uh using device IO control uh system go and here we also see the user data being passed um first the the um device IO control code uh then the data and the the sizes I skipped some details here to keep it clear for brevity but uh the Microsoft documentation is pretty clear on how to use this um you might encounter some access controls the first access control is uh defined through uh sddl the security descriptor definition language I always forget that acronym um but it en controls which kind of users can actually interact with the driver so if you want to start your own research um it's easiest to look for a driver with without an sddl or a very permissive sddl that permits any user to communicate with the driver another access control is in the create function uh remember that we had that uh Handler for the create event um in that Handler the driver can also implement all kinds of uh checks um is the process where uh that is interacting what I expect is there a signature on the process um is the right user uh connecting so you also want to find a driver that doesn't do any uh any checks in the create function so let's move into the reverse engineering part um as you might know a lot of um usually you don't have the source code um so you will have to look at the s L and open it in a disassembler and try to find out uh uh what you need to look at so here I will show the C code and the assembly side by side to give you a view of uh how this looks like from a reverse engineering perspective so here we have again the driver entry function and I'll step through it with you so here we see that it initialized a couple of strings and on the right you can also see that you see the uh same strings in our disassembler so this shows you already the the devices that are created um and this these are also the devices you can look up to communicate then um it actually creates the device with the these two system calls and then it moves on to initialization of the Handler functions now on the right in the assembly you can the the function names don't make any sense uh it's just the offsets um but if you look at the offsets into the array you can actually see um uh you see 70 80 e0 um and this actually gives you an indication of which Handler it is so first there is a fullback Handler um for all the events that are not implemented and here we see that create close and device control are created um so these are directly mapped to 70 80 and EZ so if we see something is written at offset e0 we always know that that function is our device I control Handler and here I have given the functions clear clearer names um if we look more closely at the device IO control Handler we see it first uh gets some data from the from the user input the IRP the inter um the request packet IO request packet um it gets the io control code at offset 18 um it gets the input and output buffer length um it's a bit optimized on the right um but you can at least see that one of the length is uh is obtained and it also obtains the the system buffer um so that one is most interesting for us because it contains all the user input and here we see a lot of branching statements on the right um this usually indicates a switch case statement um and we see that uh it checks the um the io control code and performs the right action so now that we have a bit of an overview of uh how drivers work um it's time to go into the actual vulnerabilities and the first one that is interesting is the dangerous legitimate functionality as I like to call it um this is very similar to Dynamite and as you know Dynamite was developed to um blow up mountains and create Pathways that trains could pass through or uh or other things um but it can actually be used in wrong ways and just the same it is with drivers um a well-known example is Dell uh they had a driver that um allowed a uh an administrator to uh read and write to arbitrary locations in kernel memory well this is very easy for debugging purposes but in production this can actually be very dangerous and gives us a read write primitive that we can do use to do all kinds of uh privileg escalation so here you see the user input on the left and also user input on the right uh the one is the left one is for the uh read I believe and the right one is for the right and in the end it all comes down to a m move call so finding these kinds of vulnerabilities is just looking for the M moves and uh seeing if there's any user input in there and then it's definitely an interesting point another dangerous legitimate functionality is terminating a process and this is a uh a vulnerability that we found in our research um here we see that a value is read from the system buffer and it's given as the first argument to a function that I have given a recognizable name already well if we go down into the function I'll spare you the details but in the end it does open process and terminate process on the process ID given by the user well you can already imagine that this can be very nice to uh disable EDR for example uh a third example is physical memory mapping um here we found I believe it was timer that found this one uh a driver that uh does uh M mm map IO space and it Maps some physical memory into a a user um writable location so users can actually read and write to uh yeah arbitrary locations in physical memory um and here is again uh the user input and it's stored in the physical address parameter for mm iio space so this is again an example of a dangerous legitimate functionality the next type is the very well-known buffer overflow yes it also happens in drivers and uh it's very interesting to exploit this this I have a couple of examples um first one is the in the macrium backup software and here we see that uh the user input determines the size of a buffer that is allocated here and later this buffer you can see the same offset to z0 is used uh uh on the bottom and it's used as the buffer for uh reading a file input into it um there is a length given into the buffer but it's actually unrelated to the length that the user gives in earlier so this is an example of where um yeah the user can just determine the size of the buffer and uh overrun it another overflow that uh that we found uh is a registry key um here we see that uh uh a location is allocated with a th000 uh hex in heximal bytes um and you would think okay that's pretty long but registry keys can actually also get pretty long there's 255 uh characters per segment and you can have an arbitrary number of segments in the registry so it's definitely possible to overrun this buffer we can see that it's stored in RBX then on the right RBX is stored in rcx um and here is actually our user input and here we see that the user input is copied into the buffer um thereby overrunning the buffer and uh uh giving us um a heap overflow that can be exploited for all kinds of things um the next uh example is a data leak uh kernel memory contains a lot of sensitive data that is explicitly not available for user memory so if you can leak arbitrary uh data from the kernel this can definitely contain interesting things that you can abuse uh in all kinds of ways um so uh here we see that this is where the input and output buffer come into play um because if we provide here a very small input buffer and a very large output buffer the kernel will integrate that in a single large buffer that is completely uninitialized and here we see that from that buffer it copies uh 100 heximal bytes and then it writes it back to the same location again um but this means that the user can actually read from the output buffer the uninitialized data that was in the kernel input buffer so this leaks about uh 100 hex a decimal uh bytes of Kernel memory to the user uh the next vulnerability is kernal handle leaks and I have found a nice analogy in uh in practice uh in this image on the left um this is a burglar that um puts a device through your door and uh pulls on the handle to actually open the um open the door this handle is not supposed to be reachable from the outside in a similar way uh the kernel handles should not be reachable from user mode but you actually need to specify this and a lot of developers forget to specify this uh this flag um and then the user handle uh the handle from the kernel is in the user handle table so if you enumerate that handle table you can actually find the the handle that you can use for um writing to a process killing a process um Etc so some an example of this here we see an open process call and there are some attributes given to it but the attributes are set to R15 and R15 is zero X or withd itself so um in this case we see that the attributes are zero so no flags have been given also not the current flag um so yeah in this case we can actually open an arbitrary uh process from the kernel and uh use the handle from user mode another example is Method direct and here the analogy is the Turkish ice cream man you have probably seen the videos where the ice cream man gives a seems to give an ice cream but just as the user takes the cone he pulls the ice cream away again uh in a similar way this is exploited in the in the kernel with a certain communication method um user user rights and kernel reads can happen concurrently so you can see where this is going if the driver is not checking it correctly um the driver can do some kind of a check in between the user changes the data the check passes and the driver actually reads incorrect data um so if you ever see a method indirect or method outdir um this is definitely something to look at because the driver needs to really closely handle uh the interaction with the user um yeah and they need to do some kind of locking to uh to make sure operations are Atomic so how does this look this is encoded in the identifier the device IO control code um and you can decode it with now for example this online decoder and shows you the communication method uh so if you decode these uh uh these values you can find these kinds of uh interesting things to look at so these are the the vulnerability types that I wanted to discuss with with you um let's move on to the automated tools um the first one that is uh well known in this area is uh popcorn um this tool is used to find um the first vulnerability type that I discussed the dangerous legitimate functionality um well not only that but it tries to find um specific functions that are used in the driver and um this can help you if if you know that a dangerous function is used you can then look if user input is uh ends up in there and that makes a very interesting case for possible vulnerabilities a more recent tool that was released is by the VM rare threat analysis unit and they um aim to improve over the design of popcorn and some other tools um and they uh use um Ida and they scripted some Ida scripts um to um perform the same kind of actions but in a a faster and um more fa tolerant way so that uh so let's move to the conclusion kernel Drive vulnerabilities have impact um we have discussed how um yeah it is actually used in practice by a lot of threat actors and um yeah it gives a lot of powerful tools to an attacker so that makes research also very important also uh for us as security uh uh researchers um red team operators there are many vulnerabilities to be found our research has uh has shown that um yeah with some analysis we could could find almost 30% uh of the drivers that we looked at to to be vulnerable and you can contribute I hope with this presentation you have the a bit of the knowledge a bit of the background and uh some tools that can get you started with uh this kind of research thank you for your attention well thank you very much um are there any questions in the audience yeah you said when uh creating your database you would only use the latest version of the driver because vulnerabilities could be fixed but if you bring your own vulnerable driver would it be useful to bring an older version as well yeah I I heard myself saying it and I thought this might come up but uh indeed uh for bring your own vulnerable drivers also old vulnerabilities are really interesting um but the thing with old vulnerabilities is usually that they are already publicly known so um it's really not worth putting your research time into it if you can also find it with a Google search so that that's the reason that I would suggest excluding those kinds of drivers okay thank you and EDR will permit it most of the times but um in one of the first slides it's uh one of the first slides it at 08 uh U the hex it was it an hex address or was it an an handle to uh one of the first slides let me see uh yeah it was about user input uh sending it to the to the kernel this one 0x8 no yeah the case uh is it a memory address uh which oh this one yeah any other oh yeah that's the device IO control code and um it has a specific format um that can also be parsed uh by that online parser that I showed later um and it encodes all kinds of attributes about how the interaction goes um but in the end it's just an identifier that the driver uses to perform a certain action because in kernel you also have aslr I think yeah there's also kernel aslr and all kinds of protection measures okay thank you clear uh one last question maybe from the audience no all right then we're uh almost ready for our lunch but for first I would like to thank you for your talk and I would like to present you with a challenge coin yes thank you thank you very much Round of Applause please


