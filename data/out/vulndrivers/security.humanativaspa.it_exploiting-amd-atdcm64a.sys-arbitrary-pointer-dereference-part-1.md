# https://security.humanativaspa.it/exploiting-amd-atdcm64a.sys-arbitrary-pointer-dereference-part-1/

[Skip to main content](https://hnsecurity.it/blog/exploiting-amd-atdcm64a.sys-arbitrary-pointer-dereference-part-1/#sections-container)

![](https://hnsecurity.it/wp-content/uploads/2025/09/AMD-uai-836x836.jpg)

# Exploiting AMD atdcm64a.sys arbitrary pointer dereference – Part 1

September 25, 2024\|[![Alessandro Iandoli](https://secure.gravatar.com/avatar/644822f5d8329ca419a50c1f39c97de5ccd163d1932e4cdc60a6cc8cb64ed29e?s=40&d=mm&r=g)](https://hnsecurity.it/blog/author/ale98/) By [Alessandro Iandoli](https://hnsecurity.it/blog/author/ale98/)

[Exploits](https://hnsecurity.it/blog/category/exploits/ "View all posts in Exploits"), [Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/ "View all posts in Vulnerabilities")

After attending the [OST2 – Exp4011](https://apps.p.ost2.fyi/learning/course/course-v1:OpenSecurityTraining2+Exp4011_Windows_Kernel_UAF_KTM+2023_v1/home) course, taught by [Cedric Halbronn](https://x.com/saidelike) (a **free course** that I **really recommend to follow** to anyone interested in the topic), I decided to start doing vulnerability research on **third-party Windows drivers**. I already had a bit of academic experience in **kernel exploit development** by crafting some exploits ( [stack overflow](https://github.com/MrAle98/HEVD-StackOverflow-x64-SMEPBypass), [arbitrary write](https://github.com/MrAle98/HEVD-ArbitraryWrite-Win10-x64), [session pool overflow](https://github.com/MrAle98/HEVD-sessionPoolOverflow-win10-x64)) for the driver [HackSysExtremeVulnerableDriver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver), so I decided to move on to real kernel drivers.

In this [series](https://hnsecurity.it/tag/atdcm64a/) of blog posts I’ll describe how I found **two vulnerabilities** in a **Windows kernel driver** part of an **old AMD software package** and how I exploited them in order to achieve **local privilege escalation**. Probably, this article won’t be very useful for experienced exploit developers/vulnerability researchers, but I think it will be useful for **red teamers** that are **looking for vulnerable drivers** that are not blacklisted, in order to **disable/bypass EDRs**. In addition, I’ll focus on how to use **IDA Pro** to **reverse and then debug drivers** with the assistance of the pseudocode.

The series is divided in three parts as follows:

- **Discovering the vulnerabilities** ( [Part 1](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-1/)) – This article
- **Confirming the vulnerabilities** ( [Part 2](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-2/))
- **Exploitation** ( [Part 3](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-3/))

I assume the reader already has **basic knowledge about Windows kernel driver development/exploitation**. If that’s not the case, I suggest reading the following articles in order to gain a basic understanding of the **interaction between user-mode processes and kernel-mode drivers** and of protection mechanisms such as **SMEP**:

- [https://connormcgarr.github.io/Kernel-Exploitation-1/](https://connormcgarr.github.io/Kernel-Exploitation-1/)
- [https://connormcgarr.github.io/Kernel-Exploitation-2/](https://connormcgarr.github.io/Kernel-Exploitation-2/)
- [https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/](https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/)
- [https://voidsec.com/windows-drivers-reverse-engineering-methodology/](https://voidsec.com/windows-drivers-reverse-engineering-methodology/)

I also recommend following the [OST2 – Dbg3011](https://apps.p.ost2.fyi/learning/course/course-v1:OpenSecurityTraining2+Dbg3011_WinDbg3+2023_v1/home) course, again taught by Cedric Halbronn, in order to become familiar with **WinDbg**.

## Disclosure

The vulnerabilities were reported directly to the [AMD product security team](https://www.amd.com/en/resources/product-security.html) on July 26th, 2024.

The AMD product security team replied the same day declaring that as the vulnerabilities affect an old software package that’s no longer maintained, **they won’t be issuing a CVE ID or a security notice**.

## Setting up the environment

If you want to follow along I suggest you to create a **Windows 11 VM**.  Specifically, I’m going to use the following build.

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

PS > systeminfo

Host Name: WINDOWS11

OS Name: Microsoft Windows 11 Pro

OS Version: 10.0.22631 N/A Build 22631

OS Manufacturer: Microsoft Corporation

\[...\]

PS > systeminfo
Host Name: WINDOWS11
OS Name: Microsoft Windows 11 Pro
OS Version: 10.0.22631 N/A Build 22631
OS Manufacturer: Microsoft Corporation
\[...\]

```
PS > systeminfo
Host Name:                 WINDOWS11
OS Name:                   Microsoft Windows 11 Pro
OS Version:                10.0.22631 N/A Build 22631
OS Manufacturer:           Microsoft Corporation
[...]
```

In addition, I provide here the **hash of the ntoskrnl.exe** file I have on my own Windows 11 VM.

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

PS > get-filehash C:\\Windows\\System32\\ntoskrnl.exe \| select -expandProperty Hash

0CE15480462E9CD3F7CBF2D44D2E393CF5674EE1D69A3459ADFA0E913A7A2AEB

PS >

PS > get-filehash C:\\Windows\\System32\\ntoskrnl.exe \| select -expandProperty Hash
0CE15480462E9CD3F7CBF2D44D2E393CF5674EE1D69A3459ADFA0E913A7A2AEB
PS >

```
PS > get-filehash C:\Windows\System32\ntoskrnl.exe | select -expandProperty Hash
0CE15480462E9CD3F7CBF2D44D2E393CF5674EE1D69A3459ADFA0E913A7A2AEB
PS >
```

In the Windows 11 VM, setup **network kernel debugging as follows** (run all commands as administrator).

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

\> bcdedit /debug on

\> bcdedit /dbgsettings net hostip:<ip of your host machine> port:<port for example 50099>

\> bcdedit /debug on
\> bcdedit /dbgsettings net hostip:<ip of your host machine> port:<port for example 50099>

```
> bcdedit /debug on
> bcdedit /dbgsettings net hostip:<ip of your host machine> port:<port for example 50099>
```

Take note of the **key** that the last command outputs. You can always get it back running the following command (again, as administrator).

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

\> bcdedit /dbgsettings

key 1dins0yu1y3cp.k42pkhb9dnua.1evtrhpv56ygd.349y5ok12c1ul

debugtype NET

hostip 192.168.157.1

port 50001

dhcp Yes

The operation completed successfully.

>

\> bcdedit /dbgsettings
key 1dins0yu1y3cp.k42pkhb9dnua.1evtrhpv56ygd.349y5ok12c1ul
debugtype NET
hostip 192.168.157.1
port 50001
dhcp Yes
The operation completed successfully.
>

```
> bcdedit /dbgsettings
key                     1dins0yu1y3cp.k42pkhb9dnua.1evtrhpv56ygd.349y5ok12c1ul
debugtype               NET
hostip                  192.168.157.1
port                    50001
dhcp                    Yes
The operation completed successfully.
>
```

Restart the VM so that changes will take effect.

## Analyzing the driver

### Reversing the driver

The vulnerable driver can be obtained following these steps:

- Download this [software package](https://drivers.amd.com/drivers/beta/win10-64bit-radeon-software-adrenalin-edition-18.12.1.1-dec5.exe)
- Open the .exe with **7zip** and extract it. The driver is located at **Packages\\Drivers\\Display\\WT6A\_INF\\B336522\\atdcm64a.sys**
- Copy the driver both on your host machine (where you have IDA Pro or any other reversing framework) and on your VM

If you are not able to download from the direct link, follow these steps:

- Navigate to this [link](https://www.amd.com/en/support/downloads/previous-drivers.html/graphics/radeon-600-500-400/radeon-rx-500-series/radeon-rx-580.html)
- Expand the “Windows 10 – 64-bit Edition” tab
- Download the package **Adrenalin Edition 18.12.1.1 Optional** (Release date: 2018-12-05)

![](https://hnsecurity.it/wp-content/uploads/2024/09/2024-09-20-13_47_32-Clipboard-1.png)Driver download page

You can use [OSRLoader](https://www.osronline.com/article.cfm%5Earticle=157.htm) to load the driver in the VM following the instructions [here](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/loading-a-windows-kernel-driver-osr-driver-loader-debugging-with-source-code) (just look at the animated GIF and ignore the other steps).

_Once the driver is loaded successfully in the VM, I suggest to create a **snapshot of the VM**. Usually the VM crashes many times especially during the exploit development phase. Having **a snapshot allows to restart quickly** from the point we want._

Now it is time to load the driver in **IDA Pro**. Once loaded, you are presented with the following interface:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-53-1.png)Initial view in IDA Pro

IDA Pro already shows the entry point: the DriverEntry routine.

First thing I like to do is **synchronize the decompiled View with the IDA View**. Spawn the decompiled view with

F5

`F5`,  right-click on the **IDA View** window and select

Synchronize With -> Pseudocode - A

`Synchronize With -> Pseudocode - A`.

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-1-1.png)Synchronizing views in IDA Pro

From now on it will keep **both cursors on the two windows synchronized**. If you scroll one window, IDA Pro automatically scrolls on the other one as well.

If you want you can also further **synchronize** the **Hex View with IDA View and Pseudocode** windows using the same procedure. Right-click on the **Hex View** window and then select

Synchronize With -> IDA VIEW A - Pseudocode - A

`Synchronize With -> IDA VIEW A - Pseudocode - A`.

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-2-1.png)Synchronizing Hex View with IDA View and Pseudocode

The next steps here are:

1. Identifying the **symbolic link to the driver** (so that we know **how to get a handle** to the driver **from user-mode**).
2. Identifying **driver dispatch routines handling IRPs**.

_In this case we will focus only on the **IRP\_MJ\_DEVICE\_CONTROL** major function code but typically he **IRP\_MJ\_READ IRP\_MJ\_WRITE and IRP\_MJ\_CREATE** major function codes are also of interest._

Usually, the **symbolic link is created in the DriverEntry routine**. Quickly inspecting the DriverEntry routine it in IDA Pro reveals the name **AtiDCM**:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-4-1.png)Symbolic link with name AtiDCM

Right after the creation of the symbolic link, we may notice the driver sets some dispatch routines in the **MajorFunction array** of the **DriverObject** struct:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-5-1.png)Definition of Dispatch routines in DriverObject

At this point I suggest to **rename the indexes** in the array with the corresponding **IRP\_MJ\_XXX code**. To do this you can:

1. Click on the number and press
m
`m`.
2. Select Yes in the popup.
3. Then
Ctrl-F
`Ctrl-F` and type **IRP\_MJ** in the search bar.
4. Select the appropriate entry and press ok.

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-6-1.png)Renaming index – Step 1-2![](https://hnsecurity.it/wp-content/uploads/2024/08/image-7-1.png)Renaming index – Step 3-4![](https://hnsecurity.it/wp-content/uploads/2024/08/image-8-1.png)Renaming index – result

In addition to renaming all the indexes I like to rename the function names. You can do it by:

1. Clicking on the **sub\_XXXX** you want to rename.
2. Press
n
`n`.
3. Change the name and press
Enter
`Enter`.

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-10-1.png)Renaming the function to IrpDeviceIoControlHandler()

After that I suggest to **change the function signature** to the appropriate one. Based on [MSDN](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_dispatch),  the signature is the following:

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

NTSTATUS DriverDispatch(

\[in, out\] \_DEVICE\_OBJECT \*DeviceObject,

\[in, out\] \_IRP \*Irp

)

NTSTATUS DriverDispatch(
\[in, out\] \_DEVICE\_OBJECT \*DeviceObject,
\[in, out\] \_IRP \*Irp
)

```
NTSTATUS DriverDispatch(
  [in, out] _DEVICE_OBJECT *DeviceObject,
  [in, out] _IRP *Irp
)
```

To change the function signature:

1. Click on the target function name.
2. Press
y
`y`.
3. Insert the appropriate function signature.

_It is advisable to keep the same calling convention you find in the original definition. In this case it is \_\_fastcall._

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-11-1.png)Redefining the function signature

Now we can move to our **IrpDeviceIoControlHandler** routine:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-12-1.png)Pseudocode of IrpDeviceIoControlHandler()

If we inspect the first function we notice it actually returns a **pointer in a global variable** that points to a memory allocation obtained by calling _ExAllocatePoolWithTag()_:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-13-1.png)Pseudocode of sub\_1400033e8()

When the driver returns from the first function, it passes the returned pointer to the next function along with the whole IRP. If we give a quick look at the **second function** we may notice It is a big function that **handles the different IOCTLs**.

I suggest to rename both functions and change their function signature:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-15-1.png)Reversed IrpDeviceIoControlHandler()

Now let’s start inspecting _InnerIrpDeviceIoCtlHandler()_:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-16-1.png)Initial pseudocode of InnerIrpDeviceIoCtlHandler()

We can see it references multiple fields inside the IRP. If we give a look at the definition of the [IRP](https://www.vergiliusproject.com/kernels/x64/windows-11/22h2/_IRP) and [\_IO\_STACK\_LOCATION](https://www.vergiliusproject.com/kernels/x64/windows-11/22h2/_IO_STACK_LOCATION)  we can see the fields _CurrentStackLocation->Parameters_ and _Irp->AssociatedIrp_ are actually **unions**.

Taking the _CurrentStackLocation->Parameters_ we can see that it’s a union that **changes based on the IRP Major Function Code** handled. As the current function handles a **IRP\_MJ\_DEVICE\_CONTROL** function code, we should use _CurrentStackLocation->Parameters.DeviceIoControl_ in IDA Pro.

To instruct IDA Pro to do so, you must:

1. Click on the union field ( _CurrentStackLication->Parameters_) press
Alt + y
`Alt + y`.
2. Ctrl + f
`Ctrl + f` for searching for DeviceIoControl and then select the proper one ( _Parameters.DeviceIoControl.IoControlCode_ in this case).

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-19-1.png)Searching the proper union field

Now we know the function accesses the _IoControlCode_ variable, provided as input from user mode, and based on that it handles the IRP differently. Let’s inspect the following piece of decompiled code:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-21-1.png)InnerIrpDeviceIoCtlHandler() before reversing

Notice it references _IoControlCode variable_ and subtract 0x22e084. If the result is zero, it calls a function (passing as input _Irp->AssociatedIrp.MasterIrp_). This means that _0x22e084_ is a valid IOCTL. If we decode it, for example with [OSR Online IOCTL Decoder](https://www.osronline.com/article.cfm%5Earticle=229.htm) we notice the info **METHOD\_BUFFERED**:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-18-1.png)IOCTL decoded

Recalling [MSDN](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes), when using **METHOD\_BUFFERED** _,_ the input and output buffer, passed from user mode, are represented by _Irp->AssociatedIrp.SystemBuffer_. At this point we are sure we can change the union _Irp->AssociatedIrp.MasterIrp_ to be actually _Irp->AssociatedIrp.SystemBuffer_.

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-22-1.png)InnerIrpDeviceIoCtlHandler() after reversing

At this point we are interested in reversing and analyzing the code that handles our s _ystemBuffer_ variable and see if there are any vulnerabilities.

### Identifying an arbitrary MSR read

Inside our _InnerIrpDeviceIoCtlHandler()_ we notice a

rdmsr

`rdmsr` instruction ( _\_\_readmsr()_ in the decompiled code).

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-23-1.png)Arbitrary MSR read

As we can see from the snippet of code above, the routine takes the **input** for the _\_\_readmsr_ instruction from the _**systemBuffer**_ (that we control) and returns the **output** again in _**systemBuffer**_. This grants us the ability to **read arbitrary MSRs!**

### Identifying an arbitrary pointer dereference

After additional reversing of _InnerIrpIoCtlHandler()_ and the functions called by _InnerIrpIoCtlHandler()_ itself, we can see a call to **_callDriver()_** (a reversed function) passing as input multiple fields from **s** _**ystemBuffer**_.

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-25-1.png)Call to callDriver()

Here’s the pseudocode of **_callDriver()_** after reversing:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-26-1.png)Pseudocode of callDriver()

We can see it performs:

1. A call to **_IoGetAttachedDeviceReference()_** passing as input the **first parameter (that we fully control)**.
2. A call to **_IofCallDriver()_** passing as input the **output of _IoGetAttachedDeviceReference()_**.

At this point we must reverse these two functions in order to understand what we are able to do.

Open another IDA Pro window and load the ntoskrnl.exe of the Windows 11 VM. After some reversing we get the shape of _IoGetAttachedDeviceReference()_:

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

PDEVICE\_OBJECT \_\_stdcall IoGetAttachedDeviceReference(PDEVICE\_OBJECT DeviceObject)

{

unsigned \_\_int8 CurrentIrql; // di

char \*v3; // rcx

\_DEVICE\_OBJECT \*i; // rax

\_DWORD \*SchedulerAssist; // r8

\_\_int64 v7; // r9

unsigned \_\_int8 v8; // cl

struct \_KPRCB \*CurrentPrcb; // r9

\_DWORD \*v10; // r8

int v11; // eax

bool v12; // zf

\[...\]

for( i = DeviceObject->AttachedDevice; i; i = i->AttachedDevice )

DeviceObject = i;

if( ObpTraceFlags )

ObpPushStackInfo((\_\_int64)&DeviceObject\[-1\].DeviceLock.Header.WaitListHead, 1, 1u, 'tlfD');

ObpIncrPointerCount((volatilesigned \_\_int64 \*)&DeviceObject\[-1\].DeviceLock.Header.WaitListHead);

KxReleaseQueuedSpinLock((char \*)KeGetPcr()->NtTib.ArbitraryUserPointer \+ 160);

if( KiIrqlFlags )

{

v8 = KeGetCurrentIrql();

if((KiIrqlFlags & 1) != 0 && v8 <= 0xFu && CurrentIrql <= 0xFu && v8 >= 2u )

{

CurrentPrcb = KeGetCurrentPrcb();

v10 = CurrentPrcb->SchedulerAssist;

v11 = ~(unsigned \_\_int16)(-1LL <<(CurrentIrql + 1));

v12 = (v11 & v10\[5\]) == 0;

v10\[5\] &= v11;

if( v12 )

KiRemoveSystemWorkPriorityKick(CurrentPrcb);

}

}

\_\_writecr8(CurrentIrql);

return DeviceObject;

}

PDEVICE\_OBJECT \_\_stdcall IoGetAttachedDeviceReference(PDEVICE\_OBJECT DeviceObject)
{
unsigned \_\_int8 CurrentIrql; // di
char \*v3; // rcx
\_DEVICE\_OBJECT \*i; // rax
\_DWORD \*SchedulerAssist; // r8
\_\_int64 v7; // r9
unsigned \_\_int8 v8; // cl
struct \_KPRCB \*CurrentPrcb; // r9
\_DWORD \*v10; // r8
int v11; // eax
bool v12; // zf

\[...\]
for ( i = DeviceObject->AttachedDevice; i; i = i->AttachedDevice )
DeviceObject = i;
if ( ObpTraceFlags )
ObpPushStackInfo((\_\_int64)&DeviceObject\[-1\].DeviceLock.Header.WaitListHead, 1, 1u, 'tlfD');
ObpIncrPointerCount((volatile signed \_\_int64 \*)&DeviceObject\[-1\].DeviceLock.Header.WaitListHead);
KxReleaseQueuedSpinLock((char \*)KeGetPcr()->NtTib.ArbitraryUserPointer + 160);
if ( KiIrqlFlags )
{
v8 = KeGetCurrentIrql();
if ( (KiIrqlFlags & 1) != 0 && v8 <= 0xFu && CurrentIrql <= 0xFu && v8 >= 2u )
{
CurrentPrcb = KeGetCurrentPrcb();
v10 = CurrentPrcb->SchedulerAssist;
v11 = ~(unsigned \_\_int16)(-1LL << (CurrentIrql + 1));
v12 = (v11 & v10\[5\]) == 0;
v10\[5\] &= v11;
if ( v12 )
KiRemoveSystemWorkPriorityKick(CurrentPrcb);
}
}
\_\_writecr8(CurrentIrql);
return DeviceObject;
}

```
PDEVICE_OBJECT __stdcall IoGetAttachedDeviceReference(PDEVICE_OBJECT DeviceObject)
{
  unsigned __int8 CurrentIrql; // di
  char *v3; // rcx
  _DEVICE_OBJECT *i; // rax
  _DWORD *SchedulerAssist; // r8
  __int64 v7; // r9
  unsigned __int8 v8; // cl
  struct _KPRCB *CurrentPrcb; // r9
  _DWORD *v10; // r8
  int v11; // eax
  bool v12; // zf

 [...]
  for ( i = DeviceObject->AttachedDevice; i; i = i->AttachedDevice )
    DeviceObject = i;
  if ( ObpTraceFlags )
    ObpPushStackInfo((__int64)&DeviceObject[-1].DeviceLock.Header.WaitListHead, 1, 1u, 'tlfD');
  ObpIncrPointerCount((volatile signed __int64 *)&DeviceObject[-1].DeviceLock.Header.WaitListHead);
  KxReleaseQueuedSpinLock((char *)KeGetPcr()->NtTib.ArbitraryUserPointer + 160);
  if ( KiIrqlFlags )
  {
    v8 = KeGetCurrentIrql();
    if ( (KiIrqlFlags & 1) != 0 && v8 <= 0xFu && CurrentIrql <= 0xFu && v8 >= 2u )
    {
      CurrentPrcb = KeGetCurrentPrcb();
      v10 = CurrentPrcb->SchedulerAssist;
      v11 = ~(unsigned __int16)(-1LL << (CurrentIrql + 1));
      v12 = (v11 & v10[5]) == 0;
      v10[5] &= v11;
      if ( v12 )
        KiRemoveSystemWorkPriorityKick(CurrentPrcb);
    }
  }
  __writecr8(CurrentIrql);
  return DeviceObject;
}
```

We can see that basically it walks the _**DeviceObject->AttachedDevice**_ linked list and then **returns the last element** in the list. In addition, before returning we can see a call to **_ObpIncrPointerCount()_** passing as input

DeviceObject-0x30

`DeviceObject-0x30`. It is easier to see it in the disassembly listing (

rbx

`rbx`corresponds to

DeviceObject

`DeviceObject`):

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-27-1.png)call to ObpIncrPointerCount passing DdeviceObject-0x30

Here’s the reversed _ObpIncrPointerCount()_ function:

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

signed \_\_int64 \_\_fastcall \_\_spoils<rax>ObpIncrPointerCount(volatilesigned \_\_int64 \*a1)

{

signed \_\_int64 result; // rax

result = \_InterlockedIncrement64(a1);

if( result <= 1 )

KeBugCheckEx(0x18u, 0LL, (ULONG\_PTR)(a1 + 6), 0x10uLL, result);

return result;

}

signed \_\_int64 \_\_fastcall \_\_spoils<rax> ObpIncrPointerCount(volatile signed \_\_int64 \*a1)
{
signed \_\_int64 result; // rax
result = \_InterlockedIncrement64(a1);
if ( result <= 1 )
KeBugCheckEx(0x18u, 0LL, (ULONG\_PTR)(a1 + 6), 0x10uLL, result);
return result;
}

```
signed __int64 __fastcall __spoils<rax> ObpIncrPointerCount(volatile signed __int64 *a1)
{
  signed __int64 result; // rax
  result = _InterlockedIncrement64(a1);
  if ( result <= 1 )
    KeBugCheckEx(0x18u, 0LL, (ULONG_PTR)(a1 + 6), 0x10uLL, result);
  return result;
}
```

Notice the call to **_\_InterlockedIncrement64()_**. This seems to grant us an **arbitrary increment primitive**. However, we have to consider that _callDriver()_, later on, calls _**ObfDereferenceObject()**_ on the same **AttachedDeviceReference** variable.

If we reverse _ObfDereferenceObject()_ we can see that the function **decrements the same field that was previously incremented**. This _compensating action_ is going to **null out our arbitrary increment** making it very **likely** **unexploitable**.

Now let’s reverse _IofCallDriver()_:

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

NTSTATUS \_\_stdcall IofCallDriver(PDEVICE\_OBJECT DeviceObject, PIRP Irp)

{

\_IO\_STACK\_LOCATION \*v2; // rax

\_\_int64 MajorFunction; // r8

if( IopDispatchCallDriver )

{

if( IopDispatchCallDriver == 3)

returnIopPerfCallDriver((PADAPTER\_OBJECT)DeviceObject);

else

returnIovCallDriver(DeviceObject);

}

else

{

if( --Irp->CurrentLocation <= 0)

KeBugCheckEx(0x35u, (ULONG\_PTR)Irp, 0LL, 0LL, 0LL);

v2 = Irp->Tail.Overlay.CurrentStackLocation \- 1;

Irp->Tail.Overlay.CurrentStackLocation = v2;

MajorFunction = v2->MajorFunction;

v2->DeviceObject = DeviceObject;

if((\_BYTE)MajorFunction == 22&&(unsigned \_\_int8)(v2->MinorFunction - 2)<= 1u )

returnIopPoHandleIrp(Irp);

else

return((\_\_int64(\_\_fastcall \*)(PDEVICE\_OBJECT))DeviceObject->DriverObject->MajorFunction\[MajorFunction\])(DeviceObject);

}

}

NTSTATUS \_\_stdcall IofCallDriver(PDEVICE\_OBJECT DeviceObject, PIRP Irp)
{
\_IO\_STACK\_LOCATION \*v2; // rax
\_\_int64 MajorFunction; // r8

if ( IopDispatchCallDriver )
{
if ( IopDispatchCallDriver == 3 )
return IopPerfCallDriver((PADAPTER\_OBJECT)DeviceObject);
else
return IovCallDriver(DeviceObject);
}
else
{
if ( --Irp->CurrentLocation <= 0 )
KeBugCheckEx(0x35u, (ULONG\_PTR)Irp, 0LL, 0LL, 0LL);
v2 = Irp->Tail.Overlay.CurrentStackLocation - 1;
Irp->Tail.Overlay.CurrentStackLocation = v2;
MajorFunction = v2->MajorFunction;
v2->DeviceObject = DeviceObject;
if ( (\_BYTE)MajorFunction == 22 && (unsigned \_\_int8)(v2->MinorFunction - 2) <= 1u )
return IopPoHandleIrp(Irp);
else
return ((\_\_int64 (\_\_fastcall \*)(PDEVICE\_OBJECT))DeviceObject->DriverObject->MajorFunction\[MajorFunction\])(DeviceObject);
}
}

```
NTSTATUS __stdcall IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  _IO_STACK_LOCATION *v2; // rax
  __int64 MajorFunction; // r8

  if ( IopDispatchCallDriver )
  {
    if ( IopDispatchCallDriver == 3 )
      return IopPerfCallDriver((PADAPTER_OBJECT)DeviceObject);
    else
      return IovCallDriver(DeviceObject);
  }
  else
  {
    if ( --Irp->CurrentLocation <= 0 )
      KeBugCheckEx(0x35u, (ULONG_PTR)Irp, 0LL, 0LL, 0LL);
    v2 = Irp->Tail.Overlay.CurrentStackLocation - 1;
    Irp->Tail.Overlay.CurrentStackLocation = v2;
    MajorFunction = v2->MajorFunction;
    v2->DeviceObject = DeviceObject;
    if ( (_BYTE)MajorFunction == 22 && (unsigned __int8)(v2->MinorFunction - 2) <= 1u )
      return IopPoHandleIrp(Irp);
    else
      return ((__int64 (__fastcall *)(PDEVICE_OBJECT))DeviceObject->DriverObject->MajorFunction[MajorFunction])(DeviceObject);
  }
}
```

The most interesting part of the function is the last line. It **calls a function pointer** inside the **MajorFunction array** part of _**DriverObject**_ part of _**DeviceObject**_. Since **we can control _DeviceObject_** then **we can control the function pointer inside the MajorFunction array**. This grants us the ability **redirect the execution flow to an arbitrary location!**

## Wrapping up

In this post we analyzed the driver EntryPoint with IDA Pro in order to retrieve the IOCTL handler. We analyzed the IOCTL handler, in order to retrieve the valid IoControlCodes and analyzed the functions in charge of handling the different IoControlCodes.

Finally, we spotted two vulnerabilities: an **arbitrary MSR read** and an **arbitrary pointer dereference.**

_You may have noticed that the **driver analysis process** (retrieving driver name, IOCTL dispatcher, IOCTL codes, …) can be quite tedious. If you want to **automate the process** I suggest you to give a look at the following [project](https://github.com/VoidSec/DriverBuddyReloaded) that directly integrates into IDA Pro._

In [Part 2](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-2/) we will confirm both vulnerabilities with the help of IDA Pro’s Debugger.

[windows](https://hnsecurity.it/blog/tag/windows/) [Tutorial](https://hnsecurity.it/blog/tag/tutorial/) [red teaming](https://hnsecurity.it/blog/tag/red-teaming/) [atdcm64a](https://hnsecurity.it/blog/tag/atdcm64a/) [exploit development](https://hnsecurity.it/blog/tag/exploit-development/) [exploit](https://hnsecurity.it/blog/tag/exploit/) [ida](https://hnsecurity.it/blog/tag/ida/) [vulnerability research](https://hnsecurity.it/blog/tag/vulnerability-research/) [reverse engineering](https://hnsecurity.it/blog/tag/reverse-engineering/) [static analysis](https://hnsecurity.it/blog/tag/static-analysis/)

[![Groovy logo](https://hnsecurity.it/wp-content/uploads/2025/09/GROOVY.jpg)](https://hnsecurity.it/blog/groovy-template-engine-exploitation-part-2/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Articles](https://hnsecurity.it/blog/category/articles/)

November 11, 2025

### [Groovy Template Engine Exploitation – Notes from a real case scenario, part 2](https://hnsecurity.it/blog/groovy-template-engine-exploitation-part-2/)

[![Microsoft 365 logo](https://hnsecurity.it/wp-content/uploads/2025/09/MIC-365.jpg)](https://hnsecurity.it/blog/export-to-pdf-allows-local-file-inclusion-path-traversal-in-microsoft-365/?media_link=1)

[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

July 8, 2025

### [Export to PDF allows local file inclusion/path traversal in Microsoft 365](https://hnsecurity.it/blog/export-to-pdf-allows-local-file-inclusion-path-traversal-in-microsoft-365/)

[![ZeroDay logo](https://hnsecurity.it/wp-content/uploads/2025/09/ZERODAY.jpg)](https://hnsecurity.it/blog/my-zero-day-quest-bluehat-podcast/?media_link=1)

[Events](https://hnsecurity.it/blog/category/events/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)[Articles](https://hnsecurity.it/blog/category/articles/)

May 6, 2025

### [My Zero Day Quest & BlueHat Podcast](https://hnsecurity.it/blog/my-zero-day-quest-bluehat-podcast/)

[![Zyxel Networks logo](https://hnsecurity.it/wp-content/uploads/2025/09/ZYXEL.jpg)](https://hnsecurity.it/blog/local-privilege-escalation-on-zyxel-usg-flex-h-series-cve-2025-1731/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

April 23, 2025

### [Local privilege escalation on Zyxel USG FLEX H Series (CVE-2025-1731)](https://hnsecurity.it/blog/local-privilege-escalation-on-zyxel-usg-flex-h-series-cve-2025-1731/)

[![Microsoft logo](https://hnsecurity.it/wp-content/uploads/2025/09/WIN.jpg)](https://hnsecurity.it/blog/cve-2024-49138-windows-clfs-heap-based-buffer-overflow-analysis-part-2/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

January 29, 2025

### [CVE-2024-49138 Windows CLFS heap-based buffer overflow analysis – Part 2](https://hnsecurity.it/blog/cve-2024-49138-windows-clfs-heap-based-buffer-overflow-analysis-part-2/)

[![Microsoft logo](https://hnsecurity.it/wp-content/uploads/2025/09/WIN.jpg)](https://hnsecurity.it/blog/cve-2024-49138-windows-clfs-heap-based-buffer-overflow-analysis-part-1/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

January 29, 2025

### [CVE-2024-49138 Windows CLFS heap-based buffer overflow analysis – Part 1](https://hnsecurity.it/blog/cve-2024-49138-windows-clfs-heap-based-buffer-overflow-analysis-part-1/)

[![](https://hnsecurity.it/wp-content/uploads/2025/09/AMD.jpg)](https://hnsecurity.it/blog/from-arbitrary-pointer-dereference-to-arbitrary-read-write-in-latest-windows-11/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

January 15, 2025

### [From arbitrary pointer dereference to arbitrary read/write in latest Windows 11](https://hnsecurity.it/blog/from-arbitrary-pointer-dereference-to-arbitrary-read-write-in-latest-windows-11/)

[![KEYCLOAK logo](https://hnsecurity.it/wp-content/uploads/2025/09/KEYCLOAK.jpg)](https://hnsecurity.it/blog/an-analysis-of-the-keycloak-authentication-system/?media_link=1)

[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)[Articles](https://hnsecurity.it/blog/category/articles/)

October 30, 2024

### [An analysis of the Keycloak authentication system](https://hnsecurity.it/blog/an-analysis-of-the-keycloak-authentication-system/)

[![](https://hnsecurity.it/wp-content/uploads/2025/09/AMD.jpg)](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-3/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

October 9, 2024

### [Exploiting AMD atdcm64a.sys arbitrary pointer dereference – Part 3](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-3/)

[Scroll to top](https://hnsecurity.it/blog/exploiting-amd-atdcm64a.sys-arbitrary-pointer-dereference-part-1/#)

We use cookies to improve your browsing experience and analyze our traffic. By clicking "Accept all", you consent to the use of cookies.Accept AllPrivacy policy