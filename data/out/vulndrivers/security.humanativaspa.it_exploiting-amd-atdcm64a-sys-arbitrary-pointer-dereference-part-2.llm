Title:
Exploiting AMD atdcm64a.sys arbitrary pointer dereference – Part 2

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post demonstrates practical exploitation confirmation of two vulnerabilities in AMD’s Windows kernel driver `atdcm64a.sys`: an arbitrary MSR read and an arbitrary pointer dereference reachable via IOCTLs.  
- For the MSR primitive, the author builds a PoC that reads `IA32_LSTAR` to leak the address of `nt!KiSystemCall64Shadow` and derives the `ntoskrnl.exe` base by subtracting a known offset.  
- For the pointer dereference, the PoC crafts fake `_OBJECT_HEADER`, `_DEVICE_OBJECT`, and `_DRIVER_OBJECT` structures in user memory to influence `IoGetAttachedDeviceReference()`/`IofCallDriver()` and reach an indirect call through `DriverObject->MajorFunction[IRP_MJ_PNP]`.  
- The execution flow is redirected to a controlled function pointer (first `0xdeadbeef` to force a crash, then a valid kernel address) and the author notes controlled registers (RBX/RCX/RDI) at the dispatch point.  
- The article also covers a workflow for kernel debugging the driver with IDA Pro + WinDbg backend, including converting the `nt` module from debugger to loader segments to get decompiled pseudocode for kernel routines.  
- Useful for kernel exploit developers/red teamers validating primitives and for defenders/researchers understanding how IOCTL-exposed bugs can become control-flow hijacks.

Technical Focus:
- Windows kernel driver IOCTL attack surface (`DeviceIoControl`, `\\.\AtiDCM`)
- Arbitrary MSR read (IA32_LSTAR) for kernel ASLR bypass / `ntoskrnl` base leak
- Fake object crafting: `_OBJECT_HEADER`, `_DEVICE_OBJECT`, `_DRIVER_OBJECT`
- Control-flow hijack via `IoGetAttachedDeviceReference()` → `IofCallDriver()` → `MajorFunction[]`
- CFG/indirect call path (`_guard_dispatch_icall`, `jmp rax`) and register control analysis
- Kernel debugging with IDA Pro (WinDbg debugger, PDB loading, segment conversion)

Use Cases:
- Validate and weaponize kernel driver primitives (info leak + control-flow redirection)
- Build LPE exploit chains leveraging third-party signed drivers
- Reproduce/debug IOCTL-triggered kernel crashes and trace call paths
- Develop detections around suspicious access to `\\.\AtiDCM` and abnormal IOCTL usage
- Learn IDA-assisted kernel debugging techniques for Windows internals research

Keywords:
atdcm64a.sys, AMD driver, Windows kernel, IOCTL, DeviceIoControl, \\.\AtiDCM, arbitrary MSR read, IA32_LSTAR, KiSystemCall64Shadow, ntoskrnl.exe base leak, KASLR bypass, arbitrary pointer dereference, _DEVICE_OBJECT, _DRIVER_OBJECT, _OBJECT_HEADER, IoGetAttachedDeviceReference, IofCallDriver, IRP_MJ_PNP, MajorFunction, _guard_dispatch_icall, IDA Pro kernel debugging, WinDbg, PDB symbols, control-flow hijack, BSOD