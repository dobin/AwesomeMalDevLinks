# https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries

<!DOCTYPE html><html lang="en-US" dir="ltr"><body id="yDmH0d" jscontroller="pjICDe" jsaction="rcuQ6b:npT2md; click:FAbpgf; auxclick:FAbpgf" class="tQj5Y ghyPEc IqBfM ecJEib EWZcud nRhiJb-qJTHM" data-has-header="true" data-has-footer="true"><div class="VUoKZ" aria-hidden="true"><div class="TRHLAc"></div></div><c-wiz jsrenderer="zPZHOe" class="SSPGKf" jsdata="deferred-i1" data-p="%.@.&quot;cloudblog&quot;,&quot;topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries&quot;,&quot;en&quot;]" data-node-index="0;0" jsmodel="hc6Ubd" view="" c-wiz="" data-ogpc=""><div class="T4LgNb " jsname="a9kxte"><div jsname="qJTHM" class="kFwPee"><article class="nRhiJb-qJTHM" jsaction="rcuQ6b:npT2md" jscontroller="kxO7ab"><section class="nRhiJb-DARUcf"><div class="Wdmc0c nRhiJb-DbgRPb-wNfPc-cGMI2b"><div class="Qwf2Db-MnozTc Qwf2Db-MnozTc-OWXEXe-MnozTc-qWD73c nRhiJb-BFbNVe-r8s4j-bMElCd dIsJJe" track-name="threat intelligence" track-type="tag">Threat Intelligence</div><div class="nRhiJb-ObfsIf"><div class="nRhiJb-kR0ZEf-OWXEXe-GV1x9e-R6PoUb"></div><div class="nRhiJb-kR0ZEf-OWXEXe-GV1x9e-EehZO nRhiJb-fmcmS-oXtfBe"><h1 class="Qwf2Db-MnozTc Qwf2Db-MnozTc-OWXEXe-MnozTc-ibL1re"><div class="Qwf2Db-MnozTc Qwf2Db-MnozTc-OWXEXe-MnozTc-ibL1re"><span class="FewWi"></span>GoStringUngarbler: Deobfuscating Strings in Garbled Binaries</div></h1></div></div><div class="nRhiJb-fmcmS-oXtfBe dEogG">March 5, 2025</div></div></section><div class="EKklye"><div class="nRhiJb-DARUcf ZWw7T"><div class="npzWPc"><div class="dzoHJ"><div class="nRhiJb-DX2B6 nRhiJb-DX2B6-OWXEXe-h30Snd"><div class="nRhiJb-j5y3u"><ul class="nRhiJb-Qijihe phRaUe" role="list"><li class="hpHPGf"><a class="nRhiJb-ARYxNe" href="https://x.com/intent/tweet?text=GoStringUngarbler:%20Deobfuscating%20Strings%20in%20Garbled%20Binaries%20@googlecloud&amp;url=https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries" track-name="x" track-type="social share" track-metadata-eventdetail="x.com/intent/tweet?text=GoStringUngarbler: Deobfuscating Strings in Garbled Binaries%20@googlecloud&amp;url=cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries" track-metadata-module="social icons" target="_blank" rel="noopener"><svg class="nRhiJb-Bz112c nRhiJb-Bz112c-OWXEXe-DX2B6 nRhiJb-Bz112c-OWXEXe-nSuQf" viewBox="0 0 24 24" role="presentation" aria-hidden="true"><path d="M13.9,10.5L21.1,2h-1.7l-6.3,7.4L8,2H2.2l7.6,11.1L2.2,22h1.7l6.7-7.8L16,22h5.8L13.9,10.5L13.9,10.5z M11.5,13.2l-0.8-1.1 L4.6,3.3h2.7l5,7.1l0.8,1.1l6.5,9.2h-2.7L11.5,13.2L11.5,13.2z"></path></svg></a></li><li class="hpHPGf"><a class="nRhiJb-ARYxNe" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries&amp;title=GoStringUngarbler:%20Deobfuscating%20Strings%20in%20Garbled%20Binaries" track-name="linkedin" track-type="social share" track-metadata-eventdetail="www.linkedin.com/shareArticle?mini=true&amp;url=cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries&amp;title=GoStringUngarbler: Deobfuscating Strings in Garbled Binaries" track-metadata-module="social icons" target="_blank" rel="noopener"><svg class="nRhiJb-Bz112c nRhiJb-Bz112c-OWXEXe-DX2B6 nRhiJb-Bz112c-OWXEXe-nSuQf" viewBox="0 0 24 24" role="presentation" aria-hidden="true"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 20c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 19H5v-9h3v9zM6.5 8.31c-1 0-1.81-.81-1.81-1.81S5.5 4.69 6.5 4.69s1.81.81 1.81 1.81S7.5 8.31 6.5 8.31zM19 19h-3v-5.3c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5V19h-3v-9h3v1.2c.52-.84 1.59-1.4 2.5-1.4 1.93 0 3.5 1.57 3.5 3.5V19z"></path></svg></a></li><li class="hpHPGf"><a class="nRhiJb-ARYxNe" href="https://www.facebook.com/sharer/sharer.php?caption=GoStringUngarbler:%20Deobfuscating%20Strings%20in%20Garbled%20Binaries&amp;u=https://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries" track-name="facebook" track-type="social share" track-metadata-eventdetail="www.facebook.com/sharer/sharer.php?caption=GoStringUngarbler: Deobfuscating Strings in Garbled Binaries&amp;u=cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries" track-metadata-module="social icons" target="_blank" rel="noopener"><svg class="nRhiJb-Bz112c nRhiJb-Bz112c-OWXEXe-DX2B6 nRhiJb-Bz112c-OWXEXe-nSuQf" viewBox="0 0 24 24" role="presentation" aria-hidden="true"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 20c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 2v3h-2c-.55 0-1 .45-1 1v2h3v3h-3v7h-3v-7h-2v-3h2V7.5C13 5.57 14.57 4 16.5 4H19z"></path></svg></a></li><li class="hpHPGf"><a class="nRhiJb-ARYxNe" href="mailto:?subject=GoStringUngarbler:%20Deobfuscating%20Strings%20in%20Garbled%20Binaries&amp;body=Check%20out%20this%20article%20on%20the%20Cloud%20Blog:%0A%0AGoStringUngarbler:%20Deobfuscating%20Strings%20in%20Garbled%20Binaries%0A%0AWe%20discuss%20how%20threat%20actors%20protect%20malware%20with%20garble%20obfuscation,%20and%20the%20process%20of%20automatically%20deobfuscating%20it.%0A%0Ahttps://cloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries" track-name="email" track-type="social share" track-metadata-eventdetail="mailto:?subject=GoStringUngarbler: Deobfuscating Strings in Garbled Binaries&amp;body=Check%20out%20this%20article%20on%20the%20Cloud%20Blog:%0A%0AGoStringUngarbler: Deobfuscating Strings in Garbled Binaries%0A%0AWe discuss how threat actors protect malware with garble obfuscation, and the process of automatically deobfuscating it.%0A%0Acloud.google.com/blog/topics/threat-intelligence/gostringungarbler-deobfuscating-strings-in-garbled-binaries" track-metadata-module="social icons" target="_blank" rel="noopener"><svg class="nRhiJb-Bz112c nRhiJb-Bz112c-OWXEXe-DX2B6 nRhiJb-Bz112c-OWXEXe-nSuQf" viewBox="0 0 24 24" role="presentation" aria-hidden="true"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-.8 2L12 10.8 4.8 6h14.4zM4 18V7.87l8 5.33 8-5.33V18H4z"></path></svg></a></li></ul></div></div></div></div></div><div><section class="nRhiJb-DARUcf"><div class="nRhiJb-DbgRPb-wNfPc-ma6Yeb nRhiJb-DbgRPb-wNfPc-cGMI2b"><section class="DA9Qj nRhiJb-ObfsIf nRhiJb-fmcmS-oXtfBe"><div class="nRhiJb-kR0ZEf-OWXEXe-GV1x9e-c5RTEf"></div><div class="nRhiJb-kR0ZEf-OWXEXe-GV1x9e-qWD73c"><h5 class="cHE8Ub Qwf2Db-MnozTc Qwf2Db-MnozTc-OWXEXe-MnozTc-qWD73c">Mandiant </h5><p class="nRhiJb-qJTHM khCp7b"></p></div></section></div></section><div class="nRhiJb-DARUcf"><div class="nRhiJb-ObfsIf nRhiJb-DbgRPb-wNfPc-ma6Yeb nRhiJb-DbgRPb-qWD73c-cGMI2b"><div class="nRhiJb-kR0ZEf-OWXEXe-GV1x9e-ibL1re dzoHJ"></div><div class="OYL9D nRhiJb-kR0ZEf-OWXEXe-GV1x9e-OiUrBf" jsname="tx2NYc"><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p>Written by: <span style="vertical-align:baseline">Chuong Dong</span></p>
<hr></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><h2><span style="vertical-align:baseline">Overview</span></h2>
<p><span style="vertical-align:baseline">In our day-to-day work, the FLARE team often encounters malware written in </span><a href="https://go.dev/" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">Go</span></a><span style="vertical-align:baseline"> that is protected using </span><a href="https://github.com/burrowers/garble" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">garble</span></a><span style="vertical-align:baseline">. While recent advancements in Go analysis from tools like IDA Pro have simplified the analysis process, </span><span style="font-style:italic;vertical-align:baseline">garble</span><span style="vertical-align:baseline"> presents a set of unique challenges, including stripped binaries, function name mangling, and encrypted strings.</span></p>
<p><span style="vertical-align:baseline">Garble's string encryption, while relatively straightforward, significantly hinders static analysis. In this blog post, we'll detail garble’s string transformations and the process of automatically deobfuscating them.</span></p>
<p><span style="vertical-align:baseline">We're also introducing </span><span style="font-style:italic;vertical-align:baseline">GoStringUngarbler</span><span style="vertical-align:baseline">, a command-line tool written in Python that automatically decrypts strings found in garble-obfuscated Go binaries. This tool can streamline the reverse engineering process by producing a deobfuscated binary with all strings recovered and shown in plain text, thereby simplifying static analysis, malware detection, and classification.</span></p></div></section><section class="k6ctOd"></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><h2><span style="vertical-align:baseline">Garble Obfuscating Compiler</span></h2>
<p><span style="vertical-align:baseline">Before detailing the GoStringUngarbler tool, we want to briefly explain how the garble compiler modifies the build process of Go binaries. By wrapping around the official Go compiler, garble</span><strong style="vertical-align:baseline"> </strong><span style="vertical-align:baseline">performs transformations on the source code during compilation through Abstract Syntax Tree (AST) manipulation using Go’s </span><a href="https://pkg.go.dev/go/ast" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">go/ast</span></a><span style="vertical-align:baseline"> library. Here, the obfuscating compiler modifies program elements to obfuscate the produced binary while preserving the semantic integrity of the program. Once transformed by garble, the program’s AST is fed back into the Go compilation pipeline, producing an executable that is harder to reverse engineer and analyze statically.&nbsp;</span></p>
<p><span style="vertical-align:baseline">While garble can apply a variety of transformations to the source code, this blog post will focus on its "literal" transformations. When garble is executed with the </span><code style="vertical-align:baseline">-literals</code><strong style="vertical-align:baseline"> </strong><span style="vertical-align:baseline">flag, it transforms all literal strings in the source code and imported Go libraries into an obfuscated form. Each string is encoded and wrapped behind a decrypting function, thwarting static string analysis.&nbsp;</span></p>
<p><span style="vertical-align:baseline">For each string, the obfuscating compiler can randomly apply one of the following literal transformations. We'll explore each in greater detail in subsequent sections.</span></p>
<ul>
<li style="list-style-type:disc;vertical-align:baseline">
<p><strong style="vertical-align:baseline">Stack transformation</strong><span style="vertical-align:baseline">: This method implements runtime encoding to strings stored directly on the stack.</span></p>
</li>
<li style="list-style-type:disc;vertical-align:baseline">
<p><strong style="vertical-align:baseline">Seed transformation</strong><span style="vertical-align:baseline">: This method employs a dynamic seed-based encryption mechanism where the seed value evolves with each encrypted byte, creating a chain of interdependent encryption operations.</span></p>
</li>
<li style="list-style-type:disc;vertical-align:baseline">
<p><strong style="vertical-align:baseline">Split transformation</strong><span style="vertical-align:baseline">: This method fragments the encrypted strings into multiple chunks, each to be decrypted independently in a block of a main switch statement.</span></p>
</li>
</ul>
<h3><span style="vertical-align:baseline">Stack Transformation</span></h3>
<p><span style="vertical-align:baseline">The stack transformation in garble</span><strong style="vertical-align:baseline"> </strong><span style="vertical-align:baseline">implements runtime encrypting techniques that operate directly on the stack, using three distinct transformation types: simple, swap, and shuffle. These names are taken directly from the garble’s source code. All three perform cryptographic operations with the string residing on the stack, but each differs in complexity and approach to data manipulation.</span></p>
<ul>
<li><strong style="vertical-align:baseline">Simple transformation:</strong><span style="vertical-align:baseline"> This transformation applies byte-by-byte encoding using a randomly generated mathematical operator and a randomly generated key of equal length to the input string.</span></li>
<li><strong style="vertical-align:baseline">Swap transformation: </strong><span style="vertical-align:baseline">This transformation applies a combination of byte-pair swapping and position-dependent encoding, where pairs of bytes are shuffled and encrypted using dynamically generated local keys.</span></li>
<li><strong style="vertical-align:baseline">Shuffle transformation:</strong><span style="vertical-align:baseline"> This transformation applies multiple layers of encryption by encoding the data with random keys, interleaving the encrypted data with its keys, and applying a permutation with XOR-based index mapping to scatter the encrypted data and keys throughout the final output.</span></li>
</ul>
<h4><span style="vertical-align:baseline">Simple Transformation</span></h4>
<p><span style="vertical-align:baseline">This transformation implements a straightforward byte-level encoding scheme at the AST level. The following is the </span><a href="https://github.com/burrowers/garble/blob/master/internal/literals/simple.go" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">implementation from the garble repository</span></a><span style="vertical-align:baseline">. In Figure 1 and subsequent code samples taken from the garble repository, comments were added by the author for readability. </span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><pre><code>// Generate a random key with the same length as the input string
key := make([]byte, len(data))

// Fill the key with random bytes
obfRand.Read(key)

// Select a random operator (XOR, ADD, SUB) to be used for encryption
op := randOperator(obfRand)

// Encrypt each byte of the data with the key using the random operator
for i, b := range key {
    data[i] = evalOperator(op, data[i], b)
}</code></pre>
<p style="text-align:center"><span style="color:#5f6368;display:block;font-size:16px;font-style:italic;margin-top:8px;width:100%">Figure 1: <span style="vertical-align:baseline">Simple transformation implementation</span></span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p><span style="vertical-align:baseline">The obfuscator begins by generating a random key of equal length to the input string. It then randomly selects a reversible arithmetic operator (XOR, addition, or subtraction) that will be used throughout the encoding process.</span></p>
<p><span style="vertical-align:baseline">The obfuscation is performed by iterating through the data and key bytes simultaneously, applying the chosen operator between each corresponding pair to produce the encoded output.</span></p>
<p><span style="vertical-align:baseline">Figure 2 shows the decompiled code produced by </span><a href="https://hex-rays.com/" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">IDA</span></a><span style="vertical-align:baseline"> of a decrypting subroutine of this transformation type.</span></p></div></section><section class="QzPuud"><div><section><figure class="NEBdNd"><section class="PBkdHd DhGbH" jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig2.max-800x800.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig2.max-800x800.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><section class="glue-modal glue-modal--dark QHdDac" role="dialog" aria-modal="true"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig2.max-800x800.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig2.max-800x800.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><button class="glue-modal__close-btn" tabindex="0" aria-label="Close this modal"></button></section></section></figure><div class="nRhiJb-cHYyed nRhiJb-DbgRPb-R6PoUb-ma6Yeb ZpqjUe"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p>Figure 2: Decompiled code of a simple transformation decrypting subroutine</p></div></div></section></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><h4><span style="vertical-align:baseline">Swap Transformation</span></h4>
<p><span style="vertical-align:baseline">The swap transformation uses a byte-shuffling and encryption algorithm to encrypt a string literal. Figure 3 shows its </span><a href="https://github.com/burrowers/garble/blob/master/internal/literals/swap.go" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">implementation from the garble repository</span></a><span style="vertical-align:baseline">.</span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><pre><code>// Determines how many swap operations to perform based on data length
func generateSwapCount(obfRand *mathrand.Rand, dataLen int) int {
    // Start with number of swaps equal to data length
    swapCount := dataLen

    // Calculate maximum additional swaps (half of data length)
    maxExtraPositions := dataLen / 2

    // Add a random amount if we can add extra positions 
    if maxExtraPositions &gt; 1 {
        swapCount += obfRand.Intn(maxExtraPositions)
    }

    // Ensure swap count is even by incrementing if odd
    if swapCount%2 != 0 {
        swapCount++
    }
    return swapCount
}

func (swap) obfuscate(obfRand *mathrand.Rand, data []byte) 
*ast.BlockStmt {
    // Generate number of swap operations to perform
    swapCount := generateSwapCount(obfRand, len(data))

    // Generate a random shift key
    shiftKey := byte(obfRand.Uint32())

    // Select a random reversible operator for encryption
    op := randOperator(obfRand)

    // Generate list of random positions for swapping bytes
    positions := genRandIntSlice(obfRand, len(data), swapCount)

    // Process pairs of positions in reverse order
    for i := len(positions) - 2; i &gt;= 0; i -= 2 {
        // Generate a position-dependent local key for each pair
        localKey := byte(i) + byte(positions[i]^positions[i+1]) + shiftKey
        
        // Perform swap and encryption:
        // - Swap positions[i] and positions[i+1]
        // - Encrypt the byte at each position with the local key
        data[positions[i]], data[positions[i+1]] = evalOperator(op, 
data[positions[i+1]], localKey), evalOperator(op, data[positions[i]], 
localKey)
    }
...
</code></pre>
<p style="text-align:center"><span style="color:#5f6368;display:block;font-size:16px;font-style:italic;margin-top:8px;width:100%">Figure 3: <span style="vertical-align:baseline">Swap transformation implementation</span></span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p><span style="vertical-align:baseline">The transformation begins by generating an even number of random swap positions, which is determined based on the data length plus a random number of additional positions (limited to half the data length). The compiler then randomly generates a list of random swap positions with this length.</span></p>
<p><span style="vertical-align:baseline">The core obfuscation process operates by iterating through pairs of positions in reverse order, performing both a swap operation and encryption on each pair. For each iteration, it generates a position-dependent local encryption key by combining the iteration index, the XOR result of the current position pair, and a random shift key. This local key is then used to encrypt the swapped bytes with a randomly selected reversible operator.</span></p>
<p><span style="vertical-align:baseline">Figure 4 shows the decompiled code produced by IDA of a decrypting subroutine of the swap transformation.</span></p></div></section><section class="QzPuud"><div><section><figure class="NEBdNd"><section class="PBkdHd DhGbH" jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig4.max-900x900.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig4.max-900x900.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><section class="glue-modal glue-modal--dark QHdDac" role="dialog" aria-modal="true"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig4.max-900x900.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig4.max-900x900.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><button class="glue-modal__close-btn" tabindex="0" aria-label="Close this modal"></button></section></section></figure><div class="nRhiJb-cHYyed nRhiJb-DbgRPb-R6PoUb-ma6Yeb ZpqjUe"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p>Figure 4: Decompiled code of a swap transformation decrypting subroutine</p></div></div></section></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><h4><span style="vertical-align:baseline">Shuffle Transformation</span></h4>
<p><span style="vertical-align:baseline">The shuffle transformation is the most complicated of the three stack transformation types. Here, garble</span><strong style="vertical-align:baseline"> </strong><span style="vertical-align:baseline">applies its obfuscation by encrypting the original string with random keys, interleaving the encrypted data with its keys, and scattering the encrypted data and keys throughout the final output. Figure 5 shows the </span><a href="https://github.com/burrowers/garble/blob/master/internal/literals/shuffle.go" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">implementation from the garble repository</span></a><span style="vertical-align:baseline">.</span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><pre><code>// Generate a random key with the same length as the original string
key := make([]byte, len(data))
obfRand.Read(key)

// Constants for the index key size bounds
const (
    minIdxKeySize = 2
    maxIdxKeySize = 16
)

// Initialize index key size to minimum value
idxKeySize := minIdxKeySize

// Potentially increase index key size based on input data length
if tmp := obfRand.Intn(len(data)); tmp &gt; idxKeySize {
    idxKeySize = tmp
}

// Cap index key size at maximum value
if idxKeySize &gt; maxIdxKeySize {
    idxKeySize = maxIdxKeySize
}

// Generate a secondary key (index key) for index scrambling
idxKey := make([]byte, idxKeySize)
obfRand.Read(idxKey)

// Create a buffer that will hold both the encrypted data and the key
fullData := make([]byte, len(data)+len(key))

// Generate random operators for each position in the full data buffer
operators := make([]token.Token, len(fullData))
for i := range operators {
    operators[i] = randOperator(obfRand)
}

// Encrypt data and store it with its corresponding key
// First half contains encrypted data, second half contains the key
for i, b := range key {
    fullData[i], fullData[i+len(data)] = evalOperator(operators[i], 
data[i], b), b
}

// Generate a random permutation of indices
shuffledIdxs := obfRand.Perm(len(fullData))

// Apply the permutation to scatter encrypted data and keys
shuffledFullData := make([]byte, len(fullData))
for i, b := range fullData {
    shuffledFullData[shuffledIdxs[i]] = b
}

// Prepare AST expressions for decryption
args := []ast.Expr{ast.NewIdent("data")}
for i := range data {
    // Select a random byte from the index key
    keyIdx := obfRand.Intn(idxKeySize)
    k := int(idxKey[keyIdx])
    
    // Build AST expression for decryption:
    // 1. Uses XOR with index key to find the real positions of data 
and key
    // 2. Applies reverse operator to decrypt the data using the 
corresponding key
    args = append(args, operatorToReversedBinaryExpr(
        operators[i],

        // Access encrypted data using XOR-ed index
        ah.IndexExpr("fullData", &amp;ast.BinaryExpr{X: ah.IntLit(shuffledIdxs[i] 
^ k), Op: token.XOR, Y: ah.CallExprByName("int", ah.IndexExpr("idxKey", 
ah.IntLit(keyIdx)))}),
        
        // Access corresponding key using XOR-ed index
        ah.IndexExpr("fullData", &amp;ast.BinaryExpr{X: 
ah.IntLit(shuffledIdxs[len(data)+i] ^ k), Op: token.XOR, Y: 
ah.CallExprByName("int", ah.IndexExpr("idxKey", ah.IntLit(keyIdx)))}),
    ))
}</code></pre>
<p style="text-align:center"><span style="color:#5f6368;display:block;font-size:16px;font-style:italic;margin-top:8px;width:100%">Figure 5: <span style="vertical-align:baseline">Shuffle transformation implementation</span></span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p><span style="vertical-align:baseline">Garble begins by generating two types of keys: a primary key of equal length to the input string for data encryption and a smaller index key (between two and 16 bytes) for index scrambling. The transformation process then occurs in the following four steps:</span></p>
<ol>
<li style="list-style-type:decimal;vertical-align:baseline">
<p><strong style="vertical-align:baseline">Initial encryption:</strong><span style="vertical-align:baseline"> Each byte of the input data is encrypted using a randomly generated reversible operator with its corresponding key byte.</span></p>
</li>
<li style="list-style-type:decimal;vertical-align:baseline">
<p><strong style="vertical-align:baseline">Data interleaving:</strong><span style="vertical-align:baseline"> The encrypted data and key bytes are combined into a single buffer, with encrypted data in the first half and corresponding keys in the second half.</span></p>
</li>
<li style="list-style-type:decimal;vertical-align:baseline">
<p><strong style="vertical-align:baseline">Index permutation:</strong><span style="vertical-align:baseline"> The key-data buffer undergoes a random permutation, scattering both the encrypted data and keys throughout the buffer.</span></p>
</li>
<li style="list-style-type:decimal;vertical-align:baseline">
<p><strong style="vertical-align:baseline">Index encryption:</strong><span style="vertical-align:baseline"> Access to the permuted data is further obfuscated by XOR-ing the permuted indices with randomly selected bytes from the index key.</span></p>
</li>
</ol>
<p><span style="vertical-align:baseline">Figure 6 shows the decompiled code produced by IDA of a decrypting subroutine of the shuffle transformation.</span></p></div></section><section class="QzPuud"><div><section><figure class="NEBdNd"><section class="PBkdHd DhGbH" jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig6.max-1100x1100.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig6.max-1100x1100.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><section class="glue-modal glue-modal--dark QHdDac" role="dialog" aria-modal="true"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig6.max-1100x1100.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig6.max-1100x1100.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><button class="glue-modal__close-btn" tabindex="0" aria-label="Close this modal"></button></section></section></figure><div class="nRhiJb-cHYyed nRhiJb-DbgRPb-R6PoUb-ma6Yeb ZpqjUe"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p>Figure 6: Decompiled code of a shuffle transformation decrypting subroutine</p></div></div></section></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><h3><span style="vertical-align:baseline">Seed Transformation</span></h3>
<p><span style="vertical-align:baseline">The seed transformation implements a chained encoding scheme where each byte’s encryption depends on the previous encryptions through a continuously updated seed value. Figure 7 shows the </span><a href="https://github.com/burrowers/garble/blob/master/internal/literals/seed.go" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">implementation from the garble repository</span></a><span style="vertical-align:baseline">.</span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><pre><code>// Generate random initial seed value
seed := byte(obfRand.Uint32())

// Store original seed for later use in decryption
originalSeed := seed

// Select a random reversible operator for encryption
op := randOperator(obfRand)

var callExpr *ast.CallExpr

// Encrypt each byte while building chain of function calls
for i, b := range data {
   // Encrypt current byte using current seed value
   encB := evalOperator(op, b, seed)

   // Update seed by adding encrypted byte
   seed += encB

   if i == 0 {
       // Start function call chain with first encrypted byte
       callExpr = ah.CallExpr(ast.NewIdent("fnc"), ah.IntLit(int(encB)))
   } else {
       // Add subsequent encrypted bytes to function call chain
       callExpr = ah.CallExpr(callExpr, ah.IntLit(int(encB)))
   }
}
...</code></pre>
<p style="text-align:center"><span style="color:#5f6368;display:block;font-size:16px;font-style:italic;margin-top:8px;width:100%"><span style="vertical-align:baseline">Figure 7</span><span style="vertical-align:baseline">: Seed transformation implementation</span></span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p><span style="vertical-align:baseline">Garble begins by randomly generating a seed value to be used for encryption. As the compiler iterates through the input string, each byte is encrypted by applying the random operator with the current seed, and the seed is updated by adding the encrypted byte. In this seed transformation, each byte’s encryption depends on the result of the previous one, creating a chain of dependencies through the continuously updated seed.</span></p>
<p><span style="vertical-align:baseline">In the decryption setup, as shown in the IDA decompiled code in Figure 8, the obfuscator generates a chain of calls to a decrypting function. For each encrypted byte starting with the first one, the decrypting function applies the operator to decrypt it with the current seed and updates the seed by adding the encrypted byte to it. Because of this setup, subroutines of this transformation type are easily recognizable in the decompiler and disassembly views due to the multiple function calls it makes in the decryption process.</span></p></div></section><section class="QzPuud"><div><section><figure class="NEBdNd"><section class="PBkdHd DhGbH" jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig8.max-1100x1100.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig8.max-1100x1100.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><section class="glue-modal glue-modal--dark QHdDac" role="dialog" aria-modal="true"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig8.max-1100x1100.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig8.max-1100x1100.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><button class="glue-modal__close-btn" tabindex="0" aria-label="Close this modal"></button></section></section></figure><div class="nRhiJb-cHYyed nRhiJb-DbgRPb-R6PoUb-ma6Yeb ZpqjUe"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p>Figure 8: Decompiled code of a seed transformation decrypting subroutine</p></div></div></section></div></section><section class="QzPuud"><div><section><figure class="NEBdNd"><section class="PBkdHd DhGbH" jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig9.max-900x900.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig9.max-900x900.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><section class="glue-modal glue-modal--dark QHdDac" role="dialog" aria-modal="true"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig9.max-900x900.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig9.max-900x900.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><button class="glue-modal__close-btn" tabindex="0" aria-label="Close this modal"></button></section></section></figure><div class="nRhiJb-cHYyed nRhiJb-DbgRPb-R6PoUb-ma6Yeb ZpqjUe"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p>Figure 9: Disassembled code of a seed transformation decrypting subroutine</p></div></div></section></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><h3><span style="vertical-align:baseline">Split Transformation</span></h3>
<p><span style="vertical-align:baseline">The split transformation is one of the more sophisticated string transformation techniques by garble, implementing a multilayered approach that combines data fragmentation, encryption, and control flow manipulation. Figure 10 shows the </span><a href="https://github.com/burrowers/garble/blob/master/internal/literals/split.go" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">implementation from the garble repository</span></a><span style="vertical-align:baseline">.</span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><pre><code>func (split) obfuscate(obfRand *mathrand.Rand, data []byte) 
*ast.BlockStmt {
    var chunks [][]byte

    // For small input, split into single bytes
    // This ensures even small payloads get sufficient obfuscation
    if len(data)/maxChunkSize &lt; minCaseCount {
        chunks = splitIntoOneByteChunks(data)
    } else {
        chunks = splitIntoRandomChunks(obfRand, data)
    }

    // Generate random indexes for all chunks plus two special cases:
    // - One for the final decryption operation
    // - One for the exit condition
    indexes := obfRand.Perm(len(chunks) + 2)

    // Initialize the decryption key with a random value
    decryptKeyInitial := byte(obfRand.Uint32())
    decryptKey := decryptKeyInitial
    
    // Calculate the final decryption key by XORing it with 
position-dependent values
    for i, index := range indexes[:len(indexes)-1] {
        decryptKey ^= byte(index * i)
    }

    // Select a random reversible operator for encryption
    op := randOperator(obfRand)

    // Encrypt all data chunks using the selected operator and key
    encryptChunks(chunks, op, decryptKey)

    // Get special indexes for decrypt and exit states
    decryptIndex := indexes[len(indexes)-2]
    exitIndex := indexes[len(indexes)-1]
    
    // Create the decrypt case that reassembles the data
    switchCases := []ast.Stmt{&amp;ast.CaseClause{
        List: []ast.Expr{ah.IntLit(decryptIndex)},
        Body: shuffleStmts(obfRand,
            // Exit case: Set next state to exit
            &amp;ast.AssignStmt{
                Lhs: []ast.Expr{ast.NewIdent("i")},
                Tok: token.ASSIGN,
                Rhs: []ast.Expr{ah.IntLit(exitIndex)},
            },
            // Iterate through the assembled data and decrypt each byte
            &amp;ast.RangeStmt{
                Key: ast.NewIdent("y"),
                Tok: token.DEFINE,
                X:   ast.NewIdent("data"),
                Body: ah.BlockStmt(&amp;ast.AssignStmt{
                    Lhs: []ast.Expr{ah.IndexExpr("data", ast.NewIdent("y"))},
                    Tok: token.ASSIGN,
                    Rhs: []ast.Expr{
                        // Apply the reverse of the encryption operation
                        operatorToReversedBinaryExpr(
                            op,
                            ah.IndexExpr("data", ast.NewIdent("y")),
                            // XOR with position-dependent key
                            ah.CallExpr(ast.NewIdent("byte"), &amp;ast.BinaryExpr{
                                X:  ast.NewIdent("decryptKey"),
                                Op: token.XOR,
                                Y:  ast.NewIdent("y"),
                            }),
                        ),
                    },
                }),
            },
        ),
    }}

    // Create switch cases for each chunk of data
    for i := range chunks {
        index := indexes[i]
        nextIndex := indexes[i+1]
        chunk := chunks[i]

        appendCallExpr := &amp;ast.CallExpr{
            Fun:  ast.NewIdent("append"),
            Args: []ast.Expr{ast.NewIdent("data")},
        }
	 ...
        // Create switch case for this chunk
        switchCases = append(switchCases, &amp;ast.CaseClause{
            List: []ast.Expr{ah.IntLit(index)},
            Body: shuffleStmts(obfRand,
                // Set next state
                &amp;ast.AssignStmt{
                    Lhs: []ast.Expr{ast.NewIdent("i")},
                    Tok: token.ASSIGN,
                    Rhs: []ast.Expr{ah.IntLit(nextIndex)},
                },
                // Append this chunk to the collected data
                &amp;ast.AssignStmt{
                    Lhs: []ast.Expr{ast.NewIdent("data")},
                    Tok: token.ASSIGN,
                    Rhs: []ast.Expr{appendCallExpr},
                },
            ),
        })
    }

    // Final block creates the state machine loop structure
    return ah.BlockStmt(
        ...

        // Update decrypt key based on current state and counter
        Body: ah.BlockStmt(
            &amp;ast.AssignStmt{
                Lhs: []ast.Expr{ast.NewIdent("decryptKey")},
                Tok: token.XOR_ASSIGN,
                Rhs: []ast.Expr{
                    &amp;ast.BinaryExpr{
                        X:  ast.NewIdent("i"),
                        Op: token.MUL,
                        Y:  ast.NewIdent("counter"),
                    },
                },
            },
            // Main switch statement as the core of the state machine
            &amp;ast.SwitchStmt{
                Tag:  ast.NewIdent("i"),
                Body: ah.BlockStmt(shuffleStmts(obfRand, switchCases...)...),
            }),</code></pre>
<p style="text-align:center"><span style="color:#5f6368;display:block;font-size:16px;font-style:italic;margin-top:8px;width:100%">Figure 10: <span style="vertical-align:baseline">Split transformation implementation</span></span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p><span style="vertical-align:baseline">The transformation begins by splitting the input string into chunks of varying sizes. Shorter strings are broken into individual bytes, while longer strings are divided into random-sized chunks of up to four bytes.</span></p>
<p><span style="vertical-align:baseline">The transformation then constructs a decrypting mechanism using a switch-based control flow pattern. Rather than processing chunks sequentially, the compiler generates a randomized execution order through a series of switch cases. Each case handles a specific chunk of data, encrypting it with a position-dependent key derived from both the chunk's position and a global encryption key.</span></p>
<p><span style="vertical-align:baseline">In the decryption setup, as shown in the IDA decompiled code in Figure 11, the obfuscator first collects the encrypted data by going through each chunk in their corresponding order. In the final switch case, the compiler performs a final pass to XOR-decrypt the encrypted buffer. This pass uses a continuously updated key that depends on both the byte position and the execution path taken through the switch statement to decrypt each byte.</span></p></div></section><section class="QzPuud"><div><section><figure class="NEBdNd"><section class="PBkdHd DhGbH" jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig11.max-1000x1000.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig11.max-1000x1000.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><section class="glue-modal glue-modal--dark QHdDac" role="dialog" aria-modal="true"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig11.max-1000x1000.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig11.max-1000x1000.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><button class="glue-modal__close-btn" tabindex="0" aria-label="Close this modal"></button></section></section></figure><div class="nRhiJb-cHYyed nRhiJb-DbgRPb-R6PoUb-ma6Yeb ZpqjUe"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p>Figure 11: Decompiled code of a split transformation decrypting subroutine</p></div></div></section></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><h2><span style="vertical-align:baseline">GoStringUngarbler: Automatic String Deobfuscator</span></h2>
<p><span style="vertical-align:baseline">To systematically approach string decryption automation, we first consider how this can be done manually. From our experience, the most efficient manual approach leverages dynamic analysis through a debugger. Upon finding a decrypting subroutine, we can manipulate the program counter to target the subroutine's entry point, execute until the </span><code style="vertical-align:baseline">ret</code><span style="vertical-align:baseline"> instruction, and extract the decrypted string from the return buffer.</span></p>
<p><span style="vertical-align:baseline">To perform this process automatically, the primary challenge lies in identifying all decrypting subroutines introduced by garble's transformations. Our analysis revealed a consistent pattern—decrypted strings are always processed through Go's </span><code style="vertical-align:baseline">runtime_slicebytetostring</code><span style="vertical-align:baseline"> function before being returned by the decrypting subroutine. This observation provides a reliable anchor point, allowing us to construct regular expression (regex) patterns to automatically detect these subroutines.</span></p>
<h3><span style="vertical-align:baseline">String Encryption Subroutine Patterns</span></h3>
<p><span style="vertical-align:baseline">Through analyzing the disassembled code, we have identified consistent instruction patterns for each string transformation variant. For each transformation on 64-bit binaries, </span><code style="vertical-align:baseline">rbx</code><span style="vertical-align:baseline"> is used to store the decrypted string pointer, and </span><code style="vertical-align:baseline">rcx</code><span style="vertical-align:baseline"> is assigned with the length of the decrypted string. The main difference between the transformations is the way these two registers are populated before the call to </span><code style="vertical-align:baseline">runtime_slicebytetostring</code><span style="vertical-align:baseline">.</span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><pre><code># Go compiler v1.21 -&gt; v1.23 (x64)

# Stack Transformation Epilogue Pattern 

48 8D 5C ?? ??     lea     rbx, [rsp+&lt;num&gt;]            # decrypted string pointer
B9 ?? ?? ?? ??     mov     ecx, &lt;num&gt;                  # decrypted string length
E8 ?? ?? ?? ??     call    runtime_slicebytetostring
48 83 ?? ??        add     rsp, &lt;num&gt;                  # epilogue clean up
5D                 pop     rbp
C3                 retn

---------------------------------------
# Split Transformation Epilogue Pattern

31 C0              xor     eax, eax
48 89 ??           mov     rbx, &lt;reg&gt;                  # decrypted string pointer
48 89 ??           mov     rcx, &lt;reg&gt;                  # decrypted string length
E8 ?? ?? ?? ??     call    runtime_slicebytetostring
48 83 ?? ??        add     rsp, &lt;num&gt;
5D                 pop     rbp
C3                 retn

---------------------------------------
# Seed Transformation Epilogue Pattern

48 8B ??           mov     rbx, [&lt;reg&gt;]                # decrypted string pointer
48 8B ?? ??        mov     rcx, [&lt;reg&gt;+8]              # decrypted string length
31 C0              xor     eax, eax
E8 ?? ?? ?? ??     call    runtime_slicebytetostring
48 83 ?? ??        add     rsp, &lt;num&gt;
5D                 pop     rbp
C3                 retn</code></pre>
<p style="text-align:center"><span style="color:#5f6368;display:block;font-size:16px;font-style:italic;margin-top:8px;width:100%">Figure 12: <span style="vertical-align:baseline">Epilogue patterns of garble’s</span><strong style="vertical-align:baseline"> </strong><span style="vertical-align:baseline">decrypting subroutines</span></span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p><span style="vertical-align:baseline">Through the assembly patterns in Figure 12, we develop regex patterns corresponding to each of garble's transformation types, which allows us to automatically identify string decrypting subroutines with high precision.</span></p>
<p><span style="vertical-align:baseline">To extract the decrypted string, we must find the subroutine’s prologue and perform instruction-level emulation from this entry point until </span><code style="vertical-align:baseline">runtime_slicebytestring</code><span style="vertical-align:baseline"> is called. For binaries of Go versions v1.21 to v1.23, we observe two main patterns of instructions in the subroutine prologue that perform the Go stack check.</span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><pre><code># Go prologue pattern 1

49 3B ?? ??             cmp     rsp, [&lt;reg&gt;+&lt;num&gt;]
0F 86 ?? ?? ?? ??       jbe     &lt;offset&gt;

------------------------
# Go prologue pattern 2

49 3B ?? ??             cmp     rsp, [&lt;reg&gt;+&lt;num&gt;]
76 ??                   jbe     short &lt;offset&gt;</code></pre>
<p style="text-align:center"><span style="color:#5f6368;display:block;font-size:16px;font-style:italic;margin-top:8px;width:100%">Figure 13: <span style="vertical-align:baseline">Prologue instruction patterns of Go subroutines</span></span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p><span style="vertical-align:baseline">These instruction patterns in the Go prologue serve as reliable entry point markers for emulation. The implementation in GoStringUngarbler leverages these structural patterns to establish reliable execution contexts for the </span><a href="https://www.unicorn-engine.org/" rel="noopener" target="_blank"><span style="font-style:italic;text-decoration:underline;vertical-align:baseline">unicorn</span><span style="text-decoration:underline;vertical-align:baseline"> emulation engine</span></a><span style="vertical-align:baseline">, ensuring accurate string recovery across various garble string transformations.</span></p>
<p><span style="vertical-align:baseline">Figure 14 shows the output of our automated extraction framework, where GoStringUngarbler</span><strong style="vertical-align:baseline"> </strong><span style="vertical-align:baseline">is able to identify and emulate all decrypting subroutines.</span></p></div></section><section class="QzPuud"><div><section><figure class="NEBdNd"><section class="PBkdHd DhGbH" jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/original_images/garble-fig14.gif" alt="https://storage.googleapis.com/gweb-cloudblog-publish/original_images/garble-fig14.gif" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><section class="glue-modal glue-modal--dark QHdDac" role="dialog" aria-modal="true"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/original_images/garble-fig14.gif" alt="https://storage.googleapis.com/gweb-cloudblog-publish/original_images/garble-fig14.gif" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><button class="glue-modal__close-btn" tabindex="0" aria-label="Close this modal"></button></section></section></figure><div class="nRhiJb-cHYyed nRhiJb-DbgRPb-R6PoUb-ma6Yeb ZpqjUe"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p>Figure 14: GoStringUngarbler’s string extraction output</p></div></div></section></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p><span style="vertical-align:baseline">From these instruction patterns, we have derived a YARA rule for detecting samples that are obfuscated with garble’s literal transformation. The rule can be found in </span><a href="https://github.com/mandiant/gostringungarbler" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">Mandiant's GitHub repository</span></a><span style="vertical-align:baseline">.</span></p>
<h3><span style="vertical-align:baseline">Deobfuscation: Subroutine Patching</span></h3>
<p><span style="vertical-align:baseline">While extracting obfuscated strings can aid malware detection through signature-based analysis, this alone is not useful for reverse engineers conducting static analysis. To aid reverse engineering efforts, we've implemented a binary deobfuscation approach leveraging the emulation results.&nbsp;</span></p>
<p><span style="vertical-align:baseline">Although developing an IDA plugin would have streamlined our development process, we recognize that not all malware analysts have access to, or prefer to use, IDA Pro. To make our tool more accessible, we developed GoStringUngarbler as a standalone Python utility to process binaries protected by garble. The tool can deobfuscate and produce functionally identical executables with recovered strings stored in plain text, improving both reverse engineering analysis and malware detection workflows.</span></p>
<p><span style="vertical-align:baseline">For each identified decrypting subroutine, we implement a strategic patching methodology, replacing the original code with an optimized stub while padding the remaining subroutine space with </span><code style="vertical-align:baseline">INT3</code><span style="vertical-align:baseline"> instructions (Figure 15).</span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><pre><code>xor     eax, eax                           ; clear return register
lea     rbx, &lt;string addr&gt;                 ; Load effective address of decrypted string 
mov     ecx, &lt;string len&gt;                  ; populate string length
call    runtime_slicebytetostring          ; convert slice to Go string
ret                                        ; return the decrypted string</code></pre>
<p style="text-align:center"><span style="color:#5f6368;display:block;font-size:16px;font-style:italic;margin-top:8px;width:100%">Figure 15: <span style="vertical-align:baseline">Function stub to patch over garble’s decrypting subroutines</span></span></p></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p><span style="vertical-align:baseline">Initially, we considered storing recovered strings within an existing binary section for efficient referencing from the patched subroutines. However, after examining obfuscated binaries, we found that there is not enough space within existing sections to consistently accommodate the deobfuscated strings. On the other hand, adding a new section, while feasible, would introduce unnecessary complexity to our tool.</span></p>
<p><span style="vertical-align:baseline">Instead, we opt for a more elegant space utilization strategy by leveraging the inherent characteristics of garble's string transformations. In our tool, we implement in-place string storage by writing the decrypted string directly after the patched stub, capitalizing on the guaranteed available space from decrypting routines:</span></p>
<ol>
<li style="list-style-type:decimal;vertical-align:baseline">
<p><strong style="vertical-align:baseline">Stack transformation:</strong><span style="vertical-align:baseline"> The decrypting subroutine stores and processes encrypted strings on the stack, providing adequate space through their data manipulation instructions. The instructions originally used for pushing encrypted data onto the stack create a natural storage space for the decrypted string.</span></p>
</li>
<li style="list-style-type:decimal;vertical-align:baseline">
<p><strong style="vertical-align:baseline">Seed transformation:</strong><span style="vertical-align:baseline"> For each character, the decrypting subroutine requires a call instruction to decrypt it and update the seed. This is more than enough space to store the decrypted bytes.</span></p>
</li>
<li style="list-style-type:decimal;vertical-align:baseline">
<p><strong style="vertical-align:baseline">Split transformation:</strong><span style="vertical-align:baseline"> The decrypting subroutine contains multiple switch cases to handle fragmented data recovery and decryption. These extensive instruction sequences guarantee sufficient space for the decrypted string data.</span></p>
</li>
</ol>
<p><span style="vertical-align:baseline">Figure 16 and Figure 17 show the disassembled and decompiled output of our patching framework, where GoStringUngarbler</span><strong style="vertical-align:baseline"> </strong><span style="vertical-align:baseline">has deobfuscated a decrypting subroutine to display the recovered original string.</span></p></div></section><section class="QzPuud"><div><section><figure class="NEBdNd"><section class="PBkdHd DhGbH" jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig16.max-1100x1100.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig16.max-1100x1100.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><section class="glue-modal glue-modal--dark QHdDac" role="dialog" aria-modal="true"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig16.max-1100x1100.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig16.max-1100x1100.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><button class="glue-modal__close-btn" tabindex="0" aria-label="Close this modal"></button></section></section></figure><div class="nRhiJb-cHYyed nRhiJb-DbgRPb-R6PoUb-ma6Yeb ZpqjUe"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p>Figure 16: Disassembly view of a deobfuscated decrypting subroutine</p></div></div></section></div></section><section class="QzPuud"><div><section><figure class="NEBdNd"><section class="PBkdHd DhGbH" jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig17.max-800x800.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig17.max-800x800.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><section class="glue-modal glue-modal--dark QHdDac" role="dialog" aria-modal="true"><img class="JcsBte mZzdH ZOnyjc" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig17.max-800x800.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/garble-fig17.max-800x800.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"><button class="glue-modal__close-btn" tabindex="0" aria-label="Close this modal"></button></section></section></figure><div class="nRhiJb-cHYyed nRhiJb-DbgRPb-R6PoUb-ma6Yeb ZpqjUe"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><p>Figure 17: Decompiled view of a deobfuscated decrypting subroutine</p></div></div></section></div></section><section class="Wy08Ac nRhiJb-qJTHM-OWXEXe-hJDwNd nRhiJb-DbgRPb-II5mzb-cGMI2b"><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true" class=" "><h2><span style="vertical-align:baseline">Downloading GoStringUngarbler</span></h2>
<p><a href="https://github.com/mandiant/gostringungarbler" rel="noopener" target="_blank"><span style="vertical-align:baseline">GoStringUngarbler</span></a><strong style="vertical-align:baseline"> </strong><span style="vertical-align:baseline">is now available as an open-source tool in Mandiant's GitHub repository</span><span style="vertical-align:baseline">.&nbsp;</span></p>
<p><span style="vertical-align:baseline">The installation requires Python3 and Python dependencies from the </span><code style="vertical-align:baseline">requirements.txt</code><span style="font-style:italic;vertical-align:baseline"> </span><span style="vertical-align:baseline">file.</span></p>
<h2><span style="vertical-align:baseline">Future Work</span></h2>
<p><span style="vertical-align:baseline">Deobfuscating binaries generated by garble</span><strong style="vertical-align:baseline"> </strong><span style="vertical-align:baseline">presents a specific challenge—its dependence on the Go compiler for obfuscation means that the calling convention can evolve between Go versions. This change can potentially invalidate the regular expression patterns used in our deobfuscation process. To mitigate this, we've designed GoStringUngarbler</span><strong style="vertical-align:baseline"> </strong><span style="vertical-align:baseline">with a modular plugin architecture. This allows for new plugins to be easily added with updated regular expressions to handle variations introduced by new Go releases. This design ensures the tool's long-term adaptability to future changes in garble’s output.</span></p>
<p><span style="vertical-align:baseline">Currently, GoStringUngarbler</span><strong style="vertical-align:baseline"> </strong><span style="vertical-align:baseline">primarily supports garble</span><strong style="vertical-align:baseline">-</strong><span style="vertical-align:baseline">obfuscated PE and ELF binaries compiled with Go versions 1.21 through 1.23. We are continuously working to expand this range as the Go compiler and garble are updated.</span></p>
<h2><span style="vertical-align:baseline">Acknowledgments</span></h2>
<p><span style="vertical-align:baseline">Special thanks to Nino Isakovic and Matt Williams for their review and continuous feedback throughout the development of GoStringUngarbler. Their insights and suggestions have been invaluable in shaping and refining the tool’s final implementation.</span></p>
<p><span style="vertical-align:baseline">We are also grateful to the FLARE team members for their review of this blog post publication to ensure its technical accuracy and clarity.</span></p>
<p><span style="vertical-align:baseline">Additional thanks to </span><a href="https://www.openanalysis.net/" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">OALabs</span></a><span style="vertical-align:baseline"> for their valuable insights from </span><a href="https://research.openanalysis.net/garble/go/obfuscation/strings/2023/08/03/garble.html" rel="noopener" target="_blank"><span style="text-decoration:underline;vertical-align:baseline">their initial research on garble’s string encryption</span></a><span style="vertical-align:baseline">.</span></p>
<p><span style="vertical-align:baseline">Finally, we want to acknowledge the developers of garble for their outstanding work on this obfuscating compiler. Their contributions to the software protection field have greatly advanced both offensive and defensive security research on Go binary analysis.</span></p></div></section><section class="kcBhad"><section class="Fabbec"><span class="WrMNjb">Posted in</span><ul class="FzXI4e"><li class="I4B51b"><a href="https://cloud.google.com/blog/topics/threat-intelligence" track-metadata-position="body" track-metadata-eventdetail="cloud.google.com/blog/topics/threat-intelligence" track-metadata-module="tag list" track-metadata-module_headline="posted in">Threat Intelligence</a></li></ul></section></section></div></div></div></div></div><section class="nRhiJb-DARUcf " track-metadata-module="related articles" track-metadata-module_headline="related articles"><div class="nRhiJb-DbgRPb-c5RTEf-ma6Yeb nRhiJb-DbgRPb-wNfPc-cGMI2b"><h5 class="Qwf2Db-MnozTc Qwf2Db-MnozTc-OWXEXe-MnozTc-wNfPc nRhiJb-DbgRPb-II5mzb-cGMI2b">Related articles</h5><section class="m9cUGf  HGev3   nJD2Qe  nRhiJb-ObfsIf"><div class="  QaGyvd  nRhiJb-kR0ZEf-OWXEXe-GV1x9e-c5RTEf nRhiJb-kR0ZEf-OWXEXe-GV1x9e-qWD73c-V2iZpe"><div class="mA0uBe"><a href="https://cloud.google.com/blog/topics/threat-intelligence/unc6201-exploiting-dell-recoverpoint-zero-day" class="lD2oe" track-name="from brickstorm to grimbolt: unc6201 exploiting a dell recoverpoint for virtual machines zero-day" track-type="card" track-metadata-eventdetail="cloud.google.com/blog/topics/threat-intelligence/unc6201-exploiting-dell-recoverpoint-zero-day"><div class="AhkbS "><div class="hqnDEf"><section class="PBkdHd "><img class=" D5RK8d" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/03_ThreatIntelligenceWebsiteBannerIdeas_BANN.max-700x700.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/03_ThreatIntelligenceWebsiteBannerIdeas_BANN.max-700x700.png" loading="lazy"></section></div><div class="JUOx5b"><div class="Qwf2Db-MnozTc Qwf2Db-MnozTc-OWXEXe-MnozTc-qWD73c nRhiJb-DbgRPb-c5RTEf-ma6Yeb nRhiJb-BFbNVe-r8s4j-bMElCd FI6Gl nRhiJb-fmcmS-oXtfBe" track-name="threat intelligence" track-type="tag">Threat Intelligence</div><h3 class="Qwf2Db-MnozTc HGFKtc Qwf2Db-MnozTc-OWXEXe-MnozTc-wNfPc">From BRICKSTORM to GRIMBOLT: UNC6201 Exploiting a Dell RecoverPoint for Virtual Machines Zero-Day</h3><p class="nRhiJb-cHYyed dTIXyb nRhiJb-DbgRPb-R6PoUb-ma6Yeb">By Mandiant  • 12-minute read</p></div></div></a></div></div><div class="  QaGyvd  nRhiJb-kR0ZEf-OWXEXe-GV1x9e-c5RTEf nRhiJb-kR0ZEf-OWXEXe-GV1x9e-qWD73c-V2iZpe"><div class="mA0uBe"><a href="https://cloud.google.com/blog/topics/threat-intelligence/distillation-experimentation-integration-ai-adversarial-use" class="lD2oe" track-name="gtig ai threat tracker: distillation experimentation and (continued) integration of ai for adversarial use" track-type="card" track-metadata-eventdetail="cloud.google.com/blog/topics/threat-intelligence/distillation-experimentation-integration-ai-adversarial-use"><div class="AhkbS "><div class="hqnDEf"><section class="PBkdHd "><img class=" D5RK8d" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/03_ThreatIntelligenceWebsiteBannerIdeas_BANN.max-700x700.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/03_ThreatIntelligenceWebsiteBannerIdeas_BANN.max-700x700.png" loading="lazy"></section></div><div class="JUOx5b"><div class="Qwf2Db-MnozTc Qwf2Db-MnozTc-OWXEXe-MnozTc-qWD73c nRhiJb-DbgRPb-c5RTEf-ma6Yeb nRhiJb-BFbNVe-r8s4j-bMElCd FI6Gl nRhiJb-fmcmS-oXtfBe" track-name="threat intelligence" track-type="tag">Threat Intelligence</div><h3 class="Qwf2Db-MnozTc HGFKtc Qwf2Db-MnozTc-OWXEXe-MnozTc-wNfPc">GTIG AI Threat Tracker: Distillation, Experimentation, and (Continued) Integration of AI for Adversarial Use</h3><p class="nRhiJb-cHYyed dTIXyb nRhiJb-DbgRPb-R6PoUb-ma6Yeb">By Google Threat Intelligence Group  • 33-minute read</p></div></div></a></div></div><div class="  QaGyvd  nRhiJb-kR0ZEf-OWXEXe-GV1x9e-c5RTEf nRhiJb-kR0ZEf-OWXEXe-GV1x9e-qWD73c-V2iZpe"><div class="mA0uBe"><a href="https://cloud.google.com/blog/topics/threat-intelligence/threats-to-defense-industrial-base" class="lD2oe" track-name="beyond the battlefield: threats to the defense industrial base" track-type="card" track-metadata-eventdetail="cloud.google.com/blog/topics/threat-intelligence/threats-to-defense-industrial-base"><div class="AhkbS "><div class="hqnDEf"><section class="PBkdHd "><img class=" D5RK8d" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/03_ThreatIntelligenceWebsiteBannerIdeas_BANN.max-700x700.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/03_ThreatIntelligenceWebsiteBannerIdeas_BANN.max-700x700.png" loading="lazy"></section></div><div class="JUOx5b"><div class="Qwf2Db-MnozTc Qwf2Db-MnozTc-OWXEXe-MnozTc-qWD73c nRhiJb-DbgRPb-c5RTEf-ma6Yeb nRhiJb-BFbNVe-r8s4j-bMElCd FI6Gl nRhiJb-fmcmS-oXtfBe" track-name="threat intelligence" track-type="tag">Threat Intelligence</div><h3 class="Qwf2Db-MnozTc HGFKtc Qwf2Db-MnozTc-OWXEXe-MnozTc-wNfPc">Beyond the Battlefield: Threats to the Defense Industrial Base</h3><p class="nRhiJb-cHYyed dTIXyb nRhiJb-DbgRPb-R6PoUb-ma6Yeb">By Google Threat Intelligence Group  • 28-minute read</p></div></div></a></div></div><div class="  QaGyvd  nRhiJb-kR0ZEf-OWXEXe-GV1x9e-c5RTEf nRhiJb-kR0ZEf-OWXEXe-GV1x9e-qWD73c-V2iZpe"><div class="mA0uBe"><a href="https://cloud.google.com/blog/topics/threat-intelligence/unc1069-targets-cryptocurrency-ai-social-engineering" class="lD2oe" track-name="unc1069 targets cryptocurrency sector with new tooling and ai-enabled social engineering" track-type="card" track-metadata-eventdetail="cloud.google.com/blog/topics/threat-intelligence/unc1069-targets-cryptocurrency-ai-social-engineering"><div class="AhkbS "><div class="hqnDEf"><section class="PBkdHd "><img class=" D5RK8d" src="https://storage.googleapis.com/gweb-cloudblog-publish/images/03_ThreatIntelligenceWebsiteBannerIdeas_BANN.max-700x700.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/03_ThreatIntelligenceWebsiteBannerIdeas_BANN.max-700x700.png" loading="lazy"></section></div><div class="JUOx5b"><div class="Qwf2Db-MnozTc Qwf2Db-MnozTc-OWXEXe-MnozTc-qWD73c nRhiJb-DbgRPb-c5RTEf-ma6Yeb nRhiJb-BFbNVe-r8s4j-bMElCd FI6Gl nRhiJb-fmcmS-oXtfBe" track-name="threat intelligence" track-type="tag">Threat Intelligence</div><h3 class="Qwf2Db-MnozTc HGFKtc Qwf2Db-MnozTc-OWXEXe-MnozTc-wNfPc">UNC1069 Targets Cryptocurrency Sector with New Tooling and AI-Enabled Social Engineering</h3><p class="nRhiJb-cHYyed dTIXyb nRhiJb-DbgRPb-R6PoUb-ma6Yeb">By Mandiant  • 26-minute read</p></div></div></a></div></div></section></div></section></article></div></div><c-data id="i1" jsdata=" n2jFB;_;1"></c-data></c-wiz></body></html>