# https://secret.club/2023/12/24/riscy-business.html

<!DOCTYPE html><html lang="en"><body><article aria-label="Content" itemscope="" itemtype="http://schema.org/BlogPosting"><h1 itemprop="name headline">RISC-Y Business: Raging against the reduced machine</h1><div itemprop="author" itemscope="" itemtype="http://schema.org/Person" style="height:48px"> <img itemprop="image" alt="main authors image" src="https://secret.club/assets/author_img/mrexodia.jpg"> <span class="mono authors"> <a href="https://secret.club/author/mrexodia" itemprop="name">mrexodia</a>, <a href="https://secret.club/author/oopsmishap" itemprop="name">oopsmishap</a> </span></div><time datetime="2023-12-24T11:00:00+00:00" itemprop="datePublished" class="mono"> Dec 24, 2023 </time><hr><main itemprop="articleBody" style="position: relative"><h2 id="abstract"> <a href="https://secret.club/2023/12/24/riscy-business.html#abstract">Abstract</a></h2><p>In recent years the interest in obfuscation has increased, mainly because people want to protect their intellectual property. Unfortunately, most of what’s been written is focused on the theoretical aspects. In this article, we will discuss the practical engineering challenges of developing a low-footprint virtual machine interpreter. The VM is easily embeddable, built on open-source technology and has various hardening features that were achieved with minimal effort.</p><h2 id="introduction"> <a href="https://secret.club/2023/12/24/riscy-business.html#introduction">Introduction</a></h2><p>In addition to protecting intellectual property, a minimal virtual machine can be useful for other reasons. You might want to have an embeddable interpreter to execute business logic (shellcode), without having to deal with RWX memory. It can also be useful as an educational tool, or just for fun.</p><p>Creating a custom VM architecture (similar to <a href="https://secret.club/2021/09/08/vmprotect-llvm-lifting-1.html">VMProtect</a>/<a href="https://github.com/67-6f-64/AntiOreans-CodeDevirtualizer">Themida</a>) means that we would have to deal with binary rewriting/lifting or write our own compiler. Instead, we decided to use a preexisting architecture, which would be supported by LLVM: <strong>RISC-V</strong>. This architecture is already widely used for educational purposes and has the advantage of being very simple to understand and implement.</p><p>Initially, the main contender was WebAssembly. However, existing interpreters were very bloated and would also require dealing with a binary format. Additionally, it looks like WASM64 is very underdeveloped and our memory model requires 64-bit pointer support. SPARC and PowerPC were also considered, but RISC-V seems to be more popular and there are a lot more resources available for it.</p><p>WebAssembly was designed for sandboxing and therefore strictly separates guest and host memory. Because we will be writing our own RISC-V interpreter, we chose to instead share memory between the guest and the host. This means that pointers in the RISC-V execution context (the guest) are valid in the host process and vice-versa.</p><p>As a result, the instructions responsible for reading/writing memory can be implemented as a simple <code class="language-plaintext highlighter-rouge">memcpy</code> call and we do not need additional code to translate/validate memory accesses (which helps with our goal of small code size). With this property, we need to implement only two system calls to perform arbitrary operations in the host process:</p><pre><code><span class="kt">uintptr_t</span> riscvm_get_peb();
<span class="kt">uintptr_t</span> riscvm_host_call(<span class="kt">uintptr_t</span> rip, <span class="kt">uintptr_t</span> args[<span class="mi">13</span>]);
</code></pre><p>The <code class="language-plaintext highlighter-rouge">riscvm_get_peb</code> is Windows-specific and it allows us to resolve exports, which we can then pass to the <code class="language-plaintext highlighter-rouge">riscvm_host_call</code> function to execute arbitrary code. Additionally, an optional <code class="language-plaintext highlighter-rouge">host_syscall</code> stub could be implemented, but this is not strictly necessary since we can just call the functions in <code class="language-plaintext highlighter-rouge">ntdll.dll</code> instead.</p><h2 id="toolchain-and-crt"> <a href="https://secret.club/2023/12/24/riscy-business.html#toolchain-and-crt">Toolchain and CRT</a></h2><p>To keep the interpreter footprint as low as possible, we decided to develop a toolchain that outputs a freestanding binary. The goal is to copy this binary into memory and point the VM’s program counter there to start execution. Because we are in freestanding mode, there is no C runtime available to us, this requires us to handle initialization ourselves.</p><p>As an example, we will use the following <code class="language-plaintext highlighter-rouge">hello.c</code> file:</p><pre><code><span class="kt">int</span> _start() {
    <span class="kt">int</span> result <span class="o">=</span> <span class="mi">0</span>;
    <span class="k">for</span>(<span class="kt">int</span> i <span class="o">=</span> <span class="mi">0</span>; i <span class="o">&lt;</span> <span class="mi">52</span>; i<span class="o">++</span>) {
        result <span class="o">+=</span> <span class="o">*</span>(<span class="k">volatile</span> <span class="kt">int</span><span class="o">*</span>)<span class="o">&amp;</span>i;
    }
    <span class="k">return</span> result <span class="o">+</span> <span class="mi">11</span>;
}
</code></pre><p>We compile the program with the following incantation:</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang <span class="nt">-target</span> riscv64 <span class="nt">-march</span><span class="o">=</span>rv64im <span class="nt">-mcmodel</span><span class="o">=</span>medany <span class="nt">-Os</span> <span class="nt">-c</span> hello.c <span class="nt">-o</span> hello.o
</code></pre></div></div><p>And then verify by disassembling the object:</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>llvm-objdump <span class="nt">--disassemble</span> hello.o

hello.o:        file format elf64-littleriscv

0000000000000000 &lt;_start&gt;:
       0: 13 01 01 ff   addi    sp, sp, <span class="nt">-16</span>
       4: 13 05 00 00   li      a0, 0
       8: 23 26 01 00   sw      zero, 12<span class="o">(</span>sp<span class="o">)</span>
       c: 93 05 30 03   li      a1, 51

0000000000000010 &lt;.LBB0_1&gt;:
      10: 03 26 c1 00   lw      a2, 12<span class="o">(</span>sp<span class="o">)</span>
      14: 33 05 a6 00   add     a0, a2, a0
      18: 9b 06 16 00   addiw   a3, a2, 1
      1c: 23 26 d1 00   sw      a3, 12<span class="o">(</span>sp<span class="o">)</span>
      20: 63 40 b6 00   blt     a2, a1, 0x20 &lt;.LBB0_1+0x10&gt;
      24: 1b 05 b5 00   addiw   a0, a0, 11
      28: 13 01 01 01   addi    sp, sp, 16
      2c: 67 80 00 00   ret
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">hello.o</code> is a regular ELF object file. To get a freestanding binary we need to invoke the linker with a linker script:</p><pre><code>ENTRY(_start)

LINK_BASE <span class="o">=</span> <span class="mh">0x8000000</span>;

SECTIONS
{
    . <span class="o">=</span> LINK_BASE;
    __base <span class="o">=</span> .;

    .text <span class="o">:</span> ALIGN(<span class="mi">16</span>) {
        . <span class="o">=</span> LINK_BASE;
        <span class="o">*</span>(.text)
        <span class="o">*</span>(.text.<span class="o">*</span>)
    }

    .data <span class="o">:</span> {
        <span class="o">*</span>(.rodata)
        <span class="o">*</span>(.rodata.<span class="o">*</span>)
        <span class="o">*</span>(.data)
        <span class="o">*</span>(.data.<span class="o">*</span>)
        <span class="o">*</span>(.eh_frame)
    }

    .init <span class="o">:</span> {
        __init_array_start <span class="o">=</span> .;
        <span class="o">*</span>(.init_array)
        __init_array_end <span class="o">=</span> .;
    }

    .bss <span class="o">:</span> {
        <span class="o">*</span>(.bss)
        <span class="o">*</span>(.bss.<span class="o">*</span>)
        <span class="o">*</span>(.sbss)
        <span class="o">*</span>(.sbss.<span class="o">*</span>)
    }

    .relocs <span class="o">:</span> {
        . <span class="o">=</span> . <span class="o">+</span> SIZEOF(.bss);
        __relocs_start <span class="o">=</span> .;
    }
}
</code></pre><p>This script is the result of an excessive amount of swearing and experimentation. The format is <code class="language-plaintext highlighter-rouge">.name : { ... }</code> where <code class="language-plaintext highlighter-rouge">.name</code> is the destination section and the stuff in the brackets is the content to paste in there. The special <code class="language-plaintext highlighter-rouge">.</code> operator is used to refer to the current position in the binary and we define a few special symbols for use by the runtime:</p><table><thead><tr><th>Symbol</th><th>Meaning</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">__base</code></td><td>Base of the executable.</td></tr><tr><td><code class="language-plaintext highlighter-rouge">__init_array_start</code></td><td>Start of the C++ init arrays.</td></tr><tr><td><code class="language-plaintext highlighter-rouge">__init_array_end</code></td><td>End of the C++ init arrays.</td></tr><tr><td><code class="language-plaintext highlighter-rouge">__relocs_start</code></td><td>Start of the relocations (end of the binary).</td></tr></tbody></table><p>These symbols are declared as <code class="language-plaintext highlighter-rouge">extern</code> in the C code and they will be resolved at link-time. While it may seem confusing at first that we have a destination section, it starts to make sense once you realize the linker has to output a regular ELF executable. That ELF executable is then passed to <code class="language-plaintext highlighter-rouge">llvm-objcopy</code> to create the freestanding binary blob. This makes debugging a whole lot easier (because we get DWARF symbols) and since we will not implement an ELF loader, it also allows us to extract the relocations for embedding into the final binary.</p><p>To link the intermediate ELF executable and then create the freestanding <code class="language-plaintext highlighter-rouge">hello.pre.bin</code>:</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ld.lld.exe <span class="nt">-o</span> hello.elf <span class="nt">--oformat</span><span class="o">=</span>elf <span class="nt">-emit-relocs</span> <span class="nt">-T</span> ..<span class="se">\l</span>ib<span class="se">\l</span>inker.ld <span class="nt">--Map</span><span class="o">=</span>hello.map hello.o
llvm-objcopy <span class="nt">-O</span> binary hello.elf hello.pre.bin
</code></pre></div></div><p>For debugging purposes we also output <code class="language-plaintext highlighter-rouge">hello.map</code>, which tells us exactly where the linker put the code/data:</p><pre><code>             VMA              LMA     Size Align Out     In      Symbol
               <span class="mi">0</span>                <span class="mi">0</span>        <span class="mi">0</span>     <span class="mi">1</span> LINK_BASE <span class="o">=</span> <span class="mh">0x8000000</span>
               <span class="mi">0</span>                <span class="mi">0</span>  <span class="mi">8000000</span>     <span class="mi">1</span> . <span class="o">=</span> LINK_BASE
         <span class="mi">8000000</span>                <span class="mi">0</span>        <span class="mi">0</span>     <span class="mi">1</span> __base <span class="o">=</span> .
         <span class="mi">8000000</span>          <span class="mi">8000000</span>       <span class="mi">30</span>    <span class="mi">16</span> .text
         <span class="mi">8000000</span>          <span class="mi">8000000</span>        <span class="mi">0</span>     <span class="mi">1</span>         . <span class="o">=</span> LINK_BASE
         <span class="mi">8000000</span>          <span class="mi">8000000</span>       <span class="mi">30</span>     <span class="mi">4</span>         hello.o<span class="o">:</span>(.text)
         <span class="mi">8000000</span>          <span class="mi">8000000</span>       <span class="mi">30</span>     <span class="mi">1</span>                 _start
         <span class="mi">8000010</span>          <span class="mi">8000010</span>        <span class="mi">0</span>     <span class="mi">1</span>                 .LBB0_1
         <span class="mi">8000030</span>          <span class="mi">8000030</span>        <span class="mi">0</span>     <span class="mi">1</span> .init
         <span class="mi">8000030</span>          <span class="mi">8000030</span>        <span class="mi">0</span>     <span class="mi">1</span>         __init_array_start <span class="o">=</span> .
         <span class="mi">8000030</span>          <span class="mi">8000030</span>        <span class="mi">0</span>     <span class="mi">1</span>         __init_array_end <span class="o">=</span> .
         <span class="mi">8000030</span>          <span class="mi">8000030</span>        <span class="mi">0</span>     <span class="mi">1</span> .relocs
         <span class="mi">8000030</span>          <span class="mi">8000030</span>        <span class="mi">0</span>     <span class="mi">1</span>         . <span class="o">=</span> . <span class="o">+</span> SIZEOF ( .bss )
         <span class="mi">8000030</span>          <span class="mi">8000030</span>        <span class="mi">0</span>     <span class="mi">1</span>         __relocs_start <span class="o">=</span> .
               <span class="mi">0</span>                <span class="mi">0</span>       <span class="mi">18</span>     <span class="mi">8</span> .rela.text
               <span class="mi">0</span>                <span class="mi">0</span>       <span class="mi">18</span>     <span class="mi">8</span>         hello.o<span class="o">:</span>(.rela.text)
               <span class="mi">0</span>                <span class="mi">0</span>       <span class="mi">3</span>b     <span class="mi">1</span> .comment
               <span class="mi">0</span>                <span class="mi">0</span>       <span class="mi">3</span>b     <span class="mi">1</span>         <span class="o">&lt;</span>internal<span class="o">&gt;:</span>(.comment)
               <span class="mi">0</span>                <span class="mi">0</span>       <span class="mi">30</span>     <span class="mi">1</span> .riscv.attributes
               <span class="mi">0</span>                <span class="mi">0</span>       <span class="mi">30</span>     <span class="mi">1</span>         <span class="o">&lt;</span>internal<span class="o">&gt;:</span>(.riscv.attributes)
               <span class="mi">0</span>                <span class="mi">0</span>      <span class="mi">108</span>     <span class="mi">8</span> .symtab
               <span class="mi">0</span>                <span class="mi">0</span>      <span class="mi">108</span>     <span class="mi">8</span>         <span class="o">&lt;</span>internal<span class="o">&gt;:</span>(.symtab)
               <span class="mi">0</span>                <span class="mi">0</span>       <span class="mi">55</span>     <span class="mi">1</span> .shstrtab
               <span class="mi">0</span>                <span class="mi">0</span>       <span class="mi">55</span>     <span class="mi">1</span>         <span class="o">&lt;</span>internal<span class="o">&gt;:</span>(.shstrtab)
               <span class="mi">0</span>                <span class="mi">0</span>       <span class="mi">5</span>c     <span class="mi">1</span> .strtab
               <span class="mi">0</span>                <span class="mi">0</span>       <span class="mi">5</span>c     <span class="mi">1</span>         <span class="o">&lt;</span>internal<span class="o">&gt;:</span>(.strtab)
</code></pre><p>The final ingredient of the toolchain is a small Python script (<code class="language-plaintext highlighter-rouge">relocs.py</code>) that extracts the relocations from the ELF file and appends them to the end of the <code class="language-plaintext highlighter-rouge">hello.pre.bin</code>. The custom relocation format only supports <code class="language-plaintext highlighter-rouge">R_RISCV_64</code> and is resolved by our CRT like so:</p><pre><code><span class="k">typedef</span> <span class="k">struct</span>
{
    <span class="kt">uint8_t</span>  type;
    <span class="kt">uint32_t</span> offset;
    <span class="kt">int64_t</span>  addend;
} __attribute__((packed)) Relocation;

<span class="k">extern</span> <span class="kt">uint8_t</span> __base[];
<span class="k">extern</span> <span class="kt">uint8_t</span> __relocs_start[];

<span class="cp">#define LINK_BASE    0x8000000
#define R_RISCV_NONE 0
#define R_RISCV_64   2
</span>
<span class="k">static</span> __attribute((noinline)) <span class="kt">void</span> riscvm_relocs()
{
    <span class="k">if</span> (<span class="o">*</span>(<span class="kt">uint32_t</span><span class="o">*</span>)__relocs_start <span class="o">!=</span> 'ALER')
    {
        asm <span class="k">volatile</span>(<span class="s">"ebreak"</span>);
    }

    <span class="kt">uintptr_t</span> load_base <span class="o">=</span> (<span class="kt">uintptr_t</span>)__base;

    <span class="k">for</span> (Relocation<span class="o">*</span> itr <span class="o">=</span> (Relocation<span class="o">*</span>)(__relocs_start <span class="o">+</span> <span class="k">sizeof</span>(<span class="kt">uint32_t</span>)); itr<span class="o">-&gt;</span>type <span class="o">!=</span> R_RISCV_NONE; itr<span class="o">++</span>)
    {
        <span class="k">if</span> (itr<span class="o">-&gt;</span>type <span class="o">==</span> R_RISCV_64)
        {
            <span class="kt">uint64_t</span><span class="o">*</span> ptr <span class="o">=</span> (<span class="kt">uint64_t</span><span class="o">*</span>)((<span class="kt">uintptr_t</span>)itr<span class="o">-&gt;</span>offset <span class="o">-</span> LINK_BASE <span class="o">+</span> load_base);
            <span class="o">*</span>ptr <span class="o">-=</span> LINK_BASE;
            <span class="o">*</span>ptr <span class="o">+=</span> load_base;
        }
        <span class="k">else</span>
        {
            asm <span class="k">volatile</span>(<span class="s">"ebreak"</span>);
        }
    }
}
</code></pre><p>As you can see, the <code class="language-plaintext highlighter-rouge">__base</code> and <code class="language-plaintext highlighter-rouge">__relocs_start</code> magic symbols are used here. The only reason this works is the <code class="language-plaintext highlighter-rouge">-mcmodel=medany</code> we used when compiling the object. You can find more details in <a href="https://www.sifive.com/blog/all-aboard-part-4-risc-v-code-models">this article</a> and in the <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc#relocations">RISC-V ELF Specification</a>. In short, this flag allows the compiler to assume that all code will be emitted in a 2 GiB address range, which allows more liberal PC-relative addressing. The <code class="language-plaintext highlighter-rouge">R_RISCV_64</code> relocation type gets emitted when you put pointers in the <code class="language-plaintext highlighter-rouge">.data</code> section:</p><pre><code><span class="kt">void</span><span class="o">*</span> functions[] <span class="o">=</span> {
    <span class="o">&amp;</span>function1,
    <span class="o">&amp;</span>function2,
};
</code></pre><p>This also happens when using vtables in C++, and we wanted to support these properly early on, instead of having to fight with horrifying bugs later.</p><p>The next piece of the CRT involves the handling of the init arrays (which get emitted by global instances of classes that have a constructor):</p><pre><code><span class="k">typedef</span> void (<span class="o">*</span>InitFunction)();
<span class="k">extern</span> InitFunction __init_array_start;
<span class="k">extern</span> InitFunction __init_array_end;

<span class="k">static</span> __attribute((optnone)) <span class="kt">void</span> riscvm_init_arrays()
{
    <span class="k">for</span> (InitFunction<span class="o">*</span> itr <span class="o">=</span> <span class="o">&amp;</span>__init_array_start; itr <span class="o">!=</span> <span class="o">&amp;</span>__init_array_end; itr<span class="o">++</span>)
    {
        (<span class="o">*</span>itr)();
    }
}
</code></pre><p>Frustratingly, we were not able to get this function to generate correct code without the <code class="language-plaintext highlighter-rouge">__attribute__((optnone))</code>. We suspect this has to do with aliasing assumptions (the start/end can technically refer to the same memory), but we didn’t investigate this further.</p><h2 id="interpreter-internals"> <a href="https://secret.club/2023/12/24/riscy-business.html#interpreter-internals">Interpreter internals</a></h2><p><strong>Note</strong>: the interpreter was initially based on <a href="https://github.com/edubart/riscvm/blob/bd9853ea774be625321c63bf51406040786025e0/riscvm.c"><code class="language-plaintext highlighter-rouge">riscvm.c</code></a> by <a href="https://twitter.com/edubart">edubart</a>. However, we have since completely rewritten it in C++ to better suit our purpose.</p><p>Based on the <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc">RISC-V Calling Conventions</a> document, we can create an <code class="language-plaintext highlighter-rouge">enum</code> for the 32 registers:</p><pre><code><span class="k">enum</span> RegIndex
{
    reg_zero, <span class="c1">// always zero (immutable)</span>
    reg_ra,   <span class="c1">// return address</span>
    reg_sp,   <span class="c1">// stack pointer</span>
    reg_gp,   <span class="c1">// global pointer</span>
    reg_tp,   <span class="c1">// thread pointer</span>
    reg_t0,   <span class="c1">// temporary</span>
    reg_t1,
    reg_t2,
    reg_s0,   <span class="c1">// callee-saved</span>
    reg_s1,
    reg_a0,   <span class="c1">// arguments</span>
    reg_a1,
    reg_a2,
    reg_a3,
    reg_a4,
    reg_a5,
    reg_a6,
    reg_a7,
    reg_s2,   <span class="c1">// callee-saved</span>
    reg_s3,
    reg_s4,
    reg_s5,
    reg_s6,
    reg_s7,
    reg_s8,
    reg_s9,
    reg_s10,
    reg_s11,
    reg_t3,   <span class="c1">// temporary</span>
    reg_t4,
    reg_t5,
    reg_t6,
};
</code></pre><p>We just need to add a <code class="language-plaintext highlighter-rouge">pc</code> register and we have the structure to represent the RISC-V CPU state:</p><pre><code><span class="k">struct</span> <span class="nc">riscvm</span>
{
    <span class="kt">int64_t</span>  pc;
    <span class="kt">uint64_t</span> regs[<span class="mi">32</span>];
};
</code></pre><p>It is important to keep in mind that the <code class="language-plaintext highlighter-rouge">zero</code> register is always set to <code class="language-plaintext highlighter-rouge">0</code> and we have to prevent writes to it by using a macro:</p><pre><code><span class="cp">#define reg_write(idx, value)        \
    do                               \
    {                                \
        if (LIKELY(idx != reg_zero)) \
        {                            \
            self-&gt;regs[idx] = value; \
        }                            \
    } while (0)
</span></code></pre><p>The instructions (ignoring the optional compression extension) are always 32-bits in length and can be cleanly expressed as a union:</p><pre><code><span class="k">union</span> Instruction
{
    <span class="k">struct</span>
    {
        <span class="kt">uint32_t</span> compressed_flags <span class="o">:</span> <span class="mi">2</span>;
        <span class="kt">uint32_t</span> opcode           <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span>                  <span class="o">:</span> <span class="mi">25</span>;
    };

    <span class="k">struct</span>
    {
        <span class="kt">uint32_t</span> opcode <span class="o">:</span> <span class="mi">7</span>;
        <span class="kt">uint32_t</span> rd     <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> funct3 <span class="o">:</span> <span class="mi">3</span>;
        <span class="kt">uint32_t</span> rs1    <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> rs2    <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> funct7 <span class="o">:</span> <span class="mi">7</span>;
    } rtype;

    <span class="k">struct</span>
    {
        <span class="kt">uint32_t</span> opcode <span class="o">:</span> <span class="mi">7</span>;
        <span class="kt">uint32_t</span> rd     <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> funct3 <span class="o">:</span> <span class="mi">3</span>;
        <span class="kt">uint32_t</span> rs1    <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> rs2    <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> shamt  <span class="o">:</span> <span class="mi">1</span>;
        <span class="kt">uint32_t</span> imm    <span class="o">:</span> <span class="mi">6</span>;
    } rwtype;

    <span class="k">struct</span>
    {
        <span class="kt">uint32_t</span> opcode <span class="o">:</span> <span class="mi">7</span>;
        <span class="kt">uint32_t</span> rd     <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> funct3 <span class="o">:</span> <span class="mi">3</span>;
        <span class="kt">uint32_t</span> rs1    <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> imm    <span class="o">:</span> <span class="mi">12</span>;
    } itype;

    <span class="k">struct</span>
    {
        <span class="kt">uint32_t</span> opcode <span class="o">:</span> <span class="mi">7</span>;
        <span class="kt">uint32_t</span> rd     <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> imm    <span class="o">:</span> <span class="mi">20</span>;
    } utype;

    <span class="k">struct</span>
    {
        <span class="kt">uint32_t</span> opcode <span class="o">:</span> <span class="mi">7</span>;
        <span class="kt">uint32_t</span> rd     <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> imm12  <span class="o">:</span> <span class="mi">8</span>;
        <span class="kt">uint32_t</span> imm11  <span class="o">:</span> <span class="mi">1</span>;
        <span class="kt">uint32_t</span> imm1   <span class="o">:</span> <span class="mi">10</span>;
        <span class="kt">uint32_t</span> imm20  <span class="o">:</span> <span class="mi">1</span>;
    } ujtype;

    <span class="k">struct</span>
    {
        <span class="kt">uint32_t</span> opcode <span class="o">:</span> <span class="mi">7</span>;
        <span class="kt">uint32_t</span> imm5   <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> funct3 <span class="o">:</span> <span class="mi">3</span>;
        <span class="kt">uint32_t</span> rs1    <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> rs2    <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> imm7   <span class="o">:</span> <span class="mi">7</span>;
    } stype;

    <span class="k">struct</span>
    {
        <span class="kt">uint32_t</span> opcode   <span class="o">:</span> <span class="mi">7</span>;
        <span class="kt">uint32_t</span> imm_11   <span class="o">:</span> <span class="mi">1</span>;
        <span class="kt">uint32_t</span> imm_1_4  <span class="o">:</span> <span class="mi">4</span>;
        <span class="kt">uint32_t</span> funct3   <span class="o">:</span> <span class="mi">3</span>;
        <span class="kt">uint32_t</span> rs1      <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> rs2      <span class="o">:</span> <span class="mi">5</span>;
        <span class="kt">uint32_t</span> imm_5_10 <span class="o">:</span> <span class="mi">6</span>;
        <span class="kt">uint32_t</span> imm_12   <span class="o">:</span> <span class="mi">1</span>;
    } sbtype;

    <span class="kt">int16_t</span>  chunks16[<span class="mi">2</span>];
    <span class="kt">uint32_t</span> bits;
};
<span class="k">static_assert</span>(<span class="k">sizeof</span>(Instruction) <span class="o">==</span> <span class="k">sizeof</span>(<span class="kt">uint32_t</span>), <span class="s">""</span>);
</code></pre><p>There are 13 top-level opcodes (<code class="language-plaintext highlighter-rouge">Instruction.opcode</code>) and some of those opcodes have another field that further specializes the functionality (i.e. <code class="language-plaintext highlighter-rouge">Instruction.itype.funct3</code>). To keep the code readable, the enumerations for the opcode are defined in <code class="language-plaintext highlighter-rouge">opcodes.h</code>. The interpreter is structured to have handler functions for the top-level opcode in the following form:</p><pre><code><span class="kt">bool</span> handler_rv64_<span class="o">&lt;</span>opcode<span class="o">&gt;</span>(riscvm_ptr self, Instruction inst);
</code></pre><p>As an example, we can look at the handler for the <a href="https://msyksphinz-self.github.io/riscv-isadoc/html/rvi.html#lui"><code class="language-plaintext highlighter-rouge">lui</code></a> instruction (note that the handlers themselves are responsible for updating <code class="language-plaintext highlighter-rouge">pc</code>):</p><pre><code>ALWAYS_INLINE <span class="k">static</span> <span class="kt">bool</span> handler_rv64_lui(riscvm_ptr self, Instruction inst)
{
    <span class="kt">int64_t</span> imm <span class="o">=</span> bit_signer(inst.utype.imm, <span class="mi">20</span>) <span class="o">&lt;&lt;</span> <span class="mi">12</span>;
    reg_write(inst.utype.rd, imm);

    self<span class="o">-&gt;</span>pc <span class="o">+=</span> <span class="mi">4</span>;
    dispatch(); <span class="c1">// return true;</span>
}
</code></pre><p>The interpreter executes until one of the handlers returns <code class="language-plaintext highlighter-rouge">false</code>, indicating the CPU has to halt:</p><pre><code><span class="kt">void</span> riscvm_run(riscvm_ptr self)
{
    <span class="k">while</span> (<span class="nb">true</span>)
    {
        Instruction inst;
        inst.bits <span class="o">=</span> <span class="o">*</span>(<span class="kt">uint32_t</span><span class="o">*</span>)self<span class="o">-&gt;</span>pc;
        <span class="k">if</span> (<span class="o">!</span>riscvm_execute_handler(self, inst))
            <span class="k">break</span>;
    }
}
</code></pre><p><a href="https://gregchadwick.co.uk/blog/building-rrs-pt1/">Plenty</a> of <a href="https://fmash16.github.io/content/posts/riscv-emulator-in-c.html">articles</a> have been <a href="https://jborza.com/post/2021-04-02-emuriscv-2021-refresh/">written</a> about the semantics of RISC-V, so you can look at the source code if you’re interested in the implementation details of individual instructions. The structure of the interpreter also allows us to easily implement obfuscation features, which we will discuss in the next section.</p><p>For now, we will declare the handler functions as <code class="language-plaintext highlighter-rouge">__attribute__((always_inline))</code> and set the <code class="language-plaintext highlighter-rouge">-fno-jump-tables</code> compiler option, which gives us a <code class="language-plaintext highlighter-rouge">riscvm_run</code> function that (comfortably) fits into a single page (<code class="language-plaintext highlighter-rouge">0xCA4</code> bytes):</p><p><img src="https://secret.club/assets/riscy-business/cfg.png" alt="interpreter control flow graph"></p><h2 id="hardening-features"> <a href="https://secret.club/2023/12/24/riscy-business.html#hardening-features">Hardening features</a></h2><p>A regular RISC-V interpreter is fun, but an attacker can easily reverse engineer our payload by throwing it into <a href="https://ghidra-sre.org/">Ghidra</a> to decompile it. To force the attacker to at least look at our VM interpreter, we implemented a few security features. These features are implemented in a Python script that parses the linker MAP file and directly modifies the opcodes: <a href="https://github.com/thesecretclub/riscy-business/blob/master/riscvm/encrypt.py"><code class="language-plaintext highlighter-rouge">encrypt.py</code></a>.</p><h3 id="opcode-shuffling"> <a href="https://secret.club/2023/12/24/riscy-business.html#opcode-shuffling">Opcode shuffling</a></h3><p>The most elegant (and likely most effective) obfuscation is to simply reorder the enums of the instruction opcodes and sub-functions. The <a href="https://github.com/thesecretclub/riscy-business/blob/master/riscvm/shuffle.py"><code class="language-plaintext highlighter-rouge">shuffle.py</code></a> script is used to generate <code class="language-plaintext highlighter-rouge">shuffled_opcodes.h</code>, which is then included into <code class="language-plaintext highlighter-rouge">riscvm.h</code> instead of <code class="language-plaintext highlighter-rouge">opcodes.h</code> to mix the opcodes:</p><pre><code><span class="cp">#ifdef OPCODE_SHUFFLING
#warning Opcode shuffling enabled
#include</span> <span class="cpf">"shuffled_opcodes.h"</span><span class="cp">
#else
#include</span> <span class="cpf">"opcodes.h"</span><span class="cp">
#endif // OPCODE_SHUFFLING
</span></code></pre><p>There is also a <code class="language-plaintext highlighter-rouge">shuffled_opcodes.json</code> file generated, which is parsed by <code class="language-plaintext highlighter-rouge">encrypt.py</code> to know how to shuffle the assembled instructions.</p><p>Because enums are used for all the opcodes, we only need to recompile the interpreter to obfuscate it; there is no additional complexity cost in the implementation.</p><h3 id="bytecode-encryption"> <a href="https://secret.club/2023/12/24/riscy-business.html#bytecode-encryption">Bytecode encryption</a></h3><p>To increase diversity between payloads for the same VM instance, we also employ a simple ‘encryption’ scheme on top of the opcode:</p><pre><code>ALWAYS_INLINE <span class="k">static</span> <span class="kt">uint32_t</span> tetra_twist(<span class="kt">uint32_t</span> input)
{
    <span class="cm">/**
     * Custom hash function that is used to generate the encryption key.
     * This has strong avalanche properties and is used to ensure that
     * small changes in the input result in large changes in the output.
     */</span>

    <span class="k">constexpr</span> <span class="kt">uint32_t</span> prime1 <span class="o">=</span> <span class="mh">0x9E3779B1</span>; <span class="c1">// a large prime number</span>

    input <span class="o">^=</span> input <span class="o">&gt;&gt;</span> <span class="mi">15</span>;
    input <span class="o">*=</span> prime1;
    input <span class="o">^=</span> input <span class="o">&gt;&gt;</span> <span class="mi">12</span>;
    input <span class="o">*=</span> prime1;
    input <span class="o">^=</span> input <span class="o">&gt;&gt;</span> <span class="mi">4</span>;
    input <span class="o">*=</span> prime1;
    input <span class="o">^=</span> input <span class="o">&gt;&gt;</span> <span class="mi">16</span>;

    <span class="k">return</span> input;
}

ALWAYS_INLINE <span class="k">static</span> <span class="kt">uint32_t</span> transform(<span class="kt">uintptr_t</span> offset, <span class="kt">uint32_t</span> key)
{
    <span class="kt">uint32_t</span> key2 <span class="o">=</span> key <span class="o">+</span> offset;
    <span class="k">return</span> tetra_twist(key2);
}

ALWAYS_INLINE <span class="k">static</span> <span class="kt">uint32_t</span> riscvm_fetch(riscvm_ptr self)
{
    <span class="kt">uint32_t</span> data;
    memcpy(<span class="o">&amp;</span>data, (<span class="k">const</span> <span class="kt">void</span><span class="o">*</span>)self<span class="o">-&gt;</span>pc, <span class="k">sizeof</span>(data));

<span class="cp">#ifdef CODE_ENCRYPTION
</span>    <span class="k">return</span> data <span class="o">^</span> transform(self<span class="o">-&gt;</span>pc <span class="o">-</span> self<span class="o">-&gt;</span>base, self<span class="o">-&gt;</span>key);
<span class="cp">#else
</span>    <span class="k">return</span> data;
<span class="cp">#endif // CODE_ENCRYPTION
</span>}
</code></pre><p>The offset relative to the start of the bytecode is used as the seed to a simple <code class="language-plaintext highlighter-rouge">transform</code> function. The result of this function is XOR’d with the instruction data before decoding. The exact transformation doesn’t really matter, because an attacker can always observe the decrypted bytecode at runtime. However, static analysis becomes more difficult and pattern-matching the payload is prevented, all for a relatively small increase in VM implementation complexity.</p><p>It would be possible to encrypt the contents of the <code class="language-plaintext highlighter-rouge">.data</code> section of the payload as well, but we would have to completely decrypt it in memory before starting execution anyway. Technically, it would be also possible to implement a lazy encryption scheme by customizing the <code class="language-plaintext highlighter-rouge">riscvm_read</code> and <code class="language-plaintext highlighter-rouge">riscvm_write</code> functions to intercept reads/writes to the payload region, but this idea was not pursued further.</p><h3 id="threaded-handlers"> <a href="https://secret.club/2023/12/24/riscy-business.html#threaded-handlers">Threaded handlers</a></h3><p>The most interesting feature of our VM is that we only need to make minor code modifications to turn it into a so-called <a href="https://en.wikipedia.org/wiki/Threaded_code">threaded interpreter</a>. Threaded code is a well-known technique used both to speed up emulators and to introduce indirect branches that complicate reverse engineering. It is called <em>threading</em> because the execution can be visualized as a thread of handlers that directly branch to the next handler. There is no classical dispatch function, with an infinite loop and a switch case for each opcode inside. The performance improves because there are fewer false-positives in the branch predictor when executing threaded code. You can find more information about threaded interpreters in the <a href="https://www.cs.toronto.edu/~matz/dissertation/matzDissertation-latex2html/node6.html#sec:direct-threading">Dispatch Techniques</a> section of the YETI paper.</p><p>The first step is to construct a handler table, where each handler is placed at the index corresponding to each opcode. To do this we use a small snippet of <code class="language-plaintext highlighter-rouge">constexpr</code> C++ code:</p><pre><code><span class="k">typedef</span> bool (<span class="o">*</span>riscvm_handler_t)(riscvm_ptr, Instruction);

<span class="k">static</span> <span class="k">constexpr</span> std<span class="o">::</span>array<span class="o">&lt;</span>riscvm_handler_t, <span class="mi">32</span><span class="o">&gt;</span> riscvm_handlers <span class="o">=</span> []
{
    <span class="c1">// Pre-populate the table with invalid handlers</span>
    std<span class="o">::</span>array<span class="o">&lt;</span>riscvm_handler_t, <span class="mi">32</span><span class="o">&gt;</span> result <span class="o">=</span> {};
    <span class="k">for</span> (<span class="kt">size_t</span> i <span class="o">=</span> <span class="mi">0</span>; i <span class="o">&lt;</span> result.size(); i<span class="o">++</span>)
    {
        result[i] <span class="o">=</span> handler_rv64_invalid;
    }

    <span class="c1">// Insert the opcode handlers at the right index</span>
<span class="cp">#define INSERT(op) result[op] = HANDLER(op)
</span>    INSERT(rv64_load);
    INSERT(rv64_fence);
    INSERT(rv64_imm64);
    INSERT(rv64_auipc);
    INSERT(rv64_imm32);
    INSERT(rv64_store);
    INSERT(rv64_op64);
    INSERT(rv64_lui);
    INSERT(rv64_op32);
    INSERT(rv64_branch);
    INSERT(rv64_jalr);
    INSERT(rv64_jal);
    INSERT(rv64_system);
<span class="cp">#undef INSERT
</span>    <span class="k">return</span> result;
}();
</code></pre><p>With the <code class="language-plaintext highlighter-rouge">riscvm_handlers</code> table populated we can define the <code class="language-plaintext highlighter-rouge">dispatch</code> macro:</p><pre><code><span class="cp">#define dispatch()                                       \
    Instruction next;                                    \
    next.bits = riscvm_fetch(self);                      \
    if (next.compressed_flags != 0b11)                   \
    {                                                    \
        panic("compressed instructions not supported!"); \
    }                                                    \
    __attribute__((musttail)) return riscvm_handlers[next.opcode](self, next)
</span></code></pre><p>The <code class="language-plaintext highlighter-rouge">musttail</code> attribute forces the call to the next handler to be a tail call. This is only possible because all the handlers have the same function signature and it generates an indirect branch to the next handler:</p><p><img src="https://secret.club/assets/riscy-business/threaded-handlers.png" alt="threaded handler disassembly"></p><p>The final piece of the puzzle is the new implementation of the <code class="language-plaintext highlighter-rouge">riscvm_run</code> function, which uses an empty <code class="language-plaintext highlighter-rouge">riscvm_execute</code> handler to bootstrap the chain of execution:</p><pre><code>ALWAYS_INLINE <span class="k">static</span> <span class="kt">bool</span> riscvm_execute(riscvm_ptr self, Instruction inst)
{
    dispatch();
}

NEVER_INLINE <span class="kt">void</span> riscvm_run(riscvm_ptr self)
{
    Instruction inst;
    riscvm_execute(self, inst);
}
</code></pre><h3 id="traditional-obfuscation"> <a href="https://secret.club/2023/12/24/riscy-business.html#traditional-obfuscation">Traditional obfuscation</a></h3><p>The built-in hardening features that we can get with a few <code class="language-plaintext highlighter-rouge">#ifdefs</code> and a small Python script are good enough for a proof-of-concept, but they are not going to deter a determined attacker for a very long time. An attacker can pattern-match the VM’s handlers to simplify future reverse engineering efforts. To address this, we can employ common obfuscation techniques using LLVM obfuscation passes:</p><ul><li>Instruction substitution (to make pattern matching more difficult)</li><li>Opaque predicates (to hinder static analysis)</li><li>Inject anti-debug checks (to make dynamic analysis more difficult)</li></ul><p>The paper <a href="https://is.muni.cz/th/v1f9y/Modern_obfuscation_techniques.pdf">Modern obfuscation techniques</a> by Roman Oravec gives a nice overview of literature and has good data on what obfuscation passes are most effective considering their runtime overhead.</p><p>Additionally, it would also be possible to further enhance the VM’s security by duplicating handlers, but this would require extra post-processing on the payload itself. The VM itself is only part of what could be obfuscated. Obfuscating the payloads themselves is also something we can do quite easily. Most likely, manually-integrated security features (stack strings with <a href="https://github.com/JustasMasiulis/xorstr">xorstr</a>, <a href="https://github.com/JustasMasiulis/lazy_importer">lazy_importer</a> and variable encryption) will be most valuable here. However, because we use LLVM to build the payloads we can also employ automated obfuscation there. It is important to keep in mind that any overhead created in the payloads themselves is <em>multiplied</em> by the overhead created by the handler obfuscation, so experimentation is required to find the sweet spot for your use case.</p><h2 id="writing-the-payloads"> <a href="https://secret.club/2023/12/24/riscy-business.html#writing-the-payloads">Writing the payloads</a></h2><p>The VM described in this post so far technically has the ability to execute arbitrary code. That being said, it would be rather annoying for an end-user to write said code. For example, we would have to manually resolve all imports and then use the <code class="language-plaintext highlighter-rouge">riscvm_host_call</code> function to actually execute them. These functions are executing in the RISC-V context and their implementation looks like this:</p><pre><code><span class="kt">uintptr_t</span> riscvm_host_call(<span class="kt">uintptr_t</span> address, <span class="kt">uintptr_t</span> args[<span class="mi">13</span>])
{
    <span class="k">register</span> <span class="kt">uintptr_t</span> a0 <span class="k">asm</span>(<span class="s">"a0"</span>) <span class="o">=</span> address;
    <span class="k">register</span> <span class="kt">uintptr_t</span> a1 <span class="k">asm</span>(<span class="s">"a1"</span>) <span class="o">=</span> (<span class="kt">uintptr_t</span>)args;
    <span class="k">register</span> <span class="kt">uintptr_t</span> a7 <span class="k">asm</span>(<span class="s">"a7"</span>) <span class="o">=</span> <span class="mi">20000</span>;
    <span class="k">asm</span> <span class="k">volatile</span>(<span class="s">"scall"</span> <span class="o">:</span> <span class="s">"+r"</span>(a0) <span class="o">:</span> <span class="s">"r"</span>(a1), <span class="s">"r"</span>(a7));
    <span class="k">return</span> a0;
}

<span class="kt">uintptr_t</span> riscvm_get_peb()
{
    <span class="k">register</span> <span class="kt">uintptr_t</span> a0 <span class="k">asm</span>(<span class="s">"a0"</span>) <span class="o">=</span> <span class="mi">0</span>;
    <span class="k">register</span> <span class="kt">uintptr_t</span> a7 <span class="k">asm</span>(<span class="s">"a7"</span>) <span class="o">=</span> <span class="mi">20001</span>;
    <span class="k">asm</span> <span class="k">volatile</span>(<span class="s">"scall"</span> <span class="o">:</span> <span class="s">"+r"</span>(a0) <span class="o">:</span> <span class="s">"r"</span>(a7) <span class="o">:</span> <span class="s">"memory"</span>);
    <span class="k">return</span> a0;
}
</code></pre><p>We can get a pointer to the <code class="language-plaintext highlighter-rouge">PEB</code> using <code class="language-plaintext highlighter-rouge">riscvm_get_peb</code> and then resolve a module by its’ <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlhashunicodestring">x65599 hash</a>:</p><pre><code><span class="c1">// Structure definitions omitted for clarity</span>
<span class="kt">uintptr_t</span> riscvm_resolve_dll(<span class="kt">uint32_t</span> module_hash)
{
    <span class="k">static</span> PEB<span class="o">*</span> peb <span class="o">=</span> <span class="mi">0</span>;
    <span class="k">if</span> (<span class="o">!</span>peb)
    {
        peb <span class="o">=</span> (PEB<span class="o">*</span>)riscvm_get_peb();
    }
    LIST_ENTRY<span class="o">*</span> begin <span class="o">=</span> <span class="o">&amp;</span>peb<span class="o">-&gt;</span>Ldr<span class="o">-&gt;</span>InLoadOrderModuleList;
    <span class="k">for</span> (LIST_ENTRY<span class="o">*</span> itr <span class="o">=</span> begin<span class="o">-&gt;</span>Flink; itr <span class="o">!=</span> begin; itr <span class="o">=</span> itr<span class="o">-&gt;</span>Flink)
    {
        LDR_DATA_TABLE_ENTRY<span class="o">*</span> entry <span class="o">=</span> CONTAINING_RECORD(itr, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        <span class="k">if</span> (entry<span class="o">-&gt;</span>BaseNameHashValue <span class="o">==</span> module_hash)
        {
            <span class="k">return</span> (<span class="kt">uintptr_t</span>)entry<span class="o">-&gt;</span>DllBase;
        }
    }
    <span class="k">return</span> <span class="mi">0</span>;
}
</code></pre><p>Once we’ve obtained the base of the module we’re interested in, we can resolve the import by walking the export table:</p><pre><code><span class="kt">uintptr_t</span> riscvm_resolve_import(<span class="kt">uintptr_t</span> image, <span class="kt">uint32_t</span> export_hash)
{
    IMAGE_DOS_HEADER<span class="o">*</span>       dos_header      <span class="o">=</span> (IMAGE_DOS_HEADER<span class="o">*</span>)image;
    IMAGE_NT_HEADERS<span class="o">*</span>       nt_headers      <span class="o">=</span> (IMAGE_NT_HEADERS<span class="o">*</span>)(image <span class="o">+</span> dos_header<span class="o">-&gt;</span>e_lfanew);
    <span class="kt">uint32_t</span>                export_dir_size <span class="o">=</span> nt_headers<span class="o">-&gt;</span>OptionalHeader.DataDirectory[<span class="mi">0</span>].Size;
    IMAGE_EXPORT_DIRECTORY<span class="o">*</span> export_dir <span class="o">=</span>
        (IMAGE_EXPORT_DIRECTORY<span class="o">*</span>)(image <span class="o">+</span> nt_headers<span class="o">-&gt;</span>OptionalHeader.DataDirectory[<span class="mi">0</span>].VirtualAddress);
    <span class="kt">uint32_t</span><span class="o">*</span> names <span class="o">=</span> (<span class="kt">uint32_t</span><span class="o">*</span>)(image <span class="o">+</span> export_dir<span class="o">-&gt;</span>AddressOfNames);
    <span class="kt">uint32_t</span><span class="o">*</span> funcs <span class="o">=</span> (<span class="kt">uint32_t</span><span class="o">*</span>)(image <span class="o">+</span> export_dir<span class="o">-&gt;</span>AddressOfFunctions);
    <span class="kt">uint16_t</span><span class="o">*</span> ords  <span class="o">=</span> (<span class="kt">uint16_t</span><span class="o">*</span>)(image <span class="o">+</span> export_dir<span class="o">-&gt;</span>AddressOfNameOrdinals);

    <span class="k">for</span> (<span class="kt">uint32_t</span> i <span class="o">=</span> <span class="mi">0</span>; i <span class="o">&lt;</span> export_dir<span class="o">-&gt;</span>NumberOfNames; <span class="o">++</span>i)
    {
        <span class="kt">char</span><span class="o">*</span>     name <span class="o">=</span> (<span class="kt">char</span><span class="o">*</span>)(image <span class="o">+</span> names[i]);
        <span class="kt">uintptr_t</span> func <span class="o">=</span> (<span class="kt">uintptr_t</span>)(image <span class="o">+</span> funcs[ords[i]]);
        <span class="c1">// Ignore forwarded exports</span>
        <span class="k">if</span> (func <span class="o">&gt;=</span> (<span class="kt">uintptr_t</span>)export_dir <span class="o">&amp;&amp;</span> func <span class="o">&lt;</span> (<span class="kt">uintptr_t</span>)export_dir <span class="o">+</span> export_dir_size)
            <span class="k">continue</span>;
        <span class="kt">uint32_t</span> hash <span class="o">=</span> hash_x65599(name, <span class="nb">true</span>);
        <span class="k">if</span> (hash <span class="o">==</span> export_hash)
        {
            <span class="k">return</span> func;
        }
    }

    <span class="k">return</span> <span class="mi">0</span>;
}
</code></pre><p>Now we can call <code class="language-plaintext highlighter-rouge">MessageBoxA</code> from RISC-V with the following code:</p><pre><code><span class="c1">// NOTE: We cannot use Windows.h here</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> main()
{
    <span class="c1">// Resolve LoadLibraryA</span>
    <span class="k">auto</span> kernel32_dll <span class="o">=</span> riscvm_resolve_dll(hash_x65599(<span class="s">"kernel32.dll"</span>, <span class="nb">false</span>))
    <span class="k">auto</span> LoadLibraryA <span class="o">=</span> riscvm_resolve_import(kernel32_dll, hash_x65599(<span class="s">"LoadLibraryA"</span>, <span class="nb">true</span>))

    <span class="c1">// Load user32.dll</span>
    <span class="kt">uint64_t</span> args[<span class="mi">13</span>];
    args[<span class="mi">0</span>] <span class="o">=</span> (<span class="kt">uint64_t</span>)<span class="s">"user32.dll"</span>;
    <span class="k">auto</span> user32_dll <span class="o">=</span> riscvm_host_call(LoadLibraryA, args);

    <span class="c1">// Resolve MessageBoxA</span>
    <span class="k">auto</span> MessageBoxA <span class="o">=</span> riscvm_resolve_import(user32_dll, hash_x65599(<span class="s">"MessageBoxA"</span>, <span class="nb">true</span>));

    <span class="c1">// Show a message to the user</span>
    args[<span class="mi">0</span>] <span class="o">=</span> <span class="mi">0</span>; <span class="c1">// hwnd</span>
    args[<span class="mi">1</span>] <span class="o">=</span> (<span class="kt">uint64_t</span>)<span class="s">"Hello from RISC-V!"</span>; <span class="c1">// msg</span>
    args[<span class="mi">2</span>] <span class="o">=</span> (<span class="kt">uint64_t</span>)<span class="s">"riscvm"</span>; <span class="c1">// title</span>
    args[<span class="mi">3</span>] <span class="o">=</span> <span class="mi">0</span>; <span class="c1">// flags</span>
    riscvm_host_call(MessageBoxA, args);
}
</code></pre><p>With some templates/macros/constexpr tricks we can probably get this down to something more readable, but fundamentally this code will always stay annoying to write. Even if calling imports were a one-liner, we would still have to deal with the fact that we cannot use <code class="language-plaintext highlighter-rouge">Windows.h</code> (or any of the Microsoft headers for that matter). The reason for this is that we are cross-compiling with Clang. Even if we were to set up the include paths correctly, it would still be a major pain to get everything to compile correctly. That being said, our VM works! A major advantage of RISC-V is that, since the instruction set is simple, once the fundamentals work, we can be confident that features built on top of this will execute as expected.</p><h2 id="whole-program-llvm"> <a href="https://secret.club/2023/12/24/riscy-business.html#whole-program-llvm">Whole Program LLVM</a></h2><p>Usually, when discussing LLVM, the compilation process is running on Linux/macOS. In this section, we will describe a pipeline that can actually be used on Windows, without making modifications to your toolchain. This is useful if you would like to analyze/fuzz/obfuscate Windows applications, which might only compile an MSVC-compatible compiler: <code class="language-plaintext highlighter-rouge">clang-cl</code>.</p><h3 id="link-time-optimization-lto"> <a href="https://secret.club/2023/12/24/riscy-business.html#link-time-optimization-lto">Link-time optimization (LTO)</a></h3><p>Without LTO, the object files produced by Clang are native COFF/ELF/Mach-O files. Every file is optimized and compiled independently. The linker loads these objects and merges them together into the final executable.</p><p>When enabling LTO, the object files are instead <a href="https://llvm.org/docs/BitCodeFormat.html">LLVM Bitcode</a> (<code class="language-plaintext highlighter-rouge">.bc</code>) files. This allows the linker to merge all the LLVM IR together and perform (more comprehensive) whole-program optimizations. After the LLVM IR has been optimized, the native code is generated and the final executable produced. The diagram below comes from the great <a href="https://convolv.es/guides/lto/">Link-time optimisation (LTO)</a> post by <a href="https://github.com/jryans">Ryan Stinnet</a>:</p><p><img src="https://convolv.es/guides/lto/lto-workflow.svg" alt="LTO workflow" width="300" height="150"></p><h3 id="compiler-wrappers"> <a href="https://secret.club/2023/12/24/riscy-business.html#compiler-wrappers">Compiler wrappers</a></h3><p>Unfortunately, it can be quite annoying to write an executable that can replace the compiler. It is quite simple when dealing with a few object files, but with bigger projects it gets quite tricky (especially when CMake is involved). Existing projects are <a href="https://github.com/travitch/whole-program-llvm">WLLVM</a> and <a href="https://github.com/SRI-CSL/gllvm">gllvm</a>, but they do not work nicely on Windows. When using CMake, you can use the <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER_LAUNCHER.html"><code class="language-plaintext highlighter-rouge">CMAKE_&lt;LANG&gt;_COMPILER_LAUNCHER</code></a> variables and intercept the compilation pipeline that way, but that is also tricky to deal with.</p><p>On Windows, things are more complex than on Linux. This is because Clang uses a different program to link the final executable and correctly intercepting this process can become quite challenging.</p><h3 id="embedding-bitcode"> <a href="https://secret.club/2023/12/24/riscy-business.html#embedding-bitcode">Embedding bitcode</a></h3><p>To achieve our goal of post-processing the bitcode of the whole program, we need to enable bitcode embedding. The first flag we need is <code class="language-plaintext highlighter-rouge">-flto</code>, which enables LTO. The second flag is <code class="language-plaintext highlighter-rouge">-lto-embed-bitcode</code>, which isn’t documented very well. When using <code class="language-plaintext highlighter-rouge">clang-cl</code>, you also need a special incantation to enable it:</p><div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span>(EMBED_TYPE <span class="s2">"post-merge-pre-opt"</span>) <span class="c1"># post-merge-pre-opt/optimized</span>
<span class="nb">if</span>(NOT CMAKE_CXX_COMPILER_ID MATCHES <span class="s2">"Clang"</span>)
    <span class="nb">if</span>(WIN32)
        <span class="nb">message</span>(FATAL_ERROR <span class="s2">"clang-cl is required, use -T ClangCL --fresh"</span>)
    <span class="nb">else</span>()
        <span class="nb">message</span>(FATAL_ERROR <span class="s2">"clang compiler is required"</span>)
    <span class="nb">endif</span>()
<span class="nb">elseif</span>(CMAKE_CXX_COMPILER_FRONTEND_VARIANT MATCHES <span class="s2">"^MSVC$"</span>)
    <span class="c1"># clang-cl</span>
    <span class="nb">add_compile_options</span>(-flto)
    <span class="nb">add_link_options</span>(/mllvm:-lto-embed-bitcode=<span class="si">${</span><span class="nv">EMBED_TYPE</span><span class="si">}</span>)
<span class="nb">elseif</span>(WIN32)
    <span class="c1"># clang (Windows)</span>
    <span class="nb">add_compile_options</span>(-fuse-ld=lld-link -flto)
    <span class="nb">add_link_options</span>(-Wl,/mllvm:-lto-embed-bitcode=<span class="si">${</span><span class="nv">EMBED_TYPE</span><span class="si">}</span>)
<span class="nb">else</span>()
	<span class="c1"># clang (Linux)</span>
    <span class="nb">add_compile_options</span>(-fuse-ld=lld -flto)
    <span class="nb">add_link_options</span>(-Wl,-lto-embed-bitcode=<span class="si">${</span><span class="nv">EMBED_TYPE</span><span class="si">}</span>)
<span class="nb">endif</span>()
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">-lto-embed-bitcode</code> flag creates an additional <code class="language-plaintext highlighter-rouge">.llvmbc</code> section in the final executable that contains the bitcode. It offers three settings:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-lto-embed-bitcode=&lt;value&gt; - Embed LLVM bitcode in object files produced by LTO
    =none                  - Do not embed 
    =optimized             - Embed after all optimization passes
    =post-merge-pre-opt    - Embed post merge, but before optimizations
</code></pre></div></div><p>Once the bitcode is embedded within the output binary, it can be extracted using <a href="https://llvm.org/docs/CommandGuide/llvm-objcopy.html">llvm-objcopy</a> and disassembled with <a href="https://llvm.org/docs/CommandGuide/llvm-dis.html">llvm-dis</a>. This is normally done as the follows:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>llvm-objcopy --dump-section=.llvmbc=program.bc program
llvm-dis program.bc &gt; program.ll
</code></pre></div></div><p>Unfortunately, we discovered a bug/oversight in LLD on Windows. The section is extracted without errors, but <code class="language-plaintext highlighter-rouge">llvm-dis</code> fails to load the bitcode. The reason for this is that Windows executables have a <code class="language-plaintext highlighter-rouge">FileAlignment</code> attribute, leading to additional padding with zeroes. To get valid bitcode, you need to remove some of these trailing zeroes:</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">pefile</span>

<span class="k">def</span> main():
    <span class="c1"># Parse the arguments
</span>    parser <span class="o">=</span> argparse.ArgumentParser()
    parser.add_argument(<span class="s">"executable"</span>, help<span class="o">=</span><span class="s">"Executable with embedded .llvmbc section"</span>)
    parser.add_argument(<span class="s">"--output"</span>, <span class="s">"-o"</span>, help<span class="o">=</span><span class="s">"Output file name"</span>, required<span class="o">=</span><span class="bp">True</span>)
    args <span class="o">=</span> parser.parse_args()
    executable: <span class="nb">str</span> <span class="o">=</span> args.executable
    output: <span class="nb">str</span> <span class="o">=</span> args.output

    <span class="c1"># Find the .llvmbc section
</span>    pe <span class="o">=</span> pefile.PE(executable)
    llvmbc <span class="o">=</span> <span class="bp">None</span>
    <span class="k">for</span> section <span class="ow">in</span> pe.sections:
        <span class="k">if</span> section.Name.decode(<span class="s">"utf-8"</span>).strip(<span class="s">"</span><span class="se">\x00</span><span class="s">"</span>) <span class="o">==</span> <span class="s">".llvmbc"</span>:
            llvmbc <span class="o">=</span> section
            <span class="k">break</span>
    <span class="k">if</span> llvmbc <span class="ow">is</span> <span class="bp">None</span>:
        <span class="k">print</span>(<span class="s">"No .llvmbc section found"</span>)
        sys.<span class="nb">exit</span>(<span class="mi">1</span>)

    <span class="c1"># Recover the bitcode and write it to a file
</span>    <span class="k">with</span> <span class="nb">open</span>(output, <span class="s">"wb"</span>) <span class="k">as</span> f:
        data <span class="o">=</span> <span class="nb">bytearray</span>(llvmbc.get_data())
        <span class="c1"># Truncate all trailing null bytes
</span>        <span class="k">while</span> data[<span class="o">-</span><span class="mi">1</span>] <span class="o">==</span> <span class="mi">0</span>:
            data.pop()
        <span class="c1"># Recover alignment to 4
</span>        <span class="k">while</span> <span class="nb">len</span>(data) <span class="o">%</span> <span class="mi">4</span> <span class="o">!=</span> <span class="mi">0</span>:
            data.append(<span class="mi">0</span>)
        <span class="c1"># Add a block end marker
</span>        <span class="k">for</span> _ <span class="ow">in</span> <span class="nb">range</span>(<span class="mi">4</span>):
            data.append(<span class="mi">0</span>)
        f.write(data)

<span class="k">if</span> __name__ <span class="o">==</span> <span class="s">"__main__"</span>:
    main()
</code></pre></div></div><p>In our testing, this doesn’t have any issues, but there might be cases where this heuristic does not work properly. In that case, a potential solution could be to brute force the amount of trailing zeroes, until the bitcode parses without errors.</p><h3 id="applications"> <a href="https://secret.club/2023/12/24/riscy-business.html#applications">Applications</a></h3><p>Now that we have access to our program’s bitcode, several applications become feasible:</p><ul><li>Write an analyzer to identify potentially interesting locations within the program.</li><li>Instrument the bitcode and then re-link the executable, which is particularly useful for code coverage while fuzzing.</li><li>Obfuscate the bitcode before re-linking the executable, enhancing security.</li><li>IR retargeting, where the bitcode compiled for one architecture can be used on another.</li></ul><h3 id="relinking-the-executable"> <a href="https://secret.club/2023/12/24/riscy-business.html#relinking-the-executable">Relinking the executable</a></h3><p>The bitcode itself unfortunately does not contain enough information to re-link the executable (although this is something we would like to implement upstream). We could either manually attempt to reconstruct the linker command line (with tools like <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/procmon">Process Monitor</a>), or use LLVM plugin support. Plugin support is not really functional on Windows (although there is some indication that Sony is using it for their PS4/PS5 toolchain), but we can still load an arbitrary DLL using the <code class="language-plaintext highlighter-rouge">-load</code> command line flag. Once we loaded our DLL, we can hijack the executable command line and process the flags to generate a script for re-linking the program after our modifications are done.</p><h2 id="retargeting-llvm-ir"> <a href="https://secret.club/2023/12/24/riscy-business.html#retargeting-llvm-ir">Retargeting LLVM IR</a></h2><p>Ideally, we would want to write code like this and magically get it to run in our VM:</p><pre><code><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> main()
{
    MessageBoxA(<span class="mi">0</span>, <span class="s">"Hello from RISC-V!"</span>, <span class="s">"riscvm"</span>, <span class="mi">0</span>);
}
</code></pre><p>Luckily this is entirely possible, it just requires writing a (fairly) simple tool to perform transformations on the Bitcode of this program (built using <code class="language-plaintext highlighter-rouge">clang-cl</code>). In the coming sections, we will describe how we managed to do this using Microsoft Visual Studio’s <a href="https://learn.microsoft.com/en-us/cpp/build/clang-support-msbuild">official LLVM integration</a> (i.e. without having to use a custom fork of <code class="language-plaintext highlighter-rouge">clang-cl</code>).</p><p>The LLVM IR of the example above looks roughly like this (it has been cleaned up slightly for readability):</p><div class="language-llvm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">source_filename</span> = <span class="s">"hello.c"</span>
<span class="k">target</span> <span class="k">datalayout</span> = <span class="s">"e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"</span>
<span class="k">target</span> <span class="k">triple</span> = <span class="s">"x86_64-pc-windows-msvc19.38.33133"</span>

<span class="vg">@message</span> = <span class="k">dso_local</span> <span class="k">global</span> [<span class="m">19</span> x <span class="kt">i8</span>] <span class="s">c"Hello from RISC-V!\00"</span>, <span class="k">align</span> <span class="m">16</span>
<span class="vg">@title</span> = <span class="k">dso_local</span> <span class="k">global</span> [<span class="m">7</span> x <span class="kt">i8</span>] <span class="s">c"riscvm\00"</span>, <span class="k">align</span> <span class="m">1</span>

<span class="c1">; Function Attrs: noinline nounwind optnone uwtable</span>
<span class="k">define</span> <span class="k">dso_local</span> <span class="kt">i32</span> <span class="vg">@main</span>() <span class="vg">#0</span> {
  <span class="nv">%1</span> = <span class="k">call</span> <span class="kt">i32</span> <span class="vg">@MessageBoxA</span>(ptr noundef <span class="k">null</span>, ptr noundef <span class="vg">@message</span>, ptr noundef <span class="vg">@title</span>, <span class="kt">i32</span> noundef <span class="m">0</span>)
  <span class="k">ret</span> <span class="kt">i32</span> <span class="m">0</span>
}

<span class="k">declare</span> <span class="k">dllimport</span> <span class="kt">i32</span> <span class="vg">@MessageBoxA</span>(ptr noundef, ptr noundef, ptr noundef, <span class="kt">i32</span> noundef) <span class="vg">#1</span>

<span class="k">attributes</span> <span class="vg">#0</span> = { <span class="k">noinline</span> <span class="k">nounwind</span> <span class="k">optnone</span> <span class="k">uwtable</span> <span class="s">"min-legal-vector-width"</span>=<span class="s">"0"</span> <span class="s">"no-trapping-math"</span>=<span class="s">"true"</span> <span class="s">"stack-protector-buffer-size"</span>=<span class="s">"8"</span> <span class="s">"target-cpu"</span>=<span class="s">"x86-64"</span> <span class="s">"target-features"</span>=<span class="s">"+cx8,+fxsr,+mmx,+sse,+sse2,+x87"</span> <span class="s">"tune-cpu"</span>=<span class="s">"generic"</span> }
<span class="k">attributes</span> <span class="vg">#1</span> = { <span class="s">"no-trapping-math"</span>=<span class="s">"true"</span> <span class="s">"stack-protector-buffer-size"</span>=<span class="s">"8"</span> <span class="s">"target-cpu"</span>=<span class="s">"x86-64"</span> <span class="s">"target-features"</span>=<span class="s">"+cx8,+fxsr,+mmx,+sse,+sse2,+x87"</span> <span class="s">"tune-cpu"</span>=<span class="s">"generic"</span> }

<span class="nv">!llvm.linker.options</span> = !{<span class="nv">!0</span>, <span class="nv">!0</span>}
<span class="nv">!llvm.module.flags</span> = !{<span class="nv">!1</span>, <span class="nv">!2</span>, <span class="nv">!3</span>}
<span class="nv">!llvm.ident</span> = !{<span class="nv">!4</span>}

<span class="nv">!0</span> = !{<span class="nv">!"/DEFAULTLIB:uuid.lib"</span>}
<span class="nv">!1</span> = !{<span class="kt">i32</span> <span class="m">1</span>, <span class="nv">!"wchar_size"</span>, <span class="kt">i32</span> <span class="m">2</span>}
<span class="nv">!2</span> = !{<span class="kt">i32</span> <span class="m">8</span>, <span class="nv">!"PIC Level"</span>, <span class="kt">i32</span> <span class="m">2</span>}
<span class="nv">!3</span> = !{<span class="kt">i32</span> <span class="m">7</span>, <span class="nv">!"uwtable"</span>, <span class="kt">i32</span> <span class="m">2</span>}
<span class="nv">!4</span> = !{<span class="nv">!"clang version 16.0.5"</span>}
</code></pre></div></div><p>To retarget this code to RISC-V, we need to do the following:</p><ul><li>Collect all the functions with a <code class="language-plaintext highlighter-rouge">dllimport</code> storage class.</li><li>Generate a <code class="language-plaintext highlighter-rouge">riscvm_imports</code> function that resolves all the function addresses of the imports.</li><li>Replace the <code class="language-plaintext highlighter-rouge">dllimport</code> functions with stubs that use <code class="language-plaintext highlighter-rouge">riscvm_host_call</code> to call the import.</li><li>Change the target triple to <code class="language-plaintext highlighter-rouge">riscv64-unknown-unknown</code> and adjust the data layout.</li><li>Compile the retargeted bitcode and link it together with <code class="language-plaintext highlighter-rouge">crt0</code> to create the final payload.</li></ul><h3 id="adjusting-the-metadata"> <a href="https://secret.club/2023/12/24/riscy-business.html#adjusting-the-metadata">Adjusting the metadata</a></h3><p>After loading the LLVM IR <code class="language-plaintext highlighter-rouge">Module</code>, the first step is to change the <code class="language-plaintext highlighter-rouge">DataLayout</code> and the <code class="language-plaintext highlighter-rouge">TargetTriple</code> to be what the RISC-V backend expects:</p><pre><code>module.setDataLayout(<span class="s">"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"</span>);
module.setTargetTriple(<span class="s">"riscv64-unknown-unknown"</span>);
module.setSourceFileName(<span class="s">"transpiled.bc"</span>);
</code></pre><p>The next step is to collect all the <code class="language-plaintext highlighter-rouge">dllimport</code> functions for later processing. Additionally, a bunch of x86-specific function attributes are removed from every function:</p><pre><code>std<span class="o">::</span>vector<span class="o">&lt;</span>Function<span class="o">*&gt;</span> importedFunctions;
<span class="k">for</span> (Function<span class="o">&amp;</span> function <span class="o">:</span> module.functions())
{
	<span class="c1">// Remove x86-specific function attributes</span>
	function.removeFnAttr(<span class="s">"target-cpu"</span>);
	function.removeFnAttr(<span class="s">"target-features"</span>);
	function.removeFnAttr(<span class="s">"tune-cpu"</span>);
	function.removeFnAttr(<span class="s">"stack-protector-buffer-size"</span>);

	<span class="c1">// Collect imported functions</span>
	<span class="k">if</span> (function.hasDLLImportStorageClass() <span class="o">&amp;&amp;</span> <span class="o">!</span>function.getName().startswith(<span class="s">"riscvm_"</span>))
	{
		importedFunctions.push_back(<span class="o">&amp;</span>function);
	}
	function.setDLLStorageClass(GlobalValue<span class="o">::</span>DefaultStorageClass);
</code></pre><p>Finally, we have to remove the <code class="language-plaintext highlighter-rouge">llvm.linker.options</code> metadata to make sure we can pass the IR to <code class="language-plaintext highlighter-rouge">llc</code> or <code class="language-plaintext highlighter-rouge">clang</code> without errors.</p><h3 id="import-map"> <a href="https://secret.club/2023/12/24/riscy-business.html#import-map">Import map</a></h3><p>The LLVM IR only has the <code class="language-plaintext highlighter-rouge">dllimport</code> storage class to inform us that a function is imported. Unfortunately, it does not provide us with the DLL the function comes from. Because this information is only available at link-time (in files like <code class="language-plaintext highlighter-rouge">user32.lib</code>), we decided to implement an extra <code class="language-plaintext highlighter-rouge">-importmap</code> argument.</p><p>The <code class="language-plaintext highlighter-rouge">extract-bc</code> script that extracts the <code class="language-plaintext highlighter-rouge">.llvmbc</code> section now also has to extract the imported functions and what DLL they come from:</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span>(importmap, <span class="s">"wb"</span>) <span class="k">as</span> f:
	<span class="k">for</span> desc <span class="ow">in</span> pe.DIRECTORY_ENTRY_IMPORT:
		dll <span class="o">=</span> desc.dll.decode(<span class="s">"utf-8"</span>)
		<span class="k">for</span> imp <span class="ow">in</span> desc.imports:
			name <span class="o">=</span> imp.name.decode(<span class="s">"utf-8"</span>)
			f.write(<span class="sa">f</span><span class="s">"</span><span class="si">{</span>name<span class="si">}</span><span class="s">:</span><span class="si">{</span>dll<span class="si">}</span><span class="se">\n</span><span class="s">"</span>.encode(<span class="s">"utf-8"</span>))
</code></pre></div></div><p>Currently, imports by ordinal and <a href="https://web.archive.org/web/20220628094135/https://lucasg.github.io/2017/10/15/Api-set-resolution/">API sets</a> are not supported, but we can easily make sure those do not occur when building our code.</p><h3 id="creating-the-import-stubs"> <a href="https://secret.club/2023/12/24/riscy-business.html#creating-the-import-stubs">Creating the import stubs</a></h3><p>For every <code class="language-plaintext highlighter-rouge">dllimport</code> function, we need to add some IR to <code class="language-plaintext highlighter-rouge">riscvm_imports</code> to resolve the address. Additionally, we have to create a stub that forwards the function arguments to <code class="language-plaintext highlighter-rouge">riscvm_host_call</code>. This is the generated LLVM IR for the <code class="language-plaintext highlighter-rouge">MessageBoxA</code> stub:</p><div class="language-llvm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Global variable to hold the resolved import address</span>
<span class="vg">@import_MessageBoxA</span> = <span class="k">private</span> <span class="k">global</span> ptr <span class="k">null</span>

<span class="k">define</span> <span class="kt">i32</span> <span class="vg">@MessageBoxA</span>(ptr noundef <span class="nv">%0</span>, ptr noundef <span class="nv">%1</span>, ptr noundef <span class="nv">%2</span>, <span class="kt">i32</span> noundef <span class="nv">%3</span>) <span class="k">local_unnamed_addr</span> <span class="vg">#1</span> {
<span class="nl">entry:</span>
  <span class="nv">%args</span> = <span class="k">alloca</span> ptr, <span class="kt">i32</span> <span class="m">13</span>, <span class="k">align</span> <span class="m">8</span>
  <span class="nv">%arg3_zext</span> = <span class="k">zext</span> <span class="kt">i32</span> <span class="nv">%3</span> <span class="k">to</span> <span class="kt">i64</span>
  <span class="nv">%arg3_cast</span> = <span class="k">inttoptr</span> <span class="kt">i64</span> <span class="nv">%arg3_zext</span> <span class="k">to</span> ptr
  <span class="nv">%import_address</span> = <span class="k">load</span> ptr, ptr <span class="vg">@import_MessageBoxA</span>, <span class="k">align</span> <span class="m">8</span>
  <span class="nv">%arg0_ptr</span> = <span class="k">getelementptr</span> ptr, ptr <span class="nv">%args</span>, <span class="kt">i32</span> <span class="m">0</span>
  <span class="k">store</span> ptr <span class="nv">%0</span>, ptr <span class="nv">%arg0_ptr</span>, <span class="k">align</span> <span class="m">8</span>
  <span class="nv">%arg1_ptr</span> = <span class="k">getelementptr</span> ptr, ptr <span class="nv">%args</span>, <span class="kt">i32</span> <span class="m">1</span>
  <span class="k">store</span> ptr <span class="nv">%1</span>, ptr <span class="nv">%arg1_ptr</span>, <span class="k">align</span> <span class="m">8</span>
  <span class="nv">%arg2_ptr</span> = <span class="k">getelementptr</span> ptr, ptr <span class="nv">%args</span>, <span class="kt">i32</span> <span class="m">2</span>
  <span class="k">store</span> ptr <span class="nv">%2</span>, ptr <span class="nv">%arg2_ptr</span>, <span class="k">align</span> <span class="m">8</span>
  <span class="nv">%arg3_ptr</span> = <span class="k">getelementptr</span> ptr, ptr <span class="nv">%args</span>, <span class="kt">i32</span> <span class="m">3</span>
  <span class="k">store</span> ptr <span class="nv">%arg3_cast</span>, ptr <span class="nv">%arg3_ptr</span>, <span class="k">align</span> <span class="m">8</span>
  <span class="nv">%return</span> = <span class="k">call</span> ptr <span class="vg">@riscvm_host_call</span>(ptr <span class="nv">%import_address</span>, ptr <span class="nv">%args</span>)
  <span class="nv">%return_cast</span> = <span class="k">ptrtoint</span> ptr <span class="nv">%return</span> <span class="k">to</span> <span class="kt">i64</span>
  <span class="nv">%return_trunc</span> = <span class="k">trunc</span> <span class="kt">i64</span> <span class="nv">%return_cast</span> <span class="k">to</span> <span class="kt">i32</span>
  <span class="k">ret</span> <span class="kt">i32</span> <span class="nv">%return_trunc</span>
}
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">uint64_t args[13]</code> array is allocated on the stack using the <code class="language-plaintext highlighter-rouge">alloca</code> instruction and every function argument is stored in there (after being zero-extended). The <code class="language-plaintext highlighter-rouge">GlobalVariable</code> named <code class="language-plaintext highlighter-rouge">import_MessageBoxA</code> is read and finally <code class="language-plaintext highlighter-rouge">riscvm_host_call</code> is executed to call the import on the host side. The return value is truncated as appropriate and returned from the stub.</p><p>The LLVM IR for the generated <code class="language-plaintext highlighter-rouge">riscvm_imports</code> function looks like this:</p><div class="language-llvm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Global string for LoadLibraryA</span>
<span class="vg">@str_USER32.dll</span> = <span class="k">private</span> <span class="k">constant</span> [<span class="m">11</span> x <span class="kt">i8</span>] <span class="s">c"USER32.dll\00"</span>

<span class="k">define</span> <span class="kt">void</span> <span class="vg">@riscvm_imports</span>() {
<span class="nl">entry:</span>
  <span class="nv">%args</span> = <span class="k">alloca</span> ptr, <span class="kt">i32</span> <span class="m">13</span>, <span class="k">align</span> <span class="m">8</span>
  <span class="nv">%kernel32.dll_base</span> = <span class="k">call</span> ptr <span class="vg">@riscvm_resolve_dll</span>(<span class="kt">i32</span> <span class="m">1399641682</span>)
  <span class="nv">%import_LoadLibraryA</span> = <span class="k">call</span> ptr <span class="vg">@riscvm_resolve_import</span>(ptr <span class="nv">%kernel32.dll_base</span>, <span class="kt">i32</span> <span class="m">-550781972</span>)
  <span class="nv">%arg0_ptr</span> = <span class="k">getelementptr</span> ptr, ptr <span class="nv">%args</span>, <span class="kt">i32</span> <span class="m">0</span>
  <span class="k">store</span> ptr <span class="vg">@str_USER32.dll</span>, ptr <span class="nv">%arg0_ptr</span>, <span class="k">align</span> <span class="m">8</span>
  <span class="nv">%USER32.dll_base</span> = <span class="k">call</span> ptr <span class="vg">@riscvm_host_call</span>(ptr <span class="nv">%import_LoadLibraryA</span>, ptr <span class="nv">%args</span>)
  <span class="nv">%import_MessageBoxA</span> = <span class="k">call</span> ptr <span class="vg">@riscvm_resolve_import</span>(ptr <span class="nv">%USER32.dll_base</span>, <span class="kt">i32</span> <span class="m">-50902915</span>)
  <span class="k">store</span> ptr <span class="nv">%import_MessageBoxA</span>, ptr <span class="vg">@import_MessageBoxA</span>, <span class="k">align</span> <span class="m">8</span>
  <span class="k">ret</span> <span class="kt">void</span>
}
</code></pre></div></div><p>The resolving itself uses the <code class="language-plaintext highlighter-rouge">riscvm_resolve_dll</code> and <code class="language-plaintext highlighter-rouge">riscvm_resolve_import</code> functions we discussed in a previous section. The final detail is that <code class="language-plaintext highlighter-rouge">user32.dll</code> is not loaded into every process, so we need to manually call <code class="language-plaintext highlighter-rouge">LoadLibraryA</code> to resolve it.</p><p>Instead of resolving the DLL and import hashes at runtime, they are resolved by the <code class="language-plaintext highlighter-rouge">transpiler</code> at compile-time, which makes things a bit more annoying to analyze for an attacker.</p><h3 id="trade-offs"> <a href="https://secret.club/2023/12/24/riscy-business.html#trade-offs">Trade-offs</a></h3><p>While the retargeting approach works well for simple C++ code that makes use of the Windows API, it currently does not work properly when the C/C++ standard library is used. Getting this to work properly will be difficult, but things like <code class="language-plaintext highlighter-rouge">std::vector</code> can be made to work with some tricks. The limitations are conceptually quite similar to driver development and we believe this is a big improvement over manually recreating types and manual wrappers with <code class="language-plaintext highlighter-rouge">riscvm_host_call</code>.</p><p>An unexplored potential area for bugs is the unverified change to the <code class="language-plaintext highlighter-rouge">DataLayout</code> of the LLVM module. In our tests, we did not observe any differences in structure layouts between rv64 and x64 code, but most likely there are some nasty edge cases that would need to be properly handled.</p><p>If the code written is mainly cross-platform, portable C++ with heavy use of the STL, an alternative design could be to compile most of it with a regular C++ cross-compiler and use the retargeting only for small Windows-specific parts.</p><p>One of the biggest advantages of retargeting a (mostly) regular Windows C++ program is that the payload can be fully developed and tested on Windows itself. Debugging is much more difficult once the code becomes RISC-V and our approach fully decouples the development of the payload from the VM itself.</p><h3 id="crt0"> <a href="https://secret.club/2023/12/24/riscy-business.html#crt0">CRT0</a></h3><p>The final missing piece of the <code class="language-plaintext highlighter-rouge">crt0</code> component is the <code class="language-plaintext highlighter-rouge">_start</code> function that glues everything together:</p><pre><code><span class="k">static</span> <span class="kt">void</span> exit(<span class="kt">int</span> exit_code);
<span class="k">static</span> <span class="kt">void</span> riscvm_relocs();
<span class="kt">void</span>        riscvm_imports() __attribute__((weak));
<span class="k">static</span> <span class="kt">void</span> riscvm_init_arrays();
<span class="k">extern</span> <span class="kt">int</span> __attribute((noinline)) main();

<span class="c1">// NOTE: This function has to be first in the file</span>
<span class="kt">void</span> _start()
{
    riscvm_relocs();
    riscvm_imports();
    riscvm_init_arrays();
    exit(main());
    asm <span class="k">volatile</span>(<span class="s">"ebreak"</span>);
}

<span class="kt">void</span> riscvm_imports()
{
    <span class="c1">// Left empty on purpose</span>
}
</code></pre><p>The <code class="language-plaintext highlighter-rouge">riscvm_imports</code> function is defined as a <code class="language-plaintext highlighter-rouge">weak</code> symbol. This means the implementation provided in <code class="language-plaintext highlighter-rouge">crt0.c</code> can be overwritten by linking to a stronger symbol with the same name. If we generate a <code class="language-plaintext highlighter-rouge">riscvm_imports</code> function in our retargeted bitcode, that implementation will be used and we can be certain we execute before <code class="language-plaintext highlighter-rouge">main</code>!</p><h2 id="example-payload-project"> <a href="https://secret.club/2023/12/24/riscy-business.html#example-payload-project">Example <code class="language-plaintext highlighter-rouge">payload</code> project</a></h2><p>Now that all the necessary tooling has been described, we can put everything together in a real project! In the repository, this is all done in the <a href="https://github.com/thesecretclub/riscy-business/tree/master/payload"><code class="language-plaintext highlighter-rouge">payload</code></a> folder. To make things easy, this is a simple <a href="https://cmkr.build/">cmkr</a> project with a <code class="language-plaintext highlighter-rouge">template</code> to enable the retargeting scripts:</p><div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Reference: https://build-cpp.github.io/cmkr/cmake-toml</span>
<span class="nn">[cmake]</span>
<span class="py">version</span> = <span class="s">"3.19"</span>
<span class="py">cmkr-include</span> = <span class="s">"cmake/cmkr.cmake"</span>

<span class="nn">[project]</span>
<span class="py">name</span> = <span class="s">"payload"</span>
<span class="py">languages</span> = <span class="nn">["CXX"]</span>
<span class="py">cmake-before</span> = <span class="s">"set(CMAKE_CONFIGURATION_TYPES Debug Release)"</span>
<span class="py">include-after</span> = <span class="nn">["cmake/riscvm.cmake"]</span>
<span class="py">msvc-runtime</span> = <span class="s">"static"</span>

<span class="nn">[fetch-content.phnt]</span>
<span class="py">url</span> = <span class="s">"https://github.com/mrexodia/phnt-single-header/releases/download/v1.2-4d1b102f/phnt.zip"</span>

<span class="nn">[template.riscvm]</span>
<span class="py">type</span> = <span class="s">"executable"</span>
<span class="py">add-function</span> = <span class="s">"add_riscvm_executable"</span>

<span class="nn">[target.payload]</span>
<span class="py">type</span> = <span class="s">"riscvm"</span>
<span class="py">sources</span> = [
    <span class="s">"src/main.cpp"</span>,
    <span class="s">"crt/minicrt.c"</span>,
    <span class="s">"crt/minicrt.cpp"</span>,
]
<span class="py">include-directories</span> = [
    <span class="s">"include"</span>,
]
<span class="py">link-libraries</span> = [
    <span class="s">"riscvm-crt0"</span>,
    <span class="s">"phnt::phnt"</span>,
]
<span class="py">compile-features</span> = <span class="nn">["cxx_std_17"]</span>
<span class="py">msvc.link-options</span> = [
    <span class="s">"/INCREMENTAL:NO"</span>,
    <span class="s">"/DEBUG"</span>,
]

</code></pre></div></div><p>In this case, the <code class="language-plaintext highlighter-rouge">add_executable</code> function has been replaced with an equivalent <code class="language-plaintext highlighter-rouge">add_riscvm_executable</code> that creates an additional <code class="language-plaintext highlighter-rouge">payload.bin</code> file that can be consumed by the <code class="language-plaintext highlighter-rouge">riscvm</code> interpreter. The only thing we have to make sure of is to enable <code class="language-plaintext highlighter-rouge">clang-cl</code> when configuring the project:</p><div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake <span class="nt">-B</span> build <span class="nt">-T</span> ClangCL
</code></pre></div></div><p>After this, you can open <code class="language-plaintext highlighter-rouge">build\payload.sln</code> in Visual Studio and develop there as usual. The custom <code class="language-plaintext highlighter-rouge">cmake/riscvm.cmake</code> script does the following:</p><ul><li>Enable LTO</li><li>Add the <code class="language-plaintext highlighter-rouge">-lto-embed-bitcode</code> linker flag</li><li>Locale <code class="language-plaintext highlighter-rouge">clang.exe</code>, <code class="language-plaintext highlighter-rouge">ld.lld.exe</code> and <code class="language-plaintext highlighter-rouge">llvm-objcopy.exe</code></li><li>Compile <code class="language-plaintext highlighter-rouge">crt0.c</code> for the <code class="language-plaintext highlighter-rouge">riscv64</code> architecture</li><li>Create a Python virtual environment with the necessary dependencies</li></ul><p>The <code class="language-plaintext highlighter-rouge">add_riscvm_executable</code> adds a custom target that processes the regular output executable and executes the retargeter and relevant Python scripts to produce the <code class="language-plaintext highlighter-rouge">riscvm</code> artifacts:</p><div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">function</span>(add_riscvm_executable tgt)
    <span class="nb">add_executable</span>(<span class="si">${</span><span class="nv">tgt</span><span class="si">}</span> <span class="si">${</span><span class="nv">ARGN</span><span class="si">}</span>)
    <span class="nb">if</span>(MSVC)
        <span class="nb">target_compile_definitions</span>(<span class="si">${</span><span class="nv">tgt</span><span class="si">}</span> PRIVATE _NO_CRT_STDIO_INLINE)
        <span class="nb">target_compile_options</span>(<span class="si">${</span><span class="nv">tgt</span><span class="si">}</span> PRIVATE /GS- /Zc:threadSafeInit-)
    <span class="nb">endif</span>()
    <span class="nb">set</span>(BC_BASE <span class="s2">"$&lt;TARGET_FILE_DIR:</span><span class="si">${</span><span class="nv">tgt</span><span class="si">}</span><span class="s2">&gt;/$&lt;TARGET_FILE_BASE_NAME:</span><span class="si">${</span><span class="nv">tgt</span><span class="si">}</span><span class="s2">&gt;"</span>)
    <span class="nb">add_custom_command</span>(TARGET <span class="si">${</span><span class="nv">tgt</span><span class="si">}</span>
        POST_BUILD
        USES_TERMINAL
        COMMENT <span class="s2">"Extracting and transpiling bitcode..."</span>
        COMMAND <span class="s2">"</span><span class="si">${</span><span class="nv">Python3_EXECUTABLE</span><span class="si">}</span><span class="s2">"</span> <span class="s2">"</span><span class="si">${</span><span class="nv">RISCVM_DIR</span><span class="si">}</span><span class="s2">/extract-bc.py"</span> <span class="s2">"$&lt;TARGET_FILE:</span><span class="si">${</span><span class="nv">tgt</span><span class="si">}</span><span class="s2">&gt;"</span> -o <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.bc"</span> --importmap <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.imports"</span>
        COMMAND <span class="s2">"</span><span class="si">${</span><span class="nv">TRANSPILER</span><span class="si">}</span><span class="s2">"</span> -input <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.bc"</span> -importmap <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.imports"</span> -output <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.rv64.bc"</span>
        COMMAND <span class="s2">"</span><span class="si">${</span><span class="nv">CLANG_EXECUTABLE</span><span class="si">}</span><span class="s2">"</span> <span class="si">${</span><span class="nv">RV64_FLAGS</span><span class="si">}</span> -c <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.rv64.bc"</span> -o <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.rv64.o"</span>
        COMMAND <span class="s2">"</span><span class="si">${</span><span class="nv">LLD_EXECUTABLE</span><span class="si">}</span><span class="s2">"</span> -o <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.elf"</span> --oformat=elf -emit-relocs -T <span class="s2">"</span><span class="si">${</span><span class="nv">RISCVM_DIR</span><span class="si">}</span><span class="s2">/lib/linker.ld"</span> <span class="s2">"--Map=</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.map"</span> <span class="s2">"</span><span class="si">${</span><span class="nv">CRT0_OBJ</span><span class="si">}</span><span class="s2">"</span> <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.rv64.o"</span>
        COMMAND <span class="s2">"</span><span class="si">${</span><span class="nv">OBJCOPY_EXECUTABLE</span><span class="si">}</span><span class="s2">"</span> -O binary <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.elf"</span> <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.pre.bin"</span>
        COMMAND <span class="s2">"</span><span class="si">${</span><span class="nv">Python3_EXECUTABLE</span><span class="si">}</span><span class="s2">"</span> <span class="s2">"</span><span class="si">${</span><span class="nv">RISCVM_DIR</span><span class="si">}</span><span class="s2">/relocs.py"</span> <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.elf"</span> --binary <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.pre.bin"</span> --output <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.bin"</span>
        COMMAND <span class="s2">"</span><span class="si">${</span><span class="nv">Python3_EXECUTABLE</span><span class="si">}</span><span class="s2">"</span> <span class="s2">"</span><span class="si">${</span><span class="nv">RISCVM_DIR</span><span class="si">}</span><span class="s2">/encrypt.py"</span> --encrypt --shuffle --map <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.map"</span> --shuffle-map <span class="s2">"</span><span class="si">${</span><span class="nv">RISCVM_DIR</span><span class="si">}</span><span class="s2">/shuffled_opcodes.json"</span> --opcodes-map <span class="s2">"</span><span class="si">${</span><span class="nv">RISCVM_DIR</span><span class="si">}</span><span class="s2">/opcodes.json"</span> --output <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.enc.bin"</span> <span class="s2">"</span><span class="si">${</span><span class="nv">BC_BASE</span><span class="si">}</span><span class="s2">.bin"</span>
        VERBATIM
    )
<span class="nb">endfunction</span>()
</code></pre></div></div><p>While all of this is quite complex, we did our best to make it as transparent to the end-user as possible. After enabling Visual Studio’s LLVM support in the installer, you can start developing VM payloads in a few minutes. You can get a precompiled <code class="language-plaintext highlighter-rouge">transpiler</code> binary from the <a href="https://github.com/thesecretclub/riscy-business/releases/tag/transpiler-v0.3">releases</a>.</p><h2 id="debugging-in-riscvm"> <a href="https://secret.club/2023/12/24/riscy-business.html#debugging-in-riscvm">Debugging in <code class="language-plaintext highlighter-rouge">riscvm</code></a></h2><p>When debugging the payload, it is easiest to load <code class="language-plaintext highlighter-rouge">payload.elf</code> in Ghidra to see the instructions. Additionally, the debug builds of the <code class="language-plaintext highlighter-rouge">riscvm</code> executable have a <code class="language-plaintext highlighter-rouge">--trace</code> flag to enable instruction tracing. The execution of <code class="language-plaintext highlighter-rouge">main</code> in the <code class="language-plaintext highlighter-rouge">MessageBoxA</code> example looks something like this (labels added manually for clarity):</p><pre><code class="language-asm">                      main:
0x000000014000d3a4:   addi     sp, sp, -0x10 = 0x14002cfd0
0x000000014000d3a8:   sd       ra, 0x8(sp) = 0x14000d018
0x000000014000d3ac:   auipc    a0, 0x0 = 0x14000d4e4
0x000000014000d3b0:   addi     a1, a0, 0xd6 = 0x14000d482
0x000000014000d3b4:   auipc    a0, 0x0 = 0x14000d3ac
0x000000014000d3b8:   addi     a2, a0, 0xc7 = 0x14000d47b
0x000000014000d3bc:   addi     a0, zero, 0x0 = 0x0
0x000000014000d3c0:   addi     a3, zero, 0x0 = 0x0
0x000000014000d3c4:   jal      ra, 0x14 -&gt; 0x14000d3d8
                        MessageBoxA:
0x000000014000d3d8:     addi     sp, sp, -0x70 = 0x14002cf60
0x000000014000d3dc:     sd       ra, 0x68(sp) = 0x14000d3c8
0x000000014000d3e0:     slli     a3, a3, 0x0 = 0x0
0x000000014000d3e4:     srli     a4, a3, 0x0 = 0x0
0x000000014000d3e8:     auipc    a3, 0x0 = 0x0
0x000000014000d3ec:     ld       a3, 0x108(a3=&gt;0x14000d4f0) = 0x7ffb3c23a000
0x000000014000d3f0:     sd       a0, 0x0(sp) = 0x0
0x000000014000d3f4:     sd       a1, 0x8(sp) = 0x14000d482
0x000000014000d3f8:     sd       a2, 0x10(sp) = 0x14000d47b
0x000000014000d3fc:     sd       a4, 0x18(sp) = 0x0
0x000000014000d400:     addi     a1, sp, 0x0 = 0x14002cf60
0x000000014000d404:     addi     a0, a3, 0x0 = 0x7ffb3c23a000
0x000000014000d408:     jal      ra, -0x3cc -&gt; 0x14000d03c
                          riscvm_host_call:
0x000000014000d03c:       lui      a2, 0x5 = 0x14000d47b
0x000000014000d040:       addiw    a7, a2, -0x1e0 = 0x4e20
0x000000014000d044:       ecall    0x4e20
0x000000014000d048:       ret      (0x14000d40c)
0x000000014000d40c:     ld       ra, 0x68(sp=&gt;0x14002cfc8) = 0x14000d3c8
0x000000014000d410:     addi     sp, sp, 0x70 = 0x14002cfd0
0x000000014000d414:     ret      (0x14000d3c8)
0x000000014000d3c8:   addi     a0, zero, 0x0 = 0x0
0x000000014000d3cc:   ld       ra, 0x8(sp=&gt;0x14002cfd8) = 0x14000d018
0x000000014000d3d0:   addi     sp, sp, 0x10 = 0x14002cfe0
0x000000014000d3d4:   ret      (0x14000d018)
0x000000014000d018: jal      ra, 0x14 -&gt; 0x14000d02c
                      exit:
0x000000014000d02c:   lui      a1, 0x2 = 0x14002cf60
0x000000014000d030:   addiw    a7, a1, 0x710 = 0x2710
0x000000014000d034:   ecall    0x2710
</code></pre><p>The tracing also uses the enums for the opcodes, so it works with shuffled and encrypted payloads as well.</p><h2 id="outro"> <a href="https://secret.club/2023/12/24/riscy-business.html#outro">Outro</a></h2><p>Hopefully this article has been an interesting read for you. We tried to walk you through the process in the same order we developed it in, but you can always refer to the <a href="https://github.com/thesecretclub/riscy-business">riscy-business</a> GitHub repository and try things out for yourself if you got confused along the way. If you have any ideas for improvements, or would like to discuss, you are always welcome in our <a href="https://discord.gg/BT764JJDhe">Discord server</a>!</p><p>We would like to thank the following people for proofreading and discussing the design and implementation with us (alphabetical order):</p><ul><li>Brit</li><li><a href="https://twitter.com/herrcore">herrcore</a></li><li><a href="https://github.com/JustasMasiulis">JustMagic</a></li><li><a href="https://github.com/ctfRenegade">Renegade</a></li><li><a href="https://nullpt.rs/">veritas</a></li></ul><p>Additionally, we highly appreciate the open source projects that we built this project on! If you use this project, consider giving back your improvements to the community as well.</p><p>Merry Christmas!</p></main></article>

</body></html>