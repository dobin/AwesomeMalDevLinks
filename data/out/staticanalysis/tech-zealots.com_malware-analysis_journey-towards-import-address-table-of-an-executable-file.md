# https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/

![NordVPN](https://tech-zealots.com/storage/2025/10/nord-logo-horizontal-white@1x.png.webp)

Up to **77% Off** NordVPN + **3 Extra Months**

[Get Deal](https://go.tech-zealots.com/nordvpn)

[MMalware Analysis](https://tech-zealots.com/category/malware-analysis/)

# Exciting Journey Towards Import Address Table (IAT) of an Executable

- by[Satyajit Daulaguphu](https://tech-zealots.com/writer/satyadau/ "View all posts by Satyajit Daulaguphu")
- August 27, 2019

[![Import Address Table of an Executable File](https://tech-zealots.com/storage/2019/08/Import-Address-Table-of-an-Executable-File-800x450.png.webp)](https://tech-zealots.com/storage/2019/08/Import-Address-Table-of-an-Executable-File.png)

0

Shares

[0](https://www.facebook.com/sharer.php?u=https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/)

[0](https://x.com/share?&text=Exciting%20Journey%20Towards%20Import%20Address%20Table%20%28IAT%29%20of%20an%20Executable&via=samyCod3r&url=https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/)

[0](https://www.linkedin.com/shareArticle?mini=true&url=https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/)

[0](https://t.me/share/url?&text=Exciting%20Journey%20Towards%20Import%20Address%20Table%20%28IAT%29%20of%20an%20Executable&url=https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/)

[0](https://www.reddit.com/submit?url=https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/)

Earlier, I wrote a post on **[Understanding PE Structure – The Layman’s Way](https://tech-zealots.com/malware-analysis/pe-portable-executable-structure-malware-analysis-part-2/)** and this one is a continuation of that post. I highly recommend my readers to go through that post, where I have gone detailed into the PE file format, before jumping onto this article.

Since the earlier post was already too long and I hadn’t gone into much detail about the Data Directory structure of PE, I decided to continue from where I left off in this post. And thought to go in deep and provide you with a better understanding of an Import Address Table and its important concepts.

## **What’s the Context**

As soon as the Windows loader loads an executable it does certain things in the background. First, it reads the files of a PE structure and loads an executable image into the memory. The other thing it does is to scan the Import Address Table (IAT) of an executable to locate the DLLs and functions that the executable uses and load all these DLLs and map them into the process address space.

This is done for the operating system to start the executable file successfully. But how this DLL loading is done and function is imported? We are going to see this in this post.

Within any executable file, we would see an array of data structures which is one per imported DLL. Each of these structures gives the name of the imported DLL and points to an array of function pointers. Import Address Table (IAT) is an array of these function pointers where the address of the imported function is written by the Windows loader.

Here, we will discuss only the important field and structures of the PE File format which is relevant to this topic as I don’t want this post to be too lengthy to be exhaustive for you.

## **Let’s Begin From Where We Left Off**

In the earlier post, I have not gone into much detail about Data Directories which is just another array of structures called **IMAGE\_DATA\_DIRECTORY**.

Just to give an overview of Data Directories, it is the last entry of the Optional Header and it is an array of several other structures. This is one of the very important data structures because this is what holds the pointer to other data structures.

This holds pointers to what functions it exports, it holds pointers to what functions it imports, pointers to where the debug information is to be found, where the digital certificate is, where the relocation information is, where the resources are, etc… This is like a big map that is pointing to all other data structures that we will be looking at later.

So, the last field of the **IMAGE\_OPTIONAL\_HEADER** structure is the so-called **IMAGE\_DATA\_DIRECTORY** where we locate the Import Address Table (IAT). The data directory field indicates where to find the other important components of executable information in the file. Below are the few data structures showing only the important ones.

```
// <winnt.h>
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
// Optional header format.
typedef struct _IMAGE_OPTIONAL_HEADER
{
    ...

    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
// Directory Entries
#define IMAGE_DIRECTORY_ENTRY_EXPORT     0 // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT     1 // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE   2 // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC  5 // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG      6 // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_TLS        9 // TLS Directory
```

Since our total focus here is on looking up the Imports of an executable file or to say what functions it has imported from other modules, we will take up the 2nd entry of the _DataDirectory_ array which represents the **Import D** **irectory**.

```
// Import Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT     1
```

Each data directory is a data structure defined as an IMAGE\_DATA\_DIRECTORY. And although the data directory entries are the same, each specific directory type is unique. The **IMAGE\_DATA\_DIRECTORY** structure is defined below as:

```
typedef struct _IMAGE_DATA_DIRECTORY {

   DWORD VirtualAddress;     // RVA of data
   DWORD Size;               // Size of the data in bytes

}IMAGE_OPTIONAL_HEADERS32, *PIMAGE_OPTIONAL_HEADERS32;
```

Each data directory entry specifies a relative virtual address and size of the directory. The _VirtualAddress_ member in this array element describes the location of the import directory which in turn is also an array. This array consists of structures of type **IMAGE\_IMPORT\_DESCRIPTOR.** One structure of this type is assigned for each DLL that is imported by the module.

The Import directory entry of the import table takes us to the position of the import table inside the file image and is a container of several important data structures like _Characteristics_, _OriginalFirstThunk, Name & FirstThunk, and these are one per DLL. So, every single DLL will have its_ **IMAGE\_IMPORT\_DESCRIPTOR** table. The **IMAGE\_IMPORT\_DESCRIPTOR** structure is defined in the WinNT.h file as below:

```
typedef struct _IMAGE_IMPORT_DESCRIPTOR {

    union {
        DWORD Characteristics;
        DWORD OriginalFirstThunk;   // RVA of ILT
    };

    ...
    ...
    DWORD Name;       // RVA of imported DLL name
    DWORD FirstThunk; // RVA to IAT

}IMAGE_IMPORT_DESCRIPTOR;
```

- **OriginalFirstThunk (OFT)**

It holds the RVA of the Import Lookup Table (ILT) or the Import Name Table (INT). The ILT field contains information about how the import is to be processed either by ordinal or by the name.

- **Name**

This is just the RVA which will point at the specific name of the module from where the imports are taken. E.g. hal.dll, ntdll.dll, etc.

- **FirstThunk (FT)**

This holds the RVA of the _Import Address Table (IAT)_. The structure and content of the import address table are identical to those of the Import Lookup Table until the file is bound.

On-disk both _OriginalFirstThunk (INT)_ points to the same data structures i.e. **IMAGE\_THUNK\_DATA**, like that of the _FirstThunk (IAT)_ but in memory, it flips around and points out to the other DLLs. Refer to the images below:

![Import address table](https://tech-zealots.com/storage/2019/08/Imports_on_Disk.png)Import Data Structures on disk

![Imports in Memory](https://tech-zealots.com/storage/2019/08/Imports_in_Memory.png)Import Data Structures in memory after imports resolved

For each function that is used by the executable module as an import, we will encounter an **IMAGE\_THUNK\_DATA** structure. The **IMAGE\_THUNK\_DATA** structure is an array of DWORDs and each DWORD represent an imported function and is defined in the WinNT.H header file as below:

```
typedef struct _IMAGE_THUNK_DATA {
     union {
         ...
         PDWORD Function;
         DWORD Ordinal;
         PIMAGE_IMPORT_BY_NAME AddressOfData;
     }u1;
}IMAGE_THUNK_DATA32;
```

The **IMAGE\_THUNK\_DATA** structures within the IAT serve two purposes. In the executable file, they contain either the ordinal of the imported API or an RVA to an **IMAGE\_IMPORT\_BY\_NAME** structure.

```
typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    BYTE    Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
```

The **IMAGE\_IMPORT\_BY\_NAME** structure is just a WORD, followed by a string naming the imported API. The WORD value is a “Hint” to the OS loader as to what the ordinal of the imported API may be. When the OS loader loads the executable in the memory, it overwrites each IAT entry with the actual address of the imported function.

Now, to know whether the function is imported by an ordinal or by its name, one must check the high bit of the **IMAGE\_THUNK\_DATA** value:

- If the high bit is set, the bottom 31 bits (or 63 bits for a 64-bit executable) is treated as an ordinal value. The function is therefore imported by its ordinal and there would be no name available.

- If the high-bit is not set, the whole DWORD is an RVA to an IMAGE\_IMPORT\_BY\_NAME structure.

## Frequently Asked Questions ( **FAQ**)

**How does the Windows loader utilize the IAT during program execution?**

On disk, the IAT (and the identical ILT/INT) contains references (names or ordinals) to the functions to be imported. When the program is loaded, the Windows loader resolves these references, finds the actual memory addresses of the functions in the loaded DLLs, and writes these addresses into the IAT. The program then uses these addresses in the IAT to make calls to the external functions. This process is central to how import address table works in PE file.

**What are the key differences between the IAT and the ILT (or INT)?**

The Import Lookup Table (ILT) or Import Name Table (INT), pointed to by `OriginalFirstThunk`, contains the names or ordinals of the functions to be imported and generally remains unchanged by the loader. The Import Address Table (IAT), pointed to by `FirstThunk`, is initially identical on disk but is overwritten by the loader with the actual resolved memory addresses of these functions. INT is another array that is identical to the IAT and is also an array of **IMAGE\_THUNK\_DATA** structures. As both point to the same data structure, the main difference between the IAT and INT is that INT isn’t overwritten by the Windows loader when the executable is loaded into the memory but IAT entries get overwritten with the actual address of the imported function.

Also, INT is not required for an executable to load but IAT is one of the essential components for an executable to load. Without this, it may fail to load.

This addresses the common query about the IAT vs INT PE file difference.

**Why is understanding the IAT crucial for malware analysts?**

The IAT provides significant clues about a program’s capabilities by listing its imported functions. Malware analysts use it to quickly assess potential malicious behavior (e.g., network activity, file manipulation, registry changes). Anomalies in the IAT, such as very few imports or suspicious function calls, can indicate packing, obfuscation, or specific malware techniques like IAT hooking. This is key to understanding PE file imports for malware.

**What is IAT hooking and how is it used by malware?**

IAT hooking is a technique where malware (or other software) modifies the entries in a process’s IAT at runtime. Instead of pointing to the legitimate API function, the IAT entry is changed to point to a malicious (hook) function. This allows malware to intercept API calls, inject code, steal data, or bypass security measures without altering the original program’s code on disk. This is a core concept in **malware analysis IAT hooking**.

**What is the primary function of the Import Address Table (IAT)?**

The IAT is a lookup table within a PE file that, once populated by the Windows loader, holds the memory addresses of functions imported from external Dynamic Link Libraries (DLLs). This allows the executable to call these external functions during runtime.

## **Wrap-up**

In the next article, we will try to look inside the Import Address Table (IAT) with the help of WinDbg or some other tools but it will be more practical as we are already done with the theory.

## **References:**

- [https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-address-table](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-address-table)

- ##### Tags:

- [Import Address Table](https://tech-zealots.com/tag/import-address-table/)
- [PE Header](https://tech-zealots.com/tag/pe-header/)
- [PE Imports](https://tech-zealots.com/tag/pe-imports/)

0 Shares:

[Share0](https://www.facebook.com/sharer.php?u=https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/)

[Tweet0](https://x.com/share?&text=Exciting%20Journey%20Towards%20Import%20Address%20Table%20%28IAT%29%20of%20an%20Executable&via=samyCod3r&url=https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/)

[Share0](https://www.linkedin.com/shareArticle?mini=true&url=https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/)

[Share0](https://t.me/share/url?&text=Exciting%20Journey%20Towards%20Import%20Address%20Table%20%28IAT%29%20of%20an%20Executable&url=https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/)

[Share0](https://www.reddit.com/submit?url=https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/)

[![](https://tech-zealots.com/core/cache/ls/avatar/c14d6f6a8c954030d98e686b8de80570.jpg?rnd=31399)](https://tech-zealots.com/writer/satyadau/)

##### [Satyajit Daulaguphu](https://tech-zealots.com/writer/satyadau/)

Satyajit Daulaguphu is a Security Researcher at Trellix (Formerly FireEye). He focuses mainly on threat detection, malware research and rules creation.

##### Leave a Reply [Cancel reply](https://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/\#respond)

Your email address will not be published.Required fields are marked \*

Comment \*

Name \*

Email \*

Website

Save my name, email, and website in this browser for the next time I comment.

Δ

This site uses Akismet to reduce spam. [Learn how your comment data is processed.](https://akismet.com/privacy/)

View Comments (0)

[— Previous article\\
\\
**DeObfuscating Emotet's Malicious VBA Macro Like a Pro!!**](https://tech-zealots.com/threat-lab/deobfuscating-emotet-vba-macro-like-a-pro/) [Next article — \\
\\
**Understanding Concepts of Virtual Address (VA), Relative Virtual Address (RVA) and File Offsets**](https://tech-zealots.com/malware-analysis/understanding-concepts-of-va-rva-and-offset/)

##### You May Also Like

[MMalware Analysis](https://tech-zealots.com/category/malware-analysis/)

![Javascript code obfuscation techniques](https://tech-zealots.com/storage/2018/04/JavaScript-Code-Obfuscation-Techniques-380x220.png.webp)

Read More

JavaScript code obfuscation techniques play a key role in delivering a malicious payload when an attackers want to…

[MMalware Analysis](https://tech-zealots.com/category/malware-analysis/)

![Understanding Concepts of VA, RVA and File Offsets](https://tech-zealots.com/storage/2019/10/Understanding-Concepts-of-VA-RVA-and-File-Offsets-380x220.png.webp)

Read More

Before we proceed to the concept of PE File Format, which describes the internal structure of all Windows…