# https://back.engineering/blog/06/05/2022/

<!DOCTYPE html><html itemscope="" class="dark" lang="en-us" itemtype="http://schema.org/WebPage"><body><div class="search-modal" aria-hidden="true" style="--color-primary:#121212"><div data-target="close-search-modal" class="search-modal-overlay"></div><div class="search-wrapper" data-image="true" data-description="true" data-tags="true" data-categories="true"><div class="search-wrapper-header"><label for="search-modal-input" style="margin-top:-1px"><span class="sr-only">search icon</span>
<svg viewBox="0 0 512 512" height="18" width="18" class="search-icon" data-type="search"><path fill="currentColor" d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8.0 45.3s-32.8 12.5-45.3.0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9.0 208S93.1.0 208 0 416 93.1 416 208zM208 352a144 144 0 100-288 144 144 0 100 288z"></path></svg>
<svg viewBox="0 0 512 512" height="18" width="18" class="search-reset" data-type="reset"><path fill="currentColor" d="M256 512A256 256 0 10256 0a256 256 0 100 512zM175 175c9.4-9.4 24.6-9.4 33.9.0l47 47 47-47c9.4-9.4 24.6-9.4 33.9.0s9.4 24.6.0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6.0 33.9s-24.6 9.4-33.9.0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9.0s-9.4-24.6.0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6.0-33.9z"></path></svg>
</label><input id="search-modal-input" type="text" data-search-input="" autocomplete="off" aria-label="Search" placeholder="Search Post..."></div><div class="search-wrapper-body"><div class="search-result" data-search-result=""></div><span class="search-result-empty"></span></div><div class="search-wrapper-footer"><span><kbd><svg width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M3.204 11h9.592L8 5.519 3.204 11zm-.753-.659 4.796-5.48a1 1 0 011.506.0l4.796 5.48c.566.647.106 1.659-.753 1.659H3.204a1 1 0 01-.753-1.659z"></path></svg>
</kbd><kbd><svg width="14" height="14" fill="currentColor" style="margin-top:1px" viewBox="0 0 16 16"><path d="M3.204 5h9.592L8 10.481 3.204 5zm-.753.659 4.796 5.48a1 1 0 001.506.0l4.796-5.48c.566-.647.106-1.659-.753-1.659H3.204a1 1 0 00-.753 1.659z"></path></svg>
</kbd>to navigate
</span><span><kbd><svg width="12" height="12" fill="currentColor" style="display:inline-block" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M14.5 1.5a.5.5.0 01.5.5v4.8a2.5 2.5.0 01-2.5 2.5H2.707l3.347 3.346a.5.5.0 01-.708.708l-4.2-4.2a.5.5.0 010-.708l4-4a.5.5.0 11.708.708L2.707 8.3H12.5A1.5 1.5.0 0014 6.8V2a.5.5.0 01.5-.5z"></path></svg>
</kbd>to select
</span><span class="search-result-info"></span>
<span data-target="close-search-modal"><kbd>ESC</kbd> to close</span></div></div></div><main><section class="section pt-7"><div class="container"><div class="row justify-center"><article class="lg:col-10"><h1 class="h2 mb-4">Theodosius - Jit linker, Symbol Mapper, and Obfuscator</h1><ul class="mb-4"><li class="mr-4 inline-block"><a href="https://back.engineering/authors/idontcode/"><i class="fa-regular fa-circle-user mr-2"></i>IDontCode</a></li><li class="mr-4 inline-block"><i class="fa-regular fa-folder mr-2"></i>
<a href="https://back.engineering/categories/windows/">Windows</a></li><li class="mr-4 inline-block"><i class="fa-regular fa-clock mr-2"></i>
May 6, 2022</li></ul><div class="content mb-10"><details open="" class="table-of-content blog"><summary>Table of Contents</summary></details><p>Repository: <a href="https://git.back.engineering/_xeroxz/Theodosius/" target="_blank">https://git.back.engineering/_xeroxz/Theodosius/</a><br>Doxygen: <a href="https://docs.back.engineering/theo/" target="_blank">https://docs.back.engineering/theo/</a></p><h2 id="table-of-contents">Table Of Contents</h2><ul><li><a href="https://back.engineering/blog/06/05/2022/#credit">Credits</a></li><li><a href="https://back.engineering/blog/06/05/2022/#intro">Introduction and Preamble</a></li><li><a href="https://back.engineering/blog/06/05/2022/#llvm-ir">LLVM IR Level Obfuscation</a></li><li><a href="https://back.engineering/blog/06/05/2022/#bin2bin">Bin2Bin Obfuscation</a></li><li><a href="https://back.engineering/blog/06/05/2022/#linker-level">Linker Level Obfuscation</a></li><li><a href="https://back.engineering/blog/06/05/2022/#Brief-Overview-Of-Theodosius">Brief Overview Of Theodosius</a><ul><li><a href="https://back.engineering/blog/06/05/2022/#Decomposition-Module">Decomposition Module</a></li><li><a href="https://back.engineering/blog/06/05/2022/#Obfuscation-Module">Obfuscation Module</a></li><li><a href="https://back.engineering/blog/06/05/2022/#Recomposition-Module">Recomposition Module</a></li></ul></li><li><a href="https://back.engineering/blog/06/05/2022/#Theodosius-Internals">Theodosius Internals</a><ul><li><a href="https://back.engineering/blog/06/05/2022/#Recursive-Symbol-Dependency-Check">Recursive Symbol Dependency Check</a></li><li><a href="https://back.engineering/blog/06/05/2022/#Theodosius-Internal-Passes">Theodosius Internal Passes</a><ul><li><a href="https://back.engineering/blog/06/05/2022/#next_inst_pass_t">next_inst_pass_t</a></li><li><a href="https://back.engineering/blog/06/05/2022/#jcc_rewrite_pass">jcc_rewrite_pass</a></li><li><a href="https://back.engineering/blog/06/05/2022/#reloc_transform_pass">reloc_transform_pass</a></li></ul></li></ul></li><li><a href="https://back.engineering/blog/06/05/2022/#Theodosius-Example">Theodosius Example</a></li><li><a href="https://back.engineering/blog/06/05/2022/#Creating-A-Pass">Creating A Pass</a></li><li><a href="https://back.engineering/blog/06/05/2022/#Conclusion">Closing Words and Conclusion</a></li></ul><h2 id="credit">Credits and Contributions</h2><ul><li><p><a href="https://twitter.com/0xdt0" target="_blank">David Torok</a>, reviewing the post and helping me better structure my thoughts.</p></li><li><p><a href="https://twitter.com/DreselCody" target="_blank">Cody Dresel</a>, reviewing post, feedback to create pros/cons list(s).</p></li><li><p><a href="https://twitter.com/mrexodia" target="_blank">Duncan Ogilvie (mrexodia)</a>, <a href="https://cmkr.build/" target="_blank">cmkr</a> related help and input.</p></li></ul><h2 id="intro">Introduction and Preamble</h2><p>Existing software protection frameworks typically operate at a small range of compilation levels. The highest level of obfuscation typically operates upon source code directly (source2source), the second highest level is LLVM IR (via optimization passes), and the third and final most common is upon the native binary image (bin2bin).</p><p>In this post I will present a framework that works to obfuscate code at the linker level. I will talk about the implications of obfuscating code at such a level and why it’s not really applicable for a commercial software product. I will also discuss the compilation process of C/C++ code to aid in the explanation of where this framework fits.</p><p>There is lots of fun to be had at the linker level as you have full control over the placement of symbols, and said code can have the pleasure of being obfuscated by all other levels detailed above (source2source, IR level, and bin2bin). The linker level also acts as a great stepping stone to bin2bin type obfuscation as much of the file formatting is the same. I highly recommend writing obfuscation at the linker level prior to directly writing anything for native binary images.</p><p>Lastly, I would like to state that this project is not even close to a competitor to any existing public code obfuscation framework. Infact, I would much rather point you to existing LLVM IR obfuscation than my own project as it is not capable of capturing semantics, but rather, it excels in native instruction substitution, native instruction virtualization (will be demonstrated in a later post), and symbol placement (mixing code and data). Again, It would be illogical for me to market or present this framework as anything other than a proof of concept, and a fun toy. In addition I want to truly drive home the point that I am not releasing a code obfuscator, but a code obfuscation framework. The code I am releasing is only limited by your imagination, it is not a rigid final product, but an open book, clearly documented. I find it important to make this clear, in text, so that my intent or implications are not falsely interpreted. With that out of the way, I humbly present an obfuscation framework of which operates at the linker level.</p><p><em>In sum, and contextual points for the rest of the post:</em></p><ul><li>Theodosius is an obfuscation framework which operates at the linker level (operates upon COFF and lib files). It is not a software protector itself, just a framework.</li><li>Theodosius does not capture the semantics of the code, nor does it generate control flow graphs, basic blocks, or other higher level abstractions of native routines. This is out of the scope of the framework itself, but could be implemented in obfuscation passes.</li><li>Theodosius intends to map code and data directly into virtual memory rather than generating a new COFF file. However, generation of a new COFF file is possible. The code responsible for the creation of a new COFF file is out of the scope of the framework itself and should be implemented by whomever inherits Theodosius.</li><li>Theodosius is intended to only work with MSVC compatible COFF files.</li><li>Theodosius is intended to only work with 64bit x86 instructions.</li><li>Theodosius has no concept or support for SEH, CET, jump tables, or thread local storage. Refer to the readme as to how to generate code that will work with Theodosius.</li></ul><h2 id="llvm-ir">LLVM IR Level Obfuscation</h2><p>When considering an obfuscation that utilises LLVM IR, typically this means you must recompile your project using clang in addition to the obfuscation pass (<a href="https://github.com/obfuscator-llvm/obfuscator" target="_blank">LLVM-Obfuscator</a>). This can imply restrictions upon the end consumer such that they may consider other options, however the inverse is true, a native instruction/file format agnostic obfuscation method could provide a “one size fits all” solution. A good application for such a thing could be <a href="https://developer.android.com/ndk/guides/abis" target="_blank">android native binaries</a> (shared objects) which can be of arm, arm64, and even x86 (some phones run x86). This, however, is not the only application of LLVM IR for obfuscation.</p><div style="text-align:center"><img src="https://back.engineering/llvm-ir-level-obfuscation.drawio.svg" alt="LLVM IR Level Obfuscation" style="max-width:900px;width:100%" width="900" height="150"></div><p>Another method to get at obfuscation via LLVM IR would be to use <a href="https://github.com/lifting-bits/mcsema" target="_blank">mcsema</a> on a completely compiled binary. This would allow you to lift an entire binary to LLVM IR where you could then run obfuscation passes upon it prior to recompilation. This would remove the need to recompile source code to achieve obfuscation, therefore less integration required. This however raises questions in terms of the ability of <a href="https://github.com/lifting-bits/mcsema" target="_blank">mcsema</a> to semantically represent x86 in terms of LLVM IR instructions. In addition, how well it can preserve things such as SEH which is more of an operating system/binary level type concept. After all, LLVM IR must respect its obligations to being agnostic.</p><p><em>Pros of obfuscating code at the LLVM IR level</em></p><ul><li>Agnostic of native instruction set and therefore offering obfuscation for any target that LLVM can compile too.</li><li>The IR represents the semantics of the underlying code and therefore more intelligent and complex obfuscation can be created. Such is the case for MBA and CFG.</li><li>Code obfuscated by LLVM IR can be further obfuscated by bin2bin and linker level obfuscation.</li></ul><p><em>Cons of obfuscating code at the LLVM IR level</em></p><ul><li>Code (most likely) will need to be recompiled with clang in addition to the obfuscation pass.</li><li>Integration into the compilation process can cause a headache for the project manager as the project will have to tailor its compiler to clang.</li></ul><h2 id="bin2bin">Bin2Bin Obfuscation</h2><p>Binary to binary obfuscation takes away the annoyance and complications of incorporating anything into the compilation process of your project. However bin2bin is not trivial at all and usually is done incorrectly. In addition, bin2bin obfuscators are typically “dumb” in the sense that they are unable to capture the semantics of a function. Consider <a href="https://vmpsoft.com/" target="_blank">VMProtect</a>, which is bin2bin, the three main obfuscation techniques offered by said product are: <a href="https://blog.back.engineering/17/05/2021/#deadstore-obfuscation-example" target="_blank">deadstore obfuscation</a>, <a href="https://blog.back.engineering/17/05/2021/#opaque-branching" target="_blank">opaque branching obfuscation</a>, and most significantly, <a href="https://blog.back.engineering/17/05/2021/#overview-virtual-machine" target="_blank">native instruction virtualization</a> (with MBA to further obscure the arithmetic done inside of the virtual machine). All three of these obfuscation techniques do not require knowledge of the function’s semantics. In comparison, <a href="https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening" target="_blank">OLLVM’s control flow flattening</a> requires semantic awareness of a function to rewrite its control flow (branches) into a while loop with a switch case.</p><center><img src="https://back.engineering/bin2bin-level-obfuscation.drawio.svg" width="300" height="150"></center><p>Additionally, bin2bin requires intimate knowledge of the native file format and the native instruction set. Moreover, knowledge of processor security features which the operating system may utilise must be taken into consideration. Such is the case for <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/technical-look-control-flow-enforcement-technology.html" target="_blank">CET</a> (for x86 processors) which aims to make ROP exploits a thing of the past by utilising a shadow stack to keep track of return addresses. This places restrictions on how software protectors can obfuscate control flow in terms of the RET instruction. As we speak <a href="https://vmpsoft.com/" target="_blank">VMProtect</a> is not <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/technical-look-control-flow-enforcement-technology.html" target="_blank">CET</a> compatible, for there <a href="https://blog.back.engineering/17/05/2021/#vm_exit" target="_blank">VMEXIT handler</a> essentially uses the RET instruction as a substitute for the native <a href="https://www.felixcloutier.com/x86/call" target="_blank">CALL</a> instruction.</p><pre tabindex="0"><code>vmexit_handler+0x0:  48 89 ec                   mov    rsp,rbp
vmexit_handler+0x3:  58                         pop    rax
vmexit_handler+0x4:  5b                         pop    rbx
vmexit_handler+0x5:  41 5f                      pop    r15
vmexit_handler+0x7:  5b                         pop    rbx
vmexit_handler+0x8:  58                         pop    rax
vmexit_handler+0x9:  41 5b                      pop    r11
vmexit_handler+0xb:  5f                         pop    rdi
vmexit_handler+0xc:  41 58                      pop    r8
vmexit_handler+0xe:  5a                         pop    rdx
vmexit_handler+0xf:  41 59                      pop    r9
vmexit_handler+0x11: 41 5a                      pop    r10
vmexit_handler+0x13: 41 5c                      pop    r12
vmexit_handler+0x15: 5d                         pop    rbp
vmexit_handler+0x16: 9d                         popf
vmexit_handler+0x17: 59                         pop    rcx
vmexit_handler+0x18: 59                         pop    rcx
vmexit_handler+0x19: 41 5e                      pop    r14
vmexit_handler+0x1b: 5e                         pop    rsi
vmexit_handler+0x1c: 41 5d                      pop    r13
vmexit_handler+0x1e: c3                         ret
</code></pre><p><em>you can read more details here: <a href="https://blog.back.engineering/17/05/2021/#vm_exit" target="_blank">https://blog.back.engineering/17/05/2021/#vm_exit</a></em></p><p>It is my opinion that not a single <em>public</em> bin2bin software protector is worth your money. Regardless of the lack of decent public tooling for <a href="https://vmpsoft.com/" target="_blank">VMProtect</a> or <a href="https://www.oreans.com/CodeVirtualizer.php" target="_blank">Oreans Code Virtualizer</a>, there is private tooling for these protectors. These protectors pose little to no difficulty against a team of educated reverse engineers. I drew this conclusion myself when creating <a href="https://git.back.engineering/vmp2/" target="_blank">my tooling for VMProtect 2</a> and <a href="https://git.back.engineering/vmp3/" target="_blank">VMProtect 3</a>. Considering that I was a lone reverse engineer with little to no prior experience with deobfuscation/devirtualization when I took the challenge upon myself to create useful tooling against <a href="https://vmpsoft.com/" target="_blank">VMProtect</a>, which I was arguably successful in doing.</p><p>Due to my research I have had the ability to see a wide range of private tooling, all of which massively nullify the protections of these public protectors. Do not be lulled into thinking that these protectors are difficult or impossible to remove simply because you cannot clone a repository off of github to remove the obfuscation.</p><p>My claims can and will be backed up as time progresses. For now, I will end this passage with the following: recently there was a full devirtualization of <a href="https://www.battleye.com/" target="_blank">BattlEye’s</a> kernel component (which is protected with <a href="https://vmpsoft.com/" target="_blank">VMProtect 3</a>). This devirtualization is unparalleled to public tooling and restores the image almost to near original assembly. A link to this image is provided below.</p><p><a href="https://www.unknowncheats.me/forum/downloads.php?do=file&amp;id=36229" target="_blank">https://www.unknowncheats.me/forum/downloads.php?do=file&amp;id=36229</a></p><p>Furthermore, it is my opinion that <a href="https://www.oreans.com/CodeVirtualizer.php" target="_blank">Code Virtualizer (CV)</a> and the products built upon it, such as <a href="https://www.oreans.com/Themida.php" target="_blank">Themida</a> and <a href="https://www.oreans.com/WinLicense.php" target="_blank">WinLicense</a>, are not viable products for CV has an abundance of semantic inaccuracies in its native instruction virtualization, this only gets exacerbated by their nested virtualization. The only obfuscation that is worth your money is obfuscation that is semantically correct. Even more, <a href="https://www.oreans.com/CodeVirtualizer.php" target="_blank">Code Virtualizer</a> cannot handle switch cases without macros, which even <a href="https://vmpsoft.com/" target="_blank">VMProtect</a> has been able to completely handle since version 2.x.</p><blockquote><p><em>When the code is virtualized, the jump goes into a virtualized (garbage) code and it produces exception.</em></p><blockquote><p>Source: <a href="https://www.oreans.com/help/cv/hm_faq_can-vm-macros-protect-switch-s.htm" target="_blank">https://www.oreans.com/help/cv/hm_faq_can-vm-macros-protect-switch-s.htm</a></p></blockquote></blockquote><p>Additionally, macros must be used for try-except/try-finally blocks. You may be tempted to think that this is a feature to allow the end user to control what should be protected. Rather, it is poor engineering that requires the end user to provide information so that it can barely work.</p><blockquote><p><em>You have to insert VM macros in try-finally clauses in the same was as you do for try-except.</em></p><blockquote><p>Source: <a href="https://www.oreans.com/help/cv/hm_faq_i-have-seen-that-insertion-of-.htm" target="_blank">https://www.oreans.com/help/cv/hm_faq_i-have-seen-that-insertion-of-.htm</a></p></blockquote></blockquote><p>Moreover, <a href="https://www.oreans.com/codevirtualizer.php" target="_blank">Code Virtualizer</a> only allows a single thread inside of the virtual machine at a time. This is because the virtual machines context is not allocated upon the stack like <a href="https://blog.back.engineering/17/05/2021/#overview-virtual-machine" target="_blank">VMProtect’s virtual machine context</a> is. <a href="https://www.oreans.com/codevirtualizer.php" target="_blank">Code Virtualizer</a> utilises a spinlock on every virtual machine enter to ensure only a single thread is executing inside of the virtual machine.</p><div style="text-align:center"><img src="https://back.engineering/cv-spinlock-lol.png" alt="Code Virtualizer Spinlock" style="max-width:800px;width:100%"></div><p>For multi threaded programs this completely nullifies the purpose of having more than a single thread. With all of this in mind, it is truly baffling that <a href="https://www.oreans.com/codevirtualizer.php" target="_blank">Code Virtualizer</a> offers protection for Windows kernel drivers. I hope no company is fooled into using this protector to obfuscate a kernel component.</p><p>I find it interesting that Oreans is willing to market such a product regardless of its known issues. I think their engineers are smart enough to know their software protectors shortcomings, yet they still present their product as though it offers unparalleled protection. Definitely raises the question as to who their products target? No legitimate company would use Code Virtualizer if they knew the risks entailed. I think what this all boils down too is that Oreans is taking advantage of ignorant customers selling them a product that their own engineers know is not stable, extremely slow, and far behind other protectors. They use their feature list to impress potential buyers when in reality, none of the features matter if none of it is stable.</p><blockquote><p>Have a look at the feature list yourself: <a href="https://www.oreans.com/codevirtualizer.php#two" target="_blank">https://www.oreans.com/codevirtualizer.php#two</a></p></blockquote><p>My negative opinions of existing bin2bin protectors has been further amplified as of recently. This is due to the fact that I have witnessed technology in development that addresses all of the complex difficulties related to bin2bin.</p><p><em>Pros of bin2bin</em></p><ul><li>Little to no compilation requirements/integration</li><li>Much easier to integrate into a project</li></ul><p><em>Cons of bin2bin</em></p><ul><li>Extremely difficult to do correctly. Not a single public bin2bin protector is worth your money as I explain in the paragraphs above.</li><li>Requires intimate knowledge of the native file format</li><li>Requires intimate knowledge of the instruction set</li><li>Requires intimate knowledge of the processor security features and how the operating system may utilise them (CET, data alignment checks/AC Bit in EFLAGS).</li><li>Typical bin2bin obfuscation is “dumb” and cannot/does not capture semantics.</li></ul><h2 id="linker-level">Linker Level Obfuscation</h2><p>So considering the above two levels of obfuscation, where does a “linker level” obfuscation framework lay? The linker level gets the short end of both sticks from bin2bin and IR level. It requires integration into the compilation process and it is bound to a single instruction set. In addition this level of obfuscation requires intimate knowledge of the COFF file format.</p><p>However, regardless of these requirements, the linker level offers a unique ability that other levels of obfuscation cannot offer. The linker level allows you to freely position code and data how you see fit. Additionally, code can be obfuscated at the IR level prior to further being obfuscated at the linker level. You can envision obfuscation at the linker level as being synonymous with bin2bin with the added support of symbol placement.</p><div style="text-align:center"><img src="https://back.engineering/linker-level-obfuscation.drawio.svg" alt="Linker Level Obfuscation" style="max-width:900px;width:100%" width="900" height="150"></div><p>If it’s not clear by now, doing obfuscation at the linker level is not viable in a commercial software protector manner. For we would have seen such a product already due to market forces, there is simply no demand for this type of product. Instead, I find obfuscation at this level to be a fantastic stepping stone to bin2bin obfuscation. For me and others, this is a great place to learn.</p><p><em>Pros of linker level obfuscation</em></p><ul><li>Control over symbol placement</li><li>Control over linking symbols together</li></ul><p><em>Cons of linker level obfuscation</em></p><ul><li>All the same cons as bin2bin</li><li>Requires integration into the compilation process</li></ul><h2 id="Brief-Overview-Of-Theodosius">Brief Overview Of Theodosius</h2><p>Theodosius operates upon COFF files. It substitutes the role of the linker and instead of generating a native file it allows you, the programmer, to obfuscate symbols, control over symbol placement, and lastly control over both static and dynamic linking. There are three main modules to Theo, decomposition (decomp), obfuscation (obf), and recomposition (recomp).</p><h3 id="Decomposition-Module">Decomposition Module</h3><p>The first component, decomposition, is used to break down COFF files into manageable data structures which contain metadata about COFF symbols (data symbols, functions, sections, etc). These metadata objects are then used throughout the rest of the framework.
The most important classes used for decomposition are detailed below. They are also defined in the doxygen generated for this project.</p><ul><li><a href="https://docs.back.engineering/theo/d6/d0e/classtheo_1_1decomp_1_1decomp__t.html" target="_blank">theo::decomp::decomp_t</a> class contains wrapper code to decompose a lib file. It is the highest level class used in decomposition.</li><li><a href="https://docs.back.engineering/theo/d9/dd5/classtheo_1_1decomp_1_1symbol__t.html" target="_blank">theo::decomp::symbol_t</a> class is extremely important to understand as it is used to describe all symbols.</li></ul><h3 id="Obfuscation-Module">Obfuscation Module</h3><p>The second module in Theo is the obfuscation system. The obfuscation system consists of a singleton engine (<a href="https://docs.back.engineering/theo/d9/d18/classtheo_1_1obf_1_1engine__t.html" target="_blank">theo::obf::engine_t</a>), and a base class pass template (<a href="https://docs.back.engineering/theo/d4/dad/classtheo_1_1obf_1_1pass__t.html" target="_blank">theo::obf::pass_t</a>). Obfuscation passes are created by defining a class that inherits <a href="https://docs.back.engineering/theo/d4/dad/classtheo_1_1obf_1_1pass__t.html" target="_blank">theo::obf::pass_t</a>, overloading the <a href="https://docs.back.engineering/theo/d4/dad/classtheo_1_1obf_1_1pass__t.html#acfadc013ff0754d66a18baffdb1a61d1" target="_blank">virtual run method</a>, and finally adding it to the obfuscation engine. The responsibility of adding passes to the engine rests upon the code base that inherits Theo. In other words, Theo does not run any passes by default, it’s entirely up to the programmer submoduling Theo to set up the passes and their order.
The most important classes used for obfuscation are detailed below. They are also defined in the doxygen generated for this project.</p><ul><li><a href="https://docs.back.engineering/theo/d9/d18/classtheo_1_1obf_1_1engine__t.html" target="_blank">theo::obf::engine_t</a> this is a singleton class which is used to keep track of passes and their order of execution. You can get a reference to this object by calling <a href="https://docs.back.engineering/theo/d9/d18/classtheo_1_1obf_1_1engine__t.html#a58715f5c3ade824a65e602aba570040e" target="_blank">theo::obf::engine_t::get</a>. You can then add passes with the <a href="https://docs.back.engineering/theo/d9/d18/classtheo_1_1obf_1_1engine__t.html#a8ffc963a133653fa3a0875798d0d3426" target="_blank">add_pass</a> function. Here is an example of that:</li></ul><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span>	 <span style="color:#75715e">// order matters, the order in which the pass is added is the order they
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>	 <span style="color:#75715e">// will be executed!
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>	 <span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>	 <span style="color:#66d9ef">auto</span> engine <span style="color:#f92672">=</span> theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>engine_t<span style="color:#f92672">::</span>get();
</span></span><span style="display:flex"><span>	 
</span></span><span style="display:flex"><span>	 <span style="color:#75715e">// add in our hello world pass here
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>	 <span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>	 engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>hello_world_pass_t<span style="color:#f92672">::</span>get());
</span></span><span style="display:flex"><span>	 
</span></span><span style="display:flex"><span>	 <span style="color:#75715e">// add the rest of the passes in this order. this order is important.
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>	 <span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>	 engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>reloc_transform_pass_t<span style="color:#f92672">::</span>get());
</span></span><span style="display:flex"><span>	 engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>next_inst_pass_t<span style="color:#f92672">::</span>get());
</span></span><span style="display:flex"><span>	 engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>jcc_rewrite_pass_t<span style="color:#f92672">::</span>get());
</span></span></code></pre></div><ul><li><a href="https://docs.back.engineering/theo/d4/dad/classtheo_1_1obf_1_1pass__t.html" target="_blank">theo::obf::pass_t</a> is the base class for all passes. There is a single virtual method, <a href="https://docs.back.engineering/theo/d4/dad/classtheo_1_1obf_1_1pass__t.html#acfadc013ff0754d66a18baffdb1a61d1" target="_blank">run</a>, that must be overloaded when inheriting this class. In addition, it is highly suggested that you make all passes singleton with a private constructor. Consider the following code for <a href="https://docs.back.engineering/theo/d6/dc1/classtheo_1_1obf_1_1jcc__rewrite__pass__t.html" target="_blank">jcc_rewrite_pass</a>:</li></ul><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span>	<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">jcc_rewrite_pass_t</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> pass_t {
</span></span><span style="display:flex"><span>	   <span style="color:#75715e">// call the parent constructor and tell it we only want “instruction” type symbols…
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>	   <span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">jcc_rewrite_pass_t</span>() <span style="color:#f92672">:</span> pass_t(decomp<span style="color:#f92672">::</span>sym_type_t<span style="color:#f92672">::</span>instruction) {}
</span></span><span style="display:flex"><span>	 <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex"><span>	   <span style="color:#66d9ef">static</span> jcc_rewrite_pass_t<span style="color:#f92672">*</span> get();
</span></span><span style="display:flex"><span>	   <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>(decomp<span style="color:#f92672">::</span>symbol_t<span style="color:#f92672">*</span> sym);
</span></span><span style="display:flex"><span>	};
</span></span></code></pre></div><h3 id="Recomposition-Module">Recomposition Module</h3><p>The last module to Theo is recomposition. This module is responsible for allocating space for symbols, resolving references to symbols, and copying symbols into memory. All three, allocation, symbol resolution, and memory copying are completely determined by the programmer. This allows the framework to be extremely open ended in its application. Symbol resolution within the COFF files themselves is handled by Theo. Any external symbols call upon the supplied resolver lambda function the programmer provides the framework.</p><p>The most important classes/data types used for recomposition are detailed below. They are also defined in the doxygen generated for this project.</p><ul><li><a href="https://docs.back.engineering/theo/da/dbd/namespacetheo_1_1recomp.html#a96995cb0c5291dce945760c3d8f55241" target="_blank">theo::recomp::allocator_t</a> - a function which is called by recomp_t to allocate space for a symbol.</li><li><a href="https://docs.back.engineering/theo/da/dbd/namespacetheo_1_1recomp.html#a604e81450773453df676c3b573651adc" target="_blank">theo::recomp::copier_t</a> - a function which is called by recomp_t to copy symbols into memory.</li><li><a href="https://docs.back.engineering/theo/da/dbd/namespacetheo_1_1recomp.html#a7364f8c94855a2a871a9d6e1057989f3" target="_blank">theo::recomp::resolver_t</a> - a function which is called by recomp_t to resolve external symbols.</li><li><a href="https://docs.back.engineering/theo/d5/d05/classtheo_1_1recomp_1_1recomp__t.html" target="_blank">theo::recomp::recomp_t</a> - the main class responsible for recomposition.</li></ul><h2 id="Theodosius-Internals">Theodosius Internals</h2><p>Let’s move onto some of the internals of Theodosius as I think it’s important to discuss such things as how relocations are handled, how routines are split into individual instructions, how function length is determined, and how <code>.rdata</code>/<code>.data</code> section symbols are handled.</p><p>To begin, when the compiler generates a COFF file, each symbol will have its own section up until there are <code>65535</code> sections, after which symbols will share sections with liked characteristics. For code/data/rdata/bss, this means symbols can have their own section and/or share a section with other symbols depending upon how many other symbols have already been declared in the COFF file. Although Theodosius aims to provide control over symbol placement, it will not split <code>.data</code>/<code>.rdata</code>/<code>.bss</code> symbols apart which reside in the same section. The reason being: some data structures may have multiple data symbols referencing inside of them.</p><div style="text-align:center"><img src="https://back.engineering/data-section-struct-with-multi-syms.drawio.png" alt="Data Section Structure" style="max-width:900px;width:100%"></div><p>This makes it extremely difficult to determine the actual size of the data. For this reason, data symbol sizes are calculated by the size of the section that contains them. Lastly, BSS symbols (zero initialised symbols) are handled in the same manner as other <code>.data</code>/<code>.rdata</code> symbols.</p><center><img src="https://back.engineering/max-section-limit-multi-symbols.drawio.svg" width="300" height="150"></center><p>Code on the other hand can be calculated by determining the distance between the start of the function and the beginning of the next symbol in the same section. If there are no other code symbols in the section then the size of the section itself is used as the size of the function. Determining size of functions in this manner offers a massive performance boost in comparison to recursively disassembling every function to determine the very last instruction. However, the method that Theo performs includes padding instructions (such at int3’s) into the function and its size.</p><center><img src="https://back.engineering/getting-function-size.drawio.svg" width="300" height="150"></center><p>During the decomposition stage of Theo a symbol is determined either code, data, or bss by looking at the characteristics of symbol type (it does not use section characteristics to deduce symbol type).</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#66d9ef">if</span> (sym<span style="color:#f92672">-&gt;</span>derived_type <span style="color:#f92672">==</span> coff<span style="color:#f92672">::</span>derived_type_id<span style="color:#f92672">::</span>function <span style="color:#f92672">&amp;&amp;</span> 
</span></span><span style="display:flex"><span>	sym<span style="color:#f92672">-&gt;</span>storage_class <span style="color:#f92672">!=</span> coff<span style="color:#f92672">::</span>storage_class_id<span style="color:#f92672">::</span>external_definition <span style="color:#f92672">&amp;&amp;</span> 
</span></span><span style="display:flex"><span>	sym<span style="color:#f92672">-&gt;</span>has_section()) {
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">auto</span> scn <span style="color:#f92672">=</span> img<span style="color:#f92672">-&gt;</span>get_section(sym<span style="color:#f92672">-&gt;</span>section_index <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">auto</span> dcmp_type <span style="color:#f92672">=</span>
</span></span><span style="display:flex"><span>    scn<span style="color:#f92672">-&gt;</span>name.to_string(img<span style="color:#f92672">-&gt;</span>get_strings()) <span style="color:#f92672">==</span> INSTR_SPLIT_SECTION_NAME
</span></span><span style="display:flex"><span>        <span style="color:#f92672">?</span> decomp<span style="color:#f92672">::</span>sym_type_t<span style="color:#f92672">::</span>instruction
</span></span><span style="display:flex"><span>        : decomp<span style="color:#f92672">::</span>sym_type_t<span style="color:#f92672">::</span>function;
</span></span><span style="display:flex"><span>        
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">auto</span> fn_size <span style="color:#f92672">=</span> next_sym(img, scn, sym);
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">auto</span> fn_bgn <span style="color:#f92672">=</span> scn<span style="color:#f92672">-&gt;</span>ptr_raw_data <span style="color:#f92672">+</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*&gt;</span>(img) <span style="color:#f92672">+</span>
</span></span><span style="display:flex"><span>              sym<span style="color:#f92672">-&gt;</span>value;
</span></span><span style="display:flex"><span>              
</span></span><span style="display:flex"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span> fn(fn_bgn, fn_bgn <span style="color:#f92672">+</span> fn_size);
</span></span><span style="display:flex"><span>  decomp<span style="color:#f92672">::</span>routine_t rtn(sym, img, scn, fn, dcmp_type);
</span></span><span style="display:flex"><span>  
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">auto</span> syms <span style="color:#f92672">=</span> rtn.decompose();
</span></span><span style="display:flex"><span>  m_syms<span style="color:#f92672">-&gt;</span>put_symbols(syms);
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>The above code is wrapper code contained inside of the decomp_t class to handle decomposition of functions. It’s important to understand that any function that is stored inside of a section with the name <code>.split</code> will result in the functions decomposition into individual instructions rather than a single symbol containing the entire function.</p><p>Another thing to note is that the size of the function is determined by subtracting the address of the next symbol in the same section. This solves the problem of multiple functions located inside of the same section. If there is only a single symbol/function in the section then the address of the end of the section is returned.</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#66d9ef">auto</span> fn_size <span style="color:#f92672">=</span> next_sym(img, scn, sym);
</span></span><span style="display:flex"><span><span style="color:#66d9ef">auto</span> fn_bgn <span style="color:#f92672">=</span> scn<span style="color:#f92672">-&gt;</span>ptr_raw_data <span style="color:#f92672">+</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*&gt;</span>(img) <span style="color:#f92672">+</span>
</span></span><span style="display:flex"><span>              sym<span style="color:#f92672">-&gt;</span>value;
</span></span><span style="display:flex"><span>              
</span></span><span style="display:flex"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span> fn(fn_bgn, fn_bgn <span style="color:#f92672">+</span> fn_size);
</span></span></code></pre></div><p>Let’s take a closer look into how functions are decomposed as it will answer how relocations are handled. When a function is decomposed into a sequence of <a href="https://docs.back.engineering/theo/d9/dd5/classtheo_1_1decomp_1_1symbol__t.html" target="_blank">theo::decomp::symbol_t’s</a> any relocations inside of that routine are passed along to the symbol_t. However relocations are rebased to be from the beginning of the routine (or instruction).</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>recomp<span style="color:#f92672">::</span>reloc_t<span style="color:#f92672">&gt;</span> relocs;
</span></span><span style="display:flex"><span><span style="color:#66d9ef">auto</span> scn_relocs <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>coff<span style="color:#f92672">::</span>reloc_t<span style="color:#f92672">*&gt;</span>(
</span></span><span style="display:flex"><span>    m_scn<span style="color:#f92672">-&gt;</span>ptr_relocs <span style="color:#f92672">+</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*&gt;</span>(m_img));
</span></span><span style="display:flex"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0u</span>; idx <span style="color:#f92672">&lt;</span> m_scn<span style="color:#f92672">-&gt;</span>num_relocs; <span style="color:#f92672">++</span>idx) {
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">auto</span> scn_reloc <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>scn_relocs[idx];
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// if the reloc is in the current function...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (scn_reloc<span style="color:#f92672">-&gt;</span>virtual_address <span style="color:#f92672">&gt;=</span> m_sym<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex"><span>      scn_reloc<span style="color:#f92672">-&gt;</span>virtual_address <span style="color:#f92672">&lt;</span> m_sym<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">+</span> m_data.size()) {
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">auto</span> sym_reloc <span style="color:#f92672">=</span> m_img<span style="color:#f92672">-&gt;</span>get_symbol(scn_relocs[idx].symbol_index);
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">auto</span> sym_name <span style="color:#f92672">=</span> symbol_t<span style="color:#f92672">::</span>name(m_img, sym_reloc);
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">auto</span> sym_hash <span style="color:#f92672">=</span> decomp<span style="color:#f92672">::</span>symbol_t<span style="color:#f92672">::</span>hash(sym_name.data());
</span></span><span style="display:flex"><span>    relocs.push_back(
</span></span><span style="display:flex"><span>        recomp<span style="color:#f92672">::</span>reloc_t(scn_reloc<span style="color:#f92672">-&gt;</span>virtual_address <span style="color:#f92672">-</span> m_sym<span style="color:#f92672">-&gt;</span>value,
</span></span><span style="display:flex"><span>                        sym_hash, sym_name.data()));
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>result.push_back(decomp<span style="color:#f92672">::</span>symbol_t(
</span></span><span style="display:flex"><span>    m_img, symbol_t<span style="color:#f92672">::</span>name(m_img, m_sym).data(), m_sym<span style="color:#f92672">-&gt;</span>value, m_data,
</span></span><span style="display:flex"><span>    m_scn, m_sym, relocs, sym_type_t<span style="color:#f92672">::</span>function));
</span></span></code></pre></div><p>The same logic applies to instructions, however relocations are rebased to the beginning of the instruction.</p><h3 id="Recursive-Symbol-Dependency-Check">Recursive Symbol Dependency Check</h3><p>Another important topic to discuss is how Theo determines which symbols are used and which symbols are not. When you compile a static library, all functions, regardless if they are referenced at all in the C/C++ source code will be compiled into the static library. This makes sense as the functions needed when statically linking with external code is unknown at the time of compilation of the static library itself, therefore all functions are included. Mapping all of these symbols is wildly inefficient as you can imagine. Therefore Theo implements a recursive symbol walk to determine all of the symbols that are used.</p><p>This is not a new concept as linkers themselves implement this very same functionality. Other forms of this can be observed in the process of decompilation, where code and data are uncovered by recursively following call instructions and tracking all references to data and functions (IDA does this).</p><p>Consider the following code (main.cpp):</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">t2</span>()
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>  <span style="color:#a6e22e">puts</span>(<span style="color:#960050;background-color:#1e0010">“</span>this func never gets called<span style="color:#960050;background-color:#1e0010">”</span>);
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">t1</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> str)
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>  <span style="color:#a6e22e">puts</span>(<span style="color:#960050;background-color:#1e0010">“</span>T1 is called<span style="color:#960050;background-color:#1e0010">”</span>);
</span></span><span style="display:flex"><span>  <span style="color:#a6e22e">puts</span>(str);
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>  <span style="color:#a6e22e">t1</span>(<span style="color:#960050;background-color:#1e0010">“</span>hello world<span style="color:#960050;background-color:#1e0010">”</span>);
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>The above code will generate 7 (and some extra) symbols into a single COFF file named “main.obj”</p><ul><li>int main in a <code>.text</code> section</li><li>void t1 in a <code>.text</code> section</li><li>void t2 in a <code>.text</code> section</li><li>A symbol for “puts”, with a storage class of <code>IMAGE_SYM_CLASS_EXTERNAL</code>, and a section index of 0 indicating that the symbol is not located inside of the COFF file.</li><li>“hello world” string in a <code>.rdata</code> section.</li><li>“T1 is called” string in a <code>.rdata</code> section.</li><li>“this func never gets called” string in a <code>.rdata</code> section</li></ul><p>Now consider that “t2” is never called by any code in the file but it will still be present in the generated COFF and archive (lib) file. It would be a waste of resources for Theo to map these unused symbols. For this reason I have implemented the following algorithm to extract the used symbols given an entry point.</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint32_t</span> decomp_t<span style="color:#f92672">::</span>ext_used_syms(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;&amp;</span> entry_sym) {
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// start with the entry point symbol...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span>sym_data_t<span style="color:#f92672">&gt;</span> entry <span style="color:#f92672">=</span> get_symbol(entry_sym.data());
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// if the entry point symbol cant be found simply return 0 (for 0 symbols
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// extracted)...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>entry.has_value())
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0u</span>;
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// little memoization for perf boost... :^)
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>coff<span style="color:#f92672">::</span>symbol_t<span style="color:#f92672">*&gt;</span> cache;
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> finding_syms <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>]() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex"><span>    <span style="color:#75715e">// for all the symbols...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> itr <span style="color:#f92672">=</span> m_used_syms.begin(); itr <span style="color:#f92672">!=</span> m_used_syms.end(); <span style="color:#f92672">++</span>itr) {
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">auto</span> [img, sym, size] <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>itr;
</span></span><span style="display:flex"><span>      <span style="color:#75715e">// if the symbol has a section and its not already in the cache...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (sym<span style="color:#f92672">-&gt;</span>has_section() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>cache.count(sym) <span style="color:#f92672">&amp;&amp;</span> size) {
</span></span><span style="display:flex"><span>        <span style="color:#66d9ef">auto</span> scn <span style="color:#f92672">=</span> img<span style="color:#f92672">-&gt;</span>get_section(sym<span style="color:#f92672">-&gt;</span>section_index <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex"><span>        <span style="color:#66d9ef">auto</span> num_relocs <span style="color:#f92672">=</span> scn<span style="color:#f92672">-&gt;</span>num_relocs;
</span></span><span style="display:flex"><span>        <span style="color:#66d9ef">auto</span> relocs <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>coff<span style="color:#f92672">::</span>reloc_t<span style="color:#f92672">*&gt;</span>(
</span></span><span style="display:flex"><span>            scn<span style="color:#f92672">-&gt;</span>ptr_relocs <span style="color:#f92672">+</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*&gt;</span>(img));
</span></span><span style="display:flex"><span>        <span style="color:#75715e">// see if there are any relocations inside of the symbol...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0u</span>; idx <span style="color:#f92672">&lt;</span> num_relocs; <span style="color:#f92672">++</span>idx) {
</span></span><span style="display:flex"><span>          <span style="color:#66d9ef">auto</span> reloc <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>relocs[idx];
</span></span><span style="display:flex"><span>          <span style="color:#75715e">// if the reloc is inside of the current symbol...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>          <span style="color:#66d9ef">if</span> (reloc<span style="color:#f92672">-&gt;</span>virtual_address <span style="color:#f92672">&gt;=</span> sym<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex"><span>              reloc<span style="color:#f92672">-&gt;</span>virtual_address <span style="color:#f92672">&lt;</span> sym<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">+</span> size) {
</span></span><span style="display:flex"><span>            <span style="color:#75715e">// get the symbol for the relocation and add it to the m_used_symbol
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// vector...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">auto</span> reloc_sym <span style="color:#f92672">=</span> img<span style="color:#f92672">-&gt;</span>get_symbol(reloc<span style="color:#f92672">-&gt;</span>symbol_index);
</span></span><span style="display:flex"><span>            <span style="color:#66d9ef">auto</span> sym_name <span style="color:#f92672">=</span> symbol_t<span style="color:#f92672">::</span>name(img, reloc_sym);
</span></span><span style="display:flex"><span>            entry <span style="color:#f92672">=</span> get_symbol(sym_name);
</span></span><span style="display:flex"><span>            <span style="color:#75715e">// if the symbol already exists in the m_used_syms vector then we
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// return out of this function and continue looping over all symbols
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// recursively...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (m_used_syms.emplace(entry.value()).second)
</span></span><span style="display:flex"><span>              <span style="color:#66d9ef">return</span> true;  <span style="color:#75715e">// returns to the for loop below this lambda. the
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>                            <span style="color:#75715e">// return true here means we added yet another
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>                            <span style="color:#75715e">// symbol to the "m_used_syms" vector...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>          }
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>        <span style="color:#75715e">// cache the symbol so we dont need to process it again...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>        cache.emplace(sym);
</span></span><span style="display:flex"><span>      }
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">return</span> false;  <span style="color:#75715e">// only ever returns false here when every single symbol
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>                   <span style="color:#75715e">// inside of m_used_syms has been looked at to see if all of
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>                   <span style="color:#75715e">// its relocation symbols are included in the m_used_syms
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>                   <span style="color:#75715e">// vector (meaning we got all the used symbols...)
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  };
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// add the entry point symbol...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  m_used_syms.emplace(entry.value());
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// keep recursively adding symbols until we found them all..
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (m_used_syms.emplace(entry.value()); finding_syms();)
</span></span><span style="display:flex"><span>    ;
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">return</span> m_used_syms.size();
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>The last section of information regarding the inner workings of Theo will discuss some intentionally embedded obfuscation and techniques to identify which routines are split up into individual instruction symbols.</p><p>Firstly, although Theo could potentially offer the ability to obfuscate code and generate a new COFF file, it was originally created with the intent of mapping and running the code straight from the COFF file after executing all obfuscation passes. For this reason, there exists a few noticeable design decisions which favour that intent.</p><p>Secondly, the <a href="https://docs.back.engineering/theo/dd/d37/classtheo_1_1recomp_1_1reloc__t.html" target="_blank">theo::recomp::reloc_t</a> structure contains information pertaining to obfuscating the address of relocations. When resolving relocations is performed, Theo will loop through a vector of transformations contained inside of the reloc_t structure, executing each transformation upon the address of the relocation, ultimately encrypting it. This is a hardcoded concept that doesn’t necessarily need to be utilised, but it is there if needed.</p><p>Thirdly, by default, allocation and resolving symbols is done in terms of linear virtual addresses. Therefore, by default, any code generated by Theodosius is not position independent. It is feasible to circumvent this however with a pass that rewrites relocations to be rip relative.</p><p>Lastly, in regards to breaking functions into individual instruction symbols, Theo does this on the basis of the section name that contains the function itself. Any function which is declared inside of a section with the name <code>.split</code> will result in the function’s decompilation into individual instruction symbols.</p><h3 id="Theodosius-Internal-Passes">Theodosius Internal Passes</h3><p>Theodosius contains a few internal passes. These passes handle boilerplate scenarios and can be built on top of easily. Additionally, these passes are optional and don’t need to be utilised.</p><p>The three internal obfuscation passes offered are the following:</p><ul><li><a href="https://docs.back.engineering/theo/d6/dc1/classtheo_1_1obf_1_1jcc__rewrite__pass__t.html" target="_blank">theo::obf::jcc_rewrite_pass_t</a></li><li><a href="https://docs.back.engineering/theo/d5/d08/classtheo_1_1obf_1_1next__inst__pass__t.html" target="_blank">theo::obf::next_inst_pass_t</a></li><li><a href="https://docs.back.engineering/theo/dc/d39/classtheo_1_1obf_1_1reloc__transform__pass__t.html" target="_blank">theo::obf::reloc_transform_pass_t</a></li></ul><h4 id="next_inst_pass_t">next_inst_pass_t</h4><p>This pass is used to generate transformations and jmp code to change RIP to the next instruction. Given the following code (get pml4 address from cr3):</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span>get_pml4:
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>,<span style="color:#ae81ff">0xfff</span>		<span style="color:#75715e">; 0:  48 c7 c0 ff 0f 00 00  
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">not</span> <span style="color:#66d9ef">rax</span>	    	<span style="color:#75715e">; 7:  48 f7 d0              
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rdx</span>,<span style="color:#66d9ef">cr3</span>     	<span style="color:#75715e">; a:  0f 20 da              
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">and</span> <span style="color:#66d9ef">rdx</span>,<span style="color:#66d9ef">rax</span>     	<span style="color:#75715e">; d:  48 21 c2              
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>,<span style="color:#66d9ef">rdx</span>     	<span style="color:#75715e">; 10: 48 89 d0              
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ret</span>             	<span style="color:#75715e">; 1C: c3                    
</span></span></span></code></pre></div><p>This pass will break up each instruction so that it can be anywhere in a linear virtual address space. This pass will not work on rip relative code, however clang will not generate such code when compiled with <code>-mcmodel=large</code>.</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span>get_pml4@0:
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">0xFFF</span>
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">push</span> [<span style="color:#66d9ef">next_inst_addr_enc</span>]
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">xor</span> [<span style="color:#66d9ef">rsp</span>], <span style="color:#ae81ff">0x3243342</span>
</span></span><span style="display:flex"><span>    <span style="color:#75715e">; a random number of transformations here...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex"><span>    next_inst_addr_enc:
</span></span><span style="display:flex"><span>    <span style="color:#75715e">; encrypted address of the next instruction goes here.
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex"><span>get_pml4@7:
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">not</span> <span style="color:#66d9ef">rax</span>
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">push</span> [<span style="color:#66d9ef">next_inst_addr_enc</span>]
</span></span><span style="display:flex"><span>    <span style="color:#a6e22e">xor</span> [<span style="color:#66d9ef">rsp</span>], <span style="color:#ae81ff">0x93983498</span>
</span></span><span style="display:flex"><span>    <span style="color:#75715e">; a random number of transformations here...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex"><span>    next_inst_addr_enc:
</span></span><span style="display:flex"><span>    <span style="color:#75715e">; encrypted address of the next instruction goes here.
</span></span></span></code></pre></div><p>This process is continued for each instruction in the function. The last instruction, RET, will have no code generated for it as there is no next instruction.</p><p>This pass also only runs at the instruction level, theodosius internally breaks up functions inside of the <code>.split</code> section into individual instruction symbols. This process also creates a pseudo relocation which simply tells this pass that there needs to be a relocation to the next symbol. The offset for these pseudo relocations is zero.</p><h4 id="jcc_rewrite_pass">jcc_rewrite_pass</h4><p>This pass rewrites rip relative jcc’s so that they are position independent.</p><p>Given the following code:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">label1</span>
</span></span><span style="display:flex"><span><span style="color:#75715e">; other code goes here
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>label1:
</span></span><span style="display:flex"><span><span style="color:#75715e">; more code here
</span></span></span></code></pre></div><p>The jnz instruction will be rewritten so that the following code is generated:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">br2</span>
</span></span><span style="display:flex"><span>br1:
</span></span><span style="display:flex"><span><span style="color:#a6e22e">jmp</span> [<span style="color:#66d9ef">rip</span>] <span style="color:#75715e">; address after this instruction contains the address
</span></span></span><span style="display:flex"><span><span style="color:#75715e">; of the instruction after the jcc.
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>br2:
</span></span><span style="display:flex"><span><span style="color:#a6e22e">jmp</span> [<span style="color:#66d9ef">rip</span>] <span style="color:#75715e">; address after this instruction contains the address of where
</span></span></span><span style="display:flex"><span><span style="color:#75715e">; branch 2 is located.
</span></span></span></code></pre></div><p>It’s important to note that other passes will encrypt (transform) the address of the next instruction. There is actually no jmp [rip] either, push/ret is used.</p><h4 id="reloc_transform_pass">reloc_transform_pass</h4><p>This pass is like the <a href="https://docs.back.engineering/theo/d5/d08/classtheo_1_1obf_1_1next__inst__pass__t.html" target="_blank">next_inst_pass</a>, however, relocations are encrypted with transformations instead of the address of the next instruction. This pass only runs at the instruction level and appends transformations into the reloc_t object of the instruction symbol.</p><p>Given the following code:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#66d9ef">cs</span>:<span style="color:#66d9ef">MessageBoxA</span>
</span></span></code></pre></div><p>This pass will generate a random number of transformations to encrypt the address of “MessageBoxA”. These transformations will then be applied by theodosius internally when resolving relocations.</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">rax</span>, <span style="color:#66d9ef">enc_MessageBoxA</span>
</span></span><span style="display:flex"><span><span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">0x389284324</span>
</span></span><span style="display:flex"><span><span style="color:#a6e22e">add</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">0x345332567</span>
</span></span><span style="display:flex"><span><span style="color:#a6e22e">ror</span> <span style="color:#66d9ef">rax</span>, <span style="color:#ae81ff">0x5353</span>
</span></span></code></pre></div><h2 id="Theodosius-Example">Theodosius Example</h2><p>Theodosius comes with a demonstration project and a few static libraries for testing purposes. These are meant to be built on Windows platforms only, however Theodosius itself can compile for linux (follow the readme for instructions).</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// read in lib file...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>ifstream f(argv[<span style="color:#ae81ff">1</span>], std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>binary);
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">auto</span> fsize <span style="color:#f92672">=</span> fs<span style="color:#f92672">::</span>file_size(fs<span style="color:#f92672">::</span>path(argv[<span style="color:#ae81ff">1</span>]));
</span></span><span style="display:flex"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">&gt;</span> fdata;
</span></span><span style="display:flex"><span>  fdata.resize(fsize);
</span></span><span style="display:flex"><span>  f.read((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)fdata.data(), fsize);
</span></span><span style="display:flex"><span>  LoadLibraryA(<span style="color:#e6db74">"user32.dll"</span>);
</span></span><span style="display:flex"><span>  LoadLibraryA(<span style="color:#e6db74">"win32u.dll"</span>);
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// declare your allocator, resolver, and copier lambda functions.
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  theo<span style="color:#f92672">::</span>recomp<span style="color:#f92672">::</span>allocator_t allocator <span style="color:#f92672">=</span>
</span></span><span style="display:flex"><span>      [<span style="color:#f92672">&amp;</span>](std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint32_t</span> size,
</span></span><span style="display:flex"><span>          coff<span style="color:#f92672">::</span>section_characteristics_t section_type) <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>uintptr_t {
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>uintptr_t<span style="color:#f92672">&gt;</span>(VirtualAlloc(
</span></span><span style="display:flex"><span>        NULL, size, MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE,
</span></span><span style="display:flex"><span>        section_type.mem_execute <span style="color:#f92672">?</span> PAGE_EXECUTE_READWRITE : PAGE_READWRITE));
</span></span><span style="display:flex"><span>  };
</span></span><span style="display:flex"><span>  theo<span style="color:#f92672">::</span>recomp<span style="color:#f92672">::</span>copier_t copier <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>](std<span style="color:#f92672">::</span>uintptr_t ptr, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> buff,
</span></span><span style="display:flex"><span>                                      std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint32_t</span> size) {
</span></span><span style="display:flex"><span>    std<span style="color:#f92672">::</span>memcpy((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)ptr, buff, size);
</span></span><span style="display:flex"><span>  };
</span></span><span style="display:flex"><span>  theo<span style="color:#f92672">::</span>recomp<span style="color:#f92672">::</span>resolver_t resolver <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>](std<span style="color:#f92672">::</span>string sym) <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>uintptr_t {
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">auto</span> loaded_modules <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>HMODULE[]<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">64</span>);
</span></span><span style="display:flex"><span>    std<span style="color:#f92672">::</span>uintptr_t result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0u</span>, loaded_module_sz <span style="color:#f92672">=</span> <span style="color:#ae81ff">0u</span>;
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>EnumProcessModules(GetCurrentProcess(), loaded_modules.get(), <span style="color:#ae81ff">512</span>,
</span></span><span style="display:flex"><span>                            (PDWORD)<span style="color:#f92672">&amp;</span>loaded_module_sz))
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">return</span> {};
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0u</span>; i <span style="color:#f92672">&lt;</span> loaded_module_sz <span style="color:#f92672">/</span> <span style="color:#ae81ff">8u</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">wchar_t</span> file_name[MAX_PATH] <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">""</span>;
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>GetModuleFileNameExW(GetCurrentProcess(), loaded_modules.get()[i],
</span></span><span style="display:flex"><span>                                file_name, _countof(file_name)))
</span></span><span style="display:flex"><span>        <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex"><span>      <span style="color:#66d9ef">if</span> ((result <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>uintptr_t<span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex"><span>               GetProcAddress(LoadLibraryW(file_name), sym.c_str()))))
</span></span><span style="display:flex"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex"><span>  };
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// init enc/dec tables only once... important that this is done before adding
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// obfuscation passes to the engine...
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  xed_tables_init();
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// order matters, the order in which the pass is added is the order they
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// will be executed!
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> engine <span style="color:#f92672">=</span> theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>engine_t<span style="color:#f92672">::</span>get();
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// add in our hello world pass here
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>hello_world_pass_t<span style="color:#f92672">::</span>get());
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// add the rest of the passes in this order. this order is important.
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>reloc_transform_pass_t<span style="color:#f92672">::</span>get());
</span></span><span style="display:flex"><span>  engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>next_inst_pass_t<span style="color:#f92672">::</span>get());
</span></span><span style="display:flex"><span>  engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>jcc_rewrite_pass_t<span style="color:#f92672">::</span>get());
</span></span><span style="display:flex"><span>  std<span style="color:#f92672">::</span>string entry_name;
</span></span><span style="display:flex"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">"enter the name of the entry point: "</span>;
</span></span><span style="display:flex"><span>  std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> entry_name;
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// create a theo object and pass in the lib, your allocator, copier, and
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// resolver functions, as well as the entry point symbol name.
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  theo<span style="color:#f92672">::</span>theo_t t(fdata, {allocator, copier, resolver}, entry_name.data());
</span></span><span style="display:flex"><span>  <span style="color:#75715e">// call the decompose method to decompose the lib into coff files and extract
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// the symbols that are used. the result of this call will be an optional
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// value containing the number of symbols extracted.
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> res <span style="color:#f92672">=</span> t.decompose();
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>res.has_value()) {
</span></span><span style="display:flex"><span>    spdlog<span style="color:#f92672">::</span>error(<span style="color:#e6db74">"decomposition failed...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span>  spdlog<span style="color:#f92672">::</span>info(<span style="color:#e6db74">"decomposed {} symbols..."</span>, res.value());
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">auto</span> entry_pnt <span style="color:#f92672">=</span> t.compose();
</span></span><span style="display:flex"><span>  spdlog<span style="color:#f92672">::</span>info(<span style="color:#e6db74">"entry point address: {:X}"</span>, entry_pnt);
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)()<span style="color:#f92672">&gt;</span>(entry_pnt)();
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>It’s important to note that this code is from the inheritor of theodosius’s perspective. Therefore it’s the programmers responsibility to call <a href="https://intelxed.github.io/ref-manual/group__INIT.html#details" target="_blank">xed_tables_init</a>. In addition, you can see that the programmer is the one who has control over the obfuscation passes and the order in which they run.</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#66d9ef">auto</span> engine <span style="color:#f92672">=</span> theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>engine_t<span style="color:#f92672">::</span>get();
</span></span><span style="display:flex"><span><span style="color:#75715e">// add in our hello world pass here
</span></span></span><span style="display:flex"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>hello_world_pass_t<span style="color:#f92672">::</span>get());
</span></span><span style="display:flex"><span><span style="color:#75715e">// add the rest of the passes in this order. this order is important.
</span></span></span><span style="display:flex"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex"><span><span style="color:#75715e"></span>engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>reloc_transform_pass_t<span style="color:#f92672">::</span>get());
</span></span><span style="display:flex"><span>engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>next_inst_pass_t<span style="color:#f92672">::</span>get());
</span></span><span style="display:flex"><span>engine<span style="color:#f92672">-&gt;</span>add_pass(theo<span style="color:#f92672">::</span>obf<span style="color:#f92672">::</span>jcc_rewrite_pass_t<span style="color:#f92672">::</span>get());
</span></span></code></pre></div><p>The example simply registers the built in obfuscation passes to run with the addition of the <a href="https://docs.back.engineering/theo/d5/d6a/classtheo_1_1obf_1_1hello__world__pass__t.html" target="_blank">hello_world_pass_t</a>.</p><h2 id="Creating-A-Pass">Creating A Pass</h2><p>To create a pass for Theodosius, one must define a class that publicly inherits the <a href="https://docs.back.engineering/theo/d4/dad/classtheo_1_1obf_1_1pass__t.html" target="_blank">theo::obf::pass_t</a> base class. This class that is defined should be a singleton class with a private constructor which invokes the parent constructor. Refer to the following code:</p><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">hello_world_pass_t</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> pass_t {
</span></span><span style="display:flex"><span>  hello_world_pass_t() <span style="color:#f92672">:</span> pass_t(decomp<span style="color:#f92672">::</span>sym_type_t<span style="color:#f92672">::</span>all) {
</span></span><span style="display:flex"><span>    spdlog<span style="color:#f92672">::</span>info(<span style="color:#e6db74">"created hello world pass..."</span>);
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span> <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">static</span> hello_world_pass_t<span style="color:#f92672">*</span> get() {
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">static</span> hello_world_pass_t obj;
</span></span><span style="display:flex"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>obj;
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>(decomp<span style="color:#f92672">::</span>symbol_t<span style="color:#f92672">*</span> sym) {
</span></span><span style="display:flex"><span>    spdlog<span style="color:#f92672">::</span>info(<span style="color:#e6db74">"[hello_world_pass_t] symbol name: {}, symbol hash: {}"</span>,
</span></span><span style="display:flex"><span>                 sym<span style="color:#f92672">-&gt;</span>name(), sym<span style="color:#f92672">-&gt;</span>hash());
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span>};
</span></span></code></pre></div><p>When invoking the parent constructor in the private default constructor of your pass you must provide which symbols you want your pass to operate upon. In the example above the hello_world_pass_t operates upon all symbols. A list of all symbols your pass can operate upon are listed below:</p><ul><li><a href="https://docs.back.engineering/theo/d9/dbd/namespacetheo_1_1decomp.html#af96177687d0ad683c5897d8fa01135f9" target="_blank">theo::decomp::sym_type_t::function</a></li><li><a href="https://docs.back.engineering/theo/d9/dbd/namespacetheo_1_1decomp.html#af96177687d0ad683c5897d8fa01135f9" target="_blank">theo::decomp::sym_type_t::instruction</a></li><li><a href="https://docs.back.engineering/theo/d9/dbd/namespacetheo_1_1decomp.html#af96177687d0ad683c5897d8fa01135f9" target="_blank">theo::decomp::sym_type_t::data</a></li><li><a href="https://docs.back.engineering/theo/d9/dbd/namespacetheo_1_1decomp.html#af96177687d0ad683c5897d8fa01135f9" target="_blank">theo::decomp::sym_type_t::section</a></li><li><a href="https://docs.back.engineering/theo/d9/dbd/namespacetheo_1_1decomp.html#af96177687d0ad683c5897d8fa01135f9" target="_blank">theo::decomp::sym_type_t::all</a></li></ul><p>This concludes the section in regards to demonstration of theodosius. You can further refer to the code in the project if you would like to learn more. Links to related documents are linked below.</p><ul><li><a href="https://docs.back.engineering/theo/dd/d70/md_examples_demo__demo__example__using__theo.html" target="_blank">https://docs.back.engineering/theo/dd/d70/md_examples_demo__demo__example__using__theo.html</a></li><li><a href="https://docs.back.engineering/theo/d9/d18/classtheo_1_1obf_1_1engine__t.html" target="_blank">https://docs.back.engineering/theo/d9/d18/classtheo_1_1obf_1_1engine__t.html</a></li><li><a href="https://docs.back.engineering/theo/d4/dad/classtheo_1_1obf_1_1pass__t.html" target="_blank">https://docs.back.engineering/theo/d4/dad/classtheo_1_1obf_1_1pass__t.html</a></li><li><a href="https://docs.back.engineering/theo/df/d0a/main_8cpp.html" target="_blank">https://docs.back.engineering/theo/df/d0a/main_8cpp.html</a></li></ul><h2 id="Conclusion">Closing Words and Conclusion</h2><p>In conclusion, Theodosius is a linker level obfuscation framework which allows a programmer to mess about with native instructions and symbol placement. The framework contains a well documented pass system, and it even comes with an example.</p><p>I originally wanted to create a framework that I could use to recreate VMProtect obfuscation techniques to better explain how they work. In my last VMProtect related post I stated the following:</p><blockquote><p><em>Lastly, during my research of VMProtect 2, there has been a subtle urge to reimplement some of the obfuscation and virtual machine features myself in an open source manner to better convey the features of VMProtect 2. However, after much thought, it would be more productive to create an obfuscation framework that would allow for these ideas to be created with relative ease.</em></p></blockquote><p>I will conclude this post by stating that although publicly researching software protectors is fun, it can be damaging to my own image as the tooling can be used in a negative manner. For that I will continue my research in private and publicly focus more on the creation of obfuscation/software protection. As to my comments in regards to Themida/Code Virtualizer they are not meant to be slander, rather constructive criticism. All of the concerns I have raised are legitimate and based in reality.</p></div><div class="row items-start justify-between"><div class="lg:col-6 mb-10 flex items-center lg:mb-0"><h5 class="mr-3">Tags:</h5><ul><li class="inline-block"><a class="bg-light hover:bg-primary dark:bg-darkmode-light dark:hover:bg-darkmode-primary dark:hover:text-text-dark m-1 block rounded px-3 py-1 hover:text-white" href="https://back.engineering/tags/obfuscation/">Obfuscation</a></li></ul></div><div class="lg:col-6 flex items-center lg:justify-end"><h5>Share :</h5><div class="share-icons"><a class="share-link share-facebook" href="https://facebook.com/sharer/sharer.php?u=%2fblog%2f06%2f05%2f2022%2f" target="_blank" rel="noopener" aria-label="share facebook"><span class="share-icon"><svg viewBox="0 0 24 24"><path d="M18.77 7.46H14.5v-1.9c0-.9.6-1.1 1-1.1h3V.5h-4.33C10.24.5 9.5 3.44 9.5 5.32v2.15h-3v4h3v12h5v-12h3.85l.42-4z"></path></svg>
</span></a><a class="share-link share-x" href="https://x.com/intent/tweet/?text=Theodosius%20-%20Jit%20linker%2c%20Symbol%20Mapper%2c%20and%20Obfuscator&amp;url=%2fblog%2f06%2f05%2f2022%2f" target="_blank" rel="noopener" aria-label="share x"><span aria-hidden="true" class="share-icon"><svg viewBox="0 0 24 24"><path d="M8 2H1l8.26 11.015L1.45 22H4.1l6.388-7.349L16 22h7l-8.608-11.478L21.8 2h-2.65l-5.986 6.886zm9 18L5 4h2l12 16z"></path></svg>
</span></a><a class="share-link share-email" href="mailto:?subject=Theodosius%20-%20Jit%20linker%2c%20Symbol%20Mapper%2c%20and%20Obfuscator&amp;body=%2fblog%2f06%2f05%2f2022%2f" target="_self" rel="noopener" aria-label="share email"><span aria-hidden="true" class="share-icon"><svg viewBox="0 0 24 24"><path d="M22 4H2C.9 4 0 4.9.0 6v12c0 1.1.9 2 2 2h20c1.1.0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7.25 14.43l-3.5 2c-.08.05-.17.07-.25.07-.17.0-.34-.1-.43-.25-.14-.24-.06-.55.18-.68l3.5-2c.24-.14.55-.06.68.18.14.24.06.55-.18.68zm4.75.07c-.1.0-.2-.03-.27-.08l-8.5-5.5c-.23-.15-.3-.46-.15-.7.15-.22.46-.3.7-.14L12 13.4l8.23-5.32c.23-.15.54-.08.7.15.14.23.07.54-.16.7l-8.5 5.5c-.08.04-.17.07-.27.07zm8.93 1.75c-.1.16-.26.25-.43.25-.08.0-.17-.02-.25-.07l-3.5-2c-.24-.13-.32-.44-.18-.68s.44-.32.68-.18l3.5 2c.24.13.32.44.18.68z"></path></svg>
</span></a><span class="fediverse-share"><a class="share-link share-fediverse" aria-label="share fediverse"><span aria-hidden="true" class="share-icon"><svg viewBox="-10 -5 1034 1034" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"><path d="M539 176q-32 0-55 22t-25 55 20.5 58 56 27 58.5-20.5 27-56-20.5-59T544 176h-5zm-87 95-232 118q20 20 25 48l231-118q-19-20-24-48zm167 27q-13 25-38 38l183 184q13-25 39-38zM477 320 342 585l40 40 143-280q-28-5-48-25zm104 16q-22 11-46 10l-8-1 21 132 56 9zM155 370q-32 0-55 22.5t-25 55 20.5 58 56.5 27 59-21 26.5-56-21-58.5-55.5-27h-6zm90 68q1 9 1 18-1 19-10 35l132 21 26-50zm225 36-26 51 311 49q-1-8-1-17 1-19 10-36zm372 6q-32 1-55 23t-24.5 55 21 58 56 27 58.5-20.5 27-56.5-20.5-59-56.5-27h-6zM236 493q-13 25-39 38l210 210 51-25zm-40 38q-21 11-44 10l-9-1 40 256q21-10 45-9l8 1zm364 22 48 311q21-10 44-9l10 1-46-294zm195 23-118 60 8 56 135-68q-20-20-25-48zm26 49-119 231q28 5 48 25l119-231q-28-5-48-25zM306 654l-68 134q28 5 48 25l60-119zm262 17-281 143q19 20 24 48l265-135zM513 771l-51 25 106 107q13-25 39-38zM222 795q-32 0-55.5 22.5t-25 55 21 57.5 56 27 58.5-20.5 27-56-20.5-58.5-56.5-27h-5zm89 68q2 9 1 18-1 19-9 35l256 41q-1-9-1-18 1-18 10-35zm335 0q-32 0-55 22.5t-24.5 55 20.5 58 56 27 59-21 27-56-20.5-58.5-56.5-27h-6z"></path></g></svg>
</span></a><span class="fediverse-input-wrapper" style="display:none"><input type="text" placeholder="Enter Fediverse Instance URL" class="fediverse-input">
<button class="fediverse-check-button">
Share
</button>
</span></span><button class="share-link share-copy">
<span class="share-icon"><svg viewBox="0 0 24 24"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1s-2.4.84-2.82 2H5c-1.1.0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1.0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7-1c.55.0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 17H5V5h14v14z"></path></svg></span></button></div></div></div></article></div><div class="section pb-0"><h2 class="h3 mb-12">Related Posts</h2><div class="row"><div class="lg:col-4 md:col-6 mb-14"><div class="bg-body dark:bg-darkmode-body"><h4 class="mb-3"><a href="https://back.engineering/blog/13/04/2022/">Writing a Mutation Engine and breaking Aimware</a></h4><ul class="mb-4"><li class="mr-4 inline-block"><i class="fa-regular fa-circle-user mr-2"></i>
<a href="https://back.engineering/authors/x86mike/" class="ms-1">x86mike</a></li><li class="mr-4 inline-block"><i class="fa-regular fa-folder mr-1"></i>
<a href="https://back.engineering/categories/windows/" class="ms-1">Windows</a></li></ul><p class="mb-6">PERSES is a X86 code obfuscation engine that works with Portable Executable files. The obfuscation works by replacing a specific instruction with a larger more sophisticated set that is semantically compatible to the original.</p><a class="btn btn-outline-primary btn-sm" href="https://back.engineering/blog/13/04/2022/">Read More</a></div></div><div class="lg:col-4 md:col-6 mb-14"><div class="bg-body dark:bg-darkmode-body"><h4 class="mb-3"><a href="https://back.engineering/blog/17/05/2021/">VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture</a></h4><ul class="mb-4"><li class="mr-4 inline-block"><i class="fa-regular fa-circle-user mr-2"></i>
<a href="https://back.engineering/authors/idontcode/" class="ms-1">IDontCode</a></li><li class="mr-4 inline-block"><i class="fa-regular fa-folder mr-1"></i>
<a href="https://back.engineering/categories/windows/" class="ms-1">Windows</a></li></ul><p class="mb-6">VMProtect 2 is a virtual machine based x86 obfuscator which converts x86 instructions to a RISC, stack machine, instruction set. Each protected binary has a unique set of encrypted virtual machine instructions with unique obfuscation. This project aims to disclose very significant signatures which are in every single VMProtect 2 binary with the intent to aid in further research...</p><a class="btn btn-outline-primary btn-sm" href="https://back.engineering/blog/17/05/2021/">Read More</a></div></div><div class="lg:col-4 md:col-6 mb-14"><div class="bg-body dark:bg-darkmode-body"><h4 class="mb-3"><a href="https://back.engineering/blog/21/06/2021/">VMProtect 2 - Part Two, Complete Static Analysis</a></h4><ul class="mb-4"><li class="mr-4 inline-block"><i class="fa-regular fa-circle-user mr-2"></i>
<a href="https://back.engineering/authors/idontcode/" class="ms-1">IDontCode</a></li><li class="mr-4 inline-block"><i class="fa-regular fa-folder mr-1"></i>
<a href="https://back.engineering/categories/windows/" class="ms-1">Windows</a></li></ul><p class="mb-6">The purpose of this article is to expound upon the prior work disclosed in the last article titled, VMProtect 2 - Detailed Analysis of the Virtual Machine Architecture, as well as correct a few mistakes. In addition, this post will focus primarily on the creation of static analysis tools using the knowledge disclosed in the prior post...</p><a class="btn btn-outline-primary btn-sm" href="https://back.engineering/blog/21/06/2021/">Read More</a></div></div></div></div></div></section></main><div id="cookie-box" class="cookie-box">This site uses cookies. By continuing to use this website, you agree to their use.
<button id="cookie-button" class="cookie-box-button btn btn-sm btn-outline-primary">
I Accept</button></div>
</body></html>