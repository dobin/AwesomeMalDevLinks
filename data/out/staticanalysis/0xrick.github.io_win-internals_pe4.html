# https://0xrick.github.io/win-internals/pe4/

<!DOCTYPE html><!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
--><html lang="en" class=" js ">

  <body class="layout--single wide">
    

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  


  <article class="page h-entry" itemscope="" itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        
      

      <section class="page__content e-content" itemprop="text">
        <div>
          
                <br>   
           
                <br>
        </div>
        
          
        
        <h2 id="a-dive-into-the-pe-file-format---pe-file-structure---part-3-nt-headers">A dive into the PE file format - PE file structure - Part 3: NT Headers<a class="header-link" href="https://0xrick.github.io/win-internals/pe4/#a-dive-into-the-pe-file-format---pe-file-structure---part-3-nt-headers" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<h3 id="introduction">Introduction<a class="header-link" href="https://0xrick.github.io/win-internals/pe4/#introduction" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>In the previous post we looked at the structure of the DOS header and we reversed the DOS stub.</p>

<p>In this post we’re going to talk about the NT Headers part of the PE file structure.</p>

<p>Before we get into the post, we need to talk about an important concept that we’re going to see a lot, and that is the concept of a Relative Virtual Address or an RVA.
An RVA is just an offset from where the image was loaded in memory (the Image Base). So to translate an RVA into an absolute virtual address you need to add the value of the RVA to the value of the Image Base.
PE files rely heavily on the use of RVAs as we’ll see later.</p>

<hr>

<h3 id="nt-headers-image_nt_headers">NT Headers (IMAGE_NT_HEADERS)<a class="header-link" href="https://0xrick.github.io/win-internals/pe4/#nt-headers-image_nt_headers" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>NT headers is a structure defined in <code class="language-plaintext highlighter-rouge">winnt.h</code> as <code class="language-plaintext highlighter-rouge">IMAGE_NT_HEADERS</code>, by looking at its definition we can see that it has three members, a <code class="language-plaintext highlighter-rouge">DWORD</code> signature, an <code class="language-plaintext highlighter-rouge">IMAGE_FILE_HEADER</code> structure called <code class="language-plaintext highlighter-rouge">FileHeader</code> and an <code class="language-plaintext highlighter-rouge">IMAGE_OPTIONAL_HEADER</code> structure called <code class="language-plaintext highlighter-rouge">OptionalHeader</code>.
<br>It’s worth mentioning that this structure is defined in two different versions, one for 32-bit executables (Also named <code class="language-plaintext highlighter-rouge">PE32</code> executables) named <code class="language-plaintext highlighter-rouge">IMAGE_NT_HEADERS</code> and one for 64-bit executables (Also named <code class="language-plaintext highlighter-rouge">PE32+</code> executables) named <code class="language-plaintext highlighter-rouge">IMAGE_NT_HEADERS64</code>. 
<br>The main difference between the two versions is the used version of <code class="language-plaintext highlighter-rouge">IMAGE_OPTIONAL_HEADER</code> structure which has two versions, <code class="language-plaintext highlighter-rouge">IMAGE_OPTIONAL_HEADER32</code> for 32-bit executables and <code class="language-plaintext highlighter-rouge">IMAGE_OPTIONAL_HEADER64</code> for 64-bit executables.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_IMAGE_NT_HEADERS64</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">Signature</span><span class="p">;</span>
    <span class="n">IMAGE_FILE_HEADER</span> <span class="n">FileHeader</span><span class="p">;</span>
    <span class="n">IMAGE_OPTIONAL_HEADER64</span> <span class="n">OptionalHeader</span><span class="p">;</span>
<span class="p">}</span> <span class="n">IMAGE_NT_HEADERS64</span><span class="p">,</span> <span class="o">*</span><span class="n">PIMAGE_NT_HEADERS64</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_IMAGE_NT_HEADERS</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">Signature</span><span class="p">;</span>
    <span class="n">IMAGE_FILE_HEADER</span> <span class="n">FileHeader</span><span class="p">;</span>
    <span class="n">IMAGE_OPTIONAL_HEADER32</span> <span class="n">OptionalHeader</span><span class="p">;</span>
<span class="p">}</span> <span class="n">IMAGE_NT_HEADERS32</span><span class="p">,</span> <span class="o">*</span><span class="n">PIMAGE_NT_HEADERS32</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="signature">Signature<a class="header-link" href="https://0xrick.github.io/win-internals/pe4/#signature" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<p>First member of the NT headers structure is the PE signature, it’s a <code class="language-plaintext highlighter-rouge">DWORD</code> which means that it occupies 4 bytes.
<br>It always has a fixed value of <code class="language-plaintext highlighter-rouge">0x50450000</code> which translates to <code class="language-plaintext highlighter-rouge">PE\0\0</code> in ASCII.</p>

<p>Here’s a screenshot from PE-bear showing the PE signature:</p>

<p><img src="https://0xrick.github.io/images/wininternals/pe4/1.png" alt="" class="align-center"></p>

<h4 id="file-header-image_file_header">File Header (IMAGE_FILE_HEADER)<a class="header-link" href="https://0xrick.github.io/win-internals/pe4/#file-header-image_file_header" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<p>Also called “The COFF File Header”, the File Header is a structure that holds some information about the PE file.
<br>It’s defined as <code class="language-plaintext highlighter-rouge">IMAGE_FILE_HEADER</code> in <code class="language-plaintext highlighter-rouge">winnt.h</code>, here’s the definition:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_IMAGE_FILE_HEADER</span> <span class="p">{</span>
    <span class="n">WORD</span>    <span class="n">Machine</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">NumberOfSections</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">TimeDateStamp</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">PointerToSymbolTable</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">NumberOfSymbols</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">SizeOfOptionalHeader</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">Characteristics</span><span class="p">;</span>
<span class="p">}</span> <span class="n">IMAGE_FILE_HEADER</span><span class="p">,</span> <span class="o">*</span><span class="n">PIMAGE_FILE_HEADER</span><span class="p">;</span>
</code></pre></div></div>

<p>It’s a simple structure with 7 members:</p>

<ul>
  <li>
<strong><code class="language-plaintext highlighter-rouge">Machine</code>:</strong> This is a number that indicates the type of machine (CPU Architecture) the executable is targeting, this field can have a lot of values, but we’re only interested in two of them, <code class="language-plaintext highlighter-rouge">0x8864</code> for <code class="language-plaintext highlighter-rouge">AMD64</code> and <code class="language-plaintext highlighter-rouge">0x14c</code> for <code class="language-plaintext highlighter-rouge">i386</code>. For a complete list of possible values you can check the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format" target="_blank" rel="noopener noreferrer">official Microsoft documentation</a>.</li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">NumberOfSections</code>:</strong> This field holds the number of sections (or the number of section headers aka. the size of the section table.).</li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">TimeDateStamp</code>:</strong> A <code class="language-plaintext highlighter-rouge">unix</code> timestamp that indicates when the file was created.</li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">PointerToSymbolTable</code> and <code class="language-plaintext highlighter-rouge">NumberOfSymbols</code>:</strong> These two fields hold the file offset to the COFF symbol table and the number of entries in that symbol table, however they get set to <code class="language-plaintext highlighter-rouge">0</code> which means that no COFF symbol table is present, this is done because the COFF debugging information is deprecated.</li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">SizeOfOptionalHeader</code>:</strong> The size of the Optional Header.</li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">Characteristics</code>:</strong> A flag that indicates the attributes of the file, these attributes can be things like the file being executable, the file being a system file and not a user program, and a lot of other things. A complete list of these flags can be found on the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format" target="_blank" rel="noopener noreferrer">official Microsoft documentation</a>.</li>
</ul>

<p>Here’s the File Header contents of an actual PE file:</p>

<p><img src="https://0xrick.github.io/images/wininternals/pe4/2.png" alt="" class="align-center"></p>

<h4 id="optional-header-image_optional_header">Optional Header (IMAGE_OPTIONAL_HEADER)<a class="header-link" href="https://0xrick.github.io/win-internals/pe4/#optional-header-image_optional_header" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h4>

<p>The Optional Header is the most important header of the NT headers, the PE loader looks for specific information provided by that header to be able to load and run the executable.
<br>It’s called the optional header because some file types like object files don’t have it, however this header is essential for image files.
<br>It doesn’t have a fixed size, that’s why the <code class="language-plaintext highlighter-rouge">IMAGE_FILE_HEADER.SizeOfOptionalHeader</code> member exists.</p>

<p>The first 8 members of the Optional Header structure are standard for every implementation of the COFF file format, the rest of the header is an extension to the standard COFF optional header defined by Microsoft, these additional members of the structure are needed by the Windows PE loader and linker.</p>

<p>As mentioned earlier, there are two versions of the Optional Header, one for 32-bit executables and one for 64-bit executables.
<br>The two versions are different in two aspects:</p>

<ul>
  <li>
<strong>The size of the structure itself (or the number of members defined within the structure):</strong> <code class="language-plaintext highlighter-rouge">IMAGE_OPTIONAL_HEADER32</code> has 31 members while <code class="language-plaintext highlighter-rouge">IMAGE_OPTIONAL_HEADER64</code> only has 30 members, that additional member in the 32-bit version is a DWORD named <code class="language-plaintext highlighter-rouge">BaseOfData</code> which holds an RVA of the beginning of the data section.</li>
  <li>
<strong>The data type of some of the members:</strong> The following 5 members of the Optional Header structure are defined as <code class="language-plaintext highlighter-rouge">DWORD</code> in the 32-bit version and as <code class="language-plaintext highlighter-rouge">ULONGLONG</code> in the 64-bit version:
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">ImageBase</code></strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">SizeOfStackReserve</code></strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">SizeOfStackCommit</code></strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">SizeOfHeapReserve</code></strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">SizeOfHeapCommit</code></strong></li>
    </ul>
  </li>
</ul>

<p>Let’s take a look at the definition of both structures.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_IMAGE_OPTIONAL_HEADER</span> <span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Standard fields.</span>
    <span class="c1">//</span>

    <span class="n">WORD</span>    <span class="n">Magic</span><span class="p">;</span>
    <span class="n">BYTE</span>    <span class="n">MajorLinkerVersion</span><span class="p">;</span>
    <span class="n">BYTE</span>    <span class="n">MinorLinkerVersion</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfCode</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfInitializedData</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfUninitializedData</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">AddressOfEntryPoint</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">BaseOfCode</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">BaseOfData</span><span class="p">;</span>

    <span class="c1">//</span>
    <span class="c1">// NT additional fields.</span>
    <span class="c1">//</span>

    <span class="n">DWORD</span>   <span class="n">ImageBase</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SectionAlignment</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">FileAlignment</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MajorOperatingSystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MinorOperatingSystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MajorImageVersion</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MinorImageVersion</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MajorSubsystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">MinorSubsystemVersion</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">Win32VersionValue</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfImage</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfHeaders</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">CheckSum</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">Subsystem</span><span class="p">;</span>
    <span class="n">WORD</span>    <span class="n">DllCharacteristics</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfStackReserve</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfStackCommit</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfHeapReserve</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">SizeOfHeapCommit</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">LoaderFlags</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">NumberOfRvaAndSizes</span><span class="p">;</span>
    <span class="n">IMAGE_DATA_DIRECTORY</span> <span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_NUMBEROF_DIRECTORY_ENTRIES</span><span class="p">];</span>
<span class="p">}</span> <span class="n">IMAGE_OPTIONAL_HEADER32</span><span class="p">,</span> <span class="o">*</span><span class="n">PIMAGE_OPTIONAL_HEADER32</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_IMAGE_OPTIONAL_HEADER64</span> <span class="p">{</span>
    <span class="n">WORD</span>        <span class="n">Magic</span><span class="p">;</span>
    <span class="n">BYTE</span>        <span class="n">MajorLinkerVersion</span><span class="p">;</span>
    <span class="n">BYTE</span>        <span class="n">MinorLinkerVersion</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SizeOfCode</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SizeOfInitializedData</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SizeOfUninitializedData</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">AddressOfEntryPoint</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">BaseOfCode</span><span class="p">;</span>
    <span class="n">ULONGLONG</span>   <span class="n">ImageBase</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SectionAlignment</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">FileAlignment</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MajorOperatingSystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MinorOperatingSystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MajorImageVersion</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MinorImageVersion</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MajorSubsystemVersion</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">MinorSubsystemVersion</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">Win32VersionValue</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SizeOfImage</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">SizeOfHeaders</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">CheckSum</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">Subsystem</span><span class="p">;</span>
    <span class="n">WORD</span>        <span class="n">DllCharacteristics</span><span class="p">;</span>
    <span class="n">ULONGLONG</span>   <span class="n">SizeOfStackReserve</span><span class="p">;</span>
    <span class="n">ULONGLONG</span>   <span class="n">SizeOfStackCommit</span><span class="p">;</span>
    <span class="n">ULONGLONG</span>   <span class="n">SizeOfHeapReserve</span><span class="p">;</span>
    <span class="n">ULONGLONG</span>   <span class="n">SizeOfHeapCommit</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">LoaderFlags</span><span class="p">;</span>
    <span class="n">DWORD</span>       <span class="n">NumberOfRvaAndSizes</span><span class="p">;</span>
    <span class="n">IMAGE_DATA_DIRECTORY</span> <span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_NUMBEROF_DIRECTORY_ENTRIES</span><span class="p">];</span>
<span class="p">}</span> <span class="n">IMAGE_OPTIONAL_HEADER64</span><span class="p">,</span> <span class="o">*</span><span class="n">PIMAGE_OPTIONAL_HEADER64</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">Magic</code>:</strong> Microsoft documentation describes this field as an integer that identifies the state of the image, the documentation mentions three common values:</p>

    <ul>
      <li>
<strong><code class="language-plaintext highlighter-rouge">0x10B</code>:</strong> Identifies the image as a <code class="language-plaintext highlighter-rouge">PE32</code> executable.</li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">0x20B</code>:</strong> Identifies the image as a <code class="language-plaintext highlighter-rouge">PE32+</code> executable.</li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">0x107</code>:</strong> Identifies the image as a ROM image.</li>
    </ul>

    <p>The value of this field is what determines whether the executable is 32-bit or 64-bit, <code class="language-plaintext highlighter-rouge">IMAGE_FILE_HEADER.Machine</code> is ignored by the Windows PE loader.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">MajorLinkerVersion</code> and <code class="language-plaintext highlighter-rouge">MinorLinkerVersion</code>:</strong> The linker major and minor version numbers.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">SizeOfCode</code>:</strong> This field holds the size of the code (<code class="language-plaintext highlighter-rouge">.text</code>) section, or the sum of all code sections if there are multiple sections.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">SizeOfInitializedData</code>:</strong> This field holds the size of the initialized data (<code class="language-plaintext highlighter-rouge">.data</code>) section, or the sum of all initialized data sections if there are multiple sections.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">SizeOfUninitializedData</code>:</strong> This field holds the size of the uninitialized data (<code class="language-plaintext highlighter-rouge">.bss</code>) section, or the sum of all uninitialized data sections if there are multiple sections.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">AddressOfEntryPoint</code>:</strong> An RVA of the entry point when the file is loaded into memory.
The documentation states that for program images this relative address points to the starting address and for device drivers it points to initialization function. For DLLs an entry point is optional, and in the case of entry point absence the <code class="language-plaintext highlighter-rouge">AddressOfEntryPoint</code> field is set to <code class="language-plaintext highlighter-rouge">0</code>.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">BaseOfCode</code>:</strong> An RVA of the start of the code section when the file is loaded into memory.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">BaseOfData</code> (<code class="language-plaintext highlighter-rouge">PE32</code> Only):</strong> An RVA of the start of the data section when the file is loaded into memory.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">ImageBase</code>:</strong> This field holds the preferred address of the first byte of image when loaded into memory (the preferred base address), this value must be a multiple of 64K.
Due to memory protections like ASLR, and a lot of other reasons, the address specified by this field is almost never used, in this case the PE loader chooses an unused memory range to load the image into, after loading the image into that address the loader goes into a process called the relocating where it fixes the constant addresses within the image to work with the new image base, there’s a special section that holds information about places that will need fixing if relocation is needed, that section is called the relocation section (<code class="language-plaintext highlighter-rouge">.reloc</code>), more on that in the upcoming posts.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">SectionAlignment</code>:</strong> This field holds a value that gets used for section alignment in memory (in bytes), sections are aligned in memory boundaries that are multiples of this value.
The documentation states that this value defaults to the page size for the architecture and it can’t be less than the value of <code class="language-plaintext highlighter-rouge">FileAlignment</code>.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">FileAlignment</code>:</strong> Similar to <code class="language-plaintext highlighter-rouge">SectionAligment</code> this field holds a value that gets used for section raw data alignment <strong>on disk</strong> (in bytes), if the size of the actual data in a section is less than the <code class="language-plaintext highlighter-rouge">FileAlignment</code> value, the rest of the chunk gets padded with zeroes to keep the alignment boundaries.
The documentation states that this value should be a power of 2 between 512 and 64K, and if the value of <code class="language-plaintext highlighter-rouge">SectionAlignment</code> is less than the architecture’s page size then the sizes of <code class="language-plaintext highlighter-rouge">FileAlignment</code> and <code class="language-plaintext highlighter-rouge">SectionAlignment</code> must match.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">MajorOperatingSystemVersion</code>, <code class="language-plaintext highlighter-rouge">MinorOperatingSystemVersion</code>, <code class="language-plaintext highlighter-rouge">MajorImageVersion</code>, <code class="language-plaintext highlighter-rouge">MinorImageVersion</code>, <code class="language-plaintext highlighter-rouge">MajorSubsystemVersion</code> and <code class="language-plaintext highlighter-rouge">MinorSubsystemVersion</code>:</strong> These members of the structure specify the major version number of the required operating system, the minor version number of the required operating system, the major version number of the image, the minor version number of the image, the major version number of the subsystem and the minor version number of the subsystem respectively.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">Win32VersionValue</code>:</strong> A reserved field that the documentation says should be set to <code class="language-plaintext highlighter-rouge">0</code>.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">SizeOfImage:</code></strong> The size of the image file (in bytes), including all headers. It gets rounded up to a multiple of <code class="language-plaintext highlighter-rouge">SectionAlignment</code> because this value is used when loading the image into memory.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">SizeOfHeaders</code>:</strong> The combined size of the DOS stub, PE header (NT Headers), and section headers rounded up to a multiple of <code class="language-plaintext highlighter-rouge">FileAlignment</code>.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">CheckSum</code>:</strong> A checksum of the image file, it’s used to validate the image at load time.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">Subsystem</code>:</strong> This field specifies the Windows subsystem (if any) that is required to run the image, A complete list of the possible values of this field can be found on the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format" target="_blank" rel="noopener noreferrer">official Microsoft documentation</a>.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">DLLCharacteristics</code>:</strong> This field defines some characteristics of the executable image file, like if it’s <code class="language-plaintext highlighter-rouge">NX</code> compatible and if it can be relocated at run time.
I have no idea why it’s named <code class="language-plaintext highlighter-rouge">DLLCharacteristics</code>, it exists within normal executable image files and it defines characteristics that can apply to normal executable files.
A complete list of the possible flags for <code class="language-plaintext highlighter-rouge">DLLCharacteristics</code> can be found on the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format" target="_blank" rel="noopener noreferrer">official Microsoft documentation</a>.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">SizeOfStackReserve</code>, <code class="language-plaintext highlighter-rouge">SizeOfStackCommit</code>, <code class="language-plaintext highlighter-rouge">SizeOfHeapReserve</code> and <code class="language-plaintext highlighter-rouge">SizeOfHeapCommit</code>:</strong> These fields specify the size of the stack to reserve, the size of the stack to commit, the size of the local heap space to reserve and the size of the local heap space to commit respectively.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">LoaderFlags</code>:</strong> A reserved field that the documentation says should be set to <code class="language-plaintext highlighter-rouge">0</code>.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">NumberOfRvaAndSizes </code>:</strong> Size of the <code class="language-plaintext highlighter-rouge">DataDirectory</code> array.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">DataDirectory</code>:</strong> An array of <code class="language-plaintext highlighter-rouge">IMAGE_DATA_DIRECTORY</code> structures. We will talk about this in the next post.</p>
  </li>
</ul>

<p>Let’s take a look at the Optional Header contents of an actual PE file.</p>

<p><img src="https://0xrick.github.io/images/wininternals/pe4/3.png" alt="" class="align-center"></p>

<p>We can talk about some of these fields, first one being the <code class="language-plaintext highlighter-rouge">Magic</code> field at the start of the header, it has the value <code class="language-plaintext highlighter-rouge">0x20B</code> meaning that this is a <code class="language-plaintext highlighter-rouge">PE32+</code> executable.</p>

<p>We can see that the entry point RVA is <code class="language-plaintext highlighter-rouge">0x12C4</code> and the code section start RVA is <code class="language-plaintext highlighter-rouge">0x1000</code>, it follows the alignment defined by the <code class="language-plaintext highlighter-rouge">SectionAlignment</code> field which has the value of <code class="language-plaintext highlighter-rouge">0x1000</code>.</p>

<p>File alignment is set to <code class="language-plaintext highlighter-rouge">0x200</code>, and we can verify this by looking at any of the sections, for example the data section:</p>

<p><img src="https://0xrick.github.io/images/wininternals/pe4/4.png" alt="" class="align-center"></p>

<p>As you can see, the actual contents of the data section are from <code class="language-plaintext highlighter-rouge">0x2200</code> to <code class="language-plaintext highlighter-rouge">0x2229</code>, however the rest of the section is padded until <code class="language-plaintext highlighter-rouge">0x23FF</code> to comply with the alignment defined by <code class="language-plaintext highlighter-rouge">FileAlignment</code>.</p>

<p><code class="language-plaintext highlighter-rouge">SizeOfImage</code> is set to <code class="language-plaintext highlighter-rouge">7000</code> and <code class="language-plaintext highlighter-rouge">SizeOfHeaders</code> is set to <code class="language-plaintext highlighter-rouge">400</code>, both are multiples of <code class="language-plaintext highlighter-rouge">SectionAlignment</code> and <code class="language-plaintext highlighter-rouge">FileAlignment</code> respectively.</p>

<p>The <code class="language-plaintext highlighter-rouge">Subsystem</code> field is set to <code class="language-plaintext highlighter-rouge">3</code> which is the Windows console, and that makes sense because the program is a console application.</p>

<p>I didn’t include the <code class="language-plaintext highlighter-rouge">DataDirectory</code> in the optional header contents screenshot because we still haven’t talked about it yet.</p>

<hr>

<h3 id="conclusion" class="active">Conclusion<a class="header-link" href="https://0xrick.github.io/win-internals/pe4/#conclusion" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h3>

<p>We’ve reached the end of this post. In summary we looked at the NT Headers structure, and we discussed the File Header and Optional Header structures in detail.
<br>In the next post we will take a look at the Data Directories, the Section Headers, and the sections.
<br>Thanks for reading.</p>

        
      </section>

      

      

      
  

    </div>

    
  </article>

  
  
</div>
    </div>

    

    

    
  







  <!-- Global site tag (gtag.js) - Google Analytics -->











  

</body></html>