Title:
Theodosius – JIT Linker, Symbol Mapper, and Obfuscator

Type:
Blog Post (with linked Git repository/tool + Doxygen docs)

Short Summary (4–8 sentences max):
- This post introduces Theodosius, a proof-of-concept obfuscation framework that operates at the linker level by consuming MSVC-compatible COFF objects and static libraries rather than source or final PE binaries.  
- It aims to give the developer control over symbol discovery, symbol placement (mixing code/data), and instruction-level transformations while “recomposing” code directly into virtual memory (or optionally emitting a new COFF).  
- The article contrasts LLVM-IR obfuscation, bin2bin protectors, and linker-level obfuscation, arguing linker-level work is a useful stepping stone to bin2bin due to similar file-format concerns plus added symbol-placement control.  
- Internals covered include COFF decomposition, function sizing heuristics, relocation extraction/rebasing, recursive dependency walking to include only referenced symbols, and a pass-based obfuscation engine.  
- Built-in example passes demonstrate instruction splitting and control-flow rewriting: encrypting relocation targets, rewriting conditional branches, and chaining instructions via push/ret to move RIP.  
- It’s most useful for reverse engineers, malware/packer/protector developers, and red team toolsmiths exploring custom obfuscation/virtualization concepts on Windows x64.

Technical Focus:
- COFF/.lib parsing and symbol metadata modeling (MSVC toolchain)
- Relocation handling, rebasing, and transformation/encryption of relocation targets
- Linker-level symbol placement and in-memory “recomposition” (VirtualAlloc + resolver/copy callbacks)
- Instruction-level obfuscation passes (Intel XED-based processing)
- Control-flow rewriting (JCC rewriting, position independence considerations)
- Recursive symbol dependency resolution via relocation graph walking

Use Cases:
- Build custom obfuscation/packing pipelines that operate on COFF objects/libs before PE generation
- Prototype VMProtect-like instruction virtualization / mutation ideas in an extensible framework
- Research symbol-level layout randomization and code/data interleaving for anti-reversing
- Create bespoke loaders that map and execute recomposed code directly from libraries
- Experiment with relocation encryption and branch rewriting to hinder static analysis

Keywords:
Theodosius, COFF, static library, .lib, MSVC, linker-level obfuscation, symbol placement, symbol resolution, relocations, IMAGE_SYM_CLASS_EXTERNAL, Intel XED, x86-64, instruction splitting, .split section, JCC rewrite, RIP-relative, push/ret control flow, VirtualAlloc, EnumProcessModules, GetProcAddress