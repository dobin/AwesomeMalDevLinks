Title:
Obfuscating native code for fun: Part 1 – Introduction

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post introduces a series on building a PE bin2bin (binary-to-binary) native code obfuscator and provides a walkthrough of the author’s initial implementation.  
- It explains key PE concepts needed for rewriting binaries (sections, relocations, RIP-relative addressing, imports) and why bin2bin differs from linker/LLVM-based obfuscation.  
- The implementation uses C++23 with zasm (Zydis-based disasm/asm) and linux-pe for parsing/editing PE files, plus supporting tooling (CMake, clang-tidy/format, Python scripts with z3/graphviz).  
- A major focus is the analysis pipeline: function boundary discovery via PDB/MAP, disassembly into an IR-like container, basic-block decomposition, CFG reconstruction, and special handling for jump tables (including size estimation and expansion).  
- It outlines a transform framework (function/BB/node/instruction callbacks, scheduling, config scoping) and describes three initial obfuscation transforms: bogus control flow (opaque predicates), arithmetic substitution, and constant “encryption” via reversible math expressions.  
- The post also discusses practical “decompiler disruption” tricks targeting IDA/Binary Ninja/Ghidra (e.g., xchg/adc behaviors, microcode exceptions, negative address edge cases) and ends with PE rebuilding/linking details (new RX section, relocation regeneration, checksum).  
- Useful for red team toolsmiths, malware devs, and reverse engineers interested in obfuscation/deobfuscation and PE rewriting internals.

Technical Focus:
- PE parsing/editing (sections, imports, relocations, checksum, rebuilding)
- Function boundary recovery from PDB (CodeView70) and MAP files
- Disassembly/reassembly pipeline with zasm/Zydis; label/relocation management
- Basic-block decomposition, CFG construction, and jump table detection/expansion
- Obfuscation transforms (bogus control flow, substitution, constant encoding)
- Decompiler analysis/evasion via instruction/edge-case exploitation (IDA/Binja/Ghidra)

Use Cases:
- Build a learning-friendly foundation for a custom PE bin2bin obfuscator
- Implement CFG-aware transforms that require BB/edge correctness (e.g., BCF, flattening later)
- Rewrite functions into a new executable section and patch original code safely
- Experiment with decompiler-breaking patterns to hinder static analysis
- Develop deobfuscation tooling by mirroring the analysis pipeline (BB/CFG/jumptable recovery)

Keywords:
PE, bin2bin, obfuscator, C++23, zasm, Zydis, linux-pe, PDB, CodeView70, MAP file, RVA, relocations, RIP-relative addressing, imports, basic blocks, CFG, jump tables, opaque predicates, bogus control flow, Binary Ninja, IDA, Ghidra, ADC, XCHG, ENTER instruction, symbolic execution, checksum, section rebuilder, transform scheduler, z3, graphviz