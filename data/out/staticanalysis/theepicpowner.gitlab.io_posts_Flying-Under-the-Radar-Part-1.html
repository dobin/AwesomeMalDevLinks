# https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/

<!DOCTYPE html><html lang="en"><body><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><div class="content"><p></p><p>John Stigerwalt released a <a href="https://www.linkedin.com/posts/john-stigerwalt-90a9b4110_assemblyprogramming-cplusplus-nasm-activity-7171882426560856064-1noU?utm_source=share&amp;utm_medium=member_android">post</a> on LinkedIn which highlighted the use of assembly to retrieve Windows functions via the PEB. This naturally interested me, led to me messing with assembly and eventually led to me writing this blog. Talking about some of his research and shared content seemed like a good place to start the blog series.</p><p>Part 1 of this series will discuss a common malware development problem that affects the bypassing of both Static Detections and Dynamic Detections when working with Windows Portable Executable (PE) files. The accessing of sensitive Windows Native API functions.</p><h3 id="disclaimer"><span class="me-2">Disclaimer:</span><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#disclaimer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>I am by no means an expert in any of the below areas, and I shall describe things as per my understanding of them. I do not condone nor encourage these materials or shared knowledge to be used for any form of illegal or unethical activity. This blog is aimed at spreading knowledge about malware development techniques to security professionals.</p><h3 id="gitlab-project-for-flying-under-the-radar---part-1"><span class="me-2">GitLab Project for Flying Under the Radar - Part 1</span><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#gitlab-project-for-flying-under-the-radar---part-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>You can find all the code used within this blog <a href="https://gitlab.com/theepicpowner/flyingundertheradar/">here</a></p><h3 id="standing-on-the-shoulders-of-giants---credits--references"><span class="me-2">Standing on the Shoulders of Giants - Credits &amp; References:</span><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#standing-on-the-shoulders-of-giants---credits--references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The content of this post owes much to the invaluable knowledge generously shared by the following individuals and the materials they have authored. Their work serves as a significant reference point, and I look up to these individuals.</p><ul><li><code class="language-plaintext highlighter-rouge">@_EthicalChaos_</code> <a href="https://ethicalchaos.dev/">blog</a></li><li>John Stigerwalt <a href="https://www.linkedin.com/posts/john-stigerwalt-90a9b4110_assemblyprogramming-cplusplus-nasm-activity-7171882426560856064-1noU?utm_source=share&amp;utm_medium=member_android">post</a></li><li><code class="language-plaintext highlighter-rouge">@xen0vas</code> <a href="https://xen0vas.github.io/Win32-Reverse-Shell-Shellcode-part-2-Locate-the-Export-Directory-Table/#">blog</a></li><li><code class="language-plaintext highlighter-rouge">@ferreirasc0</code> <a href="https://ferreirasc.github.io/PE-Export-Address-Table/">blog</a></li><li><code class="language-plaintext highlighter-rouge">@CaptMeelo</code> <a href="https://captmeelo.com/redteam/maldev/2022/10/17/independent-malware.html">blog</a></li></ul><h2 id="contents"><span class="me-2">Contents</span><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#contents" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#the-problem">The Problem</a></li><li><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#resolving-modules-and-their-functions-with-x64-masm-assembly">Resolving Modules and their Functions with x64 MASM Assembly</a><ul><li><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#accessing-a-process-loaded-dll-in-x64-assembly-via-the-process-environment-block-peb">Accessing a Process Loaded DLL in x64 MASM Assembly via PEB</a></li><li><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#finding-a-function-address-in-a-the-process-loaded-dll-in-x64-assembly">Finding a Function Address in a Process Loaded DLL in x64 MASM Assembly</a></li></ul></li><li><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#compilers-and-resulting-iat-entries">Compilers and Resulting IAT Entries</a></li><li><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#conclusion">Conclusion</a></li></ul><h2 id="the-problem"><span class="me-2">The Problem</span><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#the-problem" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Function resolving can be problematic for malware developers. This can be split into a set of smaller problems.</p><p><strong>Problem #1 - Pre-execution: Static Analysis and Sandbox Environments</strong></p><p>Amongst malware developers there is a common desire to reduce the entries in a PE’s Import Address Table (IAT). The IAT provides defenders and defensive tooling an idea of what native functions a PE is calling and therefore it allows for deductions on what the PE might be doing before it is even executed. Consequently, keeping the IAT entries minimal or rather keeping suspicious Windows Native API imports out of IAT is highly desirable for malware developers.</p><p>Furthermore, often if a particular defensive security tool is uncertain of a PE following a static analysis pass, a PE may be subject to a minimal form of Dynamic Analysis in a virtual environment such as a Sandbox. This could be an attempt to confirm any suspicions raised during the Static Analysis scan. Really this is a form of Dynamic Analysis but I thought it would be more appropriate here as I consider it part of the pre-execution phase and directly dependent on Static Analysis. Local sandboxed execution is suspected to also only be performed for a very short time to avoid decreased user experiences, but in-depth Dynamic Analysis could be performed thereafter in the security vendor’s cloud container.</p><p><strong>Problem #2 - Post Execution: Dynamic Analysis</strong></p><p>If it is possible to get to the stage of PE execution, after a PE successfully passes any Static Analysis scrutiny and/or temporary Sandbox Environments, the main problem will be facing something like an EDR.</p><p>Many EDR products exist and they all function in different ways, it is my opinion that they perform some of the following:</p><ul><li><strong>User Behavioural Analysis</strong> - e.g does the user typically perform this action or have they ever?</li><li><strong>Usermode Windows Function Monitoring</strong> - e.g EDR function hooking</li><li><strong>Call Stack Analysis</strong> - Checking the origin of function calls via the Call Stack chain</li><li><strong>Process Analysis</strong> - e.g memory region analysis, remote process access, child processes, etc</li><li><strong>Kernel Callbacks</strong> - Kernelmode notifications and/or registration system that allows for some kernel drivers (e.g EDRs) to be informed of the execution of a system function</li></ul><p>If we were to consider function hooking specifically, directly accessing and calling specific Windows Native API functions is known to trigger an EDR. Therefore, resolving access to Windows Native API functions during the PE’s runtime is seen as desirable for malware developers.</p><p><strong>Existing Solutions</strong></p><p>To address both these problems malware developers have leverage usage of two common <code class="language-plaintext highlighter-rouge">kernel32.dll</code> functions - GetProcAddress and GetModuleHandle. Or have perhaps opted to use direct or indirect syscalls (which comes with its own set of challenges) and depending on the code implementations may still result in a PE file having multiple suspicious imports in IAT. Having the ability to stealthily resolve functions on a given Windows system (whether for usage, hook inspection, or to setup an direct/indirect syscalls) is highly beneficial to a threat actor.</p><p>Lets review <code class="language-plaintext highlighter-rouge">GetProcAddress</code> and <code class="language-plaintext highlighter-rouge">GetModuleHandle</code>:</p><ul><li>GetProcAddress - allows for the resolving of a process loaded DLL’s base address</li><li>GetModuleHandle - allows for the resolving of a function address based on a DLL’s base address</li></ul><p>These can be called directly which would result in entries for <em>at least</em> both these functions in IAT (an probably an EDR detection if you ever made it to the execution phase). Or more commonly, malware developers have implemented their own custom versions of these functions in their preferred programming language.</p><p>Having used C++ or C# custom implementations of these functions, I noticed that the usage of imported Windows functions accumulated and made for a lengthy IAT entries table. When implementing your own versions of GetProcAddress and GetModuleHandle in C++ or C# to resolve either <code class="language-plaintext highlighter-rouge">kernel32.dll</code> or <code class="language-plaintext highlighter-rouge">ntdll.dll</code> functions, you cannot really reduce the existing IAT entries as you are trying to achieve the very functionality you need, which is a bit of a chicken and egg problem. While some existing IAT entries may not be “suspicious” as such, I want to explore opportunities that result in a “leaner” PE IAT entries table.</p><p>So let’s explore some ideas to try and achieve stealthy Native API Windows function resolves, so that we may later inspect them, modify them, or use them to set up a direct/indirect syscall. While setting up direct/indirect syscalls won’t be part of this initial blog, it may be covered in subsequent posts of the Flying Under the Radar series.</p><blockquote class="prompt-tip"><p><strong>Note:</strong> If you are not familiar with low-level programming, I strongly recommend you read about <a href="https://theepicpowner.gitlab.io/Knowledge-Primer/#string-length-comparisons-and-obfuscation-in-x64-masm-assembly">String Length, Comparisons and Obfuscation in x64 MASM Assembly</a> and generally become more familiar with other concepts present in the <a href="https://theepicpowner.gitlab.io/Knowledge-Primer/">Knowledge Primer</a> to get the most out of my content - it will be updated over the course of the blog series.</p></blockquote><h2 id="resolving-modules-and-their-functions-with-x64-masm-assembly"><span class="me-2">Resolving Modules and their Functions with x64 MASM Assembly</span><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#resolving-modules-and-their-functions-with-x64-masm-assembly" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Resolving Windows functions requires that we have a DLL base address from which we want to search for functions. So lets start by retrieving a given process loaded DLL base address with assembly.</p><p>Lets cover the main steps of resolving a given Windows DLL base address with assembly:</p><ul><li>Access to a given Windows process loaded DLL’s base address e.g ntdll.dll<ul><li>Access to PEB via TEB</li><li>Access to <code class="language-plaintext highlighter-rouge">PEB-&gt;Ldr</code></li><li>Access to <code class="language-plaintext highlighter-rouge">PEB-&gt;Ldr-&gt;InLoadOrderModuleList</code> (double-linked list)</li><li>Traverse linked list and find target DLL by name string comparison</li><li>Accessing the target process loaded DLL’s base address and returning from the assembly function</li></ul></li></ul><h4 id="accessing-a-process-loaded-dll-in-x64-assembly-via-the-process-environment-block-peb"><span class="me-2">Accessing a process loaded DLL in x64 assembly via the Process Environment Block (PEB)</span><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#accessing-a-process-loaded-dll-in-x64-assembly-via-the-process-environment-block-peb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Let us try an resolve <code class="language-plaintext highlighter-rouge">ntdll.dll</code> from the current process.</p><p>In x64 Windows systems, the GS register points directly to the Thread Environment Block (TEB) for the current thread, which contains a pointer to the Process Environment Block (PEB). The PEB contains various information about a process, such as process parameters, environment variables, and loaded modules. In x86 Windows systems the same is true for the FS segment register.</p><p></p><p>From the above screenshot, if we were to inspect the <code class="language-plaintext highlighter-rouge">TEB</code> structure in Windbg we can see that the PEB is at offset <code class="language-plaintext highlighter-rouge">0x60</code>. Therefore, since the GS segment register already points to the current process’s TEB we can simply point to offset <code class="language-plaintext highlighter-rouge">0x60</code> in the GS register to access the value at that location - in this case the address of PEB.</p><p></p><p>Looking at the PEB structure we can see that the offset to <code class="language-plaintext highlighter-rouge">Ldr</code> is at <code class="language-plaintext highlighter-rouge">0x18</code>. In the Process Environment Block (PEB), <code class="language-plaintext highlighter-rouge">Ldr</code> points to a <code class="language-plaintext highlighter-rouge">PEB_LDR_DATA</code> structure. This structure is used to manage loaded modules (such as DLLs) in the current process. It includes information about loaded modules, most importantly, their base addresses and name.</p><p>The <code class="language-plaintext highlighter-rouge">PEB_LDR_DATA</code> structure looks like this:</p><p></p><p>We are most interested in <code class="language-plaintext highlighter-rouge">InLoadOrderModuleList</code> which points to a double linked list. The linked list allows us to navigate between the <code class="language-plaintext highlighter-rouge">LDR_DATA_TABLE_ENTRY</code> structures that contain loaded module information.</p><p>The <code class="language-plaintext highlighter-rouge">LDR_DATA_TABLE_ENTRY</code> structure looks like so:</p><p></p><p>Within <code class="language-plaintext highlighter-rouge">LDR_DATA_TABLE_ENTRY</code> we can see the <code class="language-plaintext highlighter-rouge">dllBase</code> at offset <code class="language-plaintext highlighter-rouge">0x30</code> and the <code class="language-plaintext highlighter-rouge">baseDllname</code> (DLL name) at offset <code class="language-plaintext highlighter-rouge">0x58</code>. Note as we are traversing the loaded module linked list, our “default” position/offset in each accessed linked list <code class="language-plaintext highlighter-rouge">LDR_DATA_TABLE_ENTRY</code> struct entry will be at <code class="language-plaintext highlighter-rouge">0x10</code> (<code class="language-plaintext highlighter-rouge">InMemoryOrderLinks</code>).</p><p>Now that the basics of what we are trying to achieve are covered, we can implement assembly code.</p><p>Example x64 MASM assembly to resolve the ntdll.dll base address can be represented as such:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>GetNtdllBase proc
    ; Load the address of PEB into RAX via GS segment
    xor rax, rax
    mov rax, gs:[60h]  

    ; Navigating PEB-&gt;Ldr-&gt;InLoadOrderModuleList
    mov rax, [rax + 18h]         ; Offset of PEB-&gt;Ldr in PE
    mov rax, [rax + 20h]         ; Offset of Ldr-&gt;InLoadOrderModuleList 
	; Ldr-&gt;InLoadOrderModuleList points to the first LDR_DATA_TABLE_ENTRY structure in the linked list

	; We are currently at linked list node 0 (PE itself) so we can dereference once to get to node 1 (ntdll.dll)
	mov rax, [rax] 
	; Since we are in LDR_DATA_TABLE_ENTRY and already at offset 0x10 (InMemoryOrderLinks)
	; We add 0x20 to access the dllBase address (offset 0x30) value by dereferencing
	mov rax, [rax + 20h]  	 

	; We now have NTDLL.DLL base address in rax which we can return
	; or use for further assembly operations
	ret 
GetNtdllBase endp
</pre></td></tr></tbody></table></code></div></div><p>We can test the above <code class="language-plaintext highlighter-rouge">GetNtdllBase</code> assembly function with some C++ code in a MASM enabled VS project:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

// Assembly function declarations
extern "C" DWORD_PTR GetNtdllBase();

int main() {
    // resolve ntdll.dll base address 
    DWORD_PTR TargetAddr=0;  
    TargetAddr = (DWORD_PTR)GetNtdllBase(); 
    if (TargetAddr) {        
        printf("ntdll.dll base address (Assembly DLL resolve via PEB): 0x%p \n", TargetAddr);
    } else {
        printf("Failed to get %s base address \n", dllName);
        return 1;
    }
    getchar(); // effectively pause EXE by getting user input
    return 0;
}
</pre></td></tr></tbody></table></code></div></div><p>Execution result: </p><p>Now that the basics of getting access to process loaded DLL bases addresses are covered, we can build on the assembly so that it allows us to resolve the base address of ANY process loaded DLL. The easiest way to do that, would be to search <code class="language-plaintext highlighter-rouge">LDR_DATA_TABLE_ENTRY</code> entries the <code class="language-plaintext highlighter-rouge">InLoadOrderModuleList</code> linked list for <code class="language-plaintext highlighter-rouge">DllBaseName</code> (offset 0x58) values that match the DLL name we wish to resolve.</p><p>As a simple demonstration, it is possible to navigate through the linked list modules in x64 MASM assembly, by dereferencing the <code class="language-plaintext highlighter-rouge">rax</code> register like so:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>...
; Load the address of PEB into RAX via GS segment
xor rax, rax
mov rax, gs:[60h]  

; Navigating PEB-&gt;Ldr-&gt;InLoadOrderModuleList
mov rax, [rax + 18h]         ; Offset of PEB-&gt;Ldr in PE
mov rax, [rax + 20h]         ; Offset of Ldr-&gt;InLoadOrderModuleList 
; Ldr-&gt;InLoadOrderModuleList points to the first LDR_DATA_TABLE_ENTRY structure in the linked list

; currently linked list head points to PE itself LDR_DATA_TABLE_ENTRY struct
mov rax, [rax] ; move to next linked list node [1] e.g typically ntdll.dll LDR_DATA_TABLE_ENTRY struct
mov rax, [rax] ; move to next linked list node [2] e.g typically kernel32.dll LDR_DATA_TABLE_ENTRY struct
; etc    
...
</pre></td></tr></tbody></table></code></div></div><p>You can get a rough idea of the <code class="language-plaintext highlighter-rouge">DllBaseName</code> structure here: </p><p>Once you access the <code class="language-plaintext highlighter-rouge">DllBaseName</code> struct you will find its Length at offset <code class="language-plaintext highlighter-rouge">0x00</code> and its content buffer at <code class="language-plaintext highlighter-rouge">0x8</code>. Keep in mind that the buffer points to the base address of a character array, each character being separated by a null byte.</p><p>At a high level this would look like this in x64 MASM assembly:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>...
; We are in a given module LDR_DATA_TABLE_ENTRY struct from the module linked list..
; default location is offset +0x10 in current LDR_DATA_TABLE_ENTRY struct

; DllBaseName should be at 0x58-0x10 (offset 0x48) 
; DllBaseName struct has Length attribute at 0x00, therefore at [rax + 48h]
; Divide length by 2 to account for null byte separators
xor rdx, rdx
mov dx, word ptr [rax + 48h] ; length of module name 
; length of string with every char succeeded by a NULL byte so twice the length of characters
; we therefore need to divide the length by 2, to get the number of characters
shr rdx, 1 

; Compare current module baseDLLName with target dllName length 
cmp rdx, r13
; if length not equal move to next item
jnz module_loop 
; if equal move to byte-by-byte comparison of the two strings

; Compare each byte in current module DllBaseName string with our target dllName string
; If strings match, find the base address of current module    

; prep for string comparison function call
; rbx contains module string length
mov rcx, [rax + 48h + 8h] ; access current module string pointer as arg1
mov rdx, r12 ; target module name as arg2
mov r8, r13  ; length as arg3
...
</pre></td></tr></tbody></table></code></div></div><blockquote class="prompt-info"><p><strong>Note</strong>: You can find a full custom x64 assembly implementation of <code class="language-plaintext highlighter-rouge">GetProcAddress</code> and its supporting C++ code <a href="https://gitlab.com/theepicpowner/flyingundertheradar/-/tree/main/Concepts/CustomGetProcAddress?ref_type=heads">here</a></p></blockquote><h4 id="finding-a-function-address-in-a-the-process-loaded-dll-in-x64-assembly"><span class="me-2">Finding a function address in a the process loaded DLL in x64 assembly</span><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#finding-a-function-address-in-a-the-process-loaded-dll-in-x64-assembly" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Sticking with above example, we will also focus this section on ntdll.dll and resolving an arbitrary function address - in this case we will use <code class="language-plaintext highlighter-rouge">NtDelayExecution</code>.</p><p>At a high level - in order to resolve a function address from a process loaded DLL, the most important requirements are a base address to the DLL we wish to access and the name of the function we want to resolve. To be consistent with the section above, we shall use ntdll.dll as the DLL and <code class="language-plaintext highlighter-rouge">NtDelayExecution</code> as the function we wish to resolve.</p><p>The overall function resolving process will look like so:</p><ul><li>Getting access to the PE Header, Export Table, and Names Table from the process loaded module/DLL base address<ul><li>PE Header: <code class="language-plaintext highlighter-rouge">DOS-&gt;e_lfanew</code> + module base address</li><li>Export Table: PE Header + offset to <code class="language-plaintext highlighter-rouge">DataDirectory</code> (total offset 0x88)</li><li>Names Table: Export Table address + <code class="language-plaintext highlighter-rouge">AddressOfNames</code> offset (0x20)</li><li>Ordinal Names Table: Export Table address + <code class="language-plaintext highlighter-rouge">AddressOfOrdinalNames</code> offset (0x24)</li><li>Function Address Table: Export Table address + <code class="language-plaintext highlighter-rouge">AddressOfFunctions</code> offset (0x1C)</li></ul></li><li>Start by iterating through the <code class="language-plaintext highlighter-rouge">AddressOfNames</code> entries<ul><li>Perform string comparisons to find our desired function name</li><li>Save <code class="language-plaintext highlighter-rouge">AddressOfNames</code> array index on match</li></ul></li><li>Lookup the stored <code class="language-plaintext highlighter-rouge">AddressOfNames</code> array index in the <code class="language-plaintext highlighter-rouge">AddressOfNameOrdinals</code> array<ul><li>Save ordinal value at that <code class="language-plaintext highlighter-rouge">AddressOfNameOrdinals</code> array index</li></ul></li><li>Based on the saved function ordinal, access <code class="language-plaintext highlighter-rouge">AddressOfFunctions</code> array at using the ordinal as the index<ul><li>Retrieve the function address</li></ul></li><li>Return function address</li></ul><p>In order to access the PE Header we need to add the value pointed by of<code class="language-plaintext highlighter-rouge">DOS-&gt;e_lfanew</code> to the module base address. <code class="language-plaintext highlighter-rouge">DOS-&gt;e_lfanew</code> is the offset to the PE Header and is defined within the <code class="language-plaintext highlighter-rouge">IMAGE_DOS_HEADER</code> struct.</p><p></p><p><a href="https://xen0vas.github.io/Win32-Reverse-Shell-Shellcode-part-2-Locate-the-Export-Directory-Table/#">Source</a></p><p>The PE Header is defined in a <code class="language-plaintext highlighter-rouge">IMAGE_NT_HEADER64</code> struct which can be seen below. Now that we have the PE Header, we want to access the <code class="language-plaintext highlighter-rouge">IMAGE_EXPORT_DIRECTORY</code> struct. To resolve it, we need to add <code class="language-plaintext highlighter-rouge">DataDirectory</code> at offset <code class="language-plaintext highlighter-rouge">0x88</code> (OptionalHeader offset + DataDirectory offset) to our PE Header address:</p><p></p><p>Now that we have the address of the Export Table, we need to pinpoint 3 other key tables nested within that will allow us to perform our function lookup:</p><ul><li><code class="language-plaintext highlighter-rouge">AddressOfNames</code> - Names Table</li><li><code class="language-plaintext highlighter-rouge">AddressOfOrdinalNames</code> - Ordinal Names Table</li><li><code class="language-plaintext highlighter-rouge">AddressOfFunctions</code> - Function Address Table</li></ul><p>We see the 3 key tables are all contained in the Export Table represented as a <code class="language-plaintext highlighter-rouge">IMAGE_EXPORT_DIRECTORY</code> struct (shown below). </p><p><a href="https://xen0vas.github.io/Win32-Reverse-Shell-Shellcode-part-2-Locate-the-Export-Directory-Table/#">Image Source</a></p><p>Let’s discuss the interdependance of the <code class="language-plaintext highlighter-rouge">AddressOfNames</code>, <code class="language-plaintext highlighter-rouge">AddressOfOrdinalNames</code> and <code class="language-plaintext highlighter-rouge">AddressOfFunctions</code> tables and how one should navigate them to resolve a desired function address.</p><ul><li>Iterate the <code class="language-plaintext highlighter-rouge">AddressOfNames</code> array from <code class="language-plaintext highlighter-rouge">i=0</code> to <code class="language-plaintext highlighter-rouge">i=(NumberOfNames-1)</code>, comparing <code class="language-plaintext highlighter-rouge">AddressOfNames[i]</code> with the string <code class="language-plaintext highlighter-rouge">name3</code>.</li><li>Once we have a match in the <code class="language-plaintext highlighter-rouge">i</code> position, the loader will refer to <code class="language-plaintext highlighter-rouge">AddressOfNameOrdinals[i]</code> and get the ordinal associated to this function. Let’s suppose that <code class="language-plaintext highlighter-rouge">AddressOfNameOrdinals[i] = 4</code>.</li><li>Having the <code class="language-plaintext highlighter-rouge">ordinal = 4</code>, the loader will now refer to <code class="language-plaintext highlighter-rouge">AddressOfFunctions</code> on 4th position, that is <code class="language-plaintext highlighter-rouge">AddressOfFunctions[4]</code>, to finally get the RVA associated to the <code class="language-plaintext highlighter-rouge">name3</code> function.</li></ul><p></p><p><a href="https://ferreirasc.github.io/PE-Export-Address-Table/">Image Source</a></p><p>We can retrieve and use the above mentioned tables like so in x64 MASM assembly:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre>        ...
        ; set functionName rcx (arg1) to r9 as pointer
        mov r9, rcx  
       	; set length of string rdx (arg2) to r13 (value?)
        mov r13, rdx  
        ; pass r8 (arg3) which has module base address into r11
        mov r11, r8        

        ; pass PE HEADER to resolve export table for function symbol search
        xor r8, r8                        ; Clear R8               
        mov r8d, dword ptr [r11 + 3Ch]
        mov rdx, r8                		  ; Move DOS-&gt;e_lfanew to RDX
        add rdx, r11                      ; Calculate PE Header address + base address
        ; rdx should now point to PE header
        mov r8d, dword ptr [rdx + 88h]    ; Calculate offset to the export table (OptionalHeader (0x18) + DataDirectory (0x70) offsets)
        add r8, r11                       ; Update R8 to point to the export table
        ; r8 should now point to Export Table
        sub rsi, rsi                      ; Clear RSI
        mov esi, dword ptr [r8 + 20h]     ; Calculate the offset to the names table with split offsets
        add rsi, r11                      ; Update RSI to point to the names table
        ; rsi should now point to Names Table
        mov r12, 0                        ; Initialize RCX to 0
        ...
        ; string comparisons occur here, r12 is the loop counter
        ; r12 contains correct ordinal numbers after search loop completes
        ...
        ; once we find the correct names table entry via string comparisons               
        sub rsi, rsi                  ; Clear RSI
        mov esi, [r8 + 20h + 4h]      ; Calculate offset to the ordinals table 
        add rsi, r11                  ; Update RSI to point to the ordinals table
        mov r12w, [rsi + r12 * 2]     ; Load ordinal number 
        sub rsi, rsi                  ; Clear RSI again
        mov esi, [r8 + 0eh + 0eh]     ; Calculate offset to the address table
        add rsi, r11                  ; Update RSI to point to the address table
        mov rdx, 0                    ; Clear RDX
        mov edx, [rsi + r12 * 4]      ; Load the function address (offset)
        add rdx, r11                  ; Calculate the actual function address
        ...
</pre></td></tr></tbody></table></code></div></div><p>Execution result: </p><blockquote class="prompt-info"><p><strong>Note</strong>: You can find a full custom x64 assembly implementation of <code class="language-plaintext highlighter-rouge">GetModuleHandle</code> and its supporting C++ code can be found <a href="https://gitlab.com/theepicpowner/flyingundertheradar/-/tree/main/Concepts/CustomGetProcAddress?ref_type=heads">here</a></p></blockquote><h2 id="compilers-and-resulting-iat-entries"><span class="me-2">Compilers and Resulting IAT Entries</span><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#compilers-and-resulting-iat-entries" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Let’s explore the IAT entries of our PE’s post compilation. Starting with the results of the Visual Studio C++ compiler.</p><p><strong>MSVC</strong> Compiling with Visual Studio 2022 (MASM dependencies added) results in many random imports. </p><p>Even though we don’t directly call any <code class="language-plaintext highlighter-rouge">KERNEL32.dll</code> functions in our x64 MASM assembly code or in our C++ code, its likely the compiler added these entries in at compilation time. Playing around with different compilers and their options could allow us to reduce some such imports but probably not <em>all</em> imports as these listed function APIs are used the PE’s CRT (C runtime) library e.g <code class="language-plaintext highlighter-rouge">ucrt</code> or <code class="language-plaintext highlighter-rouge">msvcrt</code> in functions referenced by the startup or essential runtime code which is linked into every executable by default.</p><p>It is possible to compile PE’s without a CRT but we would lose access to common functionality offered by it. Perhaps it is possible to implement all required functions in x64 MASM assembly or resolve these with our custom <code class="language-plaintext highlighter-rouge">GetBase</code> and <code class="language-plaintext highlighter-rouge">resolveFunc</code> assembly functions, but this would require further exploring.</p><p>This <a href="https://captmeelo.com/redteam/maldev/2022/10/17/independent-malware.html">blog</a> shows how you might try to reduce IAT compiler or CRT imports with Visual Studio C++ compilations, but potentially at the cost of your code no longer working. It is worth playing around with settings, you might eventually achieve some good results:</p><p>In VS Project Settings - we can do things like:</p><ul><li><code class="language-plaintext highlighter-rouge">C/C++ -&gt; Code Generation</code> - Change Runtime Library to <code class="language-plaintext highlighter-rouge">/MT</code> (Static Linking)</li><li><code class="language-plaintext highlighter-rouge">Linker-&gt;Input</code> - Disable DefaultLibs</li><li><code class="language-plaintext highlighter-rouge">C/C++ -&gt; Code Generation</code> - Disable Security Checks</li><li><code class="language-plaintext highlighter-rouge">C/C++&gt;All Options&gt;Basic Runtime Checks</code> - Disable Basic Runtime Checks by setting <code class="language-plaintext highlighter-rouge">Default</code></li><li><code class="language-plaintext highlighter-rouge">Linker-&gt;Advanced</code> - Set Entrypoint e.g <code class="language-plaintext highlighter-rouge">main</code></li></ul><p>Trying these on our code would give us an error as we are not resolving <code class="language-plaintext highlighter-rouge">printf</code> which is defined in CRT (C Runtime) </p><p>If we wanted we could implement our own <code class="language-plaintext highlighter-rouge">printf</code> function, attempt to resolve it with our custom <code class="language-plaintext highlighter-rouge">GetBase</code> and <code class="language-plaintext highlighter-rouge">resolveFunction</code> assembly functions or perhaps find some way achieving minimal linking with compiler options. However, if we perform the above modifications and remove our references of usage of <code class="language-plaintext highlighter-rouge">printf</code> and <code class="language-plaintext highlighter-rouge">stdio.h</code> from our code completely, we notice that if we debug in VS the code still works and the resulting PE has <em>NO</em> imports whatsoever.</p><p>Whether this is a pro or con, will need to be determined. As we need to consider that having no IAT entries could be more suspicious than having some common CRT ones. Researching this will be an exercise left to the reader. </p><p><strong>MinGW</strong> We can explore results offered by other compilers, let us consider the <code class="language-plaintext highlighter-rouge">MinGW for Windows</code> compiler. I installed it via <code class="language-plaintext highlighter-rouge">Chocolatey</code> with the help of this <a href="https://medium.com/@_arupbasak_/setup-c-c-compiler-easiest-way-470db3f1000c#:~:text=C%2FC%2B%2B%20has%20many%20compiler,popular%20choice%20for%20Windows%20users.">blog</a>.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>choco install mingw
</pre></td></tr></tbody></table></code></div></div><p>We can assemble an object file with the x64 MASM assembly like so in x64 Native Tools for VS command prompt:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>ml64 /c /Fo asm.obj test.asm
</pre></td></tr></tbody></table></code></div></div><p>Then with <code class="language-plaintext highlighter-rouge">MinGW for Windows</code> create an object file for our C++ code, and finally link both together to produce an EXE:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>g++ -m64 -c PersASM.cpp -o PersASM.o
g++ -o MinGWPersASM.exe PersASM.o asm.obj
</pre></td></tr></tbody></table></code></div></div><p>We see the overall IAT entries number is significantly less in our PE than with Visual Studio compilations (34 less entries): </p><p>This appears already better than the default PE created by the <code class="language-plaintext highlighter-rouge">Visual Studio 2022</code> compiler. But the <code class="language-plaintext highlighter-rouge">MinGW g++</code> compiler or it’s CRT, imports this one semi-suspicious <code class="language-plaintext highlighter-rouge">KERNEL32.dll</code> function - <code class="language-plaintext highlighter-rouge">VirtualProtect</code>.</p><p><strong>LLVM/CLANG</strong> Lets look at <code class="language-plaintext highlighter-rouge">LLVM/CLANG</code> for Windows.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>choco install llvm
</pre></td></tr></tbody></table></code></div></div><p>Then compiled an object file with the x64 MASM assembly like so in x64 Native Tools for VS command prompt:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>ml64 /c /Fo asm.obj test.asm
</pre></td></tr></tbody></table></code></div></div><p>And then also with LLVM/Clang for Windows compiled an object from the c++ code, and finally produced the EXE:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>clang++ -m64 -c .\PersASM.cpp -o .\PersASM.o
clang++ -m64 .\PersASM.o .\asm.obj -o ClangPersASM.exe -v -nostdlib -lmsvcrt -nostartfiles
</pre></td></tr></tbody></table></code></div></div><p>Clang compile: </p><p>There is no <code class="language-plaintext highlighter-rouge">VirtualProtect</code> IAT entry as with <code class="language-plaintext highlighter-rouge">MinGW</code>, but we do have <em>even</em> less IAT entries overall with <code class="language-plaintext highlighter-rouge">LLVM/Clang</code>. Based on PEStudio’s output, there are also slight suspicions on our IAT entries for <code class="language-plaintext highlighter-rouge">GetCurrentProcessId</code>, <code class="language-plaintext highlighter-rouge">GetCurrentThreadId</code> and <code class="language-plaintext highlighter-rouge">RtlLookupFunctionEntry</code>.</p><p>We have explored the PE files outputted by various compilation techniques, and have seen how different compilers impact our IAT entries and we even briefly explored how we could achieve <em>NO</em> IAT entries at all. Ultimately, apart from the compiler additions to the IAT table we still have the ability to mask suspicious function usage with our custom <code class="language-plaintext highlighter-rouge">GetBase</code> and <code class="language-plaintext highlighter-rouge">resolveFunc</code> assembly functions.</p><h2 id="conclusion"><span class="me-2">Conclusion</span><a href="https://theepicpowner.gitlab.io/posts/Flying-Under-the-Radar-Part-1/#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>So let’s recap what was covered in the Flying Under the Radar series - Part 1:</p><ul><li>We covered Windows structures specific to processes e.g PEB</li><li>We covered in detail how to access process loaded modules and resolve their functions via PEB</li><li>Lastly we also performed some analysis on the outputted PE’s based on various Windows compilers</li></ul><p>Next, let’s discuss Indirect Syscalls and their benefits. And discuss the opportunity to potentially make them better.</p><p>Hopefully you enjoyed the blog or have gained some ideas of you own as to how you can improve your malware development process, and defeat Static &amp; Dynamic Analysis. Don’t hesitate to reach out to me if you have any feedback.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="https://theepicpowner.gitlab.io/categories/maldev/">Maldev</a>, <a href="https://theepicpowner.gitlab.io/categories/flying-under-the-radar/">Flying Under the Radar</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="https://theepicpowner.gitlab.io/tags/malware/" class="post-tag no-text-decoration">Malware</a> <a href="https://theepicpowner.gitlab.io/tags/maldev/" class="post-tag no-text-decoration">Maldev</a> <a href="https://theepicpowner.gitlab.io/tags/native-api/" class="post-tag no-text-decoration">Native API</a> <a href="https://theepicpowner.gitlab.io/tags/c/" class="post-tag no-text-decoration">C++</a> <a href="https://theepicpowner.gitlab.io/tags/assembly/" class="post-tag no-text-decoration">Assembly</a> <a href="https://theepicpowner.gitlab.io/tags/masm/" class="post-tag no-text-decoration">MASM</a> <a href="https://theepicpowner.gitlab.io/tags/stealth/" class="post-tag no-text-decoration">Stealth</a> <a href="https://theepicpowner.gitlab.io/tags/offensive-security/" class="post-tag no-text-decoration">Offensive-security</a> <a href="https://theepicpowner.gitlab.io/tags/iat/" class="post-tag no-text-decoration">IAT</a> <a href="https://theepicpowner.gitlab.io/tags/pe/" class="post-tag no-text-decoration">PE</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 "><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Flying%20Under%20the%20Radar:%20Part%201:%20Resolving%20Sensitive%20Windows%20Functions%20with%20x64%20Assembly%20-%20Theepicpowner%27s%20blog&amp;url=https%3A%2F%2Ftheepicpowner.gitlab.io%2Fposts%2FFlying-Under-the-Radar-Part-1%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Flying%20Under%20the%20Radar:%20Part%201:%20Resolving%20Sensitive%20Windows%20Functions%20with%20x64%20Assembly%20-%20Theepicpowner%27s%20blog&amp;u=https%3A%2F%2Ftheepicpowner.gitlab.io%2Fposts%2FFlying-Under-the-Radar-Part-1%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Ftheepicpowner.gitlab.io%2Fposts%2FFlying-Under-the-Radar-Part-1%2F&amp;text=Flying%20Under%20the%20Radar:%20Part%201:%20Resolving%20Sensitive%20Windows%20Functions%20with%20x64%20Assembly%20-%20Theepicpowner%27s%20blog" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="https://theepicpowner.gitlab.io/tags/malware/">Malware</a> <a class="post-tag btn btn-outline-primary" href="https://theepicpowner.gitlab.io/tags/assembly/">Assembly</a> <a class="post-tag btn btn-outline-primary" href="https://theepicpowner.gitlab.io/tags/c/">C++</a> <a class="post-tag btn btn-outline-primary" href="https://theepicpowner.gitlab.io/tags/flying-under-the-radar/">Flying Under the Radar</a> <a class="post-tag btn btn-outline-primary" href="https://theepicpowner.gitlab.io/tags/iat/">IAT</a> <a class="post-tag btn btn-outline-primary" href="https://theepicpowner.gitlab.io/tags/maldev/">Maldev</a> <a class="post-tag btn btn-outline-primary" href="https://theepicpowner.gitlab.io/tags/masm/">MASM</a> <a class="post-tag btn btn-outline-primary" href="https://theepicpowner.gitlab.io/tags/native-api/">Native API</a> <a class="post-tag btn btn-outline-primary" href="https://theepicpowner.gitlab.io/tags/offensive-security/">Offensive-security</a> <a class="post-tag btn btn-outline-primary" href="https://theepicpowner.gitlab.io/tags/pe/">PE</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div></div><div id="mask"></div>     
</body></html>