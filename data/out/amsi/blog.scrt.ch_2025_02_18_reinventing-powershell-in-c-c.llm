Title:
Reinventing PowerShell in C/C++ (PowerChell)

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post shows how to host the .NET CLR from a native C/C++ program to instantiate a real interactive PowerShell console (via `Microsoft.PowerShell.ConsoleShell.Start`) without launching `powershell.exe`.  
- It then demonstrates in-process patching to disable or bypass multiple PowerShell security controls, combining unmanaged patching (e.g., AMSI) with “unmanaged .NET patching” of JIT-compiled managed methods.  
- Techniques covered include a 1-byte patch of `AmsiOpenSession`, disabling PowerShell ETW logging by flipping `System.Diagnostics.Eventing.EventProvider.m_enabled`, and patching managed methods to neuter Transcription and Execution Policy enforcement.  
- For CLM, it patches `SystemSecurity.GetSystemLockdownPolicy()` to force “no enforcement,” restoring `FullLanguage` even when AppLocker script rules would normally trigger CLM.  
- It also discusses operational constraints like AppLocker executable rules and shows using a DLL + `rundll32` (or sideloading) when `.exe` execution is blocked.  
- Useful for red teamers and offensive tool developers interested in native tradecraft, CLR hosting, and memory patching paths that avoid common .NET/PowerShell execution artifacts.

Technical Focus:
- CLR hosting from native code (ICLRMetaHost/ICorRuntimeHost, AppDomains)
- COM interop types (BSTR, VARIANT, SAFEARRAY) to invoke managed methods
- AMSI bypass via in-memory patching (`amsi.dll!AmsiOpenSession`)
- PowerShell logging bypass via ETW provider manipulation (PSEtwLogProvider/EventProvider)
- Unmanaged patching of managed/JITted methods (`RuntimeMethodHandle.GetFunctionPointer`, `RuntimeHelpers.PrepareMethod`)
- CLM/AppLocker enforcement internals (`GetSystemLockdownPolicy`, script/exe rule implications)

Use Cases:
- Build a native PowerShell host for post-exploitation without `powershell.exe`
- Research/validate AMSI and PowerShell logging bypass detections
- Disable Script Block/Module logging by targeting PowerShell’s ETW provider rather than global ETW syscalls
- Bypass enforced Execution Policy and CLM via targeted managed-method patching
- Operate under AppLocker by delivering as DLL and executing via `rundll32` or sideloading

Keywords:
PowerChell, CLR hosting, ICLRMetaHost, ICorRuntimeHost, AppDomain, System.Management.Automation, Microsoft.PowerShell.ConsoleShell.Start, COM interop, VARIANT, SAFEARRAY, AMSI, amsi.dll, AmsiOpenSession, ETW, PSEtwLogProvider, System.Diagnostics.Eventing.EventProvider, Script Block Logging, Module Logging, Transcription, RuntimeHelpers.PrepareMethod, RuntimeMethodHandle.GetFunctionPointer, Execution Policy, AuthorizationManager.ShouldRunInternal, Constrained Language Mode, GetSystemLockdownPolicy, AppLocker, rundll32, DLL sideloading, VirtualProtectEx, in-memory patching