Title:
New AMSI Bypass Using CLR Hooking

Type:
Blog Post

Short Summary (4â€“8 sentences max):
- The post describes an AMSI bypass that hooks a managed (.NET/CLR) PowerShell method instead of patching native AMSI exports like `amsi.dll!AmsiScanBuffer`.  
- It targets `System.Management.Automation.AmsiUtils.ScanContent` (internal, static) and overwrites its JIT-compiled machine code in memory to redirect execution to a stub that always returns `AMSI_RESULT_NOTDETECTED`.  
- The technique uses reflection to locate the internal method, forces JIT compilation via `RuntimeHelpers.PrepareMethod`, obtains function pointers with `MethodHandle.GetFunctionPointer`, and patches the prologue with architecture-specific jump/call bytes.  
- Memory patching is performed with `VirtualProtect`, `WriteProcessMemory`, and `FlushInstructionCache` via P/Invoke, then permissions are restored.  
- It includes two PowerShell integration approaches: dynamic compilation with `Add-Type` and reflective in-memory loading of a Base64-encoded assembly.  
- Useful for red teams/pentesters and malware developers working in PowerShell/.NET, and interesting because it shifts the bypass surface to CLR-managed code paths that may evade some EDR rules focused on native AMSI tampering.

Technical Focus:
- AMSI bypass via managed method hooking (CLR/JIT patching)
- PowerShell internals (`System.Management.Automation.AmsiUtils.ScanContent`)
- Reflection on non-public .NET types/methods
- JIT control (`RuntimeHelpers.PrepareMethod`, `MethodHandle.GetFunctionPointer`)
- In-memory code patching and permission changes (`VirtualProtect`, `WriteProcessMemory`, `FlushInstructionCache`)
- PowerShell delivery (Add-Type compilation, reflective assembly load)

Use Cases:
- Bypassing AMSI scanning in a PowerShell process to execute known-signature tooling (e.g., Mimikatz) post-bypass
- Researching/validating EDR detections for managed-code tampering vs native AMSI patching
- Building tradecraft for in-memory .NET method redirection/hooking in offensive tooling
- Developing defensive detections around JIT method patching and suspicious `VirtualProtect/WriteProcessMemory` patterns in PowerShell-hosted processes

Keywords:
AMSI, Anti-Malware Scan Interface, PowerShell, PowerShell Core, System.Management.Automation, AmsiUtils, ScanContent, CLR hooking, managed API hooking, JIT compilation, RuntimeHelpers.PrepareMethod, MethodHandle.GetFunctionPointer, reflection, BindingFlags.NonPublic, VirtualProtect, WriteProcessMemory, FlushInstructionCache, P/Invoke, Add-Type, reflective assembly load