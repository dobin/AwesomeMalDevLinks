# https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft

[Skip to content](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#main-content)[IBM logo](https://www.ibm.com/)

Software

Infrastructure

[Consulting](https://www.ibm.com/consulting?lnk=L0G)Support

[Overview](https://www.ibm.com/mysupport/s/?language=en_US&lnk=flathl)[Community](https://community.ibm.com/community/user/community?lnk=flathl)[Developer](https://developer.ibm.com/?lnk=flathl)[Documentation](https://www.ibm.com/docs/en?lnk=flathl)[IBM Cloud platform](https://www.ibm.com/products/cloud/support?lnk=flathl)[Implementation](https://www.ibm.com/products/expertlabs?lnk=flatitem)[Training](https://www.ibm.com/training/?lnk=flathl)[Technology Lifecycle Services](https://www.ibm.com/services/technology-lifecycle-services?lnk=flathl)[Think](https://www.ibm.com/think)

[Cart](https://www.ibm.com/store/en/us/checkout)

My IBM
Log in


[Think](https://www.ibm.com/think)

- [Artificial intelligence](https://www.ibm.com/think/artificial-intelligence)
- [Cloud](https://www.ibm.com/think/cloud)
- [Security](https://www.ibm.com/think/security)
- [News](https://www.ibm.com/think/news)
- Videos






  - [Overview](https://www.ibm.com/think/videos)
  - [AI Academy](https://www.ibm.com/think/videos/ai-academy)
  - [Think 2025 on demand](https://www.ibm.com/think/videos/think-keynotes)
  - [Webinars](https://www.ibm.com/think/webinars)

- Reports






  - [Cost of a Data Breach Report 2025](https://www.ibm.com/reports/data-breach)
  - [The 2025 CEO Study](https://www.ibm.com/thought-leadership/institute-business-value/c-suite-study/ceo)
  - [IBM X-Force 2025 Threat Intelligence Index](https://www.ibm.com/thought-leadership/institute-business-value/report/2025-threat-intelligence-index)
  - [Industries in the AI era](https://www.ibm.com/thought-leadership/institute-business-value/report/industries-ai-era)
  - [Orchestrating agentic AI for intelligent business operations](https://www.ibm.com/thought-leadership/institute-business-value/report/agentic-process-automation)
  - [Scaling supply chain resilience: Agentic AI for autonomous operations](https://www.ibm.com/thought-leadership/institute-business-value/report/supply-chain-ai-automation-oracle)
  - [AI in Action report](https://www.ibm.com/think/reports/ai-in-action)
  - [State of Sustainability Readiness Report](https://www.ibm.com/think/reports/sustainability-readiness)
  - [View all IBV reports](https://www.ibm.com/thought-leadership/institute-business-value)

- Podcasts






  - [Overview](https://www.ibm.com/think/podcasts)
  - [AI in Action](https://www.ibm.com/think/podcasts/ai-in-action)
  - [Mixture of Experts](https://www.ibm.com/think/podcasts/mixture-of-experts)
  - [Security Intelligence](https://www.ibm.com/think/podcasts/security-intelligence)
  - [Smart Talks with IBM](https://www.ibm.com/think/podcasts/smart-talks)
  - [Techsplainers](https://www.ibm.com/think/podcasts/techsplainers)
  - [The Coherence Times](https://www.ibm.com/think/podcasts/the-coherence-times)
  - [Transformers Podcast](https://www.ibm.com/think/podcasts/transformers-podcast)

- Events






  - [Think 2026](https://www.ibm.com/events/think)
  - [Think on Tour](https://www.ibm.com/events/think/on-tour)
  - [TechXchange](https://www.ibm.com/events/techxchange)
  - [View all IBM Events](https://www.ibm.com/events)

- More






## Topics



  - [Analytics](https://www.ibm.com/think/analytics)
  - [Asset management](https://www.ibm.com/think/asset-management)
  - [Business automation](https://www.ibm.com/think/business-automation)
  - [Business operations](https://www.ibm.com/think/business-operations)
  - [Compute and servers](https://www.ibm.com/think/compute)
  - [DevOps](https://www.ibm.com/think/devops)
  - [IT automation](https://www.ibm.com/think/it-automation)
  - [IT infrastructure](https://www.ibm.com/think/it-infrastructure)
  - [Middleware](https://www.ibm.com/think/middleware)
  - [Network](https://www.ibm.com/think/network)
  - [Quantum](https://www.ibm.com/think/quantum)
  - [Security](https://www.ibm.com/think/security)
  - [Storage](https://www.ibm.com/think/storage)
  - [Sustainability](https://www.ibm.com/think/sustainability)

## Content types

  - [Explainers](https://www.ibm.com/think/topics)
  - [Insights](https://www.ibm.com/think/insights)
  - [News](https://www.ibm.com/think/news)
  - [Newsletters](https://www.ibm.com/subscribe)
  - [Reference architectures](https://www.ibm.com/think/architectures)
  - [Tutorials](https://www.ibm.com/think/tutorials)

## Industries

  - [Automotive](https://www.ibm.com/think/automotive)
  - [Banking](https://www.ibm.com/think/banking-financial-markets)
  - [Consumer Goods](https://www.ibm.com/think/consumer-goods)
  - [Energy & Utilities](https://www.ibm.com/think/energy)
  - [Government](https://www.ibm.com/think/government)
  - [Healthcare](https://www.ibm.com/think/healthcare)
  - [Manufacturing](https://www.ibm.com/think/manufacturing)
  - [Retail](https://www.ibm.com/think/retail)
  - [Telecommunications](https://www.ibm.com/think/telecommunications)
  - [Travel](https://www.ibm.com/think/travel-transportation)

[View all](https://www.ibm.com/think/search)

Subscribe

[Security](https://www.ibm.com/think/security)

# Being a good CLR host – Modernizing offensive .NET tradecraft

![Woman typing on the computer inside a dark room](https://assets.ibm.com/is/image/ibm/ma82916?dpr=on%2C1&wid=320&hei=213)

- [Overview](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Overview)
- [Key highlights](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Key+highlights)
- [A brief history of executing assemblies](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#A+brief+history+of+executing+assemblies)
- [How to host the common language runtime](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#How+to+host+the+common+language+runtime)
- [What are CLR customizations?](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#What+are+CLR+customizations%3F)
- [Implementing IHostControl](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Implementing+IHostControl)
- [Starting the CLR](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Starting+the+CLR)
- [Taking over the CLR’s memory](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Taking+over+the+CLR%E2%80%99s+memory)
- [Tracking and clearing assembly artifacts](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Tracking+and+clearing+assembly+artifacts)
- [Managing assembly loads](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Managing+assembly+loads)
- [Bypassing AMSI](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Bypassing+AMSI)
- [Proof-of-concept and further operationalization](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Proof-of-concept+and+further+operationalization)
- [Defensive considerations](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Defensive+considerations)
- [Why release this now?](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Why+release+this+now%3F)
- [Wrapping up](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Wrapping+up)
- [Acknowledgments](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Acknowledgments)
- [Related works](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#Related+works)

## Author

Joshua Magri

Senior Managing Security Consultant

Adversary Services, IBM X-Force Red

The modern red team is defined by its ability to compromise endpoints and take actions to complete objectives. To achieve the former, many teams implement their own custom command-and-control (C2) or use an open-source option. For the latter, there is a constant stream of post-exploitation tooling being released that takes advantage of various features in Windows, Active Directory and third-party applications. The execution mechanism for this tooling has, for the last several years, relied heavily on executing .NET assemblies in memory.

Despite being such a large part of the modern red team arsenal, tradecraft for executing .NET assemblies on a compromised endpoint has remained largely stagnant. In this blog post, we will discuss how red teams can bring their .NET execution harnesses into this decade.

## Key highlights

- Operators can take control over many aspects of the CLR using “CLR customizations” when executing .NET assemblies in memory
- Taking over memory management for the CLR enables operators to control and track all allocations made by the CLR, and also provides an easy way to keep track of assemblies being loaded into the process
- Implementing a custom assembly loading manager enables a novel AMSI bypass using only “intended” functionality, with no byte patches or process hacking required

Industry newsletter

### The latest tech news, backed by expert insights

Stay up to date on the most important—and intriguing—industry trends on AI, automation, data and beyond with the Think Newsletter. See the [IBM Privacy Statement](https://www.ibm.com/privacy).

### Thank you! You are subscribed.

- Account information


Current

We use your email to validate you are who you say you are, to create your IBMid, and to contact you for account related matters.

Business email

Your subscription will be delivered in English. You will find an unsubscribe link in every newsletter. You can manage your subscriptions or unsubscribe [here.](https://www.ibm.com/account/reg/us-en/signup?formid=news-urx-51525) Refer to our [IBM Privacy Statement](https://www.ibm.com/us-en/privacy) for more information.

Subscribe

Your subscription will be delivered in English. You will find an unsubscribe link in every newsletter. You can manage your subscriptions or unsubscribe [here](https://www.ibm.com/account/reg/signup?formid=news-urx-51525). Refer to our [IBM Privacy Statement](https://www.ibm.com/privacy) for more information.

## A brief history of executing assemblies

Not so long ago, many [red teams](https://www.ibm.com/think/security) relied on PowerShell for post-exploitation tooling. Cobalt Strike took a step to change that in 2018 by implementing the [execute-assembly module](https://www.cobaltstrike.com/blog/cobalt-strike-3-11-the-snake-that-eats-its-tail). Execute-assembly would spawn a sacrificial process and inject a reflective DLL into it which would load the Common Language Runtime (CLR) and execute a .NET assembly provided by the operator.

This resulted in a lot of post-exploitation tooling being shifted over to .NET assemblies. After a while, defenders began to build detections for the “fork-and-run” behavior of execute-assembly, namely the reflective DLL injection. To get around this, [Shawn Jones](https://x.com/anthemtotheego), also of the IBM Adversary Simulation team, developed the [InlineExecute-Assembly](https://www.ibm.com/think/x-force/net-execution-inlineexecute-assembly?) Beacon Object File (BOF). This allowed operators to shift away from the “fork-and-run” behavior of execute-assembly and stay within the implant process. Since then, many C2 frameworks have adopted this behavior natively.

If you are not already familiar with how to host the CLR and execute .NET assemblies, I would recommend you read Shawn’s blog post linked above.



Mixture of Experts \| 13 February, episode 94




![What do people really use AI for?](https://cdnsecakmi.kaltura.com/p/1773841/thumbnail/entry_id/1_m4234x30/width/1180)

### Decoding AI: Weekly News Roundup

Join our world-class panel of engineers, researchers, product leaders and more as they cut through the AI noise to bring you the latest in AI news and insights.

Watch all episodes of Mixture of Experts

## How to host the common language runtime

The execute-assembly technique takes advantage of a Windows feature known as “ [Unmanaged CLR Hosting](https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/clr-hosting-interfaces)”. The Common Language Runtime, or CLR, is the runtime environment for .NET. Users can write .NET assemblies in a variety of languages (C#, F#, etc.) which are compiled into an Intermediate Language (IL). The CLR is responsible for taking an assembly containing IL and executing it.

Traditionally, the execute-assembly technique has relied on the use of the deprecated [``Copy to clipboardICorRuntimeHost](https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/icorruntimehost-interface) interface. The reason that offensive practitioners use this interface is that it allows for loading assemblies from an in-memory byte array, by creating an [App Domain](https://learn.microsoft.com/en-us/dotnet/framework/app-domains/application-domains) and using the `

          Copy to clipboard

      Load_3
` method. By loading from a byte array we avoid the problem of having to drop any code to the file system, which could be scanned by defensive solutions.

The `

          Copy to clipboard

      ICorRuntimeHost
` has since been replaced by the [`\\
\\
          Copy to clipboard\\
\\
      ICLRRuntimeHost\\
`](https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/iclrruntimehost-interface) interface.

![MSDN page for the ICLRRuntimeHost interface](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-1:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 1: MSDN page for the ICLRRuntimeHost interface_

The MSDN docs for the ``Copy to clipboard
ICLRRuntimeHost
interface state that it adds the [``Copy to clipboardSetHostControl](https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/iclrruntimehost-sethostcontrol-method) method, but omits some methods provided by ``Copy to clipboard
ICorRuntimeHost
. When Microsoft says “omission of some methods”, they mean all of the fun ones that let us load assemblies reflectively. In exchange, we get access to CLR Customizations through the ``Copy to clipboard
SetHostControl
method.

Note: While we can’t use ``Copy to clipboard
ICLRRuntimeHost
directly to load reflective assemblies, we can start the CLR using ``Copy to clipboard
ICLRRuntimeHost
and then call ``Copy to clipboard
GetInterface
to get an ``Copy to clipboard
ICorRuntimeHost
interface. Then we can use the ``Copy to clipboard
ICorRuntimeHost
interface to load reflective assemblies while also having our CLR Customizations enabled.

## What are CLR customizations?

The `

          Copy to clipboard

      SetHostControl
` method allows us to provide our own implementation of the [`\\
\\
          Copy to clipboard\\
\\
      IHostControl\\
`](https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/ihostcontrol-interface) COM interface, which is how we can tell the CLR to use various customization features. CLR Customizations are a little talked-about feature which allow developers to take control over aspects of the CLR. Customizations work by using various “Manager” interfaces that we as the developer can implement, and our `

          Copy to clipboard

      IHostControl
` implementation will tell the CLR which managers we would like it to use. Anything we don’t implement will simply be handled by the CLR as it normally would. A list of supported managers is shown below..

![Some of the interfaces supported for CLR customizations](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-2:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 2: Some of the interfaces supported for CLR customizations_

I’ve used red boxes to highlight the two managers that will be covered in this blog post: [``Copy to clipboardIHostMemoryManager](https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/ihostmemorymanager-interface) and [``Copy to clipboardIHostAssemblyManager](https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/ihostassemblymanager-interface). But first, we will implement our ``Copy to clipboard
IHostControl
interface.

## Implementing IHostControl

I wrote my initial proof-of-concept for CLR Customizations in C++, but I ultimately chose to re-implement everything in pure C, which is what we will look at in this post. I prefer implants written in C to avoid the bloat of C++, so I wanted this assembly execution harness in C as well. Implementing COM interfaces in C is a massive chore, but I hope that the following information will make it easier in the future. Below is how you need to define the `

          Copy to clipboard

      IHostControl
` interface, which I have named “MyHostControl”.

![Header file implementing the IHostControl interface](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-3:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 3: Header file implementing the IHostControl interface_

To implement our COM interface, we must have the following components (shown above in this order):

1. A typedef for a struct which contains the functions for our interface. The ``Copy to clipboard
    QueryInterface
, ``Copy to clipboard
    AddRef
    and ``Copy to clipboard
    Release
    functions are boilerplate and will be in every COM interface. The two functions below, ``Copy to clipboard
    GetHostManager
    and ``Copy to clipboard
    SetAppDomainManager
, are specific to this interface.
2. A typedef for a struct that defines our actual interface, which has a Virtual Table (VTBL) and a Count.
3. Definitions for the specific functions that we will implement separately. I’ve prefixed them with “MyHostControl\_” as you will have to define ``Copy to clipboard
    QueryInterface
/``Copy to clipboard
    AddRef
/``Copy to clipboard
    Release
    for every COM interface.
4. A const of the VTBL we defined earlier but populated with the functions we defined above.

Implementing the actual methods is a bit more straightforward, as shown below:

![Implementing the QueryInterface, AddRef and Release methods](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-4:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 4: Implementing the QueryInterface, AddRef and Release methods_

As I mentioned before, the ``Copy to clipboard
QueryInterface
/``Copy to clipboard
AddRef
/``Copy to clipboard
Release
methods are boilerplate. The only thing you need to change to implement a different interface is the “xIID\_IHostControl” value in the ``Copy to clipboard
QueryInterface
method.

![Implementing the GetHostManager method](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-5:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 5: Implementing the GetHostManager method_

Here we don’t actually need to implement the ``Copy to clipboard
SetAppDomainManager
method and can simply return E\_NOTIMPL, so long as we don’t try to call it later. The ``Copy to clipboard
GetHostManager
method, which is the core of this interface, is really just a series of “if” statements where we check to see if the CLR is asking us for a manager that we care about. In the code above, I am checking if the provided IID is for the ``Copy to clipboard
IHostMemoryManager
interface, and then creating a new memory manager pointing the ppObject argument to it.

## Starting the CLR

Now that we’ve implemented our `

          Copy to clipboard

      IHostControl
` interface, we can call `

          Copy to clipboard

      SetHostControl
` and start the CLR. Below is a snippet of code for doing the normal CLR hosting stuff (`

          Copy to clipboard

      CLRCreateInstance
`, `

          Copy to clipboard

      GetRuntime
`, `

          Copy to clipboard

      GetInterface
`), and then calling `

          Copy to clipboard

      SetHostControl
` using our custom host control interface. Then we start the CLR.

![Calling SetHostControl and starting the CLR](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-6:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 6: Calling SetHostControl and starting the CLR_

## Taking over the CLR’s memory

Now that we know how to implement COM interfaces in C, implementing specific managers is more straightforward. The `

          Copy to clipboard

      IHostMemoryManager
` interface allows us to take control of the CLR’s memory management. Below is a [list of all the functions](https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/ihostmemorymanager-interface) we need to implement for `

          Copy to clipboard

      IHostMemoryManager
`.

![List of methods for the IHostMemoryManager interface](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-7:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 7: List of methods for the IHostMemoryManager interface_

You probably notice a few methods that enable some interesting behavior, namely the Virtual\* methods (VirtualAlloc, VirtualProtect, VirtualQuery, VirtualFree) which are used to do the bulk of memory management on Windows. Below is a very barebones implementation of these methods.

![Implementing VirtualAlloc, VirtualFree, VirtualQuery and VirtualProtect](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-8:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 8: Implementing VirtualAlloc, VirtualFree, VirtualQuery and VirtualProtect_

Taking control over memory allocations enables the operator to get as fancy with it as they like. For example, you could perform the allocation API calls via [indirect syscalls](https://passthehashbrowns.github.io/hiding-your-syscalls). You could also track all allocations made by the CLR and encrypt them when your implant goes to sleep. Note that encrypting CLR allocations is not very stable. In addition to the Virtual\* methods, there is also the ``Copy to clipboard
CreateMAlloc
method, which returns an implementation of the ``Copy to clipboard
IHostMalloc
interface. This interface allows us to take control over all Heap allocations made by the CLR.

## Tracking and clearing assembly artifacts

I mentioned above that trying to encrypt CLR memory allocations goes from “kind of unstable” to “very unstable”, depending on how exactly you do it. This is because if you encrypt or free a piece of memory that the CLR tries to reference later, the CLR will throw an error and crash your process. However, there is one exception to this that I have found: Allocations made during initial assembly loads.

When you load an assembly, whether that is in memory or from disk, the CLR will allocate space and map the assembly into memory. As far as I am aware, there was no good publicly known way to identify this memory region and wipe it, aside from searching process memory for byte patterns or allocations of the expected size. CLR customizations provide an easy mechanism to keep track of these allocations in the form of the `

          Copy to clipboard

      AcquiredVirtualAddressSpace
` method. This method is a notification callback that gets triggered whenever the CLR loads an assembly into the process, and the callback includes the address and size of the allocation as arguments. From my testing, this callback is only triggered when an assembly is loaded into the process, which provides us with a good way to keep track of assembly load allocations. For robustness, you can check the size or parse memory to ensure that it’s the assembly you are expecting. Below is an example of implementing this method. Since it is just a notification callback, you can do whatever you would like and then simply return S\_OK..

![Implementing the AcquiredVirtualAddressSpace method](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-9:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 9: Implementing the AcquiredVirtualAddressSpace method_

Unlike the other allocations made by the CLR, I have not had any problems with encrypting or wiping this memory region after the assembly has finished executing. You may run into problems if you try to execute the same assembly in the same App Domain again as the CLR might try to use the cached assembly which is now invalid. Most implementations of execute-assembly will create a new App Domain and then destroy it after execution, so just be sure to test with your implementation.

This notification functionality also has a minor defensive application. Typically, defensive products will use [Event Tracing for Windows (ETW)](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-) to keep track of assembly loads in the CLR, but this provides another way to be notified if an assembly has been loaded into the process. Since the memory address and size are included, it would be trivial for a defensive product to perform a memory scan on that region.

## Managing assembly loads

The other managers that we will look at are `

          Copy to clipboard

      IHostAssemblyManager
` and `

          Copy to clipboard

      IHostAssemblyStore
`. `

          Copy to clipboard

      IHostAssemblyManager
` is responsible for two things: giving the CLR a list of assemblies it should handle loading (instead of us, as the CLR host), and returning an `

          Copy to clipboard

      IHostAssemblyStore
` interface to the CLR. `

          Copy to clipboard

      IHostAssemblyStore
` has two methods: `

          Copy to clipboard

      ProvideAssembly
` and `

          Copy to clipboard

      ProvideModule
`.

`

          Copy to clipboard

      ProvideAssembly
` will be called whenever the CLR is asked to load an assembly that is not in the list of assemblies that the CLR is responsible for loading (returned by `

          Copy to clipboard

      IHostAssemblyManager
`). The CLR calls `

          Copy to clipboard

      ProvideAssembly
` and passes in the identity string for an assembly, and `

          Copy to clipboard

      ProvideAssembly
` is responsible for returning the bytes of the assembly. You’ve likely seen an identity string before, it looks something like: “`

          Copy to clipboard

      Seatbelt, Version=0.0.0.0, PublicKeyToken=null, Culture=neutral
`”.

Once `

          Copy to clipboard

      ProvideAssembly
` has resolved the assembly, the assembly content is returned by setting a pointer which is provided as an argument. I’ve highlighted the relevant argument, `

          Copy to clipboard

      ppStmAssemblyImage
`, in the screenshot below.

![Arguments for the ProvideAssembly method of the IHostAssemblyStore interface](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-10:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 10: Arguments for the ProvideAssembly method of the IHostAssemblyStore interface_

The assembly is returned by setting the pointer to the address of an in-memory IStream. Typically the CLR would try to locate the assembly by following its directory search order on disk, similar to loading a DLL in a normal Windows process. But since we can provide our own implementation, we can take a request for an assembly that would typically be loaded from disk and instead provide an assembly that we have in memory. The assembly bytes do need to be in an IStream, which can be accomplished using the [SHCreateMemStream](https://learn.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-shcreatememstream) function that takes in a byte array and returns an IStream.

You may be wondering why this matters if it’s simply another way to load assemblies in memory. What about the [Anti-Malware Scan Interface (AMSI)](https://learn.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal)?

## Bypassing AMSI

AMSI is responsible for scanning any assemblies that are loaded reflectively for malicious content. Windows Defender uses AMSI, and AMSI also allows other EDRs to hook in and scan the contents of assemblies loaded in memory. Some tend to sneer at AMSI since it can be bypassed, but I feel that for something that is installed in Windows by default, AMSI is a fairly effective security feature. At a minimum, it will catch a lot of stock malicious .NET tooling (such as [Seatbelt](https://github.com/GhostPack/Seatbelt)) being executed in memory. There is a [rich cat-and-mouse history](https://github.com/rasta-mouse/AmsiScanBufferBypass) of bypassing AMSI among red teamers, but a lot of AMSI bypasses rely on patching the bytes for key functions (such as AmsiScanBuffer) so that they either fail to execute or return a “good” value. Traditional AMSI bypasses are messy as they leave [Copy-on-Write](https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection#copy-on-write-protection) bytes in the .text section of AMSI.dll’s memory, which are a dead giveaway for any defenders looking at a suspicious process. More sophisticated AMSI bypasses such as hardware breakpoint hooks also have other IOCs associated with them, like inspecting the thread context to look for debug register usage.

By implementing our own version of the `

          Copy to clipboard

      ProvideAssembly
` method, we can circumvent AMSI entirely. Traditionally, the `

          Copy to clipboard

      Load_3
` method is used to load assemblies from a byte array and `

          Copy to clipboard

      Load_3
` is instrumented by AMSI. But did you know that there are other seldom-used Load\_\* functions?.

![The Load family of methods](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-11:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 11: The Load family of methods_

``Copy to clipboard
Load\_2
takes an assembly identity string as an argument instead of a byte array like ``Copy to clipboard
Load\_3
. Typically, this would mean that the assembly has to be on disk somewhere that the CLR can find, but we know that when the CLR is asked to load an assembly by identity it will ask our ``Copy to clipboard
ProvideAssembly
implementation to provide that assembly. We also know that we can return an in-memory byte array (in an IStream) from ``Copy to clipboard
ProvideAssembly
. This means that we can call ``Copy to clipboard
Load\_2
and provide the CLR with an in-memory assembly that it will load.

Now the important part: because we’re calling ``Copy to clipboard
Load\_2
, the CLR believes that we’re loading our assembly from disk and AMSI does not scan our assembly bytes. In fact, AMSI never even gets loaded into the process.

Below is an example of executing Seatbelt via a call to ``Copy to clipboard
Load\_2
without AMSI being loaded into the process.

![Executing Seatbelt and bypassing AMSI](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-12:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 12: Executing Seatbelt and bypassing AMSI_

![A process module listing with no AMSI.dll loaded](https://assets.ibm.com/is/image/ibm/being-a-good-clr-host-modernizing-offensive-net-tradecraft-13:16x9?fmt=png-alpha&dpr=on%2C1&wid=320&hei=180)

_Figure 13: A process module listing with no AMSI.dll loaded_

According to a [CLR Inside Out](https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/august/clr-inside-out-clr-hosting-apis) article published in the August 2006 edition of the MSDN magazine, Microsoft themselves have used a similar technique to have SQL Server 2005 load .NET assemblies from the database rather than from disk. The ability to store and execute .NET assemblies from a SQL database is a personal favorite lateral movement technique and can be done easily using [SQLRecon](https://github.com/xforcered/sqlrecon), another X-Force Red tool written by [Sanjiv Kawa](https://x.com/sanjivkawa).

## Proof-of-concept and further operationalization

I am releasing a proof-of-concept for this technique that you can find on GitHub [here](https://github.com/xforcered/Being-A-Good-CLR-Host). This proof-of-concept shows how to implement the `

          Copy to clipboard

      IHostControl
`, `

          Copy to clipboard

      IHostMemoryManager
`, `

          Copy to clipboard

      IHostMalloc
`, `

          Copy to clipboard

      IHostAssemblyStore
` and `

          Copy to clipboard

      IHostAssemblyManager
` COM interfaces. It calls `

          Copy to clipboard

      SetHostControl
` and starts the CLR using the `

          Copy to clipboard

      ICLRRuntimeHost
` interface.

The memory manager implementation simply calls the correct Windows APIs (ex: VirtualAlloc) but does include an example of tracking all memory allocations made by the CLR. It also includes an example of wiping the assembly load artifacts provided by the `

          Copy to clipboard

      AcquiredVirtualAddressSpace
` callback discussed earlier.

There is also a full proof-of-concept for the AMSI bypass. There is a caveat with this bypass if you try to implement it into your own tooling: The assembly identity that you attempt to load using the `

          Copy to clipboard

      Load_2
` method must match the identity of the assembly you ultimately return to the CLR. For example, if you call `

          Copy to clipboard

      Load_2
` with an argument of “Seatbelt, Version=0.0.0.0, PublicKeyToken=null, Culture=neutral”, then the assembly that you are ultimately trying to run must also have this identity. You cannot attempt to load mscorlib but instead return Seatbelt, as the CLR will check this and throw an error. Be mindful of what assembly names you are attempting to load, but if you are still trying to reflectively load an assembly named Seatbelt in whatever year you are reading this then I would suggest you close this blog post and pursue a more fulfilling activity.

In the proof-of-concept, I use the `

          Copy to clipboard

      GetBindingIdentityFromStream
` method of the `

          Copy to clipboard

      ICLRAssemblyIdentityManager
` interface to get the identity string for the assembly that is going to be executed. You could also shift this away from the implant and get the assembly identity on the client or teamserver, and then pass the identity string as an argument to your implant.

## Defensive considerations

While this is a novel AMSI bypass, it is ultimately just that: an AMSI bypass. Defensive products should be utilizing defense-in-depth strategies and not simply relying on AMSI to detect malicious assemblies. Any assemblies loaded using this technique will also generate the same Event Tracing for Windows (ETW) events as any other in-memory assembly. Malicious assemblies can be detected via memory scanning, as we have seen several more advanced EDR platforms doing. Many post-exploitation tools also have their own [unique IOCs](https://github.com/GhostPack/Rubeus/commit/b303d1c9d8076bc4b5f97d8151fe3c39c42e50d6).

As mentioned above there, are also some defensive applications of this research. The `

          Copy to clipboard

      AcquiredVirtualAddressSpace
` callback provides another method of being notified when assemblies are loaded into the process. If a defender were to implement the `

          Copy to clipboard

      IHostAssemblyStore
` interface then they would be inserted into the assembly loading chain and have the ability to block assembly loads entirely or modify the bytes of an assembly before it is loaded into the process. I’ll call my shot here and say that I think it’s highly likely there will be future developments in this area.

## Why release this now?

I’d like to touch on our timeline with this research, and why we are publishing it now. I performed all of this research in June of 2023 and we have kept it internal since then, although it has been submitted to several conference CFPs. At the time that this research was performed, I scoured search engines for anything similar, initially looking for reference material and later seeking to confirm if I was the first to identify this behavior. Since then, I’ve performed periodic searches to see if anyone had published any similar work. At the beginning of January 2025, I found this piece: [Using CLR Hosting to Evade AMSI](https://www.nttdata.com/global/en/-/media/nttdataglobal/1_files/services/cybersecurity/radar_magazine/2024/radar_supplement_july.pdf?), by Marcos González Hermida in the “NTT Data” magazine.

This piece disclosed this same bypass, and according to the magazine it was initially published in June of 2024 (the supplementary linked above is from July 2024). It’s an excellently written piece and I would recommend that you read it. The only notes I would make is that the author concludes that assemblies must be signed to be executed, and in their proof-of-concept, they use the `

          Copy to clipboard

      GetType_2
` method to manually obtain the Main method of the assembly they load ( [Rubeus](https://github.com/GhostPack/Rubeus), specifically). I have had no problem loading unsigned assemblies using this technique, and you can use the same `

          Copy to clipboard

      Entrypoint
` method to obtain the entry point of the loaded assembly that is used in many implementations of execute-assembly, without having to know the namespace/class names.

With the publication of Marcos’ piece and proof-of-concept, this AMSI bypass could now be considered public, so we decided it was time to publish our research along with a proof-of-concept of what we discovered.

## Wrapping up

In this post, we looked at how you can use CLR customizations to improve your OPSEC while running .NET tooling in memory. Additionally, we demonstrated a full AMSI bypass utilizing these lesser-known CLR features. The use of .NET tooling will remain effective for offensive practitioners and [threat actors](https://www.ibm.com/think/topics/threat-actor). For this reason, it is critical that defenders understand how the CLR works and build defense-in-depth strategies to detect post-exploitation tooling.

## Acknowledgments

Thank you Brett and Valentina for peer-reviewing this research!

- Brett Hawkins (@h4wkst3r)
- Valentina Palmiotti (@chompie1337)

## Related works

[Dealing with Failure: Failure Escalation Policy in CLR Hosts](https://posts.specterops.io/dealing-with-failure-failure-escalation-policy-in-clr-hosts-54ca8b728faa) – This is the only real example I could find of offensive tradecraft using CLR customizations when I was initially doing this research.

[Hosted Pumpkin](https://github.com/ldematte/HostedPumpkin) – A GitHub repository containing a proof-of-concept for implementing several CLR customizations.

Shellcode: Loading .NET Assemblies From Memory – Donut was a great deal of help in wrangling all of the relevant data structures and definitions in C.

Customizing the Microsoft .NET Framework Common Language Runtime by Steven Pratschner – This is the definitive text on CLR Customizations. Simply a must-read if you have any interest in this area.

Link copied


Loading

START


END


START


END


[![close icon](https://consent.trustarc.com/get?name=ibm_close_icon.svg)](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#)

IBM web domains

ibm.com, ibm.org, ibm-zcouncil.com, insights-on-business.com, jazz.net, mobilebusinessinsights.com, promontory.com, proveit.com, ptech.org, s81c.com, securityintelligence.com, skillsbuild.org, softlayer.com, storagecommunity.org, think-exchange.com, thoughtsoncloud.com, alphaevents.webcasts.com, ibm-cloud.github.io, ibmbigdatahub.com, bluemix.net, mybluemix.net, ibm.net, ibmcloud.com, galasa.dev, blueworkslive.com, swiss-quantum.ch, blueworkslive.com, cloudant.com, ibm.ie, ibm.fr, ibm.com.br, ibm.co, ibm.ca, community.watsonanalytics.com, datapower.com, skills.yourlearning.ibm.com, bluewolf.com, carbondesignsystem.com, openliberty.io

![close icon](https://consent.trustarc.com/get?name=ibm_close_icon.svg)

About cookies on this siteOur websites require some cookies to function properly (required). In addition, other cookies may be used with your consent to analyze site usage, improve the user experience and for advertising.For more information, please review your cookie preferences options. By visiting our website, you agree to our processing of information as described in IBM’s [privacy statement](https://www.ibm.com/privacy). To provide a smooth navigation, your cookie preferences will be shared across the IBM web domains listed [here](https://www.ibm.com/think/x-force/being-a-good-clr-host-modernizing-offensive-net-tradecraft#truste_domain_list).

Accept allMore options