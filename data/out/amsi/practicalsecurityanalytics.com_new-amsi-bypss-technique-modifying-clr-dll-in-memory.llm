Title:
New AMSI Bypass Technique: Modifying CLR.DLL in Memory

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post presents an AMSI bypass that avoids directly patching or hooking `amsi.dll!AmsiScanBuffer`, which Microsoft has started detecting via memory-scanning signatures.  
- The technique targets `clr.dll`’s native AMSI integration used when reflectively loading .NET assemblies (e.g., `Assembly.Load(byte[])`), where CLR dynamically resolves `AmsiScanBuffer` via `GetProcAddress`.  
- By locating and overwriting the `"AmsiScanBuffer"` string literal in `clr.dll`’s `.rdata` section in-memory, the resolution fails and the CLR “fails open,” continuing to load the assembly without submitting it to AMSI.  
- The author details discovery via Visual Studio breakpoints/stack traces, reverse engineering in Ghidra, and then implements the bypass by enumerating process memory (`VirtualQuery`), identifying `clr.dll` mappings (`GetMappedFileName`), changing page protections (`VirtualProtect`), and zeroing the string.  
- Implementations are provided in C, C#, and PowerShell (PowerShell uses `Reflection.Emit` to build P/Invoke wrappers without triggering AMSI during generation).  
- This is primarily useful for red team operators and offensive tool developers building in-memory .NET loaders and trying to evade modern Defender/EDR detections focused on classic AMSI patching.

Technical Focus:
- AMSI call chain in CLR for reflective .NET loads
- In-memory modification of `clr.dll` `.rdata` string literals
- Memory region enumeration with `VirtualQuery` + permission filtering
- Module-backed region identification via `GetMappedFileName` (psapi)
- Page permission changes with `VirtualProtect` and restoration
- PowerShell `Reflection.Emit` for dynamic P/Invoke/type generation

Use Cases:
- Bypassing AMSI scanning for reflectively loaded .NET tooling (e.g., credential theft wrappers, post-exploitation modules)
- Building stealthier .NET in-memory loaders that avoid `AmsiScanBuffer` patch signatures
- Researching alternative AMSI bypass surfaces “higher in the call stack” than `amsi.dll`
- Developing detections around `clr.dll` memory tampering and `.rdata` integrity changes

Keywords:
AMSI, AmsiScanBuffer, clr.dll, Common Language Runtime, reflective loading, Assembly.Load(byte[]), GetProcAddress, .rdata section, VirtualQuery, VirtualProtect, GetMappedFileNameA, psapi.dll, MEMORY_BASIC_INFORMATION, PAGE_GUARD, MEM_COMMIT, in-memory patching, string overwrite, Defender signatures, PowerShell Reflection.Emit