Title:
.NET Assembly Obfuscation for Memory Scanner Evasion

Type:
Blog Post

Short Summary (4â€“8 sentences max):
- The post explains how reflective in-memory execution of .NET assemblies (e.g., Cobalt Strike `execute-assembly`) works via CLR reflection APIs like `Assembly.Load`, and why it is widely used in post-exploitation.  
- It outlines key detection surfaces for in-memory .NET tooling: AMSI scanning of byte-array-loaded assemblies (since .NET Framework 4.8), ETW telemetry from CLR providers (including assembly load visibility), and EDR memory scanning/YARA-style signature matching.  
- The author discusses common bypass approaches for AMSI/ETW (patching, including patchless techniques such as hardware breakpoints) but emphasizes that memory scanning remains harder to evade.  
- The core evasion strategy presented is systematic .NET obfuscation: renaming identifiers/namespaces, rewriting assembly metadata (e.g., `AssemblyTitle`, `Product`, `Guid`), and applying robust string obfuscation/encryption (potentially via chained obfuscators).  
- It also highlights defender techniques like TypeRef Hash (TRH) matching and notes limited obfuscator support for altering TRH.  
- Finally, it describes an automated CI/CD pipeline (Azure DevOps agent on Windows) that continuously builds and obfuscates a fleet of offensive .NET tools, producing frequently changing binaries and addressing OPSEC risks of building from public repos.

Technical Focus:
- Reflective .NET assembly loading (CLR reflection, `Assembly.Load`, `nLoadImage`)
- AMSI scanning of in-memory assemblies (`AmsiScanBuffer`) and bypass concepts
- ETW-based .NET telemetry (CLR providers, `NtTraceEvent` patching)
- EDR memory scanning, YARA/signature matching, PE/MZ header artifacts
- .NET obfuscation techniques (identifier renaming, metadata rewriting, string encryption)
- CI/CD automation for offensive tooling (Azure DevOps pipelines, NuGet, build orchestration)

Use Cases:
- Automating obfuscated builds of common post-exploitation .NET tooling for red team operations
- Reducing static and in-memory signature hits during `execute-assembly`-style tradecraft
- Hardening OPSEC around toolchains by isolating and reviewing build sources
- Blue team reference for where to hunt: CLR ETW providers, assembly metadata, memory-resident .NET artifacts

Keywords:
.NET, CLR, Assembly.Load, System.Reflection, nLoadImage, execute-assembly, Cobalt Strike, AMSI, AmsiScanBuffer, ETW, Microsoft-Windows-DotNETRuntime, Microsoft-Windows-DotNETRuntimeRundown, NtTraceEvent, memory scanning, YARA, TypeRef Hash, TRH, obfuscation, string encryption, AssemblyInfo.cs, GUID, Azure DevOps, CI/CD, NuGet, Process Hacker, ilSpy, de4dot, ConfuserEx, Codecepticon