Title:
Reflection in C# 101

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post introduces .NET reflection in C# with an emphasis on how it’s used for fileless payload delivery and in-memory execution seen in malware and stagers.  
- It explains core .NET concepts (CLR, managed vs unmanaged code, assemblies/metadata) and how reflection can inspect loaded assemblies and dynamically create objects and invoke methods at runtime.  
- The author walks through building a simple C# DLL and a console “loader” that uses `System.Reflection` to load the DLL, resolve a `Type`, create an instance via `Activator.CreateInstance`, fetch a `MethodInfo`, and invoke the method.  
- It highlights that reflection can access members beyond typical visibility boundaries (e.g., internal/private) when used appropriately.  
- Useful for red teamers, malware analysts, and offensive tool developers learning the mechanics behind reflective loading patterns commonly used to reduce filesystem artifacts.

Technical Focus:
- .NET CLR, MSIL, managed vs unmanaged execution model  
- Assemblies, manifests, and metadata introspection  
- `System.Reflection` (Assembly, Type, MethodInfo, PropertyInfo)  
- Reflective assembly loading (`Assembly.LoadFile`) and runtime invocation (`MethodInfo.Invoke`)  
- Dynamic instantiation (`Activator.CreateInstance`) and error handling (`ReflectionTypeLoadException`)

Use Cases:
- Build a basic reflective loader for a known DLL and invoke exported class methods
- Prototype fileless execution patterns used by stagers (precursor to byte-array loading)
- Inspect and interact with .NET assemblies dynamically during analysis or tooling
- Demonstrate how malware can call into embedded/loaded assemblies without static references

Keywords:
C#, .NET, CLR, MSIL, managed code, unmanaged code, assembly, manifest, metadata, System.Reflection, Assembly.LoadFile, Type.GetType, Activator.CreateInstance, MethodInfo, MethodInfo.Invoke, ReflectionTypeLoadException, fileless, in-memory execution, reflective loading