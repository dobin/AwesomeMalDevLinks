# https://securityliterate.com/go-big-or-go-home-and-other-terrible-go-puns-tips-for-analyzing-golang-malware/

[![](https://i0.wp.com/securityliterate.com/wp-content/uploads/2025/07/grafik-6.png?resize=638%2C576&ssl=1)](https://securityliterate.com/go-big-or-go-home-and-other-terrible-go-puns-tips-for-analyzing-golang-malware/)

A few days ago, Dr. Josh Stroschein invited me on his livesteam [channel](https://www.youtube.com/@jstrosch) to talk about Golang malware. I wanted to get a quick blog post up before I forget everything we talked about. So, here is a summary of the key points we discussed in the livestream. You can also just watch the livestream [here](https://www.youtube.com/watch?v=mgCZJYRlHDI) if you’re feeling lazy. Ok, let’s get on with it.

Go (or Golang) has gained some traction over the past few years, not just among developers, but increasingly among malware authors also looking for flexibility and portability. As reverse engineers and malware analysts, that means we need to get more comfortable navigating Go binaries, understanding how they’re structured, and knowing what makes them different from traditional malware written in C, C++, or Delphi (vomit face).

## **What Is Go, and Why Does It Matter?**

Go is a statically typed, compiled programming language developed by Google. It’s designed to be simple, fast to compile, and efficient. Some of the things Go does well:

- **Cross-compilation**: Go makes it easy to build binaries for different OS’s and architectures.

- **Static linking**: Most Go binaries are self-contained, meaning no external dependencies.

- **Built-in concurrency**: Go’s goroutines make it easy to write efficient networked applications.

From a developer’s perspective, it’s efficient and practical. From a malware analyst’s perspective, it presents some interesting challenges.

## **Why Use Go for Malware?**

Go offers several advantages that make it appealing to malware authors:

- **Portability**: Malware authors can compile a single codebase for multiple platforms (Windows, Linux, macOS, ARM, etc.).

- **Self-contained binaries**: Go binaries include everything they need to run, which results in some seriously HUGE executable file sizes, but more on that later.

- **Less tooling**: Traditional reverse engineering tools aren’t as well-optimized for Go binaries, especially compared to C/C++ (but this is changing quickly).

- **Rapid development**: Go is relatively easy to write and maintain, which makes it efficient for malware development.

- **Evasion by obscurity**: Go binaries look different from typical malware, especially in static analysis, which may help them avoid basic detections (this is also changing rapidly).

## **Common Pitfalls in Analyzing Go Malware**

### **1\. Large Binary Sizes**

Even a simple Go program can compile into a binary tens of megabytes in size, which you’ll see in a moment. This is due to static linking of the Go runtime and standard libraries. For analysts, this means more to sift through as it’s often not immediately obvious where the actual malicious code begins or ends.

### **2\. Excess of Legitimate Code**

Go’s standard library is extensive, and malware often makes use of common packages like net, os, crypto, and io. Most of the code in the binary is likely benign. The challenge is identifying the small percentage of custom or malicious logic within all the legitimate functionality. Your classic needle-in-a-pile-of-needles problem.

### **3\. Obfuscation (Garble and Others)**

Go malware is increasingly using obfuscation tools like [Garble](https://github.com/burrowers/garble), which strip or randomize symbol names, re-order packages, and break common static analysis workflows. These techniques don’t necessarily make the malware more sophisticated, but they do add complexity to the reversing process.

Other common obfuscation techniques may include:

- Encrypted or encoded strings

- Control flow obfuscation

- Packing or compression

Let’s analyze a very basic Go binary. The best way to do this is to write our own code.

## **Analyzing a Basic Go Program**

Go code is fairly straightforward and simple to write. Here is literally the most basic Go application you can write, printing our favorite “Hello World” (in this case, “Hello Earth”) string:

![](https://i0.wp.com/securityliterate.com/wp-content/uploads/2025/07/grafik.png?fit=304%2C116&ssl=1)

When compiled (using the **go build** command), the binary is a fairly large executable (2MB+). Since Go ships a lot of library code into each compiled executable, even this simple Hello World binary is substantial.

Let’s open this up in IDA, my dissasembler of choice for Golang. Newer versions of IDA (I think version 8+) are good at identifying Go standard library code. IDA nicely groups these libraries in “folders”, as you can see in the screenshot below:

![](https://i0.wp.com/securityliterate.com/wp-content/uploads/2025/07/grafik-1.png?fit=384%2C580&ssl=1)

Each of these folders represent a library. For example, “internal”, “runtime”, and “math” are all libraries being imported into this Go program. IDA is able to recognize these libraries and functions and name them appropriately. If your dissasembler is not designed for Golang use, you’ll see a bunch of generic names for these functions which makes analysis of Go binaries a lot more difficult. One tool ( [GoReSim](https://github.com/mandiant/GoReSym)) can help identify these functions, and the output of this tool can then be re-imported into some disassemblers like Ghidra.

Most of the time in un-obuscated Golang binaries, the main functionality of the program will reside in the function **main.main** or, **main\_main**), which IDA identified for us:

![](https://i0.wp.com/securityliterate.com/wp-content/uploads/2025/07/grafik-2.png?fit=376%2C253&ssl=1)

_Tip: Whenever I’m analyzing a Go binary, I first always look for main\_main or other functions that contain the name “main\_\*”._

Inside main\_main we can see our Hello World code. You may be able to spot the “Hello Earth!” string in the code below:

![](https://i0.wp.com/securityliterate.com/wp-content/uploads/2025/07/grafik-3.png?fit=784%2C612&ssl=1)

This “Hello Earth!” string also contains a bunch of other junk. These are also strings in the binary. One challenge when analyzing Golang code is that strings are not null-terminated like they are in C programs. Each string is actually a structure that contains the string itself and an integer representing the string’s length. I provided some terrible pseudocode for visualization of this:

`struct string (
     value = "Hello Earth!"
     length = 12
)`

In this case, IDA didn’t know that “Hello Earth!” is a separate string from “152587…” and the others. This is one thing you’ll need to take into account when analyzing Golang.

Ok, Hello World apps are cool and all, but let’s take it up a notch. Many malware binaries written in Go will be obfuscated. [Garble](https://github.com/burrowers/garble) is one such obfuscator. Garble… well… garbles the metadata of the Go binary. It does this by stripping symbols, function names, module and build information, and other metadata from the binary during compile-time.

If we open the same Hello World binary in IDA, but “Garbled” during compilation, it looks a lot different:

![](https://i0.wp.com/securityliterate.com/wp-content/uploads/2025/07/grafik-4.png?fit=368%2C359&ssl=1)

All our nice, beautiful Golang function names have been replaced with ugly, generic IDA function names (“sub\_xxxxxx”). So how do we find our main function code now? We can’t – Golang won. Time to pack up and Go home.

No, just kidding. We just have to work a bit harder. I’ve found that Golang requires several critical libraries to correctly function, and one of those is the “ **runtime**” library, which contains a lot of Go’s runtime code. Oftentimes, the runtime library names are not obfuscated, like in this case of my binary compiled with Garble ( _Note: I think Garble can also strip the module names from “runtime” as well, but I didn’t test this. In any case, the “runtime” module names are often not obfuscated_). This means we can find cross-references to runtime functions in the code, and trace those back to the program’s main function! Let’s try this.

If we search the function list in IDA for “runtime”, we get the following:

![](https://i0.wp.com/securityliterate.com/wp-content/uploads/2025/07/grafik-5.png?fit=234%2C309&ssl=1)

One common runtime function is **runtime\_unlockOSThread**. We can double-click on this function and select **CTRL+X** to see cross-references to it. Taking a look through all the cross-referenced functions will lead you to a block of code that looks like this:

![](https://i0.wp.com/securityliterate.com/wp-content/uploads/2025/07/grafik-6.png?fit=638%2C689&ssl=1)

When you spot functionality that contains a lot of “runtime” functions, you may be near the location of the program’s main code. In this case, our main code is not far away, in **sub\_49A9E0**. You may be wondering: “Kyle, how are you so smart that you found that so fast?”. Well, intelligence aside, it was a lot of hunting around the code. No crazy tricks here.

And here we have our main code at sub\_49A9E0:

![](https://i0.wp.com/securityliterate.com/wp-content/uploads/2025/07/grafik-7.png?fit=705%2C542&ssl=1)

_Tip: Garble and other obfuscators can also obfuscate strings, not just the function names. I used the default Garble settings for this binary. The analysis methodology is the same, however._

## Additional Resources

A few more resources on Golang I find extremely helpful:

- Ivan Kwiatkowski’s [YouTube](https://www.youtube.com/watch?v=_cL-OwU9pFQ) videos on GoLang analysis.
- Josh Stroschein’s [PluralSight](https://www.pluralsight.com/courses/ot-malware-analysis-frostygoop) course on GoLang malware analysis. In this course, Josh covers the OT malware FrostyGoop.

## **Key Takeaways**

Go malware is becoming more common, and it’s likely here to stay. While it presents some unique challenges, many of the same principles from other forms of reverse engineering still apply. You just need to adjust your approach and tools.

### **5 Tips for Reversing Go Malware**

1. **Start with main.main** **(main\_main)** – This is (nearly) always the entry point for a Go binary and can give you a foothold into the rest of the logic.

2. **Use the right tooling** – IDA, Ghidra with GoReSym (other disassemblers probably worked, but I haven’t tested them), and de-obfuscators like the appropriately named [UnGarbler](https://github.com/mandiant/gostringungarbler).

3. **Ignore the noise** – Skip most of the standard library code unless it’s directly involved in malicious behavior.

4. **Look for key APIs** – Even with obfuscation, patterns like “net.Dial”, “os/exec”, or “http.Get” can help narrow down suspicious areas.

5. **Combine static and dynamic analysis** – Especially with obfuscated binaries, dynamic tracing or debugging can be the fastest way to understand real behavior. Ivan Kwiatkowski has some great tips on debugging Golang [in this video](https://www.youtube.com/watch?v=_cL-OwU9pFQ).

### Share this:

- [Share on X (Opens in new window)X](https://securityliterate.com/go-big-or-go-home-and-other-terrible-go-puns-tips-for-analyzing-golang-malware/?share=twitter&nb=1)
- [Share on Facebook (Opens in new window)Facebook](https://securityliterate.com/go-big-or-go-home-and-other-terrible-go-puns-tips-for-analyzing-golang-malware/?share=facebook&nb=1)

### Like this:

LikeLoading...

### _Related_

[“VBoxCloak” – Hiding VirtualBox from Malware](https://securityliterate.com/vboxcloak-hiding-virtualbox-from-malware/ "&#8220;VBoxCloak&#8221; &#8211; Hiding VirtualBox from Malware")December 23, 2020In "Malware Analysis"

[Book Summary – “Evasive Malware: Understanding Deceptive and Self-Defending Threats”](https://securityliterate.com/evasive-malware-book/ "Book Summary &#8211; &#8220;Evasive Malware: Understanding Deceptive and Self-Defending Threats&#8221;")May 20, 2023In "Evasive Malware Book"

[“Beeeeeeeeep!”. How Malware Uses the Beep WinAPI Function for Anti-Analysis](https://securityliterate.com/beeeeeeeeep-how-malware-uses-the-beep-winapi-function-for-anti-analysis/ "&#8220;Beeeeeeeeep!&#8221;. How Malware Uses the Beep WinAPI Function for Anti-Analysis")May 16, 2024In "Malware Analysis"

Comments are closed.

### Search Posts

Search for:Search

### Recent Posts

- [Deceiving the Deceivers: A Review of Deception Pro](https://securityliterate.com/deceiving-the-deceivers-a-review-of-deception-pro/)
- [Elephant in the Sandbox: Analyzing DBatLoader’s Sandbox Evasion Techniques](https://securityliterate.com/elephant-in-the-sandbox-blah/)
- [Go Big or Go Home (and Other Terrible Go Puns): Tips for Analyzing GoLang Malware](https://securityliterate.com/go-big-or-go-home-and-other-terrible-go-puns-tips-for-analyzing-golang-malware/)
- [“Beeeeeeeeep!”. How Malware Uses the Beep WinAPI Function for Anti-Analysis](https://securityliterate.com/beeeeeeeeep-how-malware-uses-the-beep-winapi-function-for-anti-analysis/)
- [Unpacking StrelaStealer](https://securityliterate.com/unpacking-strela-stealer/)

### Recent Comments

- [Fileless attacks: How attackers evade traditional AV and how to stop them – Computer Security Articles](http://www.palada.net/index.php/2023/04/27/news-15599/) on [Malware Analysis in 5-Minutes: Deobfuscating PowerShell Scripts](https://securityliterate.com/malware-analysis-in-5-minutes-deobfuscating-powershell-scripts/#comment-340)
- [Where do entries from regsvr32-registered DLLs get stored - Boot Panic](https://bootpanic.com/where-do-entries-from-regsvr32-registered-dlls-get-stored/) on [Chantay’s Resume: Investigating a CV-Themed ZLoader Malware Campaign](https://securityliterate.com/chantays-resume-investigating-a-cv-themed-zloader-malware-campaign/#comment-327)

### Archives

- [January 2026](https://securityliterate.com/2026/01/)
- [September 2025](https://securityliterate.com/2025/09/)
- [July 2025](https://securityliterate.com/2025/07/)
- [May 2024](https://securityliterate.com/2024/05/)
- [March 2024](https://securityliterate.com/2024/03/)
- [January 2024](https://securityliterate.com/2024/01/)
- [July 2023](https://securityliterate.com/2023/07/)
- [June 2023](https://securityliterate.com/2023/06/)
- [May 2023](https://securityliterate.com/2023/05/)
- [August 2021](https://securityliterate.com/2021/08/)
- [January 2021](https://securityliterate.com/2021/01/)
- [December 2020](https://securityliterate.com/2020/12/)
- [August 2020](https://securityliterate.com/2020/08/)
- [April 2020](https://securityliterate.com/2020/04/)
- [January 2020](https://securityliterate.com/2020/01/)
- [October 2019](https://securityliterate.com/2019/10/)
- [June 2019](https://securityliterate.com/2019/06/)
- [February 2018](https://securityliterate.com/2018/02/)
- [September 2017](https://securityliterate.com/2017/09/)
- [August 2017](https://securityliterate.com/2017/08/)

### Categories

- [Evasive Malware Book](https://securityliterate.com/category/evasive-malware-book/)
- [Forensics](https://securityliterate.com/category/forensics/)
- [Malware Analysis](https://securityliterate.com/category/malware-analysis/)
- [Product Reviews](https://securityliterate.com/category/product-reviews/)
- [Recon](https://securityliterate.com/category/recon/)

### Meta

- [Log in](https://securityliterate.com/wp-login.php)
- [Entries feed](https://securityliterate.com/feed/)
- [Comments feed](https://securityliterate.com/comments/feed/)
- [WordPress.org](https://wordpress.org/)

[Toggle photo metadata visibility](https://securityliterate.com/go-big-or-go-home-and-other-terrible-go-puns-tips-for-analyzing-golang-malware/#)[Toggle photo comments visibility](https://securityliterate.com/go-big-or-go-home-and-other-terrible-go-puns-tips-for-analyzing-golang-malware/#)

Loading Comments...

Write a Comment...

EmailNameWebsite

%d