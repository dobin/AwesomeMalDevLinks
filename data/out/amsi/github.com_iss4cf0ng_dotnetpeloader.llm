Title:
dotNetPELoader — C# PE loader for x86 and x64

Type:
GitHub Tool

Short Summary (4–8 sentences max):
dotNetPELoader is a C# console application that loads Windows PE executables into memory for in-process execution, supporting both x86 and x64 targets. It was created to address the lack of C#-based x86 PE loaders (many public implementations are x64-only). The loader reads PE bytes from disk, checks the architecture of both the loader process and the target PE, and blocks mismatched combinations (x86-in-x64 and x64-in-x86). It implements core manual-mapping functionality including base relocations and import table resolving. The project is primarily useful for red teamers, pentesters, and malware developers experimenting with fileless execution and custom loaders, and it’s also relevant to defenders analyzing in-memory PE loading tradecraft.

Technical Focus:
- Manual PE mapping (in-memory loading) in C#
- x86 vs x64 architecture handling and constraints
- Base relocations processing
- Import Address Table (IAT) / import resolving
- Fileless execution tradecraft (in-process loader)

Use Cases:
- Execute a PE payload from memory within a .NET-hosted process
- Build/modify custom loaders for red team implants or PoCs
- Test EDR detections against manual-mapped PE execution
- Study PE loading internals (relocations/imports) via readable C# code
- Run separate x86 and x64 loaders to support mixed target environments

Keywords:
C#, .NET, PE loader, manual mapping, in-memory execution, fileless, x86, x64, relocations, import resolving, IAT, Windows PE, console application, mimikatz, payload loader, process architecture, DuplexSpy RAT, offensive tooling, red team, malware development