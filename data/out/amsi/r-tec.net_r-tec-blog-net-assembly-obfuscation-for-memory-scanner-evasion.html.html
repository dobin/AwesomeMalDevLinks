# https://www.r-tec.net/r-tec-blog-net-assembly-obfuscation-for-memory-scanner-evasion.html

<!DOCTYPE html><html lang="de">
<body id="top" class="r-tec-blog-net-assembly-obfuscation-for-memory-scanner-evasion   " itemscope="" itemtype="http://schema.org/WebPage">
<div class="emergency soforthilfe"> <div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="INCIDENT RESPONSE SERVICE" href="https://www.r-tec.net/#" data-hash="#" class="hyperlink_txt sprungmarke "><span>INCIDENT RESPONSE SERVICE</span></a>
</div><div class="ce_text Kein Abstand - 0px bg-  block">
<div class="ce_text__content">
<h3>Garantierte Reaktionszeiten.<br>Umfassende Vorbereitung.</h3>
<p>Mit unserem Incident Response Service stellen wir sicher, dass Ihrem Unternehmen im Ernstfall die richtigen Ressourcen und Kompetenzen zur Verfügung stehen. Sie zahlen eine feste monatliche Pauschale und wir bieten Ihnen dafür einen Bereitschaftsdienst mit garantierten Annahme- und Reaktionszeiten. Durch einen im Vorfeld von uns erarbeiteten Maßnahmenplan sparen Sie im Ernstfall wertvolle Zeit.</p>
<p><a href="https://www.r-tec.net/incident-response-service.html">weiterlesen</a></p>            </div>
<a class="close">zurück</a></div>
</div>
<div id="wrapper">

<div id="container">
<div class="dz_stage">
<div class="dz_stage__background dz_stage__withtext" style="background-image: url('files/content/img/Buehne_schmal/arif-wahid-266541-unsplash.jpg');">
<div class="c-image-container__copyright-layer js-copyright-close">
<div class="c-image-container__copyright-layer-close">
<svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 17 17">
<path fill="#ffffff" fill-rule="evenodd" d="M16.6892426,0.311014057 C16.2748994,-0.103671352 15.6099753,-0.103671352 15.195241,0.311014057 L8.49995112,7.00551465 L1.8051501,0.311014057 C1.39031804,-0.103671352 0.725491718,-0.103671352 0.311050725,0.311014057 C-0.103683575,0.725406195 -0.103683575,1.39015414 0.311050725,1.80493731 L7.00634058,8.49894911 L0.311050725,15.1934497 C-0.103683575,15.6081351 -0.103683575,16.2729808 0.311050725,16.6872752 C0.514213826,16.8908054 0.788063607,17 1.05428744,17 C1.3201202,17 1.59387221,16.8984304 1.79713308,16.6872752 L8.49232517,9.99287236 L15.187615,16.6872752 C15.3907781,16.8908054 15.6646279,17 15.9303629,17 C16.2042127,17 16.4704365,16.8984304 16.6735996,16.6872752 C17.0883339,16.2729808 17.0883339,15.6081351 16.6735996,15.1934497 L9.99405049,8.49894911 L16.6892426,1.80493731 C17.1035858,1.39015414 17.1035858,0.725406195 16.6892426,0.311014057"></path>
</svg>
</div>© Arif Wahid 266541 - Unsplash                                    </div>
<a href="https://www.r-tec.net/#" class="c-image-container__copyright-link js-copyright-open" title="Copyright Informationen anzeigen" tabindex="0"><i class="icon-Copyright"></i></a>
</div>
<div class="container">
<div class="row">
<div class="col-lg-12">
<div class="dz_stage__content">
<h1 class="dz_stage__headline">.NET Assembly Obfuscation for Memory Scanner Evasion</h1>
</div>
</div>
</div>
</div>
</div>
<main id="main">
<div class="inside">
<!-- indexer::stop -->

<!-- indexer::continue -->
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="article-2909">
<div class="container container__article">
<div class="row">
<div class="ce_ContentDate Gering - 30px bg-  block">
<div class="date">
<p>October 2023 Author: Sven Rath, <a rel="noopener" href="https://twitter.com/eversinc33" target="_blank">@eversinc33</a></p></div>
</div>
<div class="ce_colsetStart subcolumns ce_bs_gridStart ">
<div class="c66l col_1">
<div class="subcl" style="padding-right:0;">
<div class="ce_text Gering - 30px bg-  block">
<div class="ce_text__content">
<p class="StandardText"><span lang="EN-US">Leveraging .NET based tooling, by reflectively loading assemblies into memory, is a</span> <span lang="EN-US"><a rel="noopener" href="https://attack.mitre.org/techniques/T1620//" target="_blank">common post-exploitation TTP</a></span><span lang="EN-US"> used by threat actors as well as red teams for many years already. The use of .NET is attractive for multiple reasons. First of all the .NET framework comes pre-installed with all recent versions of the Windows operating system, which allows for high portability and compatibility. In addition, .NET, especially C#, offers an easy development experience, with many libraries for common protocols and software, which allows for quick prototyping and PoCs. Hence, many of the most valuable tools for offensive operations, such as <a href="https://github.com/BloodHoundAD/SharpHound">SharpHound</a>, <a href="https://github.com/GhostPack/Certify">Certify</a> or <a href="https://github.com/GhostPack/Rubeus">Rubeus</a>, are written in or have been ported to C#.</span></p>
<p class="StandardText"><span lang="EN-US">At the latest with the release of <a href="https://www.cobaltstrike.com/blog/cobalt-strike-3-11-the-snake-that-eats-its-tail">Cobalt Strike 3.11 in 2018</a>, which introduced the <code><em>execute-assembly</em></code> </span><span lang="EN-US">command to the framework, .NET based tradecraft became a stable in every red teamer's arsenal. However, defenders caught up with this trend in recent years, employing several techniques to detect in-memory .NET assembly execution.</span></p>
<p class="StandardText"><span lang="EN-US">This blog post will give a short overview of how in-memory .NET assembly execution commonly works and what detection mechanisms exist. One of the techniques that we at r-tec employ to evade these detections is obfuscation. The final part of this post will then showcase how we automate this approach through CI/CD / DevOps techniques in our internal obfuscation pipeline.</span></p>            </div>
</div>        </div>
</div>
<div class="c33r">
<div class="subcr" style="padding-left:0px;">
<div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="1. How Does Reflective Loading of .NET Assemblies Work?" href="https://www.r-tec.net/#howto" data-hash="#howto" class="hyperlink_txt sprungmarke "><span>1. How Does Reflective Loading of .NET Assemblies Work?</span></a>
</div><div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="2. Detections" href="https://www.r-tec.net/#detections" data-hash="#detections" class="hyperlink_txt sprungmarke "><span>2. Detections</span></a>
</div><div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="3. Obfuscation &amp; .NET" href="https://www.r-tec.net/#obfuscation" data-hash="#obfuscation" class="hyperlink_txt sprungmarke "><span>3. Obfuscation &amp; .NET</span></a>
</div><div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="4. The Obfuscation Pipeline" href="https://www.r-tec.net/#pipeline" data-hash="#pipeline" class="hyperlink_txt sprungmarke "><span>4. The Obfuscation Pipeline</span></a>
</div><div class="ce_hyperlink Kein Abstand - 0px bg-  block">
<a title="5. Summary" href="https://www.r-tec.net/#summary" data-hash="#summary" class="hyperlink_txt sprungmarke "><span>5. Summary</span></a>
</div>        </div>
</div>
</div>
</div>
</div>
</div>
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="article-2910">
<div class="container container__article">
<div class="row">
<div class="ce_text Kein Abstand - 0px bg-  block" id="howto">
<h2>1. How Does Reflective Loading of .NET Assemblies Work?</h2>
<div class="ce_text__content">
<p>Almost all modern C2 frameworks support some sort of command to execute .NET assemblies in memory, such as cobalt strikes <em><code>execute-assembly</code></em>. While of course, the implementation, behavior, and IoCs differ from implementation to implementation, all public implementations&nbsp; - at least we know of - rely on calling the .NET API for <a href="https://learn.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection">code reflection through the Common Language Runtime (CLR)</a>.</p>
<p>This API enables us to dynamically create instances of types at runtime, invoke their methods, and access their members. Additionally, the common language runtime loader manages application domains for us and ensures proper loading of dependencies.</p>
<p>In C#, reflectively loading an assembly (to the host process) is as easy as 3 lines of code, using <code><em>Assembly.Load</em></code> to load an assembly from a byte array:</p>
<pre><em>Assembly assembly = Assembly.Load(assemblyBytes);</em><br><em>MethodInfo entryPoint = assembly.EntryPoint;</em><br><em>entryPoint.Invoke(null, new object[] { new string[] { "arg1", "arg2" } });</em><br><br></pre>
<p class="StandardText"><span lang="EN-US">Similar code can be achieved</span><span lang="EN-US"><a href="https://gist.github.com/xpn/e95a62c6afcf06ede52568fcd8187cc2"> with C++</a>,</span><span lang="EN-US"> although slightly more complicated since the CLR has to be loaded first. In the end, all of these techniques end up calling the native</span> <code><a href="https://github.com/microsoft/referencesource/blob/master/mscorlib/system/reflection/assembly.cs#L408"><span lang="EN-US">nLoadImage</span></a></code><span lang="EN-US"> from </span><code><span lang="EN-US"><em>System.Reflection.Assembly</em></span></code><span lang="EN-US">, which leads us to the different detection opportunities.</span></p>            </div>
</div>
</div>
</div>
</div>
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="article-2911">
<div class="container container__article">
<div class="row">
<div class="ce_text Gering - 30px bg-  block" id="detections">
<h2>2. Detections</h2>
<div class="ce_text__content">
<p>Just as in PowerShell tradecraft, AMSI is also an obstacle when using in-memory .NET execution, as since .NET framework 4.8, all assemblies loaded from byte arrays are passed to <a href="https://docs.microsoft.com/en-us/windows/desktop/api/amsi/nf-amsi-amsiscanbuffer">AmsiScanBuffer</a>. While on the one hand, this means that payloads will be scanned for malware signatures, this also means that this obstacle is easy to overcome - patching AMSI, with <a href="https://github.com/Mr-Un1k0d3r/AMSI-ETW-Patch">byte patches</a> or <a href="https://ethicalchaos.dev/2022/04/17/in-process-patchless-amsi-bypass/">patchless</a>, e.g., via hardware breakpoints, is easy and has been written about countless times.</p>
<p>Besides AMSI, the second obstacle that sends a lot of telemetry that can help defenders spot malicious activity in .NET runtimes is Event Tracing for Windows (ETW). Essentially, ETW is a provider-subscriber technology integrated into Windows, which allows applications to log events and other applications to consume them.</p>
<p>For the use-case of detecting <em><code>Assembly.Load</code></em> events, the following <a href="https://learn.microsoft.com/en-us/dotnet/framework/performance/clr-etw-providers">two providers</a> are of the most interest. Here, <em><code>DotNETRuntime</code></em> provides live events of the .NET runtime and the <em><code>DotNETRuntimeRundown</code> </em>provider lists information about assemblies already loaded into a process, when ETW tracing is enabled:</p>
<pre><em>Microsoft-Windows-DotNETRuntime {E13C0D23-CCBC-4E12-931B-D9CC2EEE27E4}</em><br><em>Microsoft-Windows-DotNETRuntimeRundown {A669021C-C450-4609-A035-5AF59AF4DF18}</em></pre>
<p>We can investigate the information these providers give using <a href="https://processhacker.sourceforge.io/">Process Hacker</a>. If we reflectively load an assembly into any process using <code><em>Assembly.Load</em></code>, e.g., through PowerShells access to the .NET framework and <a href="https://github.com/eversinc33/PowerSharpPack/blob/master/PowerSharpBinaries/Invoke-Certify.ps1">PowerSharpPack</a>, we see the assembly show up in the default AppDomain, with the name of our Post-Exploitation tool showing up in clear text - a really low hanging fruit for defenders to pick.</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/NET%20Assembly%20Obfuscation%20for%20Memory%20Scanner%20Evasion/Figure%201%3A%20Reflectively%20loading%20Certify%20in%20powershell.exe.png" width="833" height="281" alt="">
</div>
<figcaption class="caption">Figure 1: Reflectively loading Certify in powershell.exe</figcaption>
</figure>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/NET%20Assembly%20Obfuscation%20for%20Memory%20Scanner%20Evasion/Figure%202%3A%20.NET%20assembly%20view%20in%20Process%20Hacker.png" width="908" height="238" alt="">
</div>
<figcaption class="caption">Figure 2: .NET assembly view in Process Hacker</figcaption>
</figure>
</div><div class="ce_text Gering - 30px bg-  block">
<div class="ce_text__content">
<p class="StandardText"><span lang="EN-US">However, since these ETW providers reside in userland, we can simply patch one of the functions like </span><em><code><span lang="EN-US">NtTraceEvent</span> </code></em><span lang="EN-US">from </span><em><code><span lang="EN-US">ntdll.dll</span></code></em><span lang="EN-US">, similar to how we are used to patching AMSI, using one of the many <a href="https://github.com/Mr-Un1k0d3r/AMSI-ETW-Patch">known &amp; public techniques</a> and tools.</span></p>
<p class="StandardText"><span lang="EN-US">This way we stop the processes from further sending ETW telemetry data. While blinding the consumers and thus evading any ETW-based detections, we now have the IoC of a dead ETW stream - as such, patching should ideally be done in a less invasive manner, e.g. by only filtering specific events or feeding false information instead. Only disabling ETW for a small amount of time is not feasible, as the .NET assembly will then show up again after restoring the patched bytes.</span></p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/NET%20Assembly%20Obfuscation%20for%20Memory%20Scanner%20Evasion/Figure%203%3A%20Process%20Hacker%20view%20after%20patching%20ETW.png" width="912" height="264" alt="">
</div>
<figcaption class="caption">Figure 3: Process Hacker view after patching ETW</figcaption>
</figure>
</div><div class="ce_text Gering - 30px bg-  block">
<div class="ce_text__content">
<p class="StandardText"><span lang="EN-US">However, our assembly's MZ and PE headers can still be found when analyzing the memory of the process, as well as the whole assembly itself. So even if AMSI and ETW are bypassed, an EDR could still run a memory scan on our process, if it behaves suspiciously and detect the loaded assembly, e.g. with YARA rules matching known post-exploitation tool's signatures or with <a href="https://www.gdatasoftware.com/blog/2020/06/36164-introducing-the-typerefhash-trh">TypeRef Hash matching</a>.</span></p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/NET%20Assembly%20Obfuscation%20for%20Memory%20Scanner%20Evasion/Figure%204%3A%20PE%20image%20in%20memory.png" width="1159" height="661" alt="">
</div>
<figcaption class="caption">Figure 4: PE image in memory</figcaption>
</figure>
</div><div class="ce_text Kein Abstand - 0px bg-  block">
<div class="ce_text__content">
<p class="StandardText"><span lang="EN-US">As an astute reader might have noticed when using the plain</span><code> <em><span lang="EN-US">Assembly.Load</span> </em></code><span lang="EN-US">function, a memory page with </span><em><code><span lang="EN-US">RW</span> </code></em><span lang="EN-US">protection is used to store the assembly. This is because the image contains just the intermediate language (IL) code, which will be translated by the Just-In-Time compiler (JIT) and written into a memory page with execute protection when needed. This JIT compilation can also be leveraged by defenders for further insight via ETW, e.g. to monitor which functions are executed by monitoring their compilation (see <a href="https://blog.f-secure.com/detecting-malicious-use-of-net-part-2/">https://blog.f-secure.com/detecting-malicious-use-of-net-part-2/</a> for a more detailed description).</span></p>
<p class="StandardText"><span lang="EN-US">While the PE and MZ headers can be stomped, the assembly itself cannot, at least not as long as it is running.</span></p>
<p class="StandardText"><span lang="EN-US">Of course, there are other opportunities to detect malicious .NET assembly execution, be it by hooking into </span><em><code><span lang="EN-US">Assembly.Load</span></code></em><span lang="EN-US"> or its native counterpart, or by monitoring general behavior (the loading of the CLR in uncommon processes, monitoring Windows APIs, monitoring network traffic, ...), where the latter is the hardest to bypass. The <a href="http://detect-respond.blogspot.com/2013/03/the-pyramid-of-pain.html">pyramid of pain model</a> applies here as well: while some detections are easy to bypass, it gets harder the more abstract these detections become.</span></p>
<p class="StandardText"><span lang="EN-US">Discussing all of these detection opportunities and bypass techniques for each is out of the scope of this article. We however found that automated obfuscation of the assemblies themselves is an effective and efficient measure against many memory scanning and AMSI- or ETW-based detections. So (for now) proper obfuscation </span><span lang="EN-US">alone</span> <span lang="EN-US">is sufficient to evade detections in our customer's environments.</span></p>            </div>
</div>
</div>
</div>
</div>
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="obfuscation">
<div class="container container__article">
<div class="row">
<div class="ce_text Gering - 30px bg-  block" id="obfuscation">
<h2>3. Obfuscation &amp; .NET</h2>
<div class="ce_text__content">
<p class="StandardText"><span lang="EN-US">While .NET has some of the benefits that were already mentioned in the introduction, such as the ease of development and portability, there are also some OPSEC drawbacks that originate from these capabilities. To understand this, it is vital to understand what constitutes a managed framework such as .NET and where these capabilities come from.</span></p>
<p class="StandardText"><span lang="EN-US">.NET compiles source code into an intermediate language (IL) before generating machine code. This IL is an abstract representation of the program, which gets Just-in-Time compiled to the target architecture by the Common-Language-Runtime. This is similar to how Java and the Java Virtual Machine (JVM) relate.</span></p>
<p class="StandardText"><span lang="EN-US">On the one hand, this has benefits for us as operators, since we can more easily transform this abstract language to obfuscate a binary, even without having access to the source code. On the other hand, this makes a reverse engineer’s life much easier, since class names, method names, and other metadata are baked into the assembly. Also, decompilation is super easy and leads to recovering of the source code for full analysis. In contrast, a disassembled stripped C-based binary will not be that easy to analyze.</span></p>
<p class="StandardText"><span lang="EN-US">This can be illustrated by opening a compiled version of Rubeus in the <span style="text-decoration: underline;"><a href="https://github.com/icsharpcode/ILSpy">ilSpy</a> </span>decompiler and comparing it to the actual source code:</span></p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/NET%20Assembly%20Obfuscation%20for%20Memory%20Scanner%20Evasion/Figure%205%3A%20Decompiled%20Asreproast%20class.png" width="937" height="758" alt="">
</div>
<figcaption class="caption">Figure 5: Decompiled Asreproast class</figcaption>
</figure>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/NET%20Assembly%20Obfuscation%20for%20Memory%20Scanner%20Evasion/Figure%206%3A%20Actual%20source%20code%20of%20the%20Asreproast%20class.png" width="994" height="837" alt="">
</div>
<figcaption class="caption">Figure 6: Actual source code of the Asreproast class</figcaption>
</figure>
</div><div class="ce_text Gering - 30px bg-  block">
<div class="ce_text__content">
<p>As can be seen, the decompiled source almost matches the actual source. With identifier names in clear text, this also gives defenders a much more straightforward way of writing detection rules for .NET-based tools. A simple search for specific method- or class-names can give a high certainty for a true positive - unless you happen to find a legitimate tool with an <em><code>Asreproast</code> </em>class. This means, that an obfuscator, for our use case, should at least rename all identifiers with random or pseudo-random names.</p>
<p>But besides the identifiers, there is more that can and should be obfuscated. If we take a look at the metadata, some obvious IoCs jump out:</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/NET%20Assembly%20Obfuscation%20for%20Memory%20Scanner%20Evasion/Figure%207%3A%20Metadata%20of%20Rubeus.exe.png" width="905" height="322" alt="">
</div>
<figcaption class="caption">Figure 7: Metadata of Rubeus.exe</figcaption>
</figure>
</div><div class="ce_text Gering - 30px bg-  block">
<div class="ce_text__content">
<p class="StandardText"><span lang="EN-US">These assembly metadata entries come from the </span><em><code><span lang="EN-US">AssemblyInfo.cs</span></code></em><span lang="EN-US"> file corresponding to the project. Some here are very obvious, such as the </span><em><code><span lang="EN-US">AssemblyTitle</span> </code></em><span lang="EN-US">and </span><em><code><span lang="EN-US">AssemblyProduct</span></code></em><span lang="EN-US">, simply stating </span><em><code><span lang="EN-US">Rubeus</span> </code></em><span lang="EN-US">and giving away what this program contains, even if all identifiers were obfuscated. Another important one to change is the </span><em><code><span lang="EN-US">Guid</span> </code></em><span lang="EN-US">attribute, which is the COM GUID if the project is exposed to COM, which, as a unique identifier, is perfect for defenders to look for.</span></p>
<p class="StandardText"><span lang="EN-US">A good obfuscator takes care of rewriting all of these attributes, such as Accenture's <a href="https://github.com/Accenture/Codecepticon">Codecepticon</a>. If we let Codecepticon obfuscate Rubeus, all attributes are rewritten to random, empty or supposedly trustworthy attributes:</span></p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/NET%20Assembly%20Obfuscation%20for%20Memory%20Scanner%20Evasion/Figure%208%3A%20Obfuscated%20metadata.png" width="873" height="323" alt="">
</div>
<figcaption class="caption">Figure 8: Obfuscated metadata</figcaption>
</figure>
</div><div class="ce_text Kein Abstand - 0px bg-  block">
<div class="ce_text__content">
<p class="StandardText"><span lang="EN-US">Besides metadata, namespaces and identifiers, strings are another great opportunity for defenders to write detection rules - as with most programming languages, strings are stored in clear text in the binary. Here we can advise you to check how your obfuscator of choice encrypts/obfuscates strings. Some tools simply base64 encode strings, which is not sufficient from our opinion, since these strings can then be easily decoded and are predictable (e.g. </span><em><code><span lang="EN-US">Rubeus</span> </code></em><span lang="EN-US">in UTF-8 always encodes to </span><em><code><span lang="EN-US">UnViZXVz</span></code></em><span lang="EN-US">). Others take more sophisticated approaches, such as actual encryption. Daisy-chaining obfuscators can be of help here, e.g. use one obfuscator for namespace and identifier renaming, another just for string encryption, and so on.</span></p>
<p class="StandardText"><span lang="EN-US">We did not find any obfuscators yet, that also tamper with the <a href="https://www.gdatasoftware.com/blog/2020/06/36164-introducing-the-typerefhash-trh">TypeRef Hash</a>. The TypeRef Hash can be compared to an Imphash, which can be used to identify similar PEs by hashing their imports. Since a .NET PE usually only imports </span><em><code><span lang="EN-US">mscoree.dll</span></code></em><span lang="EN-US">, the regular Imphash is of no use. The TypeRef Hash instead is generated based on the imported .NET TypeNamespaces and TypeNames (e.g. </span><em><code><span class="ATechnical1Zchn"><span lang="EN-US">System.Reflection</span></span></code></em><span lang="EN-US"> was used with the TypeName </span><span class="ATechnical1Zchn"><span lang="EN-US"><em><code>AssemblyTitleAttribute</code></em>)</span></span><span lang="EN-US">. An obfuscator could alter this hash, e.g. by arbitrarily adding imports, but we also did not seem to face any endpoint detections based on TypeRef Hashes yet.</span></p>
<p class="StandardText"><span lang="EN-US">While for obvious reasons, we will not give away the exact chain of obfuscators we use in our pipeline, there are many obfuscators available as both free and paid versions, which all excel in different features, such as:</span></p>
<ul>
<li><a href="https://github.com/yck1509/ConfuserEx">https://github.com/yck1509/ConfuserEx</a></li>
<li><a href="https://github.com/Accenture/Codecepticon">https://github.com/Accenture/Codecepticon</a></li>
<li><a href="https://github.com/obfuscar/obfuscar">https://github.com/obfuscar/obfuscar</a></li>
<li><a href="https://github.com/0xb11a1/yetAnotherObfuscator">https://github.com/0xb11a1/yetAnotherObfuscator</a></li>
<li><a href="https://github.com/BinaryScary/NET-Obfuscate">https://github.com/BinaryScary/NET-Obfuscate</a></li>
</ul>
<p class="StandardText"><span lang="EN-US">Another non-exhaustive list of obfuscators can be found in the README of the following repository: <a href="https://github.com/NotPrab/.NET-Obfuscator">https://github.com/NotPrab/.NET-Obfuscator</a></span></p>
<p class="StandardText"><span lang="EN-US">There is another consideration to keep in mind when choosing your obfuscator or obfuscator chain. Just like packers and unpackers, some obfuscators can be automatically de-obfuscated with tools such as <a href="https://github.com/de4dot/de4dot">de4dot</a> - which makes the blue team's work easier. Those obfuscators should be avoided.</span></p>
<p class="StandardText"><span lang="EN-US">Now we have an idea of what and how to obfuscate our .NET assemblies. However, doing this manually for every single assembly we want to execute in our engagements is tedious and error-prone - which leads us to automation and lets us dive into a tiny bit of DevOps.</span></p>            </div>
</div>
</div>
</div>
</div>
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="wording">
<div class="container container__article">
<div class="row">
<div class="ce_text Gering - 30px bg-  block" id="pipeline">
<h2>4. The Obfuscation Pipeline</h2>
<div class="ce_text__content">
<p>For the automation, different approaches are possible. Since .NET can be cross-compiled, our pipeline could run under all the classic CI/CD Pipelines based on Linux docker containers, such as GitLab CI/CD, GitHub Actions, or others. However, from our experience, working "natively" from Windows is much more straightforward in the case of .NET, and many of the obfuscation tools are Windows-based too.</p>
<p>If you have been doing CTFs such as HackTheBox or have been playing around in your lab with C2 Frameworks and .NET offensive tooling, you are probably aware of <a href="https://twitter.com/Flangvik">@Flangvik</a>'s work with <a href="https://github.com/Flangvik/SharpCollection">SharpCollection</a>. SharpCollection is a repository with recent builds of common .NET post-exploitation tools, which is automatically updated by a CI/CD Pipeline running via a free tier of <a href="https://azure.microsoft.com/en-us/products/devops">Microsoft Azure DevOps</a>.</p>
<p>Fortunately, Flangvik also did a <a href="https://www.youtube.com/watch?v=BbXRfMNjwg0&amp;ab_channel=Flangvik">great video</a> showcasing how the SharpCollection pipeline works and how to implement it. Thus, we took this idea as a base to implement our own C# obfuscation pipeline.</p>
<p>While the process of setting up the pipeline is out of the scope of this article, the process can be summarized as follows:</p>
<ul>
<li>Set up an Azure DevOps Project</li>
<li>Set up a VM/Host as an Azure Agent (the machine that will do the compilation and obfuscation work)</li>
<li>Create a Pipeline for each .NET assembly's GitHub repository</li>
</ul>
<p>Again, for details in the implementation, refer to the <a href="https://www.youtube.com/watch?v=BbXRfMNjwg0&amp;ab_channel=Flangvik">aforementioned video</a>, or if you prefer reading text, <a href="https://blog.xpnsec.com/building-modifying-packing-devops/">this blog post</a> by <a href="https://twitter.com/_xpn_">@_xpn_</a>.</p>
<p>For our pipeline, we decided that each day, early in the morning, Azure should run the obfuscation pipeline for every repository in our list.</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/NET%20Assembly%20Obfuscation%20for%20Memory%20Scanner%20Evasion/Figure%209%3A%20Pipeline%20trigger.png" width="640" height="124" alt="">
</div>
<figcaption class="caption">Figure 9: Pipeline trigger</figcaption>
</figure>
</div><div class="ce_text Mittel - 60px bg-  block">
<div class="ce_text__content">
<p>Our pipeline template then runs the following steps for each project:</p>
<ul>
<li>Rename the project (since our obfuscator of choice does not do this)</li>
<li>Install dependencies with NuGet</li>
<li>Run our source code obfuscator</li>
<li>Build the project</li>
<li>Run another string-obfuscation tool (on the binary)</li>
<li>Move the output files to our output directory</li>
<li>Push the new binaries to our internal git repository</li>
</ul>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/NET%20Assembly%20Obfuscation%20for%20Memory%20Scanner%20Evasion/Figure%2010%3A%20Obfuscation%20pipeline%20steps.png" width="748" height="522" alt="">
</div>
<figcaption class="caption">Figure 10: Obfuscation pipeline steps</figcaption>
</figure>
</div><div class="ce_text Gering - 30px bg-  block">
<div class="ce_text__content">
<p>This way, we always have the newest versions of all our .NET tooling available, nicely organized in a GitLab repository, freshly obfuscated and ready to use with our C2 agents:</p>            </div>
</div><div class="ce_image Gering - 30px bg-  block">
<figure class="image_container">
<div style="position:relative;overflow:hidden;">
<img src="https://www.r-tec.net/files/content/img/News%2BEvents/NET%20Assembly%20Obfuscation%20for%20Memory%20Scanner%20Evasion/Figure%2011%3A%20GitLab%20repository%20with%20obfuscated%20assemblies.png" width="921" height="705" alt="">
</div>
<figcaption class="caption">Figure 11: GitLab repository with obfuscated assemblies</figcaption>
</figure>
</div><div class="ce_text Kein Abstand - 0px bg-  block">
<div class="ce_text__content">
<p>If the obfuscation was done properly, you may not even need to bypass AMSI or ETW at all for C2 in-memory execution, because most likely, all signature based IoC’s are not visible anymore.</p>
<p>Lastly some <strong>operational security considerations</strong> need to be addressed: If you are compiling code from public GitHub repositories on your Azure Pipeline Host, a backdoor in one of these can lead to a compromise of the Host. To avoid this, local copies of the repositories are recommended to be used, where only reviewed code is pushed for updates in the tools. If you’re not using local copies, the Azure Pipeline Host should definitely be hardened, according to your organization’s best practices, and isolated from your company network. Security companies and security professionals are lucrative targets for threat actors, since these companies usually deal with very sensitive data. r-tec has also observed threat actors targeting <a href="https://www.r-tec.net/r-tec-blog-when-hackers-hack-the-hackers.html">offensive security people</a> with the goal of stealing internal tools and other intellectual property. Finally, as with any public code or tool, to avoid running tools with backdoors, a thorough source code review is necessary before executing any payload in a customer’s environment.</p>            </div>
</div>
</div>
</div>
</div>
<div class="mod_article color-Schwarz Kein Abstand - 0px bg- block" id="summary">
<div class="container container__article">
<div class="row">
<div class="ce_text Mittel - 60px bg-  block" id="summary">
<h2>5. Summary</h2>
<div class="ce_text__content">
<p>Running .NET assemblies from memory, through the .NET reflection API, is one of the most common TTPs for code execution, used by red teamers and threat actors alike. While both ETW and AMSI can be used for detections, bypassing these measures through patching or via hardware breakpoints can be done without much effort - which is already automated in many C2 frameworks. However, memory scanning is a detection that is harder to bypass or avoid. Therefore we additionally obfuscate our assemblies, change metadata, encrypt strings, and rename identifiers, to avoid detections based on signatures. Using DevOps / CI/CD, this approach can be automated at scale for a whole post-exploitation arsenal, producing assemblies that are different every day. While this is from our view sufficiently stealthy currently, with other detection opportunities, as discussed in this article, additional measures might be necessary in the future.</p>            </div>
</div>
</div>
</div>
</div>
</div>
</main>
</div>

</div>






</body></html>