Title:
Bypass AMSI in 2025

Type:
Blog Post

Short Summary (4–8 sentences max):
- The post revisits how Microsoft’s Antimalware Scan Interface (AMSI) works and what bypass techniques still hold up in 2025 across PowerShell and .NET execution paths.  
- It clarifies when AMSI bypassing is actually necessary (mainly for scripts and managed code) and argues that adding AMSI bypasses to pure shellcode loaders often increases detection surface unnecessarily.  
- The author frames AMSI largely as runtime, signature-driven scanning and discusses evasion via code modification/obfuscation versus breaking AMSI functionality (patching, exception/VEH tricks, hardware breakpoints, or preventing relevant DLLs from loading).  
- It highlights the operational downside of public obfuscators (breakage, vendor-specific AMSI signatures, and VirusTotal blind spots for AMSI runtime detections).  
- A key focus is modern EDR/Defender behavior detections: classic `AmsiScanBuffer` entrypoint patches are increasingly caught via kernel-emitted telemetry (ETW-TI) plus memory validation, but alternative patch offsets/byte sequences can still work.  
- It concludes that hardware breakpoints and DLL-load/initialization manipulation are currently more OpSec-safe than entrypoint patching, though detections are evolving.  
- Useful primarily for red teams/pentesters building tradecraft around PowerShell/.NET execution and for defenders understanding common bypass patterns and telemetry.

Technical Focus:
- AMSI architecture and scan triggers (PowerShell vs CLR/.NET managed code paths)
- Signature evasion via manual modification and obfuscation (and limitations of public obfuscators)
- Runtime bypass techniques: in-memory patching, hooks, VEH/hardware breakpoints
- ETW Threat Intelligence (ETW-TI) and memory-scan based detection of AMSI tampering
- Preventing AMSI-related DLL loading / pre-initialization manipulation in new processes
- Provider enumeration and non-`amsi.dll` scanning (custom AMSI providers)

Use Cases:
- Assess whether an operation actually requires AMSI evasion (script/managed code vs BOF/COFF)
- Choose an AMSI bypass strategy based on target language and EDR behavior detections
- Develop/modify bypass implementations to avoid static signatures and known patch heuristics
- Build detections/hunts for AMSI tampering (VirtualProtect+Write patterns, ETW-TI signals, patch validation)
- Evaluate risks of using public obfuscators and validate in realistic EDR environments (not just VT)

Keywords:
AMSI, amsi.dll, AmsiScanBuffer, PowerShell, .NET, CLR, assembly load, Invoke-Expression, Add-Type, Invoke-Obfuscation, signature evasion, in-memory patching, VirtualProtect, ETW-TI, memory scanning, userland hooks, unhooking, indirect syscalls, VEH, hardware breakpoints, SetThreadContext, DLL load prevention, AMSI provider DLL, Windows Defender, EDR detection