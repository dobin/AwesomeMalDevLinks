Title:
Being a good CLR host – Modernizing offensive .NET tradecraft

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post explains how to modernize in-memory .NET assembly execution by using “Unmanaged CLR Hosting” with CLR customizations rather than relying on older, common execute-assembly patterns.  
- It shows how to host the CLR via `ICLRRuntimeHost` while still obtaining `ICorRuntimeHost` for reflective loading, enabling deeper control over CLR behavior through `SetHostControl` and `IHostControl`.  
- The core technique is implementing CLR “manager” interfaces—especially `IHostMemoryManager` and `IHostAssemblyManager/IHostAssemblyStore`—to intercept memory allocations, track assembly mapping, and wipe assembly load artifacts reliably.  
- A key outcome is a novel AMSI bypass that avoids byte patching or process tampering by loading assemblies via identity (`Load_2`) and supplying bytes through `ProvideAssembly` (IStream), which prevents AMSI from scanning and may avoid loading `amsi.dll` entirely.  
- It includes a proof-of-concept implementation in C and discusses operational caveats (e.g., assembly identity must match) plus defensive considerations (ETW visibility, memory scanning, and potential defensive use of the same callbacks).  
- Useful for red teams and implant/tooling developers building stealthier .NET execution harnesses, and for blue teams seeking to detect/mitigate CLR-host-based tradecraft.

Technical Focus:
- Unmanaged CLR hosting (`ICLRRuntimeHost`, `ICorRuntimeHost`, `SetHostControl`)
- CLR customizations via COM (`IHostControl` and manager interfaces)
- Memory manager interception (`IHostMemoryManager`, `IHostMalloc`, Virtual* APIs)
- Assembly load interception (`IHostAssemblyManager`, `IHostAssemblyStore`, `ProvideAssembly`, IStream)
- Artifact tracking/wiping via `AcquiredVirtualAddressSpace`
- AMSI evasion by alternate assembly load paths (`Load_2` vs `Load_3`)

Use Cases:
- Build an in-process execute-assembly alternative with fewer common behavioral IOCs (no fork-and-run/reflective DLL injection)
- Track and wipe in-memory assembly mapping regions after execution to reduce forensic residue
- Implement AMSI bypass without patching `AmsiScanBuffer` or hooking AMSI/ETW
- Add custom memory allocation strategies (e.g., indirect syscalls, allocation tracking, selective encryption experiments)
- Defensive R&D: detect/scan assembly mapping regions using the same CLR callbacks or block/modify loads via `IHostAssemblyStore`

Keywords:
CLR hosting, Unmanaged CLR Hosting, ICLRRuntimeHost, ICorRuntimeHost, SetHostControl, IHostControl, CLR customizations, IHostMemoryManager, IHostMalloc, VirtualAlloc, VirtualProtect, AcquiredVirtualAddressSpace, IHostAssemblyManager, IHostAssemblyStore, ProvideAssembly, SHCreateMemStream, IStream, AMSI, AmsiScanBuffer, ETW, in-memory .NET execution, Load_2, Load_3, AppDomain, COM interfaces, execute-assembly, InlineExecute-Assembly, OPSEC