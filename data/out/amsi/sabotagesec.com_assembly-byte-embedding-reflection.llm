Title:
Assembly Byte Embedding & Reflection

Type:
Blog Post

Short Summary (4–8 sentences max):
This post explains a common .NET malware/stager pattern: embedding a managed DLL as raw bytes inside a loader and executing it at runtime via reflection. It walks through converting a DLL to a byte array (using PowerShell), hardcoding that array into a C# program, and loading it in-memory with `System.Reflection.Assembly.Load(byte[])` instead of `LoadFile()`. After loading, the loader resolves a target type and method (`GetType`, `GetMethod`) and executes it using `Activator.CreateInstance` and `MethodInfo.Invoke`. The technique reduces on-disk artifacts for the payload and demonstrates how adversaries deploy managed components dynamically. It’s mainly useful for red teamers, offensive tool developers, and malware analysts; defenders can use it to understand and detect reflective .NET loading behaviors.

Technical Focus:
- Managed .NET assembly byte embedding (DLL-to-byte-array)
- In-memory assembly loading via `Assembly.Load(byte[])`
- Reflection-based type/method discovery (`GetType`, `GetMethod`)
- Dynamic object creation (`Activator.CreateInstance`)
- Runtime method execution (`MethodInfo.Invoke`)
- PowerShell file-to-bytes conversion (`Get-Content -Encoding Byte`, `ReadAllBytes`)

Use Cases:
- Build .NET loaders/stagers that execute embedded managed payloads from memory
- Prototype reflective execution chains for red team tradecraft
- Malware analysis: recognize and replicate common .NET stager deployment models
- Detection engineering: hunt for `Assembly.Load(byte[])` + reflection invocation patterns in telemetry

Keywords:
.NET, C#, System.Reflection, Assembly.Load, LoadFile, byte array embedding, managed DLL, reflection, Activator.CreateInstance, MethodInfo.Invoke, GetType, GetMethod, in-memory execution, PowerShell Get-Content, ReadAllBytes, malware stager, payload deployment, fileless execution, MA&RE, TTPs