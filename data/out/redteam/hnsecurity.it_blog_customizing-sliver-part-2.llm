Title:
Customizing Sliver – Part 2

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post explains Sliver C2’s end-to-end communication model to prepare readers to add custom commands to the framework.  
- It walks through how an operator command in the client becomes a protobuf message sent over gRPC to the server, then forwarded to an implant over the active transport (HTTP/S, DNS, WireGuard, etc.), and how responses return along the reverse path.  
- The author maps client commands (e.g., `execute-assembly`) to generated gRPC stubs from `services.proto`, and to server-side handlers in `server/rpc/rpc-*.go`.  
- It then dives into server→implant task dispatch via `sliver.proto` messages and the `rpc.GenericHandler()` flow (marshal request, `session.Request()`, unmarshal response, error propagation).  
- On the implant side, it shows how OS-specific handlers (e.g., `handlers_windows.go`) unmarshal task requests, execute logic (e.g., in-proc .NET execution with AMSI/ETW bypass flags), marshal results, and return via a callback.  
- Useful for red teamers and tool developers who want to extend Sliver cleanly by modifying protobuf definitions and regenerating code (`make pb`) while understanding where to implement client/server/implant changes.

Technical Focus:
- Sliver architecture: client ↔ server (gRPC) and server ↔ implant (transport channel)
- Protobuf schema design and code generation (services.proto, client.proto, sliver.proto; `protoc`, `services_grpc.pb.go`)
- Server RPC handlers and task routing (`server/rpc/*`, `rpc.GenericHandler`, `session.Request`)
- Implant task handlers and OS-specific dispatch (`handlers.go`, `handlers_<os>.go`)
- Sync vs async tasking (SessionID vs BeaconID, `commonpb.Request.Async`)
- In-memory .NET execution pipeline (Donut generation, in-proc execution, AMSI/ETW bypass flags)

Use Cases:
- Add a new custom Sliver command end-to-end (client command → gRPC → server handler → implant handler)
- Debug why a command’s request/response is not reaching the implant (marshal/unmarshal, message numbers, handler mapping)
- Extend protobuf messages to carry new parameters and regenerate Sliver RPC stubs
- Implement OS-specific implant functionality by placing handlers in the correct `handlers_<os>.go` file
- Understand and modify tasking behavior for sessions vs beacons (sync/async)

Keywords:
Sliver C2, BishopFox Sliver, gRPC, Protocol Buffers, protobuf, services.proto, sliver.proto, client.proto, protoc, services_grpc.pb.go, server/rpc, rpc.GenericHandler, session.Request, Beacon, Session, HTTP/S C2, DNS C2, WireGuard, implant handlers, handlers_windows.go, ExecuteAssembly, Donut, in-memory execution, AMSI bypass, ETW bypass