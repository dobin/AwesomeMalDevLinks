# https://specterops.io/blog/2025/04/07/an-operators-guide-to-device-joined-hosts-and-the-prt-cookie/

![Revisit consent button](https://cdn-cookieyes.com/assets/images/revisit.svg)

We value your privacy

We use cookies to enhance your browsing experience, serve personalized ads or content, and analyze our traffic. By clicking "Accept All", you consent to our use of cookies.

CustomizeReject AllAccept All

Customize Consent Preferences![](https://cdn-cookieyes.com/assets/images/close.svg)

NecessaryAlways Active

Necessary cookies are required to enable the basic features of this site, such as providing secure log-in or adjusting your consent preferences. These cookies do not store any personally identifiable data.

- Cookie

\_cfuvid

- Duration

session

- Description

Calendly sets this cookie to track users across sessions to optimize user experience by maintaining session consistency and providing personalized services


- Cookie

\_GRECAPTCHA

- Duration

6 months

- Description

Google Recaptcha service sets this cookie to identify bots to protect the website against malicious spam attacks.


- Cookie

cookieyes-consent

- Duration

1 year

- Description

CookieYes sets this cookie to remember users' consent preferences so that their preferences are respected on subsequent visits to this site. It does not collect or store any personal information about the site visitors.


Functional

Functional cookies help perform certain functionalities like sharing the content of the website on social media platforms, collecting feedback, and other third-party features.

- Cookie

li\_gc

- Duration

6 months

- Description

Linkedin set this cookie for storing visitor's consent regarding using cookies for non-essential purposes.


- Cookie

lidc

- Duration

1 day

- Description

LinkedIn sets the lidc cookie to facilitate data center selection.


- Cookie

yt-remote-device-id

- Duration

Never Expires

- Description

YouTube sets this cookie to store the user's video preferences using embedded YouTube videos.


- Cookie

ytidb::LAST\_RESULT\_ENTRY\_KEY

- Duration

Never Expires

- Description

The cookie ytidb::LAST\_RESULT\_ENTRY\_KEY is used by YouTube to store the last search result entry that was clicked by the user. This information is used to improve the user experience by providing more relevant search results in the future.


- Cookie

yt-remote-connected-devices

- Duration

Never Expires

- Description

YouTube sets this cookie to store the user's video preferences using embedded YouTube videos.


- Cookie

yt-remote-session-app

- Duration

session

- Description

The yt-remote-session-app cookie is used by YouTube to store user preferences and information about the interface of the embedded YouTube video player.


- Cookie

yt-remote-cast-installed

- Duration

session

- Description

The yt-remote-cast-installed cookie is used to store the user's video player preferences using embedded YouTube video.


- Cookie

yt-remote-session-name

- Duration

session

- Description

The yt-remote-session-name cookie is used by YouTube to store the user's video player preferences using embedded YouTube video.


- Cookie

yt-remote-fast-check-period

- Duration

session

- Description

The yt-remote-fast-check-period cookie is used by YouTube to store the user's video player preferences for embedded YouTube videos.


Analytics

Analytical cookies are used to understand how visitors interact with the website. These cookies help provide information on metrics such as the number of visitors, bounce rate, traffic source, etc.

- Cookie

pardot

- Duration

past

- Description

The pardot cookie is set while the visitor is logged in as a Pardot user. The cookie indicates an active session and is not used for tracking.


- Cookie

ajs\_anonymous\_id

- Duration

1 year

- Description

This cookie is set by Segment to count the number of people who visit a certain site by tracking if they have visited before.


- Cookie

ajs\_user\_id

- Duration

Never Expires

- Description

This cookie is set by Segment to help track visitor usage, events, target marketing, and also measure application performance and stability.


- Cookie

uid

- Duration

1 year 1 month 4 days

- Description

This is a Google UserID cookie that tracks users across various website segments.


- Cookie

sid

- Duration

1 year 1 month 4 days

- Description

The sid cookie contains digitally signed and encrypted records of a user‚Äôs Google account ID and most recent sign-in time.


- Cookie

\_ga

- Duration

1 year 1 month 4 days

- Description

Google Analytics sets this cookie to calculate visitor, session and campaign data and track site usage for the site's analytics report. The cookie stores information anonymously and assigns a randomly generated number to recognise unique visitors.


- Cookie

\_ga\_\*

- Duration

1 year 1 month 4 days

- Description

Google Analytics sets this cookie to store and count page views.


- Cookie

\_gcl\_au

- Duration

3 months

- Description

Google Tag Manager sets the cookie to experiment advertisement efficiency of websites using their services.


Performance

Performance cookies are used to understand and analyze the key performance indexes of the website which helps in delivering a better user experience for the visitors.

No cookies to display.

Advertisement

Advertisement cookies are used to provide visitors with customized advertisements based on the pages you visited previously and to analyze the effectiveness of the ad campaigns.

- Cookie

bcookie

- Duration

1 year

- Description

LinkedIn sets this cookie from LinkedIn share buttons and ad tags to recognize browser IDs.


- Cookie

visitor\_id\*

- Duration

1 year 1 month 4 days

- Description

Pardot sets this cookie to store a unique user ID.


- Cookie

visitor\_id\*-hash

- Duration

1 year 1 month 4 days

- Description

Pardot sets this cookie to store a unique user ID.


- Cookie

YSC

- Duration

session

- Description

Youtube sets this cookie to track the views of embedded videos on Youtube pages.


- Cookie

VISITOR\_INFO1\_LIVE

- Duration

6 months

- Description

YouTube sets this cookie to measure bandwidth, determining whether the user gets the new or old player interface.


- Cookie

VISITOR\_PRIVACY\_METADATA

- Duration

6 months

- Description

YouTube sets this cookie to store the user's cookie consent state for the current domain.


- Cookie

yt.innertube::requests

- Duration

Never Expires

- Description

YouTube sets this cookie to register a unique ID to store data on what videos from YouTube the user has seen.


- Cookie

yt.innertube::nextId

- Duration

Never Expires

- Description

YouTube sets this cookie to register a unique ID to store data on what videos from YouTube the user has seen.


Uncategorised

Other uncategorized cookies are those that are being analyzed and have not been classified into a category as yet.

- Cookie

\_zitok

- Duration

1 year

- Description

Description is currently not available.


- Cookie

lpv603731

- Duration

1 hour

- Description

Description is currently not available.


- Cookie

\_\_Secure-ROLLOUT\_TOKEN

- Duration

6 months

- Description

Description is currently not available.


Reject AllSave My PreferencesAccept All

Powered by [![Cookieyes logo](https://cdn-cookieyes.com/assets/images/poweredbtcky.svg)](https://www.cookieyes.com/product/cookie-consent/?ref=cypbcyb&utm_source=cookie-banner&utm_medium=powered-by-cookieyes)

[Introducing BloodHound Scentry: Accelerate your APM practice. Learn More](https://specterops.io/bloodhoundscentry/)

[Back to Blog](https://specterops.io/blog)

[Research & Tradecraft](https://specterops.io/blog/category/research/)

An Operator‚Äôs Guide to Device-Joined Hosts and the PRT Cookie

Author

[Matt Creel](https://specterops.io/blog/author/matt-creel/)

Read Time

15 mins

Published

Apr 7, 2025

##### Share

![Blog image for An Operator‚Äôs Guide to Device-Joined Hosts and the PRT Cookie](https://specterops.io/wp-content/uploads/sites/3/2025/04/an-operators-guide.png)

### Introduction

About five years ago, [Lee Chagolla-Christensen](https://x.com/tifkin_) shared a [blog](https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30) detailing the research and development process behind his [RequestAADRefreshToken](https://github.com/leechristensen/RequestAADRefreshToken/) proof-of-concept (POC). In short, on Entra ID joined (including hybrid joined) hosts, it‚Äôs possible to obtain a primary refresh token (PRT) cookie from the logged in user‚Äôs logon session, enabling an attacker to satisfy single-sign-on (SSO) requirements to cloud resources. [Dirk-jan Mollema](https://x.com/_dirkjan) has also [blogged](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/) about this capability, where he noted that these PRT cookies (and access tokens requested with them) may contain the multi-factor authentication (MFA) claim‚Ää‚Äî‚Ääenabling the attacker to access MFA-protected resources.

For a capability that has been publicly known for half a decade, I‚Äôve seen shockingly little online reference to it. I‚Äôm not sure if the frequency at which I encounter cloud/hybrid joined devices has recently increased or if I was sleeping on this capability for literal years (more likely), but this tradecraft has been a serious crutch on red team operations in the last six months. While some teams out there are undoubtedly reaping the benefits of this tradecraft during routine operations, I think there are probably quite a few operators out there who, like me, came across the prior works I‚Äôve linked to but didn‚Äôt immediately connect the¬†dots.

![](https://cdn-images-1.medium.com/max/1024/0*rA8fPz2ZGXX3gNDf)

This blog won‚Äôt contain any truly new information or research, but it will try to distill some operationally-focused knowledge that I learned while fumbling through this tradecraft over the last¬†year.

### Situational Awareness

A new beacon has called back to your C2 server and you want to know if this blog is applicable to you! This tradecraft will work from device joined hosts‚Ää‚Äî‚Äähosts that are either Entra ID joined (cloud-only join) or hybrid joined (joined to both Entra ID and on-premises AD), so we need to identify the join¬†state.

Relevant join information, including the join type, can be obtained by calling [NetGetAadJoinInformation](https://learn.microsoft.com/en-us/windows/win32/api/lmjoin/nf-lmjoin-netgetaadjoininformation) from NetApi32.dll. I created a small Beacon object file (BOF) to call the API, which can be found in [this PR](https://github.com/trustedsec/CS-Situational-Awareness-BOF/pull/128) to the TrustedSec situational awareness (SA) BOF repo. We‚Äôre looking for the ‚ÄúDevice join‚Äù [join type](https://learn.microsoft.com/en-us/windows/win32/api/lmjoin/ne-lmjoin-dsreg_join_type) (as opposed to workplace join, where an Entra ID work/school account is added to the device but the device isn‚Äôt joined to Entra¬†ID).

![](https://cdn-images-1.medium.com/max/1024/0*c-_FvvGsIWHCRqEq)Join Type Enumeration

Some of the other information can be useful, including the tenant ID and user join information, which reveals some details about the account that was leveraged to perform the Entra ID device join (in this case, the same account I‚Äôm logged in with locally in the lab, but that is not guaranteed to always¬†align).

> **Note:** I‚Äôm using [Havoc](https://github.com/HavocFramework/Havoc) and its demon agent for C2 in my lab environment since it‚Äôs easy to set up, there‚Äôs no licensing to mess with, and it nicely approximates some relevant capabilities of commercial frameworks; however, the tradecraft discussed in this post is C2-agnostic. Most if not all of the tools that are referenced already have Cobalt Strike aggressor scripts or can be easily hooked into your C2 of¬†choice.

We can also get most of this information from the registry under the key HKLMSYSTEMCurrentControlSetControlCloudDomainJoin. If present, its values hold information on the device join state and associated Entra ID tenant. An easy approach is to use [TrustedSec‚Äôs SA](https://github.com/trustedsec/CS-Situational-Awareness-BOF) reg\_query\_recursive BOF to surface the interesting values that are stored¬†there.

![](https://cdn-images-1.medium.com/max/1024/0*QxXSeeWcA6hGXvSG)Join Info Enumeration via the¬†Registry

The JoinInfo key won‚Äôt be present on workplace joined hosts, so just the presence of that key and its values should indicate we‚Äôre on a host that is device¬†joined.

Alright; we‚Äôve determined the host is Entra ID joined (cloud only in my lab), so the next question is, ‚ÄúWhat work or school accounts are added to the device?‚Äù Or, ‚ÄúWhat accounts can I obtain refresh token cookies¬†for?‚Äù

Initially, this seems like it should be a 1:1 relationship with the account our agent is running in the context of. It probably will be in most cases; however, I‚Äôve encountered production environments where we were able to obtain refresh tokens for multiple Entra ID accounts associated with the compromised user‚Äôs logon session. This can happen if the user has added multiple ‚Äúwork or school‚Äù accounts within System Settings. Envision a scenario involving a user who has been provisioned a separate admin account; if the user adds both their standard Entra ID account and admin Entra ID account to their user profile, now from the standard user account logon session our agent is running in, we can obtain a refresh token for both accounts. I‚Äôve attempted to mimic this in my lab setup (I‚Äôm logged in on the box as _MattC@specterdev.onmicrosoft.com_ and the agent is running as this account), but I‚Äôve also connected a second account to my profile (i.e., _admin-mattc@specterdev.onmicrosoft.com_) within System Settings.

![](https://cdn-images-1.medium.com/max/1024/0*cTAmyOK79ifkOuyD)Multiple Entra ID Accounts Added to the User¬†Profile

> **Note:** In these scenarios where multiple work/school accounts are in play, you can obtain a PRT for the account the user is locally logged in with and can obtain a refresh token for the other account(s). I‚Äôll cover this more in the next¬†section.

Finding a C2-friendly way to enumerate which work/school accounts have been added to the user‚Äôs profile has proven to be the most difficult part of putting these tradecraft notes together. If you‚Äôre familiar with enumerating cloud-joined or hybrid-joined devices, you probably know that you can use dsregcmd.exe to enumerate the information we‚Äôve discussed thus far, and it can also be used to list ‚Äúweb account manager (WAM) accounts.‚Äù If you are unfamiliar with the WAM, it is a technology on Windows that allows software such as the Microsoft Authentication Library (MSAL) to acquire tokens for cloud-based accounts. These cloud-based accounts include Entra ID accounts, AD FS accounts (which are sometimes referred to as ‚ÄúEnterprise‚Äù accounts), personal Microsoft accounts, and Microsoft work or school accounts. The dsregcmd.exe utility will collectively call all of these account types ‚ÄúWAM accounts‚Äù because the WAM can acquire tokens for all of them. The phrase ‚ÄúWAM account‚Äù is seldom used elsewhere and ‚Äúcloud-based accounts‚Äù may be a more appropriate phrase, but we will stick with using ‚ÄúWAM account‚Äù in this blog to stay consistent with the output of the dsregcmd.exe utility.

If we‚Äôre feeling into process creation and/or spawning cmd.exe, we can leverage dsregcmd.exe with the /listaccounts flag to enumerate WAM accounts that have been added (or the /status flag to enumerate the device‚Äôs join¬†state).

![](https://cdn-images-1.medium.com/max/1024/0*3rBIOAXWqBtMyOR_)**üò¨**

I can feel the collective boos raining¬†in.

![](https://cdn-images-1.medium.com/max/577/0*04PdsckH6J3eFEPq)

You‚Äôre right. Unfortunately, the [one](https://x.com/mhskai2017/status/1773532112362045680) function dsregcmd.exe imports from dsreg.dll is undocumented, as are all the other interestingly named exports dsreg.dll has. Reversing those functions to figure out how they can be called from a BOF is way beyond my ability. This left me trying to find other documented ways to query the web account manager. I found three ways I might approach¬†this:

1. Using¬†.NET projections of the Windows Runtime (WinRT), including the WebAuthenticationCoreManager¬†.NET class \[ [1](https://learn.microsoft.com/en-us/uwp/api/windows.security.authentication.web.core.webauthenticationcoremanager?view=winrt-26100),¬†[2](https://raamakrishnan.wordpress.com/tag/api/)\]
2. Using C++/WinRT or C APIs to access these same WinRT classes \[ [1](https://learn.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/),¬†[2](https://conference.hitb.org/hitbsecconf2018pek/materials/D1T2%20-%20The%20Inner%20Workings%20of%20the%20Windows%20Runtime%20-%20James%20Forshaw.pdf)\]
3. Using component object model (COM) \[ [1](https://stackoverflow.com/a/7437006),¬†[2](https://blog.xojo.com/2019/07/02/accessing-windows-runtime-winrt/)\]

My personal preference is to leverage BOFs over¬†.NET assemblies wherever possible. I was also unsure of the viability of using C++/WinRT in a BOF, so I opted for option three: using COM. Several vibe coding sessions later, I patched enough working BOF code together to list the WAM accounts that were added to the current user¬†profile.

![](https://cdn-images-1.medium.com/max/798/0*9QxQo0_o7-phx6w4)WAM Account Enumeration via¬†COM

The BOF code, along with some POC code to enumerate added WAM accounts in¬†.NET and C++/WinRT, can be found in this¬†[repo](https://github.com/Tw1sm/list-wam-accounts).

![](https://cdn-images-1.medium.com/max/494/0*wdqZfkDYmvpv4OIK)

Now that we‚Äôve been responsible operators and confirmed the device join state and WAM accounts that are present, we can continue¬†forward!

> **Note:** My coworkers [Evan McBroom](https://x.com/mcbroom_evan) and [Kai Huang](https://x.com/mhskai2017) adeptly figured out how to call the undocumented DsrCLI API that dsregcmd.exe calls. You can find an implementation of their work [here](https://github.com/EvanMcBroom/lsa-whisperer/blob/v3.0/bofs/dsrcli.cpp), which provides operators another option for performing these enumeration steps!

### Requesting and Leveraging the PRT¬†Cookie

Finally, the exciting part. Lee‚Äôs original RequestAADRefreshToken code was ported to a BOF by [wotwot563](https://github.com/wotwot563) in their [aad\_prt\_bof](https://github.com/wotwot563/aad_prt_bof) repo. This is trivial to use from our C2 agent and all we need to supply is a nonce for the request. We can obtain a nonce by running roadtx from Dirk-jan‚Äôs [ROADtools](https://github.com/dirkjanm/ROADtools) project.

![](https://cdn-images-1.medium.com/max/1024/0*upREh4hmC5A9liYB)Nonce Request

Take the nonce back to your agent and execute the aadprt BOF to obtain a PRT cookie (if you‚Äôre following along in the lab, the Havoc script that wraps the BOF can be found in [this PR](https://github.com/wotwot563/aad_prt_bof/pull/3), but the repo already contains an OutflankC2 script and a Cobalt Strike aggressor script you can use. The PR also contains modifications to output the cookies as a JSON¬†blob).

![](https://cdn-images-1.medium.com/max/1024/1*EVD9lS9U3q19mi-dGB7QNQ.png)Obtaining Refresh Token¬†Cookies

You‚Äôll likely get back a x-ms-RefreshTokenCredential and a x-ms-DeviceCredential for each account. If you obtain more than one token, you‚Äôll see a x-ms-RefreshTokenCredential, then a x-ms-RefreshTokenCredential1, and so on. The refresh token credential(s) are what we‚Äôll be leveraging for post-exploitation. The PR also spits out the cookies in a JSON blob as a quality of life improvement for the next¬†section.

### Using the¬†Browser

Each time I‚Äôve performed this in production, any MFA requirement that was present was already satisfied by the tokens that were returned (more on that in the next section). To demonstrate, if I try to logon to the Azure portal with my test account‚Äôs username and password, I‚Äôm prompted for my MFA¬†method.

![](https://cdn-images-1.medium.com/max/1024/0*ovrERH0Chdlwxs9Z)Pesky MFA¬†Policy

> **Note:** We will still need to satisfy all conditional access policies (CAPs) to sign in. At a minimum, this usually involves coming from a trusted IP address. So you‚Äôll likely need to use Proxifier on Windows (or a similar solution) to tunnel your browser traffic through your C2 agent before it goes back out to Microsoft. That is outside the scope of this blog and will be left up to¬†you.

Let‚Äôs inject the refresh token cookies from the aadprt BOF into a browser on our operator VM, confirm that we satisfy the MFA policy for our lab environment, and that we can access resources behind SSO. Lee‚Äôs blog has the steps to do this manually using Chrome‚Äôs developer tools; however, after doing this multiple times per day for multi-week operations, it gets pretty tiresome. My coworker [Forrest Kasler](https://x.com/FKasler) has some slick scripts to [steal cookies](https://github.com/fkasler/cuddlephish/blob/main/smooth_criminal.js) via the Chrome remote debugger and [inject them](https://github.com/fkasler/cuddlephish/blob/main/stealer.js) into a new instance of Chromium. We can throw the JSON blob we received from the aadprt BOF into a file and feed the file into a script from Forrest‚Äôs collection (i.e., stealer.js), which will add the cookies to our browser and open https://login.microsoftonline.com.

![](https://cdn-images-1.medium.com/max/1024/1*EWGLu8DB3exW2iiN1Hiubw.png)Stealer.js Adding the Refresh Token Cookies to¬†Chromium

Now, if I open a new tab and browse to the Azure Portal in this Chromium session, it‚Äôll briefly redirect to login.microsoftonline.com and then I‚Äôll be logged into that resource as well without receiving a prompt for¬†MFA.

![](https://cdn-images-1.medium.com/max/1024/0*glazAj5bsDTNyQBq)Azure Portal¬†Access

We can leverage this same workflow to access Microsoft cloud services and apps (e.g., Azure, Teams, SharePoint, etc.) but we can also authenticate to third-party apps configured to leverage SSO. Common examples include applications such as Confluence and Jira, ServiceNow (which MDSec recently [blogged](https://www.mdsec.co.uk/2025/03/red-teaming-with-servicenow/) about the usefulness of), CyberArk, and even custom internal apps configured to use SSO. When I first realized this, I was curious how to enumerate other third-party services the target tenant tied into SSO. Outside of downloading and reviewing browser history databases, one way is to check for app registrations in Azure. We can do this graphically in the Azure portal, or use ROADrecon data (more on this in a moment) to identify services in its ‚ÄúApplications‚Äù pane that contain ‚ÄúReply URLs.‚Äù Here‚Äôs an example of the app registration data that was collected for a tenant‚Äôs confluence app.

![](https://cdn-images-1.medium.com/max/771/0*6LFIPnMRAPSd2S9Q)ROADrecon Applications Pane

If we navigate to the reply URL in our browser while we have a valid refresh token cookie, we‚Äôll satisfy the SSO requirement and we‚Äôll be logged in (provided that the user we have a token for is granted access to that application).

### Using \[Your Favorite Entra ID/Azure Post-Ex¬†Toolkit\]

We can also leverage the refresh token to request access tokens for the Graph API, or other resources, for usage with Azure post-exploitation toolkits like [ROADrecon](https://github.com/dirkjanm/ROADtools), [TokenTactics](https://github.com/rvrsh3ll/TokenTactics), [GraphRunner](https://github.com/dafthack/GraphRunner), [TeamFiltration](https://github.com/Flangvik/TeamFiltration), [MicroBurst](https://github.com/NetSPI/MicroBurst), [ADOKit](https://github.com/xforcered/ADOKit), and¬†more.

I prefer to use roadtx for token manipulation. If we take a token from the aadprt BOF output and use the roadtx auth module, we can request access tokens by passing our refresh token cookie in via the ‚Äìprt-cookie argument. That will get a token for the older Azure AD Graph by default, but other resources can be specified with the -r/‚Äìresource flag.

![](https://cdn-images-1.medium.com/max/1000/1*-hOHhU5_bbMyXTkLUv3tvA.png)Access Token Request Using Our PRT¬†Cookie

Now we have a Azure AD Graph access token that we could use to perform a ROADrecon data collection with.

Dirk-jan makes a point in his [blog](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/) that I think is worth repeating‚Ää‚Äî‚Äärefresh tokens and access tokens that are requested via a PRT cookie will inherit the same claims that the original PRT cookie had. So if the PRT cookie contained the MFA claim and a device ID (since we originally obtained it on a device joined host), our access tokens will too. This is why we can continue to satisfy CAPs that require MFA or usage of a joined¬†device.

![](https://cdn-images-1.medium.com/max/1024/0*pNusSEATm6Pey9RT)Access Token Containing the MFA Claim and Device¬†ID

Shifting back to the post-exploitation examples, now that the roadtx auth module has populated my auth file (i.e.,¬†.roadtools\_auth), it can be fed that into another tool such as TeamFiltration to use its exfiltration modules as¬†well.

![](https://cdn-images-1.medium.com/max/944/0*2-Be5VYTJRKs-gVI)Collecting Microsoft Teams Data with TeamFiltration

For TeamFiltration, the ‚Äìteams module gathers data including contact lists, shared attachments, and conversations. That makes it a good alternative to adding a refresh token cookie to your browser and graphically browsing¬†Teams.

![](https://cdn-images-1.medium.com/max/1024/0*wJGurk8voEYs7Wab)TeamFiltration Display of My Super Sensitive Teams¬†Chat

Other tools may require tokens for different resources or different clients. As an example, MicroBurst modules that gather data on Azure resources rely on the Azure PowerShell module and thus will need an access token for the Azure Resource Manager (AzureRM) that specifies the Azure CLI client ID when authenticating. We can request that access token using roadtx by specifying the associated alias for that resource and the appropriate client¬†name.

![](https://cdn-images-1.medium.com/max/1024/1*ORRhx0-_kmQVn4rP14tkKw.png)Access Token Request for Usage with MicroBurst

Take the resulting access token from the¬†.roadtools\_auth file and supply it to the Connect-AzAccount cmdlet from the Az PowerShell module and you should see that it succeeds.

![](https://cdn-images-1.medium.com/max/1024/1*hHrTO9UhfY-Uf__YaDpuIw.png)Connecting the Azure PowerShell Module

MicroBurst can now be imported and run via Get-AzDomainInfo (in this example, we omit enumeration for things like Entra ID users and groups, which would also require a graph¬†token).

![](https://cdn-images-1.medium.com/max/1024/1*Ldt4fSpCIRkWN3iLEg4KsQ.png)MicroBurst Data Collection

These are just a few examples of the token requests that can be made using different tools. There are a number of other tools you utilize for different areas of the post-exploitation, but the operational workflow will generally remain the¬†same.

### Detection Guidance

The different tools outlined during this blog for situational awareness and token requests will cause different DLLs to be loaded in an agent‚Äôs process. When these DLLs are present together within the same process, that may indicate suspicious activity:

1. **aadjoininfo BOF and** **dsrcli BOF**‚Äî‚ÄäUsed to enumerate the device‚Äôs join state and causes C:WindowsSystem32dsreg.dll to be loaded into the beacon¬†process
2. **listwamaccounts BOF**‚Äî‚ÄäUsed to enumerate work or school accounts added to the current user profile; causes C:WindowsSystem32aadWamExtension.dll to be loaded into the beacon¬†process
3. **aadprt BOF**‚Ää‚Äî‚ÄäUsed to obtain refresh token cookies. Being based on Lee‚Äôs original POC, the DLL load event he calls out for C:WindowsSystem32MicrosoftAccountTokenProvider.dll is still applicable here

On the separate device joined and workplace joined hosts I have access to, there are no running processes (outside of the beaconing demon.x64.exe process) that have loaded all three DLLs. Even examining processes on my host that have just two of these DLLs loaded shows that it‚Äôs limited to svchost.exe, OneDrive.exe, and ServiceHub.IdentityHost.exe.

![](https://cdn-images-1.medium.com/max/916/0*sg1kNIoY6EidxQsI)Processes With dsreg.dll Loaded![](https://cdn-images-1.medium.com/max/915/0*pR845YRDFzVr3sUQ)Processes With aadWamExtension.dll Loaded![](https://cdn-images-1.medium.com/max/916/0*REVa2ysUmwvLYekY)Processes With MicrosoftAccountTokenProvider.dll Loaded

This is bound to vary from environment to environment, but baselining processes that normally load two or more of these DLLs and monitoring for anomalies may be able to provide an indication of processes to review for reconnaissance and token gathering actions, like those described in this¬†blog.

### Conclusion

This blog examined how an operator can perform situational awareness steps prior to making a token request and how tokens can be effectively used once obtained. Hopefully, you‚Äôve come away with some guidance and examples on how to leverage this tradecraft and some of the quality of life scripts/tools that may help¬†you!

![](https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bcd0db2812c4)

Post Views:2,643

Ready to get started?

[Book a Demo](https://specterops.io/get-a-demo/)

You might also be interested in

[![STOP THE CAP: Making Entra ID Conditional Access Make Sense Offline](https://specterops.io/wp-content/uploads/sites/3/2026/02/Screenshot-2026-02-10-at-1.51.13-PM.png?w=300)\\
\\
Research & Tradecraft\\
\\
STOP THE CAP: Making Entra ID Conditional Access Make Sense Offline\\
\\
TL;DR: Conditional Access is powerful but hard to reason about once policies start to overlap. CAPSlock is an offline Conditional‚Ä¶ \\
\\
By: \\
Lee Robinson \\
\\
18 mins](https://specterops.io/blog/2026/02/17/stop-the-cap-making-entra-id-conditional-access-make-sense-offline/)

[![V8 Heap Archaeology: Finding Exploitation Artifacts in Chrome‚Äôs Memory](https://specterops.io/wp-content/uploads/sites/3/2026/01/Screenshot-2026-01-31-154306.png?w=300)\\
\\
Research & Tradecraft\\
\\
V8 Heap Archaeology: Finding Exploitation Artifacts in Chrome‚Äôs Memory\\
\\
TL;DR¬†: This post aims to introduce readers to the anatomy and detection of JavaScript memory corruption exploits that target Google‚Ä¶ \\
\\
By: \\
Liam D. \\
\\
17 mins](https://specterops.io/blog/2026/02/11/v8-heap-archaeology-finding-exploitation-artifacts-in-chromes-memory/)

[![Weaponizing Whitelists: An Azure Blob Storage Mythic C2 Profile](https://specterops.io/wp-content/uploads/sites/3/2026/01/Screenshot-2026-01-21-at-10.19.48-AM.png?w=300)\\
\\
Research & Tradecraft\\
\\
Weaponizing Whitelists: An Azure Blob Storage Mythic C2 Profile\\
\\
TL;DR: Mature enterprises lock down egress but often carve out broad exceptions for trusted cloud services. This post shows how‚Ä¶ \\
\\
By: \\
Andrew Gomez, Allen DeMoura \\
\\
10 mins](https://specterops.io/blog/2026/01/30/weaponizing-whitelists-an-azure-blob-storage-mythic-c2-profile/)

![](<Base64-Image-Removed>)

[Previous image](https://specterops.io/blog/2025/04/07/an-operators-guide-to-device-joined-hosts-and-the-prt-cookie/)[Next image](https://specterops.io/blog/2025/04/07/an-operators-guide-to-device-joined-hosts-and-the-prt-cookie/)

Notifications