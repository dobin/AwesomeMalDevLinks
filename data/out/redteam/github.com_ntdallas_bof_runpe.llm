Title:
BOF_RunPE — In-memory PE execution inside Cobalt Strike Beacon without console creation

Type:
GitHub Tool

Short Summary (4–8 sentences max):
BOF_RunPE is a Cobalt Strike Beacon Object File (BOF) that maps and executes a Windows PE entirely in-memory inside the existing Beacon process, avoiding fork&run behavior. It solves common OPSEC issues by not spawning a child process, not creating a console window, and not using named pipes for output; instead it captures output by IAT-hooking common CRT/console APIs and redirects it to the Beacon console. The project implements multiple memory allocation and loading strategies (heap, NtAllocateVirtualMemory, and module stomping) and supports “proxy” execution paths such as timer queue or RegisterWaitForSingleObject callbacks. It includes evasion-oriented features like indirect syscalls, optional ntdll unhooking from disk, stack spoofing (“Draugr”), and thread start address spoofing via RIP/context manipulation. The README also documents likely detection vectors (ETW-TI, context/thread manipulation, RX transitions, stomped module integrity mismatches). It’s primarily useful for red teams and pentesters operating in Windows environments where EDR telemetry around process creation and console/pipe artifacts is heavily monitored.

Technical Focus:
- In-memory PE loading/mapping (sections, relocations, IAT patching)
- Output redirection via IAT hooking (printf/WriteConsole/UCRT)
- Indirect syscalls and syscall resolution (userland hook bypass)
- Stack spoofing and thread start address spoofing (RIP hijack via context)
- Module stomping and alternative allocation strategies (heap vs VirtualAlloc)
- NTDLL unhooking by restoring .text from disk

Use Cases:
- Execute native x64 tooling (e.g., credential dumping utilities) inline within Beacon without spawning a new process
- Reduce telemetry tied to fork&run, console creation, and named pipe output capture
- Test/benchmark EDR detections around ETW-TI, thread context manipulation, RX transitions, and module stomping
- Run payloads with configurable allocation/proxy methods to vary behavioral signatures
- Research tradeoffs/limitations of inline execution (e.g., CET impact, lack of .NET support)

Keywords:
Cobalt Strike, Beacon Object File, BOF, inline execution, RunPE, in-memory PE, reflective loading, IAT hooking, printf hook, WriteConsoleA, __getmainargs, NtAllocateVirtualMemory, NtProtectVirtualMemory, indirect syscalls, syscall resolution, ntdll unhooking, module stomping, stack spoofing, thread start spoofing, NtGetContextThread, NtSetContextThread, ETW-TI, RIP hijacking, Timer Queue, RegisterWaitForSingleObject, x64 Windows