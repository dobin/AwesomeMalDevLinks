# https://rastamouse.me/cobalt-strike-postex-kit/

<!DOCTYPE html><html lang="en">

<body class="post-template is-head-left-logo is-dropdown-loaded">
<div class="site">

    


    <div class="site-content">
        
<main class="site-main">

        <article class="single post no-image">

        

    <div class="single-content gh-content gh-canvas">
        <p>The CS 4.10 update saw the introduction of the Postex Kit.  This was a bit overshadowed by BeaconGate, which was also added in 4.10 (I wrote about this in my <a href="https://rastamouse.me/udrl-sleepmask-and-beacongate/" rel="noreferrer">last post</a>).  The intention of this post is to highlight what this kit is about and how it can be used.</p><p>As you may know, post-ex execution in CS falls into two broad categories - <em>inline</em> and <em>fork &amp; run</em>.  Inline execution is performed using Beacon Object Files (BOFs) and fork &amp; run is performed using reflective DLLs (rDLLs).  For the most part, Beacon is a single-threaded application.  BOFs execute on that single thread, and therefore block Beacon from doing anything else (checking in, going to sleep, etc) until they complete.  This is undesirable for long-running tasks that you want to run in the background, such as the keylogger.  Fork &amp; run works by injecting an rDLL into another process and executing it under its own thread.  This keeps Beacon free to do other things while the task is running.</p><p>There are two variants of fork &amp; run called <code>spawn</code> and <code>explicit</code> in CS's nomenclature.  The spawn variant instructs Beacon to start a new temporary process and inject the rDLL into it.  The explicit variant instructs Beacon to inject the rDLL into a process that is already running.  In both cases, communication between Beacon and the rDLL is done over named pipes.  The rDLL will start a named pipe server, and Beacon will connect to it shortly after performing the injection.</p><p>The postex kit is a Visual Studio project that provides a template for building your own post-ex rDLLs, plugging them into CS's job architecture, and even communicating with them at runtime.  These custom rDLLs are also fully compatible with CS's other evasion features, such as the postex UDRL and the process inject kit.</p><h2 id="dllmain">DllMain</h2><p>We don't need to mess around inside DllMain, as the work to properly bootstrap the rDLL is already done for us.  I just want to highlight that when the entry point is called with a 'reason' of <code>DLL_POSTEX_ATTACH</code>, DllMain calls <code>PostexMain</code> which is where we'd put our task logic.  When this function returns, DllMain then calls <code>PostexExit</code> which will close and cleanup the named pipe, and then calls <code>ExitThread</code> or <code>ExitProcess</code> depending on which variant of fork &amp; run was used.</p><h2 id="postexmain">PostexMain</h2><p><code>PostexMain</code> takes a pointer to some <code>POSTEX_DATA</code>.</p><figure class="kg-card kg-code-card"><pre class="language-cpp" tabindex="0"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">PostexMain</span><span class="token punctuation">(</span>PPOSTEX_DATA postexData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">RETURN_ON_NULL</span><span class="token punctuation">(</span>postexData<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// do my stuff</span>
    
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><figcaption><p><span style="white-space: pre-wrap;">postexmain.cpp</span></p></figcaption></figure><p>This structure contains user-definable postex data, such as any arguments passed by the operator.  These arguments are packed on the client-side using the <code>bof_pack</code> Aggressor function.  The postex template provides access to the same BOF APIs for unpacking these arguments.</p><figure class="kg-card kg-code-card"><pre class="language-cpp" tabindex="0"><code class="language-cpp">datap parser<span class="token punctuation">;</span>

<span class="token function">BeaconDataParse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>parser<span class="token punctuation">,</span>
    postexData<span class="token operator">-&gt;</span>UserArgumentInfo<span class="token punctuation">.</span>Buffer<span class="token punctuation">,</span>
    postexData<span class="token operator">-&gt;</span>UserArgumentInfo<span class="token punctuation">.</span>Size<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><figcaption><p><span style="white-space: pre-wrap;">postexmain.cpp</span></p></figcaption></figure><p>We also have access to the same format and output APIs, such as <code>BeaconFormatAlloc</code>, <code>BeaconFormatAppend</code>, <code>BeaconFormatPrintf</code>, <code>BeaconPrintf</code>, etc.  Under the hood, <code>BeaconPrintf</code> is a wrapper around <code>BeaconOutput</code>.  In debug mode, this uses <code>WriteConsoleA</code> to print the data to the console.  In release mode, it properly chunks up the data and writes it to the named pipe for Beacon to read.</p><pre class="language-cpp" tabindex="0"><code class="language-cpp"><span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token function">BeaconDataExtract</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>parser<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">BeaconPrintf</span><span class="token punctuation">(</span>CALLBACK_OUTPUT<span class="token punctuation">,</span> <span class="token string">"Hello %s\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="mock-arguments">Mock Arguments</h3><p>As with the C++ BOF and UDRL Visual Studio templates, we can provide mock arguments when running in debug mode.</p><figure class="kg-card kg-code-card"><pre class="language-cpp" tabindex="0"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    BOOL startPipeServer <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    

    PostexDataPacker userArguments<span class="token punctuation">;</span>
    userArguments<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">pack</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Rasta"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">DebugEntryPoint</span><span class="token punctuation">(</span>userArguments<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> userArguments<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> startPipeServer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><figcaption><p><span style="white-space: pre-wrap;">postexmain.cpp</span></p></figcaption></figure><figure class="kg-card kg-image-card"><img src="https://rastamouse.me/content/images/2024/12/image.png" class="kg-image" alt="" loading="lazy" width="798" height="340"></figure><h3 id="pipes">Pipes</h3><p>Because operators can send messages to the postex DLL at runtime, the template also provides some abstractions around reading from the named pipe.  <code>BeaconInputAvailable</code> returns the number of bytes available to read and <code>BeaconInputRead</code> reads the given number of bytes from the pipe.</p><figure class="kg-card kg-code-card"><pre class="language-cpp" tabindex="0"><code class="language-cpp">DWORD bytesAvailable <span class="token operator">=</span> <span class="token function">BeaconInputAvailable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>bytesAvailable <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span><span class="token operator">*</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>bytesAvailable<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">BeaconInputRead</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> bytesAvailable<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// do something with input</span>
<span class="token punctuation">}</span></code></pre><figcaption><p><span style="white-space: pre-wrap;">postexmain.cpp</span></p></figcaption></figure><h3 id="infinite-loops">Infinite Loops</h3><p>A common scenario for a long-running task is for it to run indefinity until cancelled by the operator (via the <code>jobkill</code> command).  However, what I found when playing with the kit is that killing a job on the client-side doesn't forcefully terminate the DLL.  So if you have a <code>while (true)</code> (or similar) loop in your <code>PostexMain</code>, Beacon will disconnect itself from the named pipe and you will no longer see any output on the client's console, but the DLL itself will never stop.</p><p>I think the simplest remedy to this is to monitor the status of the named pipe from inside your loop.  When the postex DLL starts the named pipe server, it passes a value of <code>1</code> for the number max instances and stores the handle in a global variable called <code>gPipeHandle</code>.</p><figure class="kg-card kg-code-card"><pre class="language-cpp" tabindex="0"><code class="language-cpp">gPipeHandle <span class="token operator">=</span> <span class="token function">CreateNamedPipeA</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>LPCSTR<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>gPipeName<span class="token punctuation">)</span><span class="token punctuation">,</span>
    PIPE_ACCESS_DUPLEX<span class="token punctuation">,</span> 
    PIPE_TYPE_MESSAGE <span class="token operator">|</span> PIPE_READMODE_MESSAGE<span class="token punctuation">,</span>
    <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment">// nMaxInstances</span>
    BUFFER_SIZE<span class="token punctuation">,</span> 
    BUFFER_SIZE<span class="token punctuation">,</span>
    <span class="token number">0</span><span class="token punctuation">,</span> 
    <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><figcaption><p><span style="white-space: pre-wrap;">pipes.cpp</span></p></figcaption></figure><p>APIs like <code>PeekNamedPipe</code> can be used to check the status of the pipe.  We surmise that Beacon has disconnected if the call fails with a status of <code>ERROR_BROKEN_PIPE</code>.  We simply break from our loop so that <code>PostexMain</code> is free to return.</p><figure class="kg-card kg-code-card"><pre class="language-cpp" tabindex="0"><code class="language-cpp">BOOL <span class="token function">ClientConnected</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">PeekNamedPipe</span><span class="token punctuation">(</span>gPipeHandle<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ERROR_BROKEN_PIPE<span class="token punctuation">)</span>
            <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>

    <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">PostexMain</span><span class="token punctuation">(</span>PPOSTEX_DATA postexData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">BeaconPrintf</span><span class="token punctuation">(</span>CALLBACK_OUTPUT<span class="token punctuation">,</span> <span class="token string">"Counter: %d"</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        counter<span class="token operator">++</span><span class="token punctuation">;</span>
        
        <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ClientConnected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><figcaption><p><span style="white-space: pre-wrap;">postexmain.cpp</span></p></figcaption></figure><h2 id="execute-dll">execute-dll</h2><p>The new <code>execute-dll</code> command will inject a postex DLL, using either the spawn or explicit fork &amp; run variant, and creates a new job.</p><pre class="language-text" tabindex="0"><code class="language-text">beacon&gt; help execute-dll
Use: execute-dll [pid] [/path/to/postex.dll] [args]
     execute-dll [/path/to/postex.dll] [args]

Inject the provided postex DLL into the specified process. This DLL must be generated by the postex kit in the Arsenal
Kit to make use of Cobalt Strike's existing job architecture. Use execute-dll with no pid to spawn a temporary process
and inject the postex DLL into it.

Utilize the POSTEX_RDLL_GENERATE hook to specify a UDRL and/or use PROCESS_INJECT to specify the injection method.</code></pre><pre class="language-text" tabindex="0"><code class="language-text">beacon&gt; execute-dll C:\Tools\cobaltstrike\arsenal-kit\kits\postex\x64\Release\demo.dll
[*] Tasked beacon to execute a User-Defined Postex Task
[+] host called home, sent: 138560 bytes
[+] job registered with id 4

[+] [job 4] received output:
Counter: 1

[+] [job 4] received output:
Counter: 2

[+] [job 4] received output:
Counter: 3

[+] [job 4] received output:
Counter: 4

[+] [job 4] received output:
Counter: 5

beacon&gt; jobkill 4
[*] Tasked beacon to kill job 4
[+] host called home, sent: 10 bytes
[+] job 4 completed</code></pre><h2 id="beaconexecutepostexjob">beacon_execute_postex_job</h2><p>The <code>beacon_execute_postex_job</code> Aggressor function provides more flexibility as it lets you register a custom callback function that will fire every time the job is updated.</p><pre class="language-perl" tabindex="0"><code class="language-perl"><span class="token variable">$callback</span> <span class="token operator">=</span> lambda<span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token keyword">local</span><span class="token punctuation">(</span><span class="token string">'$bid $data $result %info $type'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
    <span class="token comment"># get arguments passed to lambda</span>
    <span class="token punctuation">(</span><span class="token variable">$bid</span><span class="token punctuation">,</span> <span class="token variable">$result</span><span class="token punctuation">,</span> <span class="token variable">%info</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token variable">@_</span><span class="token punctuation">;</span>
        
    <span class="token comment"># get the job status/type</span>
    <span class="token comment"># can be job_registered, output, error, or job_completed.</span>
    <span class="token variable">$type</span> <span class="token operator">=</span> <span class="token variable">%info</span><span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment"># get the job id</span>
    <span class="token variable">$jid</span> <span class="token operator">=</span> <span class="token variable">%info</span><span class="token punctuation">[</span><span class="token string">'jid'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment"># do something based on status</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token comment"># run the postex task...</span>
beacon_execute_postex_job<span class="token punctuation">(</span><span class="token variable">$1</span><span class="token punctuation">,</span> <span class="token variable">$null</span><span class="token punctuation">,</span> <span class="token variable">$postex_dll</span><span class="token punctuation">,</span> <span class="token variable">$null</span><span class="token punctuation">,</span> <span class="token variable">$callback</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>When using a custom callback, you must log output and errors yourself, using <code>bjoblog</code> and <code>bjoberror</code> respectively.</p><pre class="language-perl" tabindex="0"><code class="language-perl"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$type</span> <span class="token operator">eq</span> <span class="token string">'output'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bjoblog<span class="token punctuation">(</span><span class="token variable">$bid</span><span class="token punctuation">,</span> <span class="token variable">$jid</span><span class="token punctuation">,</span> <span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$type</span> <span class="token operator">eq</span> <span class="token string">'error'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bjoberror<span class="token punctuation">(</span><span class="token variable">$bid</span><span class="token punctuation">,</span> <span class="token variable">$jid</span><span class="token punctuation">,</span> <span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>You can also call additional Aggressor functions here to interact with Beacon or the various data models.  For example, if you had a postex DLL that performed password scaping, you could parse the output and call <code>credential_add</code> to add them to the credentials data model.</p><p>The <code>bjob_send_data</code> function can be used to send data to the post-ex DLL via the named pipe.</p><pre class="language-perl" tabindex="0"><code class="language-perl">bjob_send_data<span class="token punctuation">(</span><span class="token variable">$bid</span><span class="token punctuation">,</span> <span class="token variable">$jid</span><span class="token punctuation">,</span> <span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>This can be placed in the callback, but it's also possible to wrap in a separate alias to send data to an arbitrary job ID.</p><pre class="language-perl" tabindex="0"><code class="language-perl">alias test <span class="token punctuation">{</span>
    bjob_send_data<span class="token punctuation">(</span><span class="token variable">$1</span><span class="token punctuation">,</span> <span class="token variable">$2</span><span class="token punctuation">,</span> <span class="token variable">$3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>The <code>beacon_job_hide_output</code> function instructs the client not to print the output from the task in the main Beacon console, but restricts it to the new Job Console view.</p><pre class="language-perl" tabindex="0"><code class="language-perl"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$type</span> <span class="token operator">eq</span> <span class="token string">'job_registered'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    beacon_job_hide_output<span class="token punctuation">(</span><span class="token variable">$bid</span><span class="token punctuation">,</span> <span class="token variable">$jid</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><figure class="kg-card kg-image-card"><img src="https://rastamouse.me/content/images/2024/12/image-1.png" class="kg-image" alt="" loading="lazy" width="620" height="549"></figure><h2 id="conclusion">Conclusion</h2><p>That just about covers everything I've learned about the postex kit so far (let me know if I missed anything juicy).  I hope it was useful and that it encourages you to try writing your own custom postex DLLs.</p>
    </div>

    <div class="gh-canvas">
    
    </div>

</article>
        
        
</main>
    </div>

    

</div>

    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="pswp__bg"></div>

    <div class="pswp__scroll-wrap">
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






<div id="sodo-search-root"></div></body></html>