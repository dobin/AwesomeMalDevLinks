Title:
NyxInvoke

Type:
GitHub Tool

Short Summary (4–8 sentences max):
NyxInvoke is a Rust-based Windows execution wrapper that runs .NET assemblies, PowerShell commands/scripts, Beacon Object Files (BOFs), and PE files. It targets common defensive controls by including “patchless” AMSI and ETW bypasses plus an NTDLL unhooking routine designed to avoid triggering process creation notify callbacks (PspCreateProcessNotifyRoutine). Payloads can be provided from disk, URL, or compiled into the binary, and can be AES-encrypted with runtime decryption. The project supports dual builds: a standalone EXE CLI or a DLL callable via rundll32 with the same execution modes. It’s primarily useful for red teams and pentesters needing flexible in-memory execution and tradecraft experimentation around telemetry/scan evasion. It’s interesting because it consolidates multiple execution primitives (CLR/PS/BOF/PE) with built-in evasion and encrypted staging in a Rust implementation.

Technical Focus:
- Patchless AMSI bypass
- Patchless ETW bypass / telemetry suppression
- NTDLL unhooking and user-mode hook evasion
- In-memory execution of .NET (CLR hosting), BOFs, and PE loading
- AES-encrypted payload staging (key/IV handling) and remote retrieval
- Dual-mode packaging (EXE vs rundll32-invoked DLL)

Use Cases:
- Execute encrypted .NET tooling (e.g., Seatbelt) with reduced AMSI/ETW visibility
- Run PowerShell scripts/commands without standard script-block scanning paths
- Execute BOFs outside of Cobalt Strike for post-exploitation tasks
- Load and run PE payloads from disk/URL/embedded resources
- Build a DLL-based launcher for LOLBin-style execution via rundll32

Keywords:
Rust, Windows, CLI, DLL, rundll32, .NET assembly execution, CLR hosting, PowerShell, BOF, Beacon Object File, PE loader, AMSI bypass, ETW bypass, NTDLL unhooking, user-mode hooks, PspCreateProcessNotifyRoutine, AES encryption, payload decryption, remote payload staging, inline assembly