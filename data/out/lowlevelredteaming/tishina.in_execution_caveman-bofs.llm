Title:
caveman-bofs

Type:
Blog Post

Short Summary (4–8 sentences max):
- This write-up explores a proof-of-concept method for executing Cobalt Strike BOFs (Beacon Object Files) by reusing RWX memory regions that appear after loading certain “trusted” Windows DLLs.  
- Instead of allocating new RWX memory with `VirtualAlloc`, the approach scans the current process for existing RWX private committed regions, then `LoadLibraryA`s a candidate DLL and identifies any newly created RWX region to use as a “code cave.”  
- The author provides a simple scanner that iterates System32 DLLs, loads them, checks for RWX regions, and unloads them to find usable candidates (example: `mfcm120.dll`).  
- A NiCOFF-based loader is modified to write the BOF into the discovered RWX region and execute it, avoiding the typical single obvious RWX allocation pattern.  
- It’s mainly useful for red teamers/malware developers experimenting with alternative in-process execution and memory allocation evasion ideas, with the caveat that the technique is unstable and memory-size constrained.

Technical Focus:
- BOF/COFF in-memory loading (NiCOFF)
- RWX memory region discovery via `VirtualQueryEx`
- DLL loading side-effects (`LoadLibraryA` / `FreeLibrary`)
- Reusing “code caves” instead of `VirtualAlloc` RWX
- Windows memory protections and region metadata (MEM_COMMIT, MEM_PRIVATE, PAGE_EXECUTE_READWRITE)

Use Cases:
- Identify DLLs that create RWX regions on load for potential execution staging
- Prototype BOF execution paths that avoid direct RWX `VirtualAlloc`
- Research/validation of EDR heuristics around RWX allocation vs. reuse
- Build alternative in-process loaders leveraging existing executable memory

Keywords:
BOF, Beacon Object File, COFF, NiCOFF, Nim, Windows, LoadLibraryA, FreeLibrary, VirtualQueryEx, VirtualAlloc, RWX, PAGE_EXECUTE_READWRITE, MEM_PRIVATE, MEM_COMMIT, code cave, in-memory execution, mfcm120.dll, DllMain, memory scanning, EDR evasion