Title:
Peeling back the curtain with call stacks

Type:
Blog Post

Short Summary (4–8 sentences max):
- This article explains how Elastic Defend enriches endpoint telemetry with kernel/user-mode call stacks to add context to alerts and improve detection quality.  
- It shows how stack walking and call stack summaries can reduce ambiguity in common events (process, file, library, registry) by revealing the true initiating code path (e.g., WMI event consumers, scheduled tasks, Explorer ZIP execution).  
- The post provides concrete EQL/KQL examples that use module/function frames and “unbacked” memory regions to detect stealthy behaviors and bypass techniques.  
- Detection examples include process forking/reflection (Dirty Vanity), direct syscalls identified via leading instruction bytes, Office OLE embedded object drops, ransomware-like file renames from injected signed processes, malicious service DLL behavior, print monitor persistence, ROP-gadget-based DLL loading, and LdrpKernel32 overwrite evasion.  
- It’s primarily useful for detection engineers and blue teams, but also valuable for red teams to understand what call-stack-aware EDR telemetry can expose.  
- The key value is using call stacks to simultaneously improve false positive reduction, catch evasive tradecraft, and make alerts more explainable for triage/IR.

Technical Focus:
- Windows call stacks and stack walking (CaptureStackBackTrace)  
- Kernel call stack enrichment in EDR telemetry  
- EQL/KQL detections using call_stack / call_stack_summary fields  
- Unbacked memory regions and in-memory tradecraft visibility  
- Process reflection/forking (RtlCreateProcessReflection, RtlCloneUserProcess)  
- Direct syscalls, ROP gadgets, and loader/bootstrapping evasion (LdrpKernel32)

Use Cases:
- Triage enrichment: determine whether process creation came from WMI consumers, scheduled tasks, Explorer ZIP handling, etc.  
- Hunt for process forking/reflection followed by suspicious follow-on actions (child spawn, network, DLL loads).  
- Detect direct-syscall execution by matching syscall instruction byte patterns in call sites.  
- Identify malicious document behavior via OLE stream save/load call paths in Office processes.  
- Spot injection-backed ransomware activity by correlating trusted signer + suspicious “Unbacked” stack frames.  
- Detect persistence/priv-esc via print monitor installs, service DLL execution paths, and remote registry modifications.

Keywords:
Elastic Defend, kernel call stacks, stack walking, CaptureStackBackTrace, EDR enrichment, EQL, KQL, call_stack_summary, unbacked memory, code injection, Dirty Vanity, RtlCreateProcessReflection, RtlCloneUserProcess, direct syscall, syscall instruction 0F05, handle inheritance, WMI event consumer, wbemcons.dll, scheduled tasks, ubpm.dll, zipfld.dll, OleSaveToStream, print spooler, SplAddMonitor, localspl.dll, ROP gadgets, win32u.dll, ntdll.dll, LdrLoadDll, NtMapViewOfSection, LdrpKernel32 overwrite, Remote Registry, regsvc.dll, rpcrt4.dll