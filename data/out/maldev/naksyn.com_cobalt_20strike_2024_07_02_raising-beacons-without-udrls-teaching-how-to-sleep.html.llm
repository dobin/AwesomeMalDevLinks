Title:
Raising Beacons without UDRLs and Teaching them How to Sleep

Type:
Blog Post

Short Summary (4–8 sentences max):
- The post explains how to generate and run a Cobalt Strike Beacon exported without a UDRL (reflective loader), enabling use of a generic in-memory PE loader and easier experimentation with sleep obfuscation.  
- It shows that an “UDRL-less” Beacon DLL can be executed by mapping it (e.g., via MemoryModule) and calling its entrypoint twice, using two different `fdwReason` values to trigger distinct (including undocumented) DllMain paths needed for config decryption and C2 polling.  
- With imports resolved by the external loader, the author can perform dynamic IAT hooking of `Sleep` to implement custom sleep obfuscation without relying on Beacon’s SleepMask/UDRL constraints.  
- Two prototype techniques are introduced: **MemoryBouncing** (free/unmap the PE during sleep and restore it afterward) and **MemoryHopping** (remap the PE at a new address each sleep, adjusting return address and applying relocations).  
- The goal is to evade RX→RW permission-flip detections such as Elastic’s EtwTI-FluctuationMonitor and related scanners; the author reports bypassing several public tools with MemoryBouncing in their tests.  
- This is mainly useful for red teamers and malware/tooling developers who want a faster iteration loop for loader and sleep-evasion research, and for defenders to understand emerging evasion patterns.

Technical Focus:
- Cobalt Strike 4.9.1+ UDRL-less Beacon export via CNA customization
- In-memory PE loading (MemoryModule-style mapping) and DllMain/EntryPoint invocation semantics
- Dynamic IAT hooking of `Sleep` for sleep obfuscation
- RX→RW (VirtualProtect-based) fluctuation detections via ETW TI monitoring
- MemoryBouncing (free/restore mapped image) and MemoryHopping (relocate/remap per sleep)
- PE relocations and return-address adjustment during remapping

Use Cases:
- Prototype and test Beacon sleep obfuscation without writing/debugging PIC UDRLs
- Build generic PE loaders for UDRL-less Beacon execution with controllable import resolution
- Evaluate/evade RX→RW fluctuation detections (e.g., ETW TI-based monitors)
- Research implications of freeing/remapping payload memory on memory scanners and stack inspection
- Develop defensive detections for “unmap-on-sleep” and “remap/relocate-on-sleep” behaviors

Keywords:
Cobalt Strike, Beacon, UDRL, reflective loader, CNA script, stageless payload, in-memory PE loader, MemoryModule, DllMain, fdwReason, DLL_PROCESS_ATTACH, IAT hooking, Sleep hook, SleepEx, sleep obfuscation, ETW TI, EtwTI-FluctuationMonitor, CFG-FindHiddenShellcode, Moneta, PE-Sieve, VirtualProtect, RWX allocation, PE relocations, return address fixup, MemoryBouncing, MemoryHopping, WinHTTP