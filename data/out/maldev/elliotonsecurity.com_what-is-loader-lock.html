# https://elliotonsecurity.com/what-is-loader-lock/

<!DOCTYPE html><html dir="ltr" lang="en"><body class="sticky-footer" id="top"><div id="page-wrapper"><div class="mobile-menu"><div aria-label="Site navigation expandable mobile menu button" class="button_container" id="toggle" role="menu"><span class="middle"></span></div></div><section id="start"><section class="section" id="body-wrapper"><section class="container grid-lg"><div class="columns"><div class="column col-8 col-md-12 extra-spacing" id="item"><div class="card"><div class="card-image"><img alt="What is Loader Lock?" class="post-cover"></div><div class="card-header"><div class="card-title" style="margin-top:.25rem"><div class="text-center"><h1 class="post-title">What is Loader Lock?</h1><div class="post-meta" style="display:inline-flex"><span class="blog-date" style="display:inline-flex">   <i class="gg-calendar" style="margin-right:5px;margin-top:3px" title="Calendar"></i><time datetime="2023-12-06"> 2023-12-06 </time></span><span style="margin-left:.5em;margin-right:.5em"> <svg fill="none" height="10" role="separator" stroke="currentColor" stroke-width="1.5" width="10"><circle cx="5" cy="5" r="3"></circle></svg> </span><span class="post-author"> Elliot Killick </span><span style="display:inline-flex">    <a aria-label="Twitter" href="https://twitter.com/ElliotKillick" style="margin-left:.3em" target="_blank" title="Twitter"><svg class="icon icon-tabler icon-tabler-brand-x" viewBox="0 0 24 24" fill="none" height="20" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.25" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none" stroke="none"></path><path d="M4 4l11.733 16h4.267l-11.733 -16z"></path><path d="M4 20l6.768 -6.768m2.46 -2.46l6.772 -6.772"></path></svg></a> <a aria-label="GitHub" href="https://github.com/ElliotKillick" style="margin-left:.3em" target="_blank" title="GitHub"><svg class="icon icon-tabler icon-tabler-brand-github" viewBox="0 0 24 24" fill="none" height="20" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.25" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none" stroke="none"></path><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg></a> </span></div></div></div><div class="card-toc"></div></div><article class="card-body"><p>{{ alert_warning(message="This article is currently being rewritten to reflect new reverse engineering findings and accuracy improvements. For the time being, I advise skipping this article and referring the <a href="https://github.com/ElliotKillick/operating-system-design-review" target="_blank">Operating System Design Review</a> document where my newest research is available.") }}</p><p>In Windows, every DLL starts by executing its initialization function known as <code>DllMain</code>. This function runs while internal loader synchronization objects, including loader lock, are held. So, you must be especially careful not to violate a lock hierarchy in your <code>DllMain</code>; otherwise, a deadlock may occur.</p><p>Loader lock is a <a href="https://learn.microsoft.com/en-us/windows/win32/sync/critical-section-objects" target="_blank">critical section</a>. In WinDbg, you can detect the presence of loader lock with this command:</p><pre class="language-cmd" data-lang="cmd" style="background:#fafafa;color:#61676c"><code class="language-cmd" data-lang="cmd"><span style="color:#ff8f40">0</span><span>:</span><span style="color:#ff8f40">000</span><span style="color:#ed9366">&gt; </span><span>!critsec ntdll!LdrpLoaderLock
</span><span>
</span><span>CritSec ntdll!LdrpLoaderLock+</span><span style="color:#ff8f40">0 </span><span style="color:#fa6e32">at</span><span> 00007ffef2ef55c8
</span><span>WaiterWoken        No
</span><span>LockCount          </span><span style="color:#ff8f40">0
</span><span>RecursionCount     </span><span style="color:#ff8f40">1
</span><span>OwningThread       46e0
</span><span>EntryCount         </span><span style="color:#ff8f40">0
</span><span>ContentionCount    </span><span style="color:#ff8f40">0
</span><span>*** Locked
</span></code></pre><p>External code can search the Process Environment Block (PEB) for loader lock. Then you can use <code>RtlIsCriticalSectionLockedByThread</code> (an NTDLL export) to check its status:</p><pre class="language-cmd" data-lang="cmd" style="background:#fafafa;color:#61676c"><code class="language-cmd" data-lang="cmd"><span style="color:#ff8f40">0</span><span>:</span><span style="color:#ff8f40">000</span><span style="color:#ed9366">&gt;</span><span> dt _PEB </span><span style="color:#ed9366">@</span><span>$peb -n LoaderLock
</span><span>ntdll!_PEB
</span><span>   +</span><span style="color:#ff8f40">0x110</span><span> LoaderLock : </span><span style="color:#ff8f40">0x00007ffe</span><span>`f2ef55c8 _RTL_CRITICAL_SECTION
</span></code></pre><p>Its location at offset <code>+0x110</code> in the PEB has been stable since Windows NT 4.0 (the predecessor to Windows 2000). This is the offset for 64-bit processes; 32-bit processes have this member at offset <code>+0xa0</code>. Still, loader lock is officially an opaque implementation detail that Microsoft is contractually free to change or remove at any time.</p><p>A <a href="https://devblogs.microsoft.com/oldnewthing/20040128-00/?p=40853" target="_blank">previous (outdated) look at loader lock</a> states that the purpose of this lock is controlling access between threads to the <strong>module list</strong>. <span style="font-weight:800">Let's put that theory to the test on a modern Windows 10 system.</span></p><h2 id="legacy-loader-analysis">Legacy Loader Analysis<a aria-label="Anchor link for: legacy-loader-analysis" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#legacy-loader-analysis">ðŸ”—</a></h2><p>First, we will confirm the hypothesis was true at the time. We will base this analysis on ReactOS code. ReactOS is an open source reimplementation of Microsoft Windows built from the ground up by reverse engineering. It targets Windows Server 2003 support (additionally featuring some Windows 7+ APIs); this is around the same time Raymond Chen wrote his article summarizing loader lock in 2004.</p><p>Looking into the <code>LoadLibrary</code> function seems like an excellent place to start.</p><p>Delving into <a href="https://doxygen.reactos.org/" target="_blank">ReactOS source code</a>, we follow the call chain from <a href="https://doxygen.reactos.org/de/de3/dll_2win32_2kernel32_2client_2loader_8c.html#a90011aa8d7dab05b5b7590f6999b1094" target="_blank"><code>LoadLibraryW</code></a> â†’ <code>LoadLibraryExW</code> â†’ <code>LdrLoadDll</code> â†’ <code>LdrpLoadDll</code>. In both <a href="https://doxygen.reactos.org/d7/d55/ldrapi_8c.html#a7671bda932dbb5096570f431ff83474c" target="_blank"><code>LdrLoadDll</code></a> and <a href="https://doxygen.reactos.org/d8/d55/ldrutils_8c.html#a2108d522b1162cb346c676b0ddc5272e" target="_blank"><code>LdrpLoadDll</code></a> (and all of their subfunctions), it's clear to see that loader lock and <strong>no other locks</strong> are acquired before reading/modifying existing entries <em>or</em> adding/removing new entries to/from the module list. In <code>LdrLoadDll</code>, loader lock is acquired and released with <code>LdrLockLoaderLock</code> and <code>LdrUnlockLoaderLock</code>, respectively. In <code>LdrpLoadDll</code>, the effect is the same by directly calling <code>RtlEnterCriticalSection</code> and <code>RtlLeaveCriticalSection</code> on loader lock (<code>LdrpLoaderLock</code>).</p><div class="alert alert-info"><img alt="Information alert" src="https://elliotonsecurity.com/assets/images/alert-icons/circle-info-solid.svg" style="width:24px;height:24px" width="24" height="24"><span style="font-weight:700">Info</span><br> Function prefixes such as <code>Ldr</code> (loader) and <code>Ldrp</code> (loader internals) are function prefixes used to sort Native API / NT components into groups. Here's a <a href="https://en.wikipedia.org/wiki/Ntoskrnl.exe#Overview" target="_blank">longer list</a> of them if you want to know more.</div><p>For reading/modifying existing module entries, this fact becomes even more apparent when simply looking at any function which <a href="https://doxygen.reactos.org/d4/daf/struct__LDR__DATA__TABLE__ENTRY.html#a1c82c76c94dca8f269dfd81d651b95c9" target="_blank">touches the <code>LoadCount</code></a> of a module in the list. If a module's <code>LoadCount</code> (or reference count) equals zero, it gets unloaded from the process. A module's <code>LoadCount</code> is stored with the rest of the module's information in the module list. Loader lock is always the <strong>only lock</strong> acquired before interacting with the <code>LoadCount</code>.</p><p>Looking into a reading function like <code>GetModuleHandle</code>, we can see that <a href="https://doxygen.reactos.org/de/de3/dll_2win32_2kernel32_2client_2loader_8c.html#ab1bb2ffc2c8e91c6129a0a4d1320f825" target="_blank"><code>BasepGetModuleHandleExW</code></a> -&gt; <code>RtlPcToFileHeader</code> is in turn called to find the requested module. <code>GetModuleHandle</code> calls <code>BasepGetModuleHandleExW</code> with <code>NoLock</code> set to <code>TRUE</code>, thereby causing <code>BasepGetModuleHandleExW</code> to <em>not</em> acquire loader lock (no <code>LdrLockLoaderLock</code>). However, upon entry into <code>RtlPcToFileHeader</code>, loader lock is immediately acquired (<code>RtlEnterCriticalSection (NtCurrentPeb()-&gt;LoaderLock)</code>) before walking the module list to find the requested module. This quick look confirms that the loader also acquires loader lock for reads (this was obvious because performing writes already wasn't atomic/lock-free in nature, but it's good to verify).</p><p>From this short look into the loader source code, we can conclude that the theory is <strong>absolutely true</strong> for the legacy Windows Server 2003 loader. Furthermore, the legacy loader uses loader lock as <strong>one big lock</strong> around all functions that do loader work. This lock protects against not only concurrent module list access but also concurrent module loads/unloads, initialization/deinitialization (i.e. <code>DllMain</code>), and more.</p><h3 id="recursive-loading">Recursive Loading<a aria-label="Anchor link for: recursive-loading" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#recursive-loading">ðŸ”—</a></h3><p>Reading the source code of the aforementioned <code>LdrLoadDll</code> and <code>LdrpLoadDll</code> ReactOS functions, one might notice that <code>LdrLoadDll</code> acquires loader lock then calls <code>LdrpLoadDll</code> and it acquires loader lock again. How can <code>LdrpLoadDll</code> acquire loader lock when <code>LdrLoadDll</code> has already acquired it?</p><p>This question is along the same vein as a similar question I got in response to my previous article regarding loader lock: <strong>How is it <em>possible</em> for <code>LoadLibrary</code> to work from <code>DllMain</code> when we're still under Loader Lock!?</strong> It's true, calling <code>LoadLibrary</code> from <code>DllMain</code> (while not considered best practices by Microsoft) successfully loads libraries with <strong>no prior steps</strong>:</p><pre class="language-C" data-lang="C" style="background:#fafafa;color:#61676c"><code class="language-C" data-lang="C"><span style="font-style:italic;color:#abb0b6">// DllMain boilerplate code (required in every DLL)
</span><span style="font-style:italic;color:#55b4d4">BOOL WINAPI </span><span style="color:#f29718">DllMain</span><span>(</span><span style="font-style:italic;color:#55b4d4">HINSTANCE </span><span style="color:#ff8f40">hinstDll</span><span style="color:#61676ccc">, </span><span style="font-style:italic;color:#55b4d4">DWORD </span><span style="color:#ff8f40">fdwReason</span><span style="color:#61676ccc">, </span><span style="font-style:italic;color:#55b4d4">LPVOID </span><span style="color:#ff8f40">lpvReserved</span><span>)
</span><span>{
</span><span>    </span><span style="color:#fa6e32">switch </span><span>(fdwReason)
</span><span>    {
</span><span>    </span><span style="color:#fa6e32">case</span><span> DLL_PROCESS_ATTACH</span><span style="color:#61676ccc">:
</span><span>        </span><span style="font-style:italic;color:#abb0b6">// This DLL, for example, will successfully load from DllMain
</span><span>        </span><span style="font-style:italic;color:#abb0b6">// Ensure the DLL isn't already loaded with the WinDbg !address command
</span><span>        </span><span style="color:#f29718">LoadLibrary</span><span>(</span><span style="color:#fa6e32">L</span><span style="color:#86b300">"user32"</span><span>)</span><span style="color:#61676ccc">;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#fa6e32">return </span><span style="color:#ff8f40">TRUE</span><span style="color:#61676ccc">;
</span><span>}
</span></code></pre><p><strong>But how?</strong> Confusion regarding this stems from a misunderstanding of what a critical section is. <strong>A critical section is a <em>thread</em> synchronization mechanism.</strong> It's not for synchronizing subroutines within the same thread.</p><p>This fact means critical sections support <strong>recursive acquisition</strong> (this is fundamental). That is, a lock can be acquired multiple times in the <strong>same thread</strong> without waiting for its release. Here we have our sample test DLL (<code>Dll2</code>) containing the above code as a demonstration of this ability:</p><div style="text-align:center"><figure><a href="https://elliotonsecurity.com/what-is-loader-lock/loader-lock-recursive-acquisition.png" target="_blank"> <img src="https://elliotonsecurity.com/what-is-loader-lock/loader-lock-recursive-acquisition.png"> </a><figcaption>Loader lock is acquired recursively by the same <code>OwningThread</code>, thus increasing <code>RecursionCount</code>. As a result, program execution continues without waiting.</figcaption></figure></div><p>This screenshot is taken on Windows 10, hence the <code>LdrpReleaseLoaderLock</code> function.</p><p>The recursive acquisition of loader lock is a natural occurrence when loading a library that depends on other libraries. Indeed, the ReactOS code for <code>LdrLoadDll</code> makes reference to recursive loads with variable names such as <code>LdrpShowRecursiveLoads</code>.</p><p>If <strong>another thread</strong> tries to come along and acquire loader lock (a critical section) simultaneously as <strong>our thread</strong> is already holding the lock, then that increases the lock's <code>ContentionCount</code> and the <strong>other thread</strong> has to wait for its release.</p><p>A critical section can effectively be used as a subroutine synchronization mechanism if you're careful not to call any code that would recursively acquire it. However, that's not its primary purpose and using a critical section in that scenario unnecessarily increases overhead when a simpler lock would suffice. Splitting up a thread synchronization lock into separate, more specialized locks would also increase concurrency, thus improving a system's perceived performance.</p><p>Keep in mind that, while possible, loading libraries from <code>DllMain</code> is still not the <a href="https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices#general-best-practices" target="_blank">best practice</a> and is officially unsupported by Microsoft. It's poor for performance because invoking long-running operations while holding loader lock blocks other threads from loading libraries. If such operations are carried out during load-time (at process startup), all program execution gets held up! This is <a href="https://en.wikipedia.org/wiki/Priority_inversion" target="_blank">priority inversion</a> and it's best avoided. Additionally, there may be previous Windows versions where loading libraries from <code>DllMain</code> isn't possible due to some design/implementation quirk (and we all know how much Microsoft likes their decades upon decades of backward compatibility). In particular, it appears that doing risky things from <code>DllMain</code> during <code>DLL_PROCESS_DETACH</code> (not during <code>DLL_PROCESS_ATTACH</code> as shown above) is an <a href="https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices#best-practices-for-synchronization" target="_blank">acutely horrible idea, especially before Windows Vista</a>.</p><h2 id="modern-loader-analysis">Modern Loader Analysis<a aria-label="Anchor link for: modern-loader-analysis" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#modern-loader-analysis">ðŸ”—</a></h2><p>Now that we're familiar with loaders gone by - let's take a look at a modern Windows 10 (22H2) loader!</p><p>Through this analysis, we will see how what was once one large blocking loader lock around all loader work (<strong>coarse-grained</strong> locking) has been split up into smaller, specialized locks (more <strong>fine-grained</strong> locking), to increase concurrency, thereby improving perceived performance.</p><h3 id="data-structures">Data Structures<a aria-label="Anchor link for: data-structures" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#data-structures">ðŸ”—</a></h3><p>Before analyzing the modern Windows loader, it's essential to determine what type of data structures the loader stores module information in. The shared data structures determine where and what kind of locking would be necessary to protect module information from unsynchronized access, thereby helping us in our analysis.</p><h4 id="linked-list">Linked List<a aria-label="Anchor link for: linked-list" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#linked-list">ðŸ”—</a></h4><p>The module lists consist of the same entries linked in multiple different orders. The lists hold <code>LDR_DATA_TABLE_ENTRY</code> structures, each of which lives in an allocation on the heap:</p><pre class="language-cmd" data-lang="cmd" style="background:#fafafa;color:#61676c"><code class="language-cmd" data-lang="cmd"><span style="color:#ff8f40">0</span><span>:</span><span style="color:#ff8f40">000</span><span style="color:#ed9366">&gt;</span><span> x /</span><span style="color:#ff8f40">0</span><span> ntdll!PebLdr
</span><span>00007ffe`f2efb4c0
</span><span style="color:#ff8f40">0</span><span>:</span><span style="color:#ff8f40">000</span><span style="color:#ed9366">&gt;</span><span> dt _PEB_LDR_DATA 00007ffe`f2efb4c0
</span><span>ntdll!_PEB_LDR_DATA
</span><span>   +</span><span style="color:#ff8f40">0x000</span><span> Length           : </span><span style="color:#ff8f40">0x58
</span><span>   +</span><span style="color:#ff8f40">0x004</span><span> Initialized      : </span><span style="color:#ff8f40">0x1</span><span> ''
</span><span>   +</span><span style="color:#ff8f40">0x008</span><span> SsHandle         : (null) 
</span><span>   +</span><span style="color:#ff8f40">0x010</span><span> InLoadOrderModuleList : _LIST_ENTRY [ </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12d30 - </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12ba0 ]
</span><span>   +</span><span style="color:#ff8f40">0x020</span><span> InMemoryOrderModuleList : _LIST_ENTRY [ </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12d40 - </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12bb0 ]
</span><span>   +</span><span style="color:#ff8f40">0x030</span><span> InInitializationOrderModuleList : _LIST_ENTRY [ </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12bc0 - </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12bc0 ]
</span><span>   +</span><span style="color:#ff8f40">0x040</span><span> EntryInProgress  : (null) 
</span><span>   +</span><span style="color:#ff8f40">0x048</span><span> ShutdownInProgress : </span><span style="color:#ff8f40">0</span><span> ''
</span><span>   +</span><span style="color:#ff8f40">0x050</span><span> ShutdownThreadId : (null) 
</span><span style="color:#ff8f40">0</span><span>:</span><span style="color:#ff8f40">000</span><span style="color:#ed9366">&gt;</span><span> $$ The following command is generated by clicking on `InLoadOrderModuleList` in WinDbg command output
</span><span style="color:#ff8f40">0</span><span>:</span><span style="color:#ff8f40">000</span><span style="color:#ed9366">&gt;</span><span> dx -r1 (*((ntdll!_LIST_ENTRY *)</span><span style="color:#ff8f40">0x7ffef2efb4d0</span><span>))
</span><span>(*((ntdll!_LIST_ENTRY *)</span><span style="color:#ff8f40">0x7ffef2efb4d0</span><span>))                 [</span><span style="color:#fa6e32">Type</span><span>: _LIST_ENTRY]
</span><span>    [+</span><span style="color:#ff8f40">0x000</span><span>] Flink            : </span><span style="color:#ff8f40">0x1e7f9c12d30</span><span> [</span><span style="color:#fa6e32">Type</span><span>: _LIST_ENTRY *]
</span><span>    [+</span><span style="color:#ff8f40">0x008</span><span>] Blink            : </span><span style="color:#ff8f40">0x1e7f9c12ba0</span><span> [</span><span style="color:#fa6e32">Type</span><span>: _LIST_ENTRY *]
</span><span>$$ Click on `Flink`/`Blink` (forward/backward link) to inspect the next/previous list entry from the current (first) entry of </span><span style="color:#ff8f40">0x7ffef2efb4d0
</span><span style="color:#ff8f40">0</span><span>:</span><span style="color:#ff8f40">000</span><span style="color:#ed9366">&gt;</span><span> !address </span><span style="color:#ff8f40">0x1e7f9c12d30
</span><span>...
</span><span>Usage:                  Heap
</span><span>...
</span><span>$$ Here's our EXE, it's a module with a LDR_DATA_TABLE_ENTRY structure in the same way DLLs are
</span><span style="color:#ff8f40">0</span><span>:</span><span style="color:#ff8f40">000</span><span style="color:#ed9366">&gt;</span><span> dt _LDR_DATA_TABLE_ENTRY </span><span style="color:#ff8f40">0x1e7f9c12d30
</span><span>ntdll!_LDR_DATA_TABLE_ENTRY
</span><span>   +</span><span style="color:#ff8f40">0x000</span><span> InLoadOrderLinks : _LIST_ENTRY [ </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12ba0 - </span><span style="color:#ff8f40">0x00007ffe</span><span>`f2efb4d0 ]
</span><span>   +</span><span style="color:#ff8f40">0x010</span><span> InMemoryOrderLinks : _LIST_ENTRY [ </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12bb0 - </span><span style="color:#ff8f40">0x00007ffe</span><span>`f2efb4e0 ]
</span><span>   +</span><span style="color:#ff8f40">0x020</span><span> InInitializationOrderLinks : _LIST_ENTRY [ </span><span style="color:#ff8f40">0x00000000</span><span>`</span><span style="color:#ff8f40">00000000</span><span> - </span><span style="color:#ff8f40">0x00000000</span><span>`</span><span style="color:#ff8f40">00000000</span><span> ]
</span><span>   +</span><span style="color:#ff8f40">0x030</span><span> DllBase          : </span><span style="color:#ff8f40">0x00007ff6</span><span>`</span><span style="color:#ff8f40">28690000</span><span> Void
</span><span>   +</span><span style="color:#ff8f40">0x038</span><span> EntryPoint       : </span><span style="color:#ff8f40">0x00007ff6</span><span>`286912d0 Void
</span><span>   +</span><span style="color:#ff8f40">0x040</span><span> SizeOfImage      : </span><span style="color:#ff8f40">0x7000
</span><span>   +</span><span style="color:#ff8f40">0x048</span><span> FullDllName      : _UNICODE_STRING </span><span style="color:#86b300">"C:\Users\user\source\repos\EmptyProject\x64\Release\EmptyProject.exe"
</span><span>   +</span><span style="color:#ff8f40">0x058</span><span> BaseDllName      : _UNICODE_STRING </span><span style="color:#86b300">"EmptyProject.exe"
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> FlagGroup        : [</span><span style="color:#ff8f40">4</span><span>] </span><span style="color:#86b300">"???"
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> Flags            : </span><span style="color:#ff8f40">0x22c4 </span><span>(Flags variable stores all flag states)
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> PackagedBinary   : 0y0 (List all possible flags)
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> MarkedForRemoval : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> ImageDll         : 0y1
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> LoadNotificationsSent : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> TelemetryEntryProcessed : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> ProcessStaticImport : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> InLegacyLists    : 0y1
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> InIndexes        : 0y1
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> ShimDll          : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> InExceptionTable : 0y1
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> ReservedFlags1   : 0y00
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> LoadInProgress   : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> LoadConfigProcessed : 0y1
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> EntryProcessed   : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> ProtectDelayLoad : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> ReservedFlags3   : 0y00
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> DontCallForThreads : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> ProcessAttachCalled : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> ProcessAttachFailed : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> CorDeferredValidate : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> CorImage         : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> DontRelocate     : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> CorILOnly        : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> ChpeImage        : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> ReservedFlags5   : 0y00
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> Redirected       : 0y0
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> ReservedFlags6   : 0y00
</span><span>   +</span><span style="color:#ff8f40">0x068</span><span> CompatDatabaseProcessed : 0y0 (End list of all possible flags)
</span><span>   +</span><span style="color:#ff8f40">0x06c</span><span> ObsoleteLoadCount : </span><span style="color:#ff8f40">0xffff
</span><span>   +</span><span style="color:#ff8f40">0x06e</span><span> TlsIndex         : </span><span style="color:#ff8f40">0
</span><span>   +</span><span style="color:#ff8f40">0x070</span><span> HashLinks        : _LIST_ENTRY [ </span><span style="color:#ff8f40">0x00007ffe</span><span>`f2efb240 - </span><span style="color:#ff8f40">0x00007ffe</span><span>`f2efb240 ]
</span><span>   +</span><span style="color:#ff8f40">0x080</span><span> TimeDateStamp    : </span><span style="color:#ff8f40">0x655c238e
</span><span>   +</span><span style="color:#ff8f40">0x088</span><span> EntryPointActivationContext : (null) 
</span><span>   +</span><span style="color:#ff8f40">0x090 </span><span style="color:#fa6e32">Lock</span><span>             : (null) 
</span><span>   +</span><span style="color:#ff8f40">0x098</span><span> DdagNode         : </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12e60 _LDR_DDAG_NODE
</span><span>   +</span><span style="color:#ff8f40">0x0a0</span><span> NodeModuleLink   : _LIST_ENTRY [ </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12e60 - </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12e60 ]
</span><span>   +</span><span style="color:#ff8f40">0x0b0</span><span> LoadContext      : </span><span style="color:#ff8f40">0x000000e5</span><span>`62eff0e0 _LDRP_LOAD_CONTEXT
</span><span>   +</span><span style="color:#ff8f40">0x0b8</span><span> ParentDllBase    : (null) 
</span><span>   +</span><span style="color:#ff8f40">0x0c0</span><span> SwitchBackContext : (null) 
</span><span>   +</span><span style="color:#ff8f40">0x0c8</span><span> BaseAddressIndexNode : _RTL_BALANCED_NODE
</span><span>   +</span><span style="color:#ff8f40">0x0e0</span><span> MappingInfoIndexNode : _RTL_BALANCED_NODE
</span><span>   +</span><span style="color:#ff8f40">0x0f8</span><span> OriginalBase     : </span><span style="color:#ff8f40">0x00007ff6</span><span>`</span><span style="color:#ff8f40">28690000
</span><span>   +</span><span style="color:#ff8f40">0x100</span><span> LoadTime         : _LARGE_INTEGER </span><span style="color:#ff8f40">0x01da1deb</span><span>`cb90b0a4
</span><span>   +</span><span style="color:#ff8f40">0x108</span><span> BaseNameHashValue : </span><span style="color:#ff8f40">0x6190c450
</span><span>   +</span><span style="color:#ff8f40">0x10c</span><span> LoadReason       : </span><span style="color:#ff8f40">4 </span><span>( LoadReasonDynamicLoad )
</span><span>   +</span><span style="color:#ff8f40">0x110</span><span> ImplicitPathOptions : </span><span style="color:#ff8f40">0
</span><span>   +</span><span style="color:#ff8f40">0x114</span><span> ReferenceCount   : </span><span style="color:#ff8f40">2
</span><span>   +</span><span style="color:#ff8f40">0x118</span><span> DependentLoadFlags : </span><span style="color:#ff8f40">0
</span><span>   +</span><span style="color:#ff8f40">0x11c</span><span> SigningLevel     : </span><span style="color:#ff8f40">0</span><span> ''
</span><span>$$ Pro tip: Generate a list of all module entries with this command:
</span><span style="color:#ff8f40">0</span><span>:</span><span style="color:#ff8f40">000</span><span style="color:#ed9366">&gt; </span><span>!list -x "dt ntdll!_LDR_DATA_TABLE_ENTRY</span><span style="color:#86b300">" @@C++(&amp;@$peb-&gt;Ldr-&gt;InLoadOrderModuleList)
</span></code></pre><p><code>PEB_LDR_DATA</code> (<code>ntdll!PebLdr</code> at <code>0x7ffef2efb4d0</code>) contains list heads, after which each <code>LIST_ENTRY</code> points to a <code>LDR_DATA_TABLE_ENTRY</code>. This is a list of <code>LDR_DATA_TABLE_ENTRY</code> structures.</p><p>As we can see, all three of these lists in their various link orders, including <code>InLoadOrderModuleList</code>, <code>InMemoryOrderModuleList</code>, and <code>InInitializationModuleList</code> are of type <code>LIST_ENTRY</code>, which means they're <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/singly-and-doubly-linked-lists#doubly-linked-lists" target="_blank">doubly linked and circular</a>.</p><p>I've created this diagram to illustrate (<a href="https://viewer.diagrams.net/?tags=%7B%7D&amp;highlight=0000ff&amp;edit=_blank&amp;layers=1&amp;nav=1#R7V1bk5s2FP41nmkfsgPiYvy43kuTzqbNZHfa5GmHNbKtBiMX4107v77CSNwEGNvIYms1M40RAgm%2B75zznYMgA%2BNmsfktdJfzz9iD%2FgBo3mZg3A4AAIY9In%2FFLdukRQeGlrTMQuTRtqzhEf2EtJF1WyMPrgodI4z9CC2LjRMcBHASFdrcMMRvxW5T7BdHXbozyDU8Tlyfb%2F0bedE8aXUsLWv%2FCNFszkbWNbpn4bLOtGE1dz38lmsy7gbGTYhxlPxabG6gH989dl%2BS4%2B5r9qYTC2EQtTnAW394unl%2Bm4P175MnFM3%2B2jzcf6DwvLr%2Bml7wANg%2BOd94islpyayjLb0V9r9rzHZ8WO2AuiYdAFgStMfZfvJrFv%2F9KXjArvdn6MHwAQU%2FVqTvLwMw1jbar2yMl5B1Zi1k%2BsnArBkU5gDe5iiCj0t3Em%2B%2FEc6RTvNo4ZMtnfx0fTQLyO8JuScwJA2z0PUQ2bjBPibbtwEOyJHjVRTiHymgdnxVyPdZpwEwprv%2F0p65PYTC5E86t1cYRnBTC4meAk1MBOIFjMIt6UIPsBmNqHU4ZrL5ljHNYPYyz7HMpG0uJfcsPXOGP%2FlBKXAAHXRLJB8%2BwwUOtxWM0DNKXDYBdCCdAbZIBnwKUIQIRj%2FdCOGggglAOYdabtjSuTEUx42rqysF804zadJhdsTBPHZX8Nb3%2F3AXMLV5y1HeP4HelA0906rKwkXCLF3mxcefXfa%2FT5EXI49IOnhNx1wgz4un2QUx0lyxN%2BoPGOfV%2FzV00DoblFOVinrV1JMuLhn3JSUexv8k8TgnaeRLVSA0Wy0HsndHhi4wB3bPalRAYBZ6QIy6LNR7IE0EZqVN8UHB3w95IPBJxcVmphzO8iO6IbACUSg%2BKbwHfag4Gbqy6zPgLF21mQJxVkq9EnRLlw660DqjkurVsFvSYRdaRVRSvRn%2BkXT4BVbyVEhnONuGdJwFLhZSUp3Deygdb4HFVmXXDOehfNUmtNKmpDq%2FIqAHSl3oQmCl1CtRly7ULYHFNiXU96AvXadbqvQmHmb5Mt0SWIS5eJnOwS1dpVsCiy%2FKqnsj0kcCk%2B%2BLhbm8wEn6U5ORSrnFoyz%2FIagz5G459GbwkW6S60LR9iv0d0L6LtszXs3dZdyDvv0a361xiNeBBz2KDQ6jOZ7hwPUfMF7Sxn9gFG3pu7buOsJFOMlw4fYb2dDYxvd448pim7eb%2FM7bLd3y3Rfoj93Jj9luCgw9D07d9Y5mHKoOeDFsm2OGVcWp2oWNMXPv3QXy43l8hP4rjPvRHfQidZ1u85OCgXcdvyccj%2BW7qxWa8Lz0LOh4Znzj1oslQ4WSOkEuhquZjgRdvA4nsIEG7N27yA1nMGromKyF4gke7ijyWpxJ94%2FsRxxbpXGOo5Q9ceDLtJJSZVBd6ExjsOEGRd%2FYPMjv3MhkKxs43mDjtjPPHV2SS7ZL7HHDeOiEEl9giAg0MIxdLApmdIwOmTVqSSyzxnO2JtbuUGJP7jbXYYlREK1yZ%2F4SN%2BQdsm0VPbKhlVianDLjbDq3E0petaH1pbz%2Bu22s1Z2aWPuAVvEJPkLXS8sfLZaZp80vtaGZhEHetVLXxPnQvAXQPjkbrPWwVeE%2Fs%2FiMqidFZaAXOcA%2BAJELymngzgdlQ1RQrpdewvhxR3wbgvUFskvig66N%2BkYInbvbF6HSPPvFtt6BSiOpA5hMKuNslyLNahtLgZRYqoOi2RhW6bMwew8YniH4gg5qz3adM739%2Bnx7%2FXT9%2FHQ9frh7vvvj6ev3tpkudZ85O6v0pBWOs70pnMV92mYRVYv3noZ5Tu%2FJ6uAHe88z%2Bsa6DOGQLKNDVwNAS1czkpoOHlu8kAdsGikOiXVdAmu0BDYJNtKQdRqRzfCThOr%2BFJ%2FVbeorT8ck%2F10ywWyrJgwZasIsJ%2BZ0vnViotzftPeJD%2F3EA2y9MCNBaqWDhy11auXL3fiZKZaLUymjnomUIV%2Fa7EOKpx%2FmFw9P8Rr0TK9SvFSRCU3xQNs6vCm1Du9ol0lWVY%2Bo%2BhzCfrLKzRKAuBCqEv54L7D6Fkz7%2BVRbBdOmYNr9U2325u%2F%2Bp9q2jBRHL1fKDHCG%2BqdjHZFaC7ELFX9PpHcnZX6eltao9AkWtkqJnSOxJ3pYxtfD%2BW%2BU4sawOcfnDmAzE2swzeXjMxqMWh7VanlU94bWumgqKY5YjZWp%2FQcYo%2Bbal62f1l93zmCnZgdfZ1M6%2FxCdbzqyhb4D%2BuKbL0CsHxt%2B2nvi%2FUJdjOThHjaUCVujeHjHx95sY4rGKEknuuzyVOlUmi8bpn5aEmST0RfTVOuVJOUnbdf%2BAjlPGMvJh95oQ6YESTNqrrMfa0M86sdYFX18zZ5Rt3l8fQGJiPggudfuWPl1v92ZQqJpaVWfPmwXTA%2B1X3BY0gMa1xOIsV%2F2mQWVkpxprWEPMpJjVi71JCN5f872iCVUYh%2BJnvpYvtp3jZxiRdbWS6forCI7bFQ5%2Bw8Y7qkM6Zp%2B4gHs2sUKr9MXietmjeO%2BR%2BHulRtir0DzsesNAJmkNqXNKCD%2FW%2Bw%2BW5TsWEHiFjx2AGKftkk%2Fe3H4PxrSD%2Fdf5Q9qHQfvKARED6Pqnxo4a%2FQYAXG8e5qj0ON5F9FmjndRvr%2BiXXe04%2BqoPeDd6Z9uqeXdY8F%2FZcRL%2FRrHvGneQyrmCWTesOpDcOdl3ukpUn2kJXKNXBUfave85nrywHRcsYNUWk7hipXpiNMKIi2HbIY4xjqTtOSmzD9jD8Y9%2FgM%3D" target="_blank">diagram viewer</a>):</p><div style="text-align:center"><figure><a href="https://elliotonsecurity.com/what-is-loader-lock/module-lists-visualization.svg" target="_blank"> <img src="https://elliotonsecurity.com/what-is-loader-lock/module-lists-visualization.svg" width="300" height="150"> </a><figcaption>Visualization of module <code>LDR_DATA_TABLE_ENTRY</code> sturctures linked in multiple orders thus creating the module lists. Arrows are bidirectional due to double linking.</figcaption></figure></div><h4 id="hash-table">Hash Table<a aria-label="Anchor link for: hash-table" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#hash-table">ðŸ”—</a></h4><p>Each <code>LDR_DATA_TABLE_ENTRY</code> possesses a <code>HashLinks</code> member. These hash links point to a bucket in <code>ntdll!LdrpHashTable</code>. The Windows loader uses this hash table to improve lookup performance when searching for a module.</p><p>This hash table contains 32 buckets. <code>ntdll!LdrpHashTable</code> is 512 bytes in size (<code>ln</code> command), and each bucket is made up of a list entry containing two pointers for <code>Flink</code>/<code>Blink</code> (totalling 16 bytes), so we can prove 32 buckets by doing <code>512 / 16 = 32</code>. This size has remained unchanged since the legacy loader (in ReactOS source code).</p><p>Hashing each name is done by calling <code>LdrpHashUnicodeString</code> (which in turn calls <code>RtlHashUnicodeString</code>). Upon hashing, each name resolves to one of the <code>LDR_DATA_TABLE_ENTRY</code> entries in the module list.</p><p>A hash table (or hash map) is an array with each index ("bucket") in that array being a structure containing that bucket's list head. These list heads point to the list entries (<code>HashLinks</code> in <code>LDR_DATA_TABLE_ENTRY</code>) which may point to more list entires. Suppose a collision occurs (most hash table implementations employ a lightweight, imperfect hash function for performance reasons) whereby hashing resolves a name to the same bucket. In that case, the list entry points to a separate overflow bucket containing all overlapping entries. This process is called <a href="https://en.wikipedia.org/wiki/Hash_table#Collision_resolution" target="_blank">separate chaining</a> and is the most common method of hash table conflict resolution. Software uses hash tables because they typically outperform other data structures at their job.</p><h4 id="red-black-tree">Red-Black Tree<a aria-label="Anchor link for: red-black-tree" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#red-black-tree">ðŸ”—</a></h4><p>Starting with Windows 8, each <code>LDR_DATA_TABLE_ENTRY</code> is given two new members called <code>BaseAddressIndexNode</code> and <code>MappingInfoIndexNode</code>, both of type <code>RTL_BALANCED_NODE</code>.</p><p>I'll let this excerpt from <em>Windows Internals: System architecture, processes, threads, memory management, and more, Part 1</em> (7th edition) take it from here:</p><blockquote><p>Additionally, because lookups in linked lists are algorithmically expensive (being done in linear time), the loader also maintains two red-black trees, which are efficient binary lookup trees. The first is sorted by base address, while the second is sorted by the hash of the module's name. With these trees, the searching algorithm can run in logarithmic time, which is significantly more efficient and greatly speeds up process-creation performance in Windows 8 and later.</p></blockquote><h4 id="directed-acyclic-graph-dag">Directed Acyclic Graph (DAG)<a aria-label="Anchor link for: directed-acyclic-graph-dag" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#directed-acyclic-graph-dag">ðŸ”—</a></h4><p>Beginning with Windows 8, each <code>LDR_DATA_TABLE_ENTRY</code> is given a <code>LDR_DDAG_NODE</code> member. Microsoft added this member to solve issues in the <a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntldr/ldr_ddag_node.htm" target="_blank">resolution of complex dependency chains</a> between libraries as they're loaded and unloaded.</p><p>The extra "D" on <code>DDAG</code> most likely stands for "dependency", which makes sense because this DAG is for tracking dependencies.</p><p>A graph data structure is a superset of the tree and directed acyclic graph (DAG) data structures. Trees and DAGs are directional, meaning they have parent-child relationships. Each node in a tree can only have one parent, unlike a DAG where each node can have multiple parents. Both data structures are acyclic.</p><h3 id="locking-approach">Locking Approach<a aria-label="Anchor link for: locking-approach" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#locking-approach">ðŸ”—</a></h3><p>Controlling access to shared data structures like those reviewed above is likely only achievable by full or per-node locking. A programmer's choice would be weighed for costs and benefits. In the case of the Windows loader, I'll tell you upfront that the loader only does full locking to control access to data structures.<b>*</b></p><p>Particularly in the case of the module linked lists, they're doubly linked in multiple different orders. There's no single atomic assembly instruction (such as <code>lock cmpxchg</code> in x86 for atomically modifying a simple flag) you could give the CPU to do, for example, an insertion into even two of these lists in their various link orders (e.g. <code>InLoadOrderModuleList</code> and <code>InMemoryOrderModuleList</code>) in a single step (assumming you wanted to keep these two lists consistent with each other), thus enabling a developer to write so-called "lock-free" code. Lock-free deletion of a node in even just one singly linked list is already difficult due to the <a href="https://en.wikipedia.org/wiki/ABA_problem" target="_blank">ABA problem</a>. In general, lock-free code is rare due to relying on CPU architectural details such as the memory model which is different on x86 than on, for instance, ARM. This was somewhat of a tangent for the sake of completeness, but, my point is that we can expect to see the code employing OS-level synchronization mechanisms.</p><p><b>*</b>This statement does <em>not</em> include what happens in the case of delay loading. Delay loading is generally known as lazy loading on Linux (passing <code>RTLD_LAZY</code> flag to <code>dlopen</code>) and in web technologies. During delay loading, the <code>LdrpWriteBackProtectedDelayLoad</code> function acquires the <code>Lock</code> member (this is an exclusive SRW lock) of <code>LDR_DATA_TABLE_ENTRY</code> (shown earlier at offset <code>+0x90</code>) which implements some level of per-node locking. This <code>Lock</code> member was introduced in Windows 10. Delay loading is complex enough to require an article of its own and isn't touched on here. Feel free to go investigate this on your own!</p><h3 id="analysis">Analysis<a aria-label="Anchor link for: analysis" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#analysis">ðŸ”—</a></h3><p>Starting with Windows Vista / Server 2008, a new lock variety was added to Windows known as the <a href="https://learn.microsoft.com/en-us/windows/win32/sync/slim-reader-writer--srw--locks" target="_blank">slim read/write (SRW) lock</a>. SRW locks introduced two new lock types to the Windows API, including an <a href="https://stackoverflow.com/a/11837714" target="_blank">exclusive/write lock and shared/read lock</a>. Most notable for our purposes is the <strong>exclusive SRW lock</strong>. Unlike critical sections, this lock type doesn't keep track of the acquiring thread ID, making it useful for doing <strong>synchronization between subroutines</strong> (within the same thread and between threads; the acquiring thread is irrelevant). In terms of locks, it's about as minimal as it gets only storing a single pointer-sized integer which is set to indicate whether the lock is unlocked (0), owned/locked (1), contended (2), or there's a wait block (<code>StackWaitBlock</code>) for keeping track of who tried to acquire a contended lock first when there are multiple waiters. This is all according to ReactOS code. Its minimal nature could improve performance for highly parallelized workloads that don't require the extra features offered by a critical section. In the following analysis, we will see how the modern Windows loader uses this newer exclusive SRW lock.</p><p>In WinDbg, we set a breakpoint on <code>ntdll!RtlAcquireSRWLockExclusive</code>, tell the debugger to stop on NTDLL library load using the <code>sxe ld:ntdll</code> command, and hit <code>Go</code>!</p><p>Pretty soon, we hit our breakpoint when <code>LdrpInitializeProcess</code> -&gt; <code>LdrpInsertModuleToIndex</code> calls <code>RtlAcquireSRWLockExclusive</code> to acquire a lock known as the <strong><code>LdrpModuleDatatableLock</code></strong> (<code>LdrpInitializeProcess</code> does a few tasks before this using different SRW locks but it's unrelated).</p><div style="text-align:center"><figure><a href="https://elliotonsecurity.com/what-is-loader-lock/LdrpInsertModuleToIndex-RtlAcquireSRWLockExclusive-LdrpModuleDatatableLock-call-stack.png" target="_blank"> <img src="https://elliotonsecurity.com/what-is-loader-lock/LdrpInsertModuleToIndex-RtlAcquireSRWLockExclusive-LdrpModuleDatatableLock-call-stack.png"> </a></figure></div><pre class="language-asm" data-lang="asm" style="background:#fafafa;color:#61676c"><code class="language-asm" data-lang="asm"><span style="color:#f29718">ntdll!LdrpInsertModuleToIndex:
</span><span style="color:#fa6e32">mov     </span><span style="color:#f07171">qword ptr </span><span>[</span><span style="color:#ff8f40">rsp</span><span>+</span><span style="color:#ff8f40">8</span><span>], </span><span style="color:#ff8f40">rbx
</span><span style="color:#fa6e32">push    </span><span style="color:#ff8f40">rdi
</span><span style="color:#fa6e32">sub     </span><span style="color:#ff8f40">rsp</span><span>, </span><span style="color:#ff8f40">20h
</span><span style="color:#fa6e32">mov     </span><span style="color:#ff8f40">rdi</span><span>, </span><span style="color:#ff8f40">rcx
</span><span style="color:#fa6e32">mov     </span><span style="color:#ff8f40">rbx</span><span>, </span><span style="color:#ff8f40">rdx
</span><span style="color:#fa6e32">lea     </span><span style="color:#ff8f40">rcx</span><span>, [</span><span style="color:#f29718">ntdll!LdrpModuleDatatableLock (7ff9f74bd260)</span><span>]
</span><span style="color:#fa6e32">call    </span><span style="color:#f29718">ntdll!RtlAcquireSRWLockExclusive (7ff9f73790a0)
</span><span style="color:#fa6e32">mov     </span><span style="color:#ff8f40">rdx</span><span>, </span><span style="color:#ff8f40">rbx
</span><span style="color:#fa6e32">mov     </span><span style="color:#ff8f40">rcx</span><span>, </span><span style="color:#ff8f40">rdi
</span><span style="color:#fa6e32">call    </span><span style="color:#f29718">ntdll!LdrpInsertModuleToIndexLockHeld (7ff9f7364744)
</span><span style="color:#fa6e32">lea     </span><span style="color:#ff8f40">rcx</span><span>, [</span><span style="color:#f29718">ntdll!LdrpModuleDatatableLock (7ff9f74bd260)</span><span>]
</span><span style="color:#fa6e32">mov     </span><span style="color:#ff8f40">rbx</span><span>, </span><span style="color:#f07171">qword ptr </span><span>[</span><span style="color:#ff8f40">rsp</span><span>+</span><span style="color:#ff8f40">30h</span><span>]
</span><span style="color:#fa6e32">add     </span><span style="color:#ff8f40">rsp</span><span>, </span><span style="color:#ff8f40">20h
</span><span style="color:#fa6e32">pop     </span><span style="color:#ff8f40">rdi
</span><span style="font-style:italic;color:#abb0b6">; This is a tail call compiler optimization
</span><span style="font-style:italic;color:#abb0b6">; It's equivalent to a call then ret but faster
</span><span style="color:#fa6e32">jmp     </span><span style="color:#f29718">ntdll!RtlReleaseSRWLockExclusive (7ff9f7362c70)
</span></code></pre><p>Upon analyzing the registers immediately before <code>LdrpInsertModuleToIndexLockHeld</code> so we can know the passed arguments, we see that <strong>this is adding NTDLL's own <code>LDR_DATA_TABLE_ENTRY</code> to the index of modules</strong> (confirmed by running <code>r rcx; dt _LDR_DATA_TABLE_ENTRY &lt;RCX_VALUE&gt;</code>). Stepping up in the call stack to <code>LdrpInitializeProcess</code> (this is an expansive function for handling all process initialization on process startup), we see these three interesting functions called one after another:</p><ul><li><code>LdrpAllocateModuleEntry</code></li><li><code>LdrpInsertDataTableEntry</code></li><li><code>LdrpInsertModuleToIndex</code></li></ul><p>Let's do a deep dive into what each of these functions are doing to our known data structures.</p><h4 id="module-entry-creation-deep-dive">Module Entry Creation Deep Dive<a aria-label="Anchor link for: module-entry-creation-deep-dive" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#module-entry-creation-deep-dive">ðŸ”—</a></h4><h5 id="ldrpallocatemoduleentry">LdrpAllocateModuleEntry<a aria-label="Anchor link for: ldrpallocatemoduleentry" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#ldrpallocatemoduleentry">ðŸ”—</a></h5><p>Calls <code>RtlAllocateHeap</code> to allocate the new module entry to the heap. These allocations are done into the process heap which has already been created earlier in <code>LdrpInitializeProcess</code> by calling <code>LdrpInitializeProcessHeap</code>, which in turn calls <code>RtlCreateHeap</code>.</p><p><code>RtlAllocateHeap</code> is called twice:</p><p>The memory returned by the first call becomes a pointer to this module's <code>LDR_DATA_TABLE_ENTRY</code>. This memory address become the return value for <code>LdrpAllocateModuleEntry</code> as a whole.</p><p>The memory returned by the second call creates a <code>DDAG_NODE</code>, which is pointed to by its own <code>LDR_DATA_TABLE_ENTRY</code>.</p><p>In the context of being called from <code>LdrpInitializeProcess</code> during process startup, NTDLL is a little special in that a pointer to its <code>LDR_DATA_TABLE_ENTRY</code> gets put into <code>ntdll!LdrpNtDllDataTableEntry</code> for easy access shortly after <code>LdrpAllocateModuleEntry</code> returns.</p><h5 id="ldrpinsertdatatableentry">LdrpInsertDataTableEntry<a aria-label="Anchor link for: ldrpinsertdatatableentry" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#ldrpinsertdatatableentry">ðŸ”—</a></h5><p>Hashes the <code>BaseDllName</code> member (e.g. <code>ntdll.dll</code>) from the <code>LDR_DATA_TABLE_ENTRY</code> by calling <code>LdrpHashUnicodeString</code>. Based on the hash, a bucket from <code>ntdll!LdrpHashTable</code> is chosen. A pointer to this bucket is added to <code>HashLinks</code>, a doubly linked list in <code>LDR_DATA_TABLE_ENTRY</code>. Then, a pointer to the current <code>LDR_DATA_TABLE_ENTRY.HashLinks</code> gets put into the hash table at the chosen bucket.</p><p><code>LdrpInsertDataTableEntry</code> then links the newly allocated <code>LDR_DATA_TABLE_ENTRY</code> into the <code>InLoadOrderModuleList</code> and <code>InMemoryOrderModuleList</code> linked lists.</p><p>ModuleList</p><p>ReactOS has a function similar to this called <a href="https://doxygen.reactos.org/d8/d55/ldrutils_8c_source.html" target="_blank"><code>LdrpInsertMemoryTableEntry</code></a> which appears to have been its name in the <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2002/march/windows-2000-loader-what-goes-on-inside-windows-2000-solving-the-mysteries-of-the-loader#ldrpmapdll" target="_blank">Windows 2000 era</a>. One difference I notice is that <code>LdrpInsertDataTableEntry</code> performs consistency checks on the linked list data structures before modifying them. If one of these checks fail, a <code>__fastfail</code> (<code>int 29h</code>) with code <code>FAST_FAIL_CORRUPT_LIST_ENTRY</code> is raised. This bolsters security against exploits by catching memory corruption earlier.</p><p>In the context of being called from <code>LdrpInitializeProcess</code> during process startup, while NTDLL is the first module added to <code>InLoadOrderModuleList</code>, it's contradictively not the first module loaded into the process. As can been by <code>ModLoad</code> debug messages outputted by WinDbg, the first module loaded into our process' address space by the kernel is our EXE directly followed by <code>ntdll.dll</code> (use WinDbg command <code>sxe ld:ntdll</code> and restart the process to see this). <code>LdrpInitializeProcess</code> corrects this on its next call to <code>LdrpInsertDataTableEntry</code> by making our EXE first in the <code>InLoadOrderModuleList</code> followed by <code>ntdll.dll</code>. <code>LdrpInitializeProcess</code> likely does this because NTDLL setup is a requirement for doing practically anything else in user-mode hence it being done as early as possible.</p><h5 id="ldrpinsertmoduletoindex">LdrpInsertModuleToIndex<a aria-label="Anchor link for: ldrpinsertmoduletoindex" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#ldrpinsertmoduletoindex">ðŸ”—</a></h5><p>Firstly, <code>LdrpInsertModuleToIndex</code> acquires <code>LdrpModuleDatatableLock</code> and calls <code>LdrpInsertModuleToIndexLockHeld</code>.</p><p><code>LdrpInsertModuleToIndexLockHeld</code> calls <a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/rtl/rbtree/rbinsertnodeex.htm" target="_blank"><code>RtlRbInsertNodeEx</code></a> to create an <code>RTL_BALANCED_NODE</code> at <code>MappingInfoIndexNode</code> inside the current <code>LDR_DATA_TABLE_ENTRY</code>. This is not a pointer, the <code>LDR_DATA_TABLE_ENTRY</code> structure directly embeds a <code>RTL_BALANCED_NODE</code> structure starting at the offset of <code>MappingInfoIndexNode</code>. The tree's root node at <code>ntdll!LdrpMappingInfoIndex</code> (an <code>RTL_RB_TREE</code> stored in NTDLL) is only modified if one of its direct descendants is added or removed. Otherwise, the <code>Parent</code> argument is non-NULL, and <code>RtlRbInsertNodeEx</code> creates the new node as a descendant of the specified node.</p><p><code>RtlRbInsertNodeEx</code> is called again, this time performing the operation for <code>LDR_DATA_TABLE_ENTRY.BaseAddressIndexNode</code> and <code>ntdll!LdrpModuleBaseAddressIndex</code>.</p><h4 id="module-initialization-and-deinitialization">Module Initialization and Deinitialization<a aria-label="Anchor link for: module-initialization-and-deinitialization" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#module-initialization-and-deinitialization">ðŸ”—</a></h4><p>Initialization is the last step in the process of setting up a module.</p><p>The remaining module gets linked into the remaining list sorted by initialization, <code>InInitializationOrderModuleList</code>. For NTDLL, linking into <code>InInitializationOrderModuleList</code> happens immediately after <code>ntdll!RtlInitializeHistoryTable</code> returns still in <code>LdrpInitializeProcess</code>. For a normal module load (e.g. <code>LoadLibrary</code>), this happens early in <code>LdrpInitializeNode</code> (called by <code>LdrpInitializeGraphRecurse</code>). <code>LdrpInitializeNode</code> later calls <code>LdrpCallInitRoutine</code>, in turn calling the module's <code>DllMain</code> where module initialization occurs.</p><p>During module initialization and deinitialization, the DAG comes into play. For a normal library load (e.g. <code>LoadLibrary</code>), <code>LdrpInitializeGraphRecurse</code> <a href="https://elliotonsecurity.com/what-is-loader-lock/_blank">recursively</a> (meaning <code>LdrpInitializeGraphRecurse</code> calls itself) walks the DAG, calling each module's initialization function (<code>DllMain</code>) in the correct order, until all dependencies are initialized. <code>LdrpInitializeGraphRecurse</code> recurses once for every <code>DDAG_NODE</code> (each pertaining to its own module) it walks from the given parent node:</p><pre class="language-asm" data-lang="asm" style="background:#fafafa;color:#61676c"><code class="language-asm" data-lang="asm"><span style="color:#fa6e32">call    </span><span style="color:#f29718">ntdll!LdrpAcquireLoaderLock (7ffef2dce6c4)
</span><span style="color:#fa6e32">mov     </span><span style="color:#ff8f40">rcx</span><span>, </span><span style="color:#f07171">qword ptr </span><span>[</span><span style="color:#ff8f40">rdi</span><span>+</span><span style="color:#ff8f40">98h</span><span>]
</span><span style="color:#fa6e32">lea     </span><span style="color:#ff8f40">r8</span><span>, [</span><span style="color:#ff8f40">rsp</span><span>+</span><span style="color:#ff8f40">50h</span><span>]
</span><span style="color:#fa6e32">mov     </span><span style="color:#ff8f40">rdx</span><span>, </span><span style="color:#ff8f40">rsi
</span><span style="color:#fa6e32">mov     </span><span style="color:#f07171">byte ptr </span><span>[</span><span style="color:#ff8f40">rsp</span><span>+</span><span style="color:#ff8f40">50h</span><span>], </span><span style="color:#ff8f40">0
</span><span style="color:#fa6e32">call    </span><span style="color:#f29718">ntdll!LdrpInitializeGraphRecurse (7ffef2dfc018)
</span><span style="color:#fa6e32">mov     </span><span style="color:#ff8f40">r8d</span><span>, </span><span style="color:#ff8f40">eax
</span><span style="color:#fa6e32">mov     </span><span style="color:#ff8f40">edx</span><span>, </span><span style="color:#ff8f40">2
</span><span style="color:#fa6e32">mov     </span><span style="color:#ff8f40">ebx</span><span>, </span><span style="color:#ff8f40">eax
</span><span style="color:#fa6e32">call    </span><span style="color:#f29718">ntdll!LdrpReleaseLoaderLock (7ffef2dce664)
</span></code></pre><p>Likewise, during a normal <code>FreeLibrary</code>, <code>LdrpUnloadNode</code> calls our DLL's <code>DllMain</code>, passing <code>DLL_PROCESS_DETACH</code> as the <code>fdwReason</code>. Note that Windows loader only unloads the immediate node (module) and none of its dependencies; this is just how <code>FreeLibrary</code> works on Windows:</p><pre class="language-asm" data-lang="asm" style="background:#fafafa;color:#61676c"><code class="language-asm" data-lang="asm"><span style="color:#fa6e32">call    </span><span style="color:#f29718">ntdll!LdrpAcquireLoaderLock (7ffef2dce6c4)
</span><span style="color:#fa6e32">mov     </span><span style="color:#ff8f40">rcx</span><span>, </span><span style="color:#ff8f40">rbx
</span><span style="color:#fa6e32">call    </span><span style="color:#f29718">ntdll!LdrpUnloadNode (7ffef2dfa4c8)
</span><span style="color:#fa6e32">xor     </span><span style="color:#ff8f40">r8d</span><span>, </span><span style="color:#ff8f40">r8d
</span><span style="color:#fa6e32">lea     </span><span style="color:#ff8f40">edx</span><span>, [</span><span style="color:#ff8f40">r8</span><span>+</span><span style="color:#ff8f40">8</span><span>]
</span><span style="color:#fa6e32">call    </span><span style="color:#f29718">ntdll!LdrpReleaseLoaderLock (7ffef2dce664)
</span></code></pre><p>An interesting lock we have surrounding these function calls.</p><h4 id="ldrpmoduledatatablelock">LdrpModuleDatatableLock<a aria-label="Anchor link for: ldrpmoduledatatablelock" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#ldrpmoduledatatablelock">ðŸ”—</a></h4><p><strong><code>LdrpModuleDatatableLock</code> is an exclusive lock that protects the <code>InLoadOrderModuleList</code> and <code>InMemoryOrderModuleList</code> module linked lists, hash table, and red-black tree during module entry read or write operations.</strong></p><p>Whenever the Windows loader wants to ensure these data structures remain in an unchanged, consistent, and valid state, <code>LdrpModuleDatatableLock</code> is acquired. This includes, for example, acquisition during module search operations like <code>LdrpFindLoadedDllByName</code>.</p><p>A nuance is that acquiring <code>LdrpModuleDatatableLock</code> (or <code>LdrpLoaderLock</code>) isn't necessary during <code>LdrpInitializeProcess</code>. This is because our thread remains the only thread in the process <em>and</em> new threads spawned into our process during <code>LdrpInitializeProcess</code> (a remote process could call <code>CreateRemoteThread</code>) won't be able to make progress anyway due to <code>LdrpInitCompleteEvent</code> (a Win32 event) waiting. During early initialization in <code>LdrpInitialize</code>, new threads wait (<code>NtWaitForSingleObject</code>) on <code>LdrpInitCompleteEvent</code> before doing anything. It's not until <code>LdrpProcessInitializationComplete</code> calls <code>NtSetEvent</code> on <code>LdrpInitCompleteEvent</code>, thereby allowing other threads to move, that locking is necessary. Even if <code>LdrpModuleDatatableLock</code> is a subroutine locking mechanism, it's not relevant to hold it because, in practice, our single thread isn't going to do something rash that would deadlock itself or do inconsistent modification to a data structure whether the subroutine does or doesn't lock <code>LdrpModuleDatatableLock</code> (certainly not before calling into any third-party, non-Microsoft code).</p><p>This nuance allows <code>LdrpModuleDatatableLock</code> to not be held during <code>LdrpInsertDataTableEntry</code>, instead only acquiring it in <code>LdrpInsertModuleToIndex</code>. I suspect that the only reason <code>LdrpInitializeProcress</code> calls <code>LdrpInsertModuleToIndex</code>, thus acquiring <code>LdrpModuleDatatableLock</code>, is because not acquiring it would mean having to call <code>LdrpInsertModuleToIndexLockHeld</code>, which would be a misnomer in this context; it's not that it's locked it's just that you don't have to acquire the lock given this unique circumstance of process initialization.</p><p>I've confirmed that during normal loader operation (e.g. doing a <code>LoadLibrary</code>), the loader calls <code>RtlAcquireSRWLockExclusive</code> to acquire <code>LdrpModuleDatatableLock</code>, safely calls <code>LdrpInsertDataTableEntry</code>, then safely calls <code>LdrpInsertModuleToIndexLockHeld</code> directly, lastly releasing by doing a <code>RtlReleaseSRWLockExclusive</code> on <code>LdrpModuleDatatableLock</code>. This pattern of operations protects all of the relevant module info data structures during process run-time.</p><h4 id="loader-lock-ldrploaderlock">Loader Lock (LdrpLoaderLock)<a aria-label="Anchor link for: loader-lock-ldrploaderlock" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#loader-lock-ldrploaderlock">ðŸ”—</a></h4><p>But wait, how about the one and only: loader lock? We had to get away from it to put this information in context, but we're ready to discuss it now!</p><p>So, we know that loader lock isn't responsible for protecting the <code>InLoadOrderModuleList</code> and <code>InMemoryOrderModuleList</code> linked lists, hash table, or red-black tree. This leaves only two data structures: <strong>the DAG and <code>InInitializationOrderModuleList</code></strong>.</p><p>Recall the code in the <a href="https://elliotonsecurity.com/what-is-loader-lock/#module-initialization-and-deinitialization">Module Initialization</a> section. During <code>LoadLibrary</code> in <code>LdrpInitializeGraphRecurse</code>, you would have seen the code get an address at a register plus offset <code>0x98</code> (<code>mov     rcx, qword ptr [rdi+98h]</code>). For <code>FreeLibrary</code>, this same operation is also done before <code>LdrpUnloadNode</code>; it's just out of frame. And what do we know is at offset <code>0x98</code>?</p><pre class="language-cmd" data-lang="cmd" style="background:#fafafa;color:#61676c"><code class="language-cmd" data-lang="cmd"><span>   +</span><span style="color:#ff8f40">0x098</span><span> DdagNode         : </span><span style="color:#ff8f40">0x000001e7</span><span>`f9c12e60 _LDR_DDAG_NODE
</span></code></pre><p>Yes, here we have a pointer to a <code>DdagNode</code> being extracted from the <code>LDR_DATA_TABLE_ENTRY</code> of our currently loading module!</p><p>Regarding <code>InInitializationOrderModuleList</code>, this list has its links protected by loader lock. The previously covered <code>LdrpInitializeNode</code> function accesses the <code>InInitializationOrderModuleList</code> through its list head in <code>PEB_LDR_DATA</code>. No <code>LDR_DATA_TABLE_ENTRY</code> structures are ever accessed so it's not necessary to acquire <code>LdrpModuleDatatableLock</code>.</p><p>The loader also acquires loader lock during <code>RtlExitUserProcess</code> to ensure no new libraries initialize while the process shuts down and performs module deinitialization (i.e. calling each module's <code>DllMain</code> passing <code>DLL_PROCESS_DETACH</code> as the <code>fdwReason</code>).</p><p>I believe we have our answer: <strong>Loader lock is a critical section that controls access to the DAG data structure used by the loader to track dependency chains, protects <code>InInitializationOrderModuleList</code>, and guards against concurrent DLL initialization/deinitialization.</strong></p><h3 id="windows-vs-linux-loader-architectures">Windows vs. Linux Loader Architectures<a aria-label="Anchor link for: windows-vs-linux-loader-architectures" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#windows-vs-linux-loader-architectures">ðŸ”—</a></h3><p>The Windows and Linux (GNU dl, dynamic linker) loaders are very different. For one, Linux only maintains a single data structure for module info, a non-circular doubly linked list called <code>link_map</code>... that's it.</p><p>On Linux, the Windows critical section (a thread synchronization mechanism) equivalent is a mutex (this is part of POSIX defined <code>pthread</code>). On Windows, critical sections and mutexes are the same, except the former is intra-process, whereas the latter is inter-process.</p><p>Glibc source code refers to loader lock as <code>_dl_load_lock</code>. This lock protects from concurrent loads and unloads and in that way it's structured similarly to the Windows Server 2003 loader lock. It's acquired by <code>dlopen</code> or <code>dlclose</code> upon committing to do any loader work.</p><p><code>_dl_load_write_lock</code> works like a modern Windows loader's <code>LdrpModuleDatatableLock</code>. These exclusive/write locks control access to module data structures. The only difference is that <code>_dl_load_write_lock</code> is shortly acquired/released once for every <code>dlopen</code> on Linux. In contrast, I counted the equivalent <code>LdrpModuleDatatableLock</code> to be acquired 20 times for each <code>LoadLibrary</code> (passing in the full path to an empty test DLL) on Windows.</p><p>Architecturally speaking, the reason loader lock problems are significantly more prevalent on Windows than on Linux comes down to each design approach of these operating systems: Windows lock hierarchies are much less modular than Linux. In other words, the loader's state may be implictly shared with other Windows components due to the <strong>monolithic architecture</strong> of the Windows API. Hence, doing <a href="https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices#general-best-practices" target="_blank">unrelated things</a> that synchronize threads like spawning <em>and waiting</em> on a thread's creation (<em>without</em> loading/unloading any libraries on the new thread) can violate the <strong>greater NTDLL lock hierarchy</strong>. Contrast that with the <a href="https://en.wikipedia.org/wiki/Unix_philosophy" target="_blank">Unix philosophy</a>.</p><p>I've released the <a href="https://github.com/ElliotKillick/operating-system-design-review" target="_blank">Operating System Design Review</a> repo containing the full info, including my experiments comparing and contrasting the Windows and Linux loaders (and now lots more stuff)!</p><h3 id="wrapping-up">Wrapping Up<a aria-label="Anchor link for: wrapping-up" class="zola-anchor" href="https://elliotonsecurity.com/what-is-loader-lock/#wrapping-up">ðŸ”—</a></h3><p>In this article, we learned the building blocks of a modern Windows loader. Using this knowledge, we understood how operating systems perform locking around the relevant shared data structures and sections of code.</p><p>Atop these building blocks is another layer of abstraction: the parallel loader. Introduced in Windows 10 to further improve performance, this is a thread pool (i.e. a bunch of threads assigned and ready to do one task at any time) for only loader work. These show up as <code>ntdll!TppWorkerThread</code> threads in WinDbg. Following NTDLL initialization, <code>LdrpInitializeProcess</code> calls <code>LdrpInitParallelLoadingSupport</code>, thus beginning parallel loader setup. I'll glaze over this by stating that the <code>LdrpAllocatePlaceHolder</code> function allocates a <code>LdrpWorkQueue</code> <code>LIST_ENTRY</code> item and then calls <code>LdrpAllocateModuleEntry</code> to create a module entry, thus creating a whole work item. Loader work threads then read work items from the work queue and do the appropriate work (mapping or snapping). Now you're seeing how this whole system starts to come together! If you want to learn more about the modern Windows loader, then I recommend you check out <a href="https://blogs.blackberry.com/en/2017/10/windows-10-parallel-loading-breakdown" target="_blank">Windows 10 Parallel Loading Breakdown</a> by Jeffrey Tang from BlackBerry as he provides a fantastic high-level overview.</p><p>In any case, I hope reading this article allowed you to more deeply appreciate everything that goes on under the hood when you double-click a program on Windows.</p><div style="padding-top:1em;border-top:1px solid #ddd"></div><div class="interaction-buttons"><p style="margin-bottom:.2em">Share on:</p><ul><li><a class="twitter btn" href="https://twitter.com/intent/tweet?text=https://elliotonsecurity.com/what-is-loader-lock/" title="Share on X/Twitter" target="_blank"> <svg class="bi bi-twitter-x" viewBox="0 0 16 16" fill="currentColor" height="16" width="16" xmlns="http://www.w3.org/2000/svg"><path d="M12.6.75h2.454l-5.36 6.142L16 15.25h-4.937l-3.867-5.07-4.425 5.07H.316l5.733-6.57L0 .75h5.063l3.495 4.633L12.601.75Zm-.86 13.028h1.36L4.323 2.145H2.865l8.875 11.633Z"></path></svg> <span>X / Twitter</span> </a></li><li><a class="linkedin btn" href="https://www.linkedin.com/sharing/share-offsite/?url=https://elliotonsecurity.com/what-is-loader-lock/" title="Share on LinkedIn" target="_blank"> <svg aria-label="LinkedIn social share" viewBox="0 0 448 512" fill="currentColor" role="button" style="width:1em;height:1em;vertical-align:text-top;position:relative;top:1px" xmlns="http://www.w3.org/2000/svg"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg> <span>LinkedIn</span> </a></li><li><a class="hacker-news btn" href="https://news.ycombinator.com/submitlink?u=https://elliotonsecurity.com/what-is-loader-lock/" title="Share on Hacker News" target="_blank"> <svg aria-label="Hacker News social share" viewBox="0 0 448 512" fill="currentColor" role="button" style="width:1em;height:1em;vertical-align:text-top;position:relative;top:2px" xmlns="http://www.w3.org/2000/svg"><path d="M0 32v448h448V32H0zm21.2 197.2H21c.1-.1.2-.3.3-.4 0 .1 0 .3-.1.4zm218 53.9V384h-31.4V281.3L128 128h37.3c52.5 98.3 49.2 101.2 59.3 125.6 12.3-27 5.8-24.4 60.6-125.6H320l-80.8 155.1z"></path></svg> <span>Hacker News</span> </a></li><li><a class="reddit btn" href="https://www.reddit.com/submit?url=https://elliotonsecurity.com/what-is-loader-lock/" title="Share on Reddit" target="_blank"> <svg aria-label="Reddit social share" viewBox="0 0 512 512" fill="currentColor" role="button" style="width:1em;height:1em;vertical-align:text-top;position:relative;top:2px" xmlns="http://www.w3.org/2000/svg"><path d="M201.5 305.5c-13.8 0-24.9-11.1-24.9-24.6 0-13.8 11.1-24.9 24.9-24.9 13.6 0 24.6 11.1 24.6 24.9 0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4 0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8 0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7 0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9 0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5 0 52.6 59.2 95.2 132 95.2 73.1 0 132.3-42.6 132.3-95.2 0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6 0-2.2-2.2-6.1-2.2-8.3 0-2.5 2.5-2.5 6.4 0 8.6 22.8 22.8 87.3 22.8 110.2 0 2.5-2.2 2.5-6.1 0-8.6-2.2-2.2-6.1-2.2-8.3 0zm7.7-75c-13.6 0-24.6 11.1-24.6 24.9 0 13.6 11.1 24.6 24.6 24.6 13.8 0 24.9-11.1 24.9-24.6 0-13.8-11-24.9-24.9-24.9z"></path></svg> <span>Reddit</span> </a></li></ul></div></article><div class="card-footer"><div class="columns"><div class="column col-9 col-sm-7"><div class="taxonomies text-left"><a class="label label-rounded label-secondary p-category" href="https://elliotonsecurity.com/categories/system-architecture/">system architecture</a><a class="label label-rounded label-secondary p-category" href="https://elliotonsecurity.com/categories/concurrency/">concurrency</a><a class="label label-rounded label-secondary p-category" href="https://elliotonsecurity.com/categories/reverse-engineering/">reverse engineering</a><a class="label label-rounded tag" href="https://elliotonsecurity.com/tags/windows/">#windows</a><a class="label label-rounded tag" href="https://elliotonsecurity.com/tags/technical/">#technical</a></div></div></div></div></div></div></div></section></section></section><section class="container grid-lg" style="padding-left:1rem;padding-right:1rem"><a href="https://elliotonsecurity.com/"> <ul class="pagination paginator"><p style="margin:0;color:white;line-height:0;font-weight:700;opacity:50%">Explore Similar Content âž¤</p></ul> </a></section></div><div class="mobile-container"></div></body></html>