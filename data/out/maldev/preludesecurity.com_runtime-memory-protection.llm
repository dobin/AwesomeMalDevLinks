Title:
Introducing Runtime Memory Protection

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post previews Prelude’s research on a Windows endpoint agent aimed at reliably detecting in-memory (“fileless”) malicious code execution.  
- It focuses on “out-of-context execution,” where attackers force unintended code paths via exploitation, dynamic code, and local/remote injection.  
- The core claim is that traditional kernel-inline EDR architectures can’t scale to high-volume execution telemetry without performance tradeoffs, leading to opportunistic scans and race conditions attackers exploit.  
- Prelude proposes an asynchronous, user-mode architecture (implemented in Rust) that consumes hardware-backed and OS telemetry (e.g., IPT/LBR/context switches via ETW) to reconstruct execution provenance per thread/process/user.  
- Detection anchors on ground truth: identifying instruction-pointer transitions from image-backed code into private executable memory, then enriching with a graph “digital twin” of OS objects to reduce false positives and support investigation.  
- It’s most relevant to Blue Teams/EDR engineers and defenders focused on memory injection/exploitation detection, and to red teamers as an indicator of where endpoint detection is heading.

Technical Focus:
- Hardware-assisted execution tracing (Intel Processor Trace, Last Branch Record)
- ETW-based asynchronous telemetry collection in user mode
- Detecting execution from private executable memory vs image-backed code
- Full-system provenance: mapping instructions to thread/process/user context
- Edge analytics at high event volume (hundreds of millions of events/day)
- Graph-based OS object lifecycle modeling (“digital twin”) for investigations

Use Cases:
- Detecting process injection, reflective loading, and other in-memory execution techniques
- Identifying exploit-driven dynamic code execution and short-lived “smash-and-grab” payloads
- Investigating suspicious execution with timeline/subgraph snapshots of related OS objects
- Building higher-fidelity detections that avoid periodic memory scanning race conditions
- Evaluating user-mode, asynchronous alternatives to kernel-inline EDR designs

Keywords:
Windows user-mode agent, Rust, runtime memory protection, in-memory attacks, fileless malware, out-of-context execution, ETW, Intel Processor Trace, IPT, Last Branch Record, LBR, context switches, RIP, private executable memory, code injection, remote thread injection, exploitation, execution provenance, edge analytics, graph database, OS object lifecycle, EDR architecture, memory scanning race condition