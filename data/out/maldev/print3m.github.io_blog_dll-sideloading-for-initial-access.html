# https://print3m.github.io/blog/dll-sideloading-for-initial-access

<!DOCTYPE html><html lang="en" data-mantine-color-scheme="dark"><body style="background-color: rgb(36, 36, 36);"><div class="m_89ab340 mantine-AppShell-root" style="--app-shell-transition-duration: 200ms; --app-shell-transition-timing-function: ease; background: var(--mantine-color-dark-7;" data-resizing="true"><main class="m_8983817 mantine-AppShell-main" style="padding-top: calc(calc(3.75rem * var(--mantine-scale)) + var(--mantine-spacing-md));"><div class="" style="margin-inline: auto; padding-top: calc(2.8125rem * var(--mantine-scale)); max-width: calc(43.75rem * var(--mantine-scale));"><a class="mantine-focus-auto mantine-active m_77c9d27d mantine-Button-root m_87cf2631 mantine-UnstyledButton-root" data-variant="subtle" data-with-left-section="true" href="https://print3m.github.io/" style="--button-bg: transparent; --button-hover: var(--mantine-color-blue-light-hover); --button-color: var(--mantine-color-blue-light-color); --button-bd: calc(0.0625rem * var(--mantine-scale)) solid transparent;"><span class="m_80f1301b mantine-Button-inner"><span class="m_a74036a mantine-Button-section" data-position="left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-arrow-back-up"><path d="M9 14l-4 -4l4 -4"></path><path d="M5 10h11a4 4 0 1 1 0 8h-1"></path></svg></span><span class="m_811560b9 mantine-Button-label">All posts</span></span></a><div class="" style="height: var(--mantine-spacing-md); min-height: var(--mantine-spacing-md);"></div><h1 class="m_8a5d1357 mantine-Title-root" data-order="1" style="--title-fw: var(--mantine-h1-font-weight); --title-lh: var(--mantine-h1-line-height); --title-fz: var(--mantine-h1-font-size);">DLL Sideloading for Initial Access – Red Team Operator's Guide</h1><div class="" style="padding-top: calc(0.375rem * var(--mantine-scale)); font-size: var(--mantine-font-size-md);">Created at: 2025-09-02</div><div class="m_d6493fad mantine-TypographyStylesProvider-root" style="padding-top: var(--mantine-spacing-xl); text-align: justify;"><p>Replacing one of the DLL libraries is the easiest way to add your own functionality to a compiled program on Windows. We do not touch the main digitally signed EXE file, but replace one of the libraries loaded by the running process. This is a simple but still very effective method of confusing EDRs.</p>
<p>How can this be used for initial access? We need to find the right trusted software, subtly backdoor one of its DLLs not to disrupt the operation of the program, pack everything into an archive and send it to the victim. It sounds simple, but there are quite a few tricks and caveats that we should take into account during red team exercises.</p>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/dll-sideloading-for-initial-access#dll-sideloading-dll-proxying"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>DLL Sideloading &amp; DLL Proxying</h2>
<p>DLL sideloading involves copying an application's executable file to another folder and substituting your own DLL libraries for those expected by the program. DLL sideloading is possible when the application loads DLL libraries using relative paths rather than absolute paths, i.e., it uses, for example, <code class="MDRenderer_code___eFJE">LoadLibrary("./utils/math.dll")</code>. Most applications do this because the user can choose where to install the application on the system, and the application must work everywhere. This is not a particular vulnerability. You could even say it's a feature, as most applications do this intentionally. We will use this feature to substitute our own malicious DLL into a legitimate program, pack it, and send it to the victim. This way, our malware is launched by trusted software.</p>
<p>DLL Proxying is a technique used in DLL Sideloading to substitute your own code without disrupting the normal operation of the program. Everything looks legitimate, and your malicious code has been executed. I will discuss this technique in more detail later in this article.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/1.png" alt="img" style="cursor: pointer;"></p>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/dll-sideloading-for-initial-access#find-the-right-software-to-backdoor"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Find the right software to backdoor</h2>
<p>Perfect software to backdoor should be:</p>
<ul>
<li>Modular - Of course, the program must have some DLLs that we can backdoor. We are talking about custom software DLLs, not the system ones.</li>
<li>"DLL Sideloadable" - The program must be vulnerable to DLL sideloading when moved to another location.</li>
<li>Small - Remember, we want to send this to the victim. It can't be 20 gigabytes.</li>
<li>Popular - It must be something common, something that EDR has seen millions of times across the globe. Think about archivers (7zip, WinRAR), lightweight editors (Notepad++), PDF readers, image viewers.</li>
<li>Digitally signed -  The program must be legit and digitally signed with valid certificate.</li>
</ul>
<p>Do not use dual-use software! Some people use, for example, the Python interpreter and perform DLL Sideloading on it. It may work, but it makes no more sense than using a "regular" app. The Python interpreter itself can be suspicious, and we do not use anything Python-specific to take additional risks. The best software is the most ordinary, innocent and common one you can find.</p>
<blockquote class="MDRenderer_blockquote__JCOCK">
<p><strong>NOTE</strong>: Not every software has its own DLLs at all. Some programs only use system libraries. Some software has its own DLLs, but they are so obfuscated, with strange calling conventions and name mangling, that it's better not to touch them. Look for something else.</p>
</blockquote>
<p><strong>Testing ideas</strong></p>
<p>To test whether the application is vulnerable to DLL sideloading suitable for Initial Access, follow these steps:</p>
<ol>
<li>Install the application.</li>
<li>Copy the entire folder with installed application to another location.</li>
<li>Uninstall the original application (e.g. using control panel).</li>
<li>Try to run the copied application.</li>
</ol>
<p>If everything works correctly, it means <strong>we can start backdooring application's DLL files!</strong></p>
<p><strong>If the application crashes or not everything works correctly, then unfortunately we are out of luck.</strong> The application probably needs some values in the Windows registry or configuration files in fixed locations, which it places there during installation. This prevents us from performing DLL Sideloading as an Initial Access vector. In reality, there is no other way than to test manually, because everything depends on the decisions made by the developers who created the application.</p>
<p><strong>Another problem is what happens when we deliver an application to a user who already has it installed.</strong> Various things can happen here, including our EXE starting to use the original DLLs in the installation location. This means that our backdoor will not be launched or proxied functions will not work. <strong>If there's a chance, test that too with already installed software!</strong></p>
<p><strong>Common software</strong></p>
<p>In the case of normal applications used by millions of people around the world, I suspect that majority of application DLL libraries will be vulnerable to DLL Sideloading. I have already written about this, but I will repeat: this is (mostly) not a bug, it is a feature.</p>
<p>You can find some known abusable applications at <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://hijacklibs.net/">hijacklibs.net<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a>. Keep in mind that this is by no means an exhaustive list, and finding vulnerable software manually is not that difficult.</p>
<p>Application categories worth checking out:</p>
<ul>
<li>File archivers</li>
<li>Image / video viewers</li>
<li>PDF viewers and editors</li>
<li>Lightweight document viewers (Excel / Word / PowerPoint replacements)</li>
<li>Password managers</li>
<li>Lightweight code editors</li>
<li>Lightweight graphic editors</li>
<li>File managers</li>
<li>FTP / SSH / whatever clients</li>
<li>Note-taking applications</li>
<li>Lightweight system administration tools</li>
</ul>
<p><a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://www.microsoft.com/en-in/store/top-free/apps/pc">Here is a good list of free apps<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a> that users most often install from the Windows Store. It's worth checking out.</p>
<p>Consider this list as inspiration for your search. I will show a specific example using Notepad++ later in this article.</p>
<p><strong>LOLBIN</strong></p>
<p>In the case of LOLBIN, the situation is slightly different. By LOLBIN, I mean applications built into Windows, usually located in the <code class="MDRenderer_code___eFJE">%SYSTEM32%</code> folder. Some LOLBINs do not have their own libraries at all, they only use the default system libraries. In the case of LOLBIN DLLs, sideloading is no longer so certain, as they are usually located in a fixed and documented location, so theoretically they can refer to their libraries using absolute paths, as their location should not be changed.</p>
<p>Despite this, there are still LOLBINs signed by Microsoft that load their libraries using relative paths. You can find them at <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://hijacklibs.net/#vendor:microsoft">hijacklibs.net<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a> by selecting the "sideloading" option in the search bar. People are, of course, constantly discovering new LOLBINs vulnerable to DLL sideloading. How to automate finding new ones is beyond the scope of this article.</p>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/dll-sideloading-for-initial-access#find-the-right-dll-to-backdoor"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Find the right DLL to backdoor</h2>
<p>Our target are custom application DLLs, not default system ones. I write more about why not to use system libraries in the section "OPSEC considerations". But how do you know which one to choose? Which one is really loaded and when – statically or dynamically? Stay with me.</p>
<p><strong>Lazy Method</strong></p>
<p>When we look at the folder with the installed application, we see an EXE file and usually several DLL libraries. Often, even from the names of the DLL files, we can tell which ones are used in which situations. For example, we can guess that <code class="MDRenderer_code___eFJE">7z.dll</code> will be used by <code class="MDRenderer_code___eFJE">7z.exe</code>, etc. There are usually not many DLL libraries in smaller programs. This method is often effective enough, although not very precise.</p>
<p>For example, in the 7Zip program folder, we see only 3 DLL files:</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/2.png" alt="img" style="cursor: pointer;"></p>
<p><strong>Effective Method</strong></p>
<p>To see all loaded DLL libraries, we can use the <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://learn.microsoft.com/en-us/sysinternals/downloads/procmon">Process Monitor<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a> program from the <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://learn.microsoft.com/en-us/sysinternals/">Sysinternals<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a> package.</p>
<blockquote class="MDRenderer_blockquote__JCOCK">
<p><strong>NOTE</strong>: We can do something similar using Process Explorer, but in my opinion Process Monitor has better filtering and better output to our case.</p>
</blockquote>
<p>Process Monitor allows us to filter out all Load Image events for a given process. This way, we can see exactly which DLL libraries are loaded and when exactly this happens. Process Monitor shows both DLLs loaded statically by IAT and dynamically during program execution. Nested DLL files, i.e., those loaded by other DLLs, are also shown, giving us a complete picture of the situation.</p>
<p>Process Monitor does not provide an easy way to distinguish between statically loaded DLLs and dynamically loaded DLLs. But this is not a big problem. First of all, this information is usually not very important. Secondly, if we want to, we can inspect binaries manually using tool like <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://github.com/hasherezade/pe-bear">PE-bear<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a> to figure out what's included in the IAT (static linking).</p>
<p>Below is a list of DLLs loaded by <code class="MDRenderer_code___eFJE">notepad++.exe</code>. Most of them are system DLLs, but there are also a few libraries loaded from the program folder. These are our target.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/3.png" alt="img" style="cursor: pointer;"></p>
<blockquote class="MDRenderer_blockquote__JCOCK">
<p><strong>NOTE</strong>: If DLL Sideloading is to be used for Initial Access, after moving the program to another folder, the above "application" DLLs should be successfully found in the new location with no error.</p>
</blockquote>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/dll-sideloading-for-initial-access#backdoor-the-dll-function"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Backdoor the DLL function</h2>
<p>Let's assume that we have decided to install a backdoor in Notepad++. Analysis of the program using Process Monitor showed that the <code class="MDRenderer_code___eFJE">NppConverter.dll</code> library is loaded dynamically, which is ideal. Our goal is to write our own library with the same name, which will execute our backdoor code and not interrupt the normal operation of the program. In other words, we want to add our proxy DLL between the program and its original DLL.</p>
<p>For this purpose, we will use my tool: <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://github.com/Print3M/DllShimmer">DllShimmer<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a>. You can read about all the parameters on GitHub, but in short DllShimmer parses the original DLL and extracts information about exported functions. Based on this information, DllShimmer creates a boilerplate C++ file (<code class="MDRenderer_code___eFJE">.cpp</code>). The generated file allows you to add your own code to each function exported from the original DLL without disrupting the normal operation of the program. No reverse engineering or instrumentation is required, because DllShimmer does not rely on function signatures.</p>
<p>Using DllShimmer is very easy. Provide the original DLL file and it will generate a new project with all the necessary files:</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="bash" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="bash" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span style="color: rgb(255, 203, 107);">./DllShimmer-linux-amd64</span><span style="color: rgb(195, 232, 141);"> -i</span><span style="color: rgb(195, 232, 141);"> NppConverter.dll</span><span style="color: rgb(195, 232, 141);"> -o</span><span style="color: rgb(195, 232, 141);"> project/</span><span style="color: rgb(195, 232, 141);"> -x</span><span style="color: rgb(137, 221, 255);"> '</span><span style="color: rgb(195, 232, 141);">NppConverter2.dll</span><span style="color: rgb(137, 221, 255);">'</span><span style="color: rgb(195, 232, 141);"> -m</span><span style="color: rgb(195, 232, 141);"> --debug-file</span><span style="color: rgb(137, 221, 255);"> '</span><span style="color: rgb(195, 232, 141);">C:\Users\john\Desktop\npp-dbg.txt</span><span style="color: rgb(137, 221, 255);">'</span></span></code></pre></figure>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/4.png" alt="img" style="cursor: pointer;"></p>
<p>The code we will be editing is located in the <code class="MDRenderer_code___eFJE">NppConverter.dll.cpp</code> file.  Here are two example functions that we can backdoor.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/5.png" alt="img" style="cursor: pointer;"></p>
<p>We also have <code class="MDRenderer_code___eFJE">DllMain</code> at our disposal, which is executed automatically after loading the DLL into memory.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/6.png" alt="img" style="cursor: pointer;"></p>
<p>So which function should we backdoor? I do not recommend backdooring <code class="MDRenderer_code___eFJE">DllMain</code> because <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices">it has a number of limitations<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a> (e.g., it cannot create new threads), which make it very difficult to use for executing shellcode. I write more about <code class="MDRenderer_code___eFJE">DllMain</code> in the “OPSEC considerations" section.</p>
<p>So we want to backdoor some normal exported function used by Notepad++. But which functions are actually used? And when exactly? Fortunately, we don't have to guess. DllShimmer adds a lot of debugging information to the generated <code class="MDRenderer_code___eFJE">.cpp</code> file. All we have to do is compile the generated C++ code, substitute our proxy DLL in the right place, and we get a full dump of the executed functions. We can backdoor each of them.</p>
<p>Compilation is very simple; just run the generated <code class="MDRenderer_code___eFJE">compile.sh</code> file in the project directory.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/7.png" alt="img" style="cursor: pointer;"></p>
<p>Now we change the name of the original DLL (<code class="MDRenderer_code___eFJE">NppConverter.dll</code> -&gt; <code class="MDRenderer_code___eFJE">NppConverter2.dll</code>) according to what we declared when generating the project in DllShimmer. And we put our proxy <code class="MDRenderer_code___eFJE">NppConverter.dll</code> in the same place. Done, we can launch Notepad++. Unfortunately, an unexpected error has occurred.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/8.png" alt="img" style="cursor: pointer;"></p>
<blockquote class="MDRenderer_blockquote__JCOCK">
<p><strong>NOTE</strong>: Most programs don't display such a nice error message as Notepad++. Usually, they just crash with no additional information.</p>
</blockquote>
<p>To debug what exactly is going on, let's take a look at the <code class="MDRenderer_code___eFJE">npp-dbg.txt</code> file created on the desktop. It contains a record of all actions performed on our proxy DLL.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/9.png" alt="img" style="cursor: pointer;">
The proxy DLL has been loaded. The <code class="MDRenderer_code___eFJE">isUnicode</code> function has been called. However, the attempt to load the original <code class="MDRenderer_code___eFJE">NppConverter2.dll</code> has failed. We can see that the original DLL was searched for in the <code class="MDRenderer_code___eFJE">C:\Program Files\Notepad++</code> directory, where it is not located. No wonder the program threw an error. We can quickly fix this by specifying the correct path to the original DLL in the <code class="MDRenderer_code___eFJE">-x</code> parameter of DllShimmer.</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="bash" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="bash" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span style="color: rgb(255, 203, 107);">./DllShimmer-linux-amd64</span><span style="color: rgb(195, 232, 141);"> -i</span><span style="color: rgb(195, 232, 141);"> NppConverter.dll</span><span style="color: rgb(195, 232, 141);"> -o</span><span style="color: rgb(195, 232, 141);"> project/</span><span style="color: rgb(195, 232, 141);"> -x</span><span style="color: rgb(137, 221, 255);"> '</span><span style="color: rgb(195, 232, 141);">.\plugins\NppConverter\NppConverter2.dll</span><span style="color: rgb(137, 221, 255);">'</span><span style="color: rgb(195, 232, 141);"> -m</span><span style="color: rgb(195, 232, 141);"> --debug-file</span><span style="color: rgb(137, 221, 255);"> '</span><span style="color: rgb(195, 232, 141);">C:\Users\john\Desktop\npp-dbg.txt</span><span style="color: rgb(137, 221, 255);">'</span></span></code></pre></figure>
<p>With the new project, we repeat everything again and launch Notepad++.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/10.png" alt="img" style="cursor: pointer;"></p>
<p>Now everything works as it should. Notepad++ launches correctly and is fully functional. In the <code class="MDRenderer_code___eFJE">npp-dbg.txt</code> file, we can see exactly which functions from the original <code class="MDRenderer_code___eFJE">NppConverter.dll</code> are being executed. We can backdoor any of them.</p>
<p><code class="MDRenderer_code___eFJE">getName</code> function looks good. Now let's go back to the previously generated C++ code and add a piece of code that mimics our backdoor. Remember to add the code inside the <code class="MDRenderer_code___eFJE">if</code> condition, which protects us from multiple calls to our backdoor during a single program run.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/11.png" alt="img" style="cursor: pointer;"></p>
<p>Now let's compile the project without debugging information (delete the section marked below from the <code class="MDRenderer_code___eFJE">compile.sh</code> file) and put the proxy DLL back in the same place.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/12.png" alt="img" style="cursor: pointer;"></p>
<p>We start Notepad++ as usual...</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/13.png" alt="img" style="cursor: pointer;"></p>
<p>It works! Notepad++ launches correctly, and a calculator also pops up, which means our backdoor worked. In a real Initial Access scenario, we should place code there that quickly establishes some kind of persistence or migrates to another process, because Notepad++ can be quickly closed by the user. Our backdoor is a standard C++ function, so all malware development techniques can be used here.</p>
<p>Let's see that the Export Address Table (EAT) of our proxy DLL is exactly the same as the EAT of the original DLL, i.e., they export exactly the same functions. There are no unnecessarily forwarded functions.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/14.png" alt="img" style="cursor: pointer;"></p>
<p>Additionally, the IAT proxy DLL does not contain any suspicious records indicating that it is only a proxy. Everything looks completely normal.</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/dll-sideloading-for-initial-access/15.png" alt="img" style="cursor: pointer;"></p>
<p>DllShimmer is not capable of backdooring every DLL in the world. I haven't come across one yet that I haven't been able to backdoor on a modern system, but it's worth reading about <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://github.com/Print3M/DllShimmer?tab=readme-ov-file#limitations">Limitations<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a> of this tool.</p>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/dll-sideloading-for-initial-access#payload-delivery"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Payload Delivery</h2>
<p>Payload delivery is no different from standard malware delivery.  There is nothing innovative here. Create a folder with subfolders, add some harmless PDF files here and there, put the entire backdoored program in a nested subfolder. Create a LNK to the backdoored software in the main folder. Pack the entire thing into some container (e.g. <code class="MDRenderer_code___eFJE">.zip</code>, <code class="MDRenderer_code___eFJE">.7z</code>, <code class="MDRenderer_code___eFJE">.rar</code>, <code class="MDRenderer_code___eFJE">.iso</code>) and you are good to go!</p>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/dll-sideloading-for-initial-access#opsec-considerations"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>OPSEC considerations</h2>
<p>In real-world redteam operations, it is worth keeping in mind a few OPSEC issues that I have not mentioned before.</p>
<p><strong>Backdooring System vs Application DLL</strong></p>
<p>In my opinion, it is always better to backdoor custom application DLLs. First of all, it is simpler in the case of Initial Access, where the entire program must be sent in a container. We do not have to look for any DLL Hijacking vulnerabilities, we just replace the existing DLL with a proxy. Secondly, it is definitely more stealthy. EDRs do not know application DLLs, they do not know what hashes they have and whether they have been changed. Even if the proxy DLL is not digitally signed, it looks much less suspicious than a well-known modified system library in the application folder.</p>
<p><strong>Backdooring <code class="MDRenderer_code___eFJE">DllMain</code> vs Exported Function</strong></p>
<p>In my opinion, it is always better to backdoor an exported function and additionally protect the backdoor against multiple executions (DLlShimmer does this using a global mutex). As I mentioned above, <code class="MDRenderer_code___eFJE">DllMain</code> has many limitations that hinder malware development. Besides, backdooring an exported function is more stealthy. <code class="MDRenderer_code___eFJE">DllMain</code> can be executed without any problems by any sandbox. This is a standard method of testing malicious DLLs. The situation is different in the case of exported functions whose signature is unknown (custom application DLLs!) and it is not known how they should be run.</p>
<p>Of course, the backdoor should still be equipped with anti-sandbox techniques, because it can simply be executed in the sandbox along with the main EXE file. However, backdooring an exported function provides additional protection against arbitrary attempts to run the DLL itself.</p>
<p><strong>Backdooring LOLBIN vs Signed App vs Unsigned App</strong></p>
<p>Do not backdoor unsigned applications. The whole idea of using DLL Sideloading in Initial Access is to backdoor trusted, i.e., signed applications.</p>
<p>I can't answer the question about LOLBIN or the standard signed application. However, there are a few things to keep in mind when backdooring LOLBIN:</p>
<ul>
<li>It is easy to create a YARA rule that detects the execution of LOLBIN from an unusual location. Microsoft documentation often explicitly specifies the location of the LOLBINs.</li>
<li>The libraries used by LOLBINs are signed by Microsoft, and their signatures are known to EDRs. Modification of such a library may be suspicious.</li>
<li>Simply sending LOLBIN to the victim is suspicious. Default Windows programs are simply pre-installed, not downloaded from the internet.</li>
<li>The list of LOLBINs vulnerable to DLL sideloading is known (<a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://hijacklibs.net/">hijacklibs.net<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a>) and potentially monitored.</li>
</ul>
<p>LOLBs are definitely the most trusted, after all, they were written by Microsoft itself. But that's why they are the most closely monitored...</p>
<p><strong>No parameters == best execution</strong></p>
<p>The most stealthy way to run an application with DLL sideloading is when we don't have to provide any parameters. This means that we can create a completely normal LNK file leading to a completely legitimate signed EXE file, without any parameters. The simpler the LNK, the better.</p>
<p>Of course, this is not always possible. Often, we want to display a decoy after launching our payload. However, it is worth considering a scenario that justifies running the program without a decoy as a “controlled error." For example, in the example described above, an empty Notepad++ will launch. The victim will probably report to us that “something is not working" or that “the file is empty." We will then politely apologize and send them the correct PDF, and in the meantime, our implant will have been launched. Creativity is required.</p>
<p><strong>Proxy DLL signing</strong></p>
<p>Here, the same rules apply as for classic malware. You can sign a DLL to lower its detection rate. It is not necessary, but it can sometimes help.</p>
<p>Expired certificate: Certificates sometimes leak, and although they are immediately invalidated by the company, they can still be used to increase the credibility of malware. Statistics of stolen certs: <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://certcentral.org/dashboard">https://certcentral.org/dashboard<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a></p>
<p>Self-signed certificate: Nothing special but signing the executable file almost always lowers detection rate, so it is always worth doing.</p>
<p><strong>Proxy DLL metadata</strong></p>
<p>Keep in mind the metadata produced during compilation of the proxy DLL. These are general rules for all malware development, so I won't go into detail here.</p>
<p>Things to keep in mind:</p>
<ul>
<li>linker paths</li>
<li>compilation paths</li>
<li>compilation timestamp</li>
<li>compilation toolchain</li>
<li>file properties</li>
</ul>
<p>Ideally, all these values should be identical to those in the original DLL.</p></div></div></main></div><div data-portal="true"><div><div class="m_f11b401e mantine-Drawer-root" style="--mb-z-index: 200;"></div></div></div><next-route-announcer style="position: absolute;"><div aria-live="assertive" id="__next-route-announcer__" role="alert" style="position: absolute; border: 0px; height: 1px; margin: -1px; padding: 0px; width: 1px; clip: rect(0px, 0px, 0px, 0px); overflow: hidden; white-space: nowrap; overflow-wrap: normal;"></div></next-route-announcer></body></html>