Title:
UDRL, SleepMask, and BeaconGate

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post explains how Cobalt Strike Beacon’s User-Defined Reflective Loader (UDRL), custom Sleep Masks, and BeaconGate relate and how they can be combined for evasion.  
- It details how Beacon’s reflective DLL loader works (PE mapping, imports, relocations, entrypoint execution) and how UDRL lets developers replace the default loader to control allocation, header/PE stomping, and other in-memory artifacts beyond Malleable C2 options.  
- It highlights a key pitfall: using a UDRL bypasses `stage` profile settings, which can break the default Sleep Mask’s assumptions (e.g., `stage.userwx` vs section-specific protections), and shows how to pass allocation metadata to Sleep Mask via Beacon User Data (BUD).  
- The post covers supplying custom syscall resolution data (direct/indirect) to Beacon via BUD, enabling alternative syscall-gating approaches (Hell’s Gate/Halo’s Gate/etc.) instead of the default resolver.  
- BeaconGate is described as an API-proxy mechanism that routes selected WinAPI calls through the Sleep Mask so it can mask/unmask Beacon memory and add evasion like call stack spoofing, optionally performing syscalls using the custom syscall info.  
- It’s most useful for red team tool developers and operators building custom loaders, Sleep Masks, and BOFs who want tighter control over memory artifacts and API telemetry.

Technical Focus:
- Reflective DLL injection / custom PE loader implementation (UDRL)
- Beacon User Data (BUD) structures for passing allocation + syscall metadata
- Sleep Mask memory masking/unmasking and section protection handling
- Direct vs indirect syscalls and custom syscall resolvers (SSN/jump gadgets)
- BeaconGate API call proxying via Sleep Mask + call stack spoofing integration
- BOF syscall helper APIs (e.g., BeaconVirtualAlloc/Protect/OpenProcess)

Use Cases:
- Implement a custom reflective loader to control Beacon’s in-memory layout and artifacts (headers/PE stomping, allocator choice, section protections).
- Provide Sleep Mask accurate allocation/section metadata to safely mask all Beacon regions and custom allocations.
- Swap Beacon’s syscall resolution method to alternative gates/resolvers and feed syscall info to Beacon/Sleep Mask.
- Proxy high-signal APIs (e.g., VirtualAlloc) through BeaconGate to add masking + call stack spoofing around sensitive operations.
- Centralize syscall/call-stack-evasion logic so multiple BOFs can reuse Beacon’s configured execution path.

Keywords:
Cobalt Strike, Beacon, UDRL, ReflectiveLoader, Reflective DLL Injection, PE loader, Malleable C2, stage.userwx, stage.obfuscate, stage.allocator, stage.stomppe, Beacon User Data, DLL_BEACON_USER_DATA, Sleep Mask, BeaconGate, FUNCTION_CALL, call stack spoofing, direct syscalls, indirect syscalls, SysWhispers3, Hell’s Gate, Halo’s Gate, Tartarus’ Gate, NtAllocateVirtualMemory, NtProtectVirtualMemory, BOF, BeaconVirtualAlloc, BeaconGetSyscallInformation