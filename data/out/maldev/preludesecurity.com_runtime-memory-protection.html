# https://www.preludesecurity.com/runtime-memory-protection

<!DOCTYPE html><!-- Last Published: Fri Jan 09 2026 16:45:49 GMT+0000 (Coordinated Universal Time) --><html data-wf-domain="www.preludesecurity.com" data-wf-page="6887d5c2fc79c2367e3d4c72" data-wf-site="686bd4d91556b08defea7e70" lang="en" class="w-mod-js w-mod-ix wf-articulatcf-n7-active wf-argentcf-n6-active wf-articulatcf-i7-active wf-argentcf-n3-active wf-argentcf-i3-active wf-articulatcf-n4-active wf-articulatcf-i2-active wf-articulatcf-i4-active wf-articulatcf-n2-active wf-argentpixelcf-n4-active wf-argentcf-i6-active wf-active"><body><div id="hs-web-interactives-top-push-anchor" class="go3670563033"></div><div data-w-id="d26234b9-5998-7510-3d7d-ad1933dd16b6" data-animation="default" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" role="banner" class="section_mega-nav w-nav"><div class="padding-global"><div class="container-large"><div class="mega-nav is-landing-page"><a href="https://www.preludesecurity.com/" class="mega-nav-logo-link w-nav-brand" aria-label="home"><div class="mega-nav-logo-wrapper"><img loading="lazy" src="https://cdn.prod.website-files.com/686bd4d91556b08defea7e70/686bd4d91556b08defea7e84_logo_dark.svg" alt="Logo" width="300" height="150"></div></a></div></div></div><div class="w-nav-overlay" data-wf-ignore="" id="w-nav-overlay-0"></div></div><section class="section-block stroke-bottom"><div class="padding-global"><div class="w-layout-blockcontainer container-small margin-vertical margin-medium w-container"><h1 class="heading-style-h1 text-size-jumbo text-align-center">Introducing Runtime Memory Protection</h1><h2 class="heading-style-h2 is-subhead text-align-center align-center"><em>A research preview of our user-mode Windows agent that comprehensively catches malicious code execution.</em></h2></div></div><div class="max-width-full"><div class="w-embed"><svg viewBox="0 0 1200 400" width="100%" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
  <g fill="none" stroke-width="1">
    <!-- Animated lines -->
    
    <path d="M0,80 C450,80 750,320 1200,320" stroke="red">
      <animate attributeName="stroke-dashoffset" values="0;-1000" dur="20s" begin="0.5s" repeatCount="indefinite"></animate>
    </path>
    <path d="M0,110 C450,110 750,290 1200,290" stroke="#666" stroke-dasharray="10">
      <animate attributeName="stroke-dashoffset" values="0;-1000" dur="20s" begin="1s" repeatCount="indefinite"></animate>
    </path>
    <path d="M0,140 C450,140 750,260 1200,260" stroke="#666" stroke-dasharray="10">
      <animate attributeName="stroke-dashoffset" values="0;-1000" dur="20s" begin="1.5s" repeatCount="indefinite"></animate>
    </path>
    <path d="M0,170 C450,170 750,230 1200,230" stroke="#666" stroke-dasharray="10">
      <animate attributeName="stroke-dashoffset" values="0;-1000" dur="20s" begin="2s" repeatCount="indefinite"></animate>
    </path>
    <path d="M0,200 C450,200 750,200 1200,200" stroke="#666" stroke-dasharray="10">
      <animate attributeName="stroke-dashoffset" values="0;-1000" dur="20s" repeatCount="indefinite"></animate>
    </path>
    <path d="M0,230 C450,230 750,170 1200,170" stroke="#666" stroke-dasharray="10">
      <animate attributeName="stroke-dashoffset" values="0;-1000" dur="20s" begin="2.5s" repeatCount="indefinite"></animate>
    </path>
    <path d="M0,260 C450,260 750,140 1200,140" stroke="#666" stroke-dasharray="10">
      <animate attributeName="stroke-dashoffset" values="0;-1000" dur="20s" begin="3s" repeatCount="indefinite"></animate>
    </path>
    <path d="M0,290 C450,290 750,110 1200,110" stroke="#666" stroke-dasharray="10">
      <animate attributeName="stroke-dashoffset" values="0;-1000" dur="20s" begin="3.5s" repeatCount="indefinite"></animate>
    </path>
    
    <!-- Radiating rings -->
    <circle cx="600" cy="200" r="6" stroke="red" opacity="0.5">
      <animate attributeName="r" values="6;50" dur="4s" repeatCount="indefinite"></animate>
      <animate attributeName="opacity" values="0.5;0" dur="4s" repeatCount="indefinite"></animate>
    </circle>
    <circle cx="600" cy="200" r="6" stroke="red" opacity="0.5">
      <animate attributeName="r" values="6;50" dur="4s" begin="1.3s" repeatCount="indefinite"></animate>
      <animate attributeName="opacity" values="0.5;0" dur="4s" begin="1.3s" repeatCount="indefinite"></animate>
    </circle>
    <circle cx="600" cy="200" r="6" stroke="red" opacity="0.5">
      <animate attributeName="r" values="6;50" dur="4s" begin="2.6s" repeatCount="indefinite"></animate>
      <animate attributeName="opacity" values="0.5;0" dur="4s" begin="2.6s" repeatCount="indefinite"></animate>
    </circle>
    <!-- Static center node -->
    <circle cx="600" cy="200" r="6" fill="red"></circle>
  </g>
</svg></div></div><div class="padding-global"><div class="w-layout-blockcontainer container-fixed w-container"><div class="rich-style-serif w-richtext"><p>Today, we’re introducing a novel approach to detecting in-memory attacks on endpoints, which is written in Rust and runs exclusively in user mode. It leverages advances in modern edge computing architecture, hardware-level telemetry, and a graph-based understanding of the Windows operating system to catch adversaries the moment that they compromise an endpoint. Rather than endlessly attempting to predict what an adversary <em>might </em>do, trapping adversaries at this universal and unavoidable chokepoint that lies at the center of their operations allows us to focus all of our efforts on what they <strong>must </strong>do, regardless of their sophistication or how much creativity (or AI) they apply to their tactics.</p><p>Our goal is simple: to detect <em>out-of-context execution</em> in a way that remains entirely outside the adversary’s control. Out-of-context execution occurs when an attacker coerces an application to run code paths that were not intended by the original application. This includes in-memory execution techniques such as local and remote injection, exploitation that results in the execution of dynamic code, and fileless malware</p><h2 class="heading-style-h2 is-subhead">Why Out-Of-Context Execution?</h2><p>The approaches for detecting file-based threats—file reputation, static and machine learning-based signatures, and sandbox detonation—had the intended effect of deterring adversaries from writing malware to the filesystem and are still employed today by antivirus (AV), which has become ubiquitous, and Endpoint Detection and Response (EDR). Adversaries, always incentivized to continue innovating, moved their tradecraft to focus on remaining entirely in-memory. This is validated and outlined most concretely by the fact that roughly <a href="https://go.crowdstrike.com/rs/281-OBQ-266/images/CrowdStrikeGlobalThreatReport2025.pdf" target="_blank">75%</a> of advanced cyberattacks are exclusively in-memory, never dropping a file to disk.&nbsp;</p><p>While the AV-led approach of scanning evolved to include opportunistic memory scanning, so too did adversaries who learned that even trivial modifications could subvert these defenses. EDR’s behavioral prediction methodology was the next iteration: if we can’t predict what the malware will look like, maybe we can detect it by observing its side effects. This gave rise to the modern Security Operations Center (SOC), which is focused exclusively on cataloging, categorically detecting, and responding to all possible adversary tradecraft. Where EDR and detection engineers would establish deterrence around a technique, such as extracting credentials from the Local Security Authority, a new permutation would emerge, creating a never-ending game of cat and mouse between offense and defense.&nbsp;</p><p>Amidst this complexity, there is a simple, universal truth. While initial access techniques are endless and post-compromise actions vary, nearly all advanced cyberattacks share one critical step: <strong>the execution of code on an endpoint</strong>. It doesn't matter how sophisticated the adversary, their goals, or their toolkit; to control a system, they <strong>must</strong> execute code at the CPU level. Whether this is in the form of in-memory code injection or simply loading code from an executable file from disk, adversary-supplied or adversary-influenced code must run at some point. We believe that <strong>the only code that should run on your computer is yours</strong>.&nbsp;</p><p>Where legacy AV and EDR established disk- and artifact-level deterrence, making it untenable for adversaries to operate there, we want to do the same for memory.&nbsp;</p><h2 class="heading-style-h2 is-subhead">Why It’s So Hard To Catch Malicious Code Execution</h2><p>If the chokepoint for malicious code is so obvious, why do current-generation security platforms consistently fail to stop it? The answer isn’t a lack of effort, but a foundational flaw—an architectural decision made a decade ago that has reached its breaking point.</p><p>The core of every EDR is a synchronous, kernel-level architecture. The original logic was sound: to see everything, you must sit inline with the operating system’s most critical functions. However, this design creates an inescapable performance bottleneck. Because the EDR's logic executes in real-time for every file, registry, or network operation it monitors, it imposes a microscopic "tax" on each one. On today's processors executing billions of operations per second, this accumulated tax threatens to degrade system performance and, in the worst case, grind the entire system to a halt.</p><p>This reality forces EDR developers into a constant, unwinnable trade-off between security coverage and system stability. To ensure the system remains usable, they must prioritize performance. In practice, this means they cannot afford to run complex, context-aware analytics in the critical, blocking path. Instead, they fall back on a familiar model: using simple events like thread or file creation as triggers for an opportunistic and out-of-band memory scan. This approach is a direct regression to the classic antivirus model, and it suffers from the exact same detection gaps.</p><p>Adversaries are acutely aware of this architectural weakness and exploit it. For rapid "smash-and-grab" attacks, they execute malicious code and release the memory before the EDR's slow, out-of-band scan can even be triggered - an unwinnable race condition. For attacks that need to persist, they simply encrypt or obfuscate their components during periods of inactivity, rendering them invisible to these periodic, surface-level scans. The very design meant to provide total visibility has become a fundamental limitation, as the speed and stealth of modern, in-memory attacks are specifically engineered to thrive in the blind spots created by an architecture that is, by its very nature, always a step behind.</p><p>This performance ceiling becomes an absolute barrier when considering the ultimate source of execution data: hardware-level telemetry from sources like <a href="https://edc.intel.com/content/www/us/en/design/products/platforms/processor-and-core-i3-n-series-datasheet-volume-1-of-2/002/" target="_blank">Intel Processor Trace (IPT)</a>, Last Branch Record (LBR), and Context Switches. This data stream offers the most definitive ground truth for detecting threats, but its volume is orders of magnitude greater than the OS-level events an EDR monitors today. If the synchronous model already struggles with the computational cost of analyzing its current telemetry while balancing performance, the prospect of processing a constant firehose of hardware data inline is simply infeasible. No matter how powerful the endpoint hardware becomes, the synchronous architecture cannot scale to meet this demand.</p></div></div><div class="w-layout-blockcontainer container-fixed is-highlight padding-bottom w-container"><h2 class="heading-style-h2 is-subhead"><em>Our Approach</em></h2><div class="rich-style-serif w-richtext"><p>Robustly detecting the execution of all code on the system requires a complete restructuring of how we approach detection and the architecture necessary to achieve this. Instead of traditional content-centric strategies, such as memory scanning using signatures or rules-based behavioral detection, we rely on rich hardware-assisted and operating system telemetry to track every thread’s execution across the entire OS. Rather than probing memory only when a specific trigger (such as cross‑process injection) fires, we continuously model all memory allocations and the full-system context around every thread executing on the CPU to evaluate what legitimate control flow should look like. The extremely high event volume, around 700 million events per day per endpoint, eliminates the possibility of using the traditional cloud-hosted data lake approach favored by EDR and instead requires that we leverage advances in modern hardware to process events at the edge while maintaining low resource utilization (&lt;2% CPU in our testing). All of this together allows us to decide in real-time whether a code path belongs on the system at all.</p><p>Instead of accepting the legacy tradeoffs, we started fresh. <strong>We chose to build our agent to operate entirely in user mode</strong>. Many will point out that this is safer, and it is. Running in user mode means we don't risk a catastrophic system crash (i.e., a Blue Screen of Death, or BSOD) if our agent has a problem, a constant risk associated with kernel-mode drivers. But safety was only part of our decision. The most powerful advantage of operating in user mode, however, is <strong>asynchronicity</strong>. By giving up the ability to be "inline" and handling telemetry out of band, we gained the ability to scale. We can tap into streams that require no blocking or inline hooking, preserving performance without compromising data quality, which will only improve with the expansion of the <a href="https://blogs.windows.com/windowsexperience/2025/06/26/the-windows-resiliency-initiative-building-resilience-for-a-future-ready-enterprise/" target="_blank">Windows Resiliency Initiative</a>.</p><p>Asynchronous telemetry sources, such as Event Tracing for Windows (ETW), are the only legitimate interfaces for receiving high-volume streams of hardware-backed execution telemetry. Even though we operate only in user mode, we can gain comprehensive visibility into these extremely granular OS operations, providing insight into the necessary activities to detect malicious code execution more comprehensively. We chose to trade the rarely-used capability of inline blocking for the essential promise of comprehensive detection. </p></div></div><div class="w-layout-blockcontainer table-container w-container"><h2 class="heading-style-h2 is-subhead"><em>Endpoints Are Now Powerful Enough To Watch Themselves</em></h2><img src="https://cdn.prod.website-files.com/686bd4d91556b08defea7e70/68880d527127f141b894bb9b_CPU_Chart_fully_transparent%20(2).svg" loading="lazy" alt="A chart of rising compute abilities from 2011 to the present day." class="max-width-full" width="300" height="150"></div><div class="w-layout-blockcontainer container-fixed is-highlight padding-bottom background-color-overlay w-container"><div class="context"><div class="rich-style-small w-richtext"><h2 class="heading-style-h2 is-subhead"><em>Here’s How It Works:</em></h2><p><strong>Anchoring on Ground Truth: </strong>We start with the CPU—specifically its instruction pointer (i.e., RIP on x64 systems)—because every instruction that gets executed must pass through it. The CPU determines the execution flow of all software, making it a key vantage point for understanding and controlling program behavior. We leverage modern hardware-level telemetry, such as Intel Processor Trace (IPT) and Last Branch Record (LBR) tracing, to obtain a complete, ordered record of execution. This isn’t a guess or a behavioral pattern; it is the ground truth of what is running on the endpoint. Additionally, we can inspect context switches, allowing us insight from the first time (or last time) a thread was scheduled on a processor, until it leaves the processor in a manner entirely outside the adversary’s control.</p><p><strong>Establishing Full-System Execution Context: </strong>This firehose of OS-provided and hardware-based telemetry allows us to reconstruct the entire program flow with end-to-end provenance. The sheer volume of this data stream makes a traditional cloud-hosted data lake approach impractical for the real-time analysis we require, so our architecture is instead built to handle this entirely at the edge. By leveraging advances in modern hardware, our agent processes this stream of events on the endpoint itself, providing us with an immense amount of context that allows us to attribute every instruction to a thread, process, and user, establishing a clear identity for every piece of executing code, all while maintaining low resource utilization (&lt;2% CPU in our testing).</p><p><strong>Enforcing Legitimate Execution:</strong> With this visibility, we can perform many actions. With our research preview product, we have decided to start with a simple assertion: Private memory should be executed in predictable ways. Any time the CPU’s instruction pointer jumps from legitimate, image-backed code into a region of private, executable memory, this provides the signal to investigate further. However, research taking this even further, up to and including reconstructing common and legitimate code paths determined by our hardware-backed telemetry sources and enforcing actions against deviations or other “out-of-context” execution that deviates from baseline code paths, is already underway.</p><p><strong>Queryless Search for Signal Extraction: </strong>A lone signal, however, isn’t enough to distinguish a genuine threat from a false positive. To do that, we need deeper system-wide context. At the foundation of our approach is a database that tracks the lifecycle of every OS object—from processes and threads to network connections and registry keys. Its schema maps all relationships between objects, creating a high-fidelity digital twin of system state at any moment. When one of our assertions is violated, we capture a snapshot of the relevant subgraph and send it to our platform for analysis. Because the data is structured as a graph, we can render it as an interactive map—no queries needed—revealing complex relationships at a glance and allowing us to replay the exact timeline of events.</p></div></div></div><div class="w-layout-blockcontainer container-fixed w-container"><div class="rich-style-serif w-richtext"><p>This research is still in its early stages and has limitations. We are working with early design partners to defend critical infrastructure, ensuring stability, accuracy, and usability in complex, heterogeneous enterprise environments. In particular, we believe a novel approach to false positive reduction built upon the fact that false positives themselves are useful signals, which is quite different from the traditional “rules-based” approach, is needed to scale memory protection to organizations of all shapes and sizes. If you’re interested in testing out this research preview, please get in touch with us <a href="mailto:research@preludesecurity.com?subject=Runtime%20memory%20protection">here</a>.</p></div></div><div class="w-layout-blockcontainer container-medium w-container"><h2 class="heading-style-h2 text-align-center max-width-large align-center text-size-regular">Explore the full technical breakdown in our runtime memory protection whitepaper</h2><div class="button-group margin-top margin-medium"><a href="https://info.preludesecurity.com/hubfs/Content/Closing%20the%20Execution%20Gap.pdf" target="_blank" class="button align-center w-button">Download the whitepaper</a></div></div></div></section><section class="section_footer padding-section-small padding-top"><div class="padding-global"><div class="container-large"><div class="w-layout-grid grid_wrapper"><div id="w-node-b4806781-1727-7ab7-d419-e696f54f6684-fe15b78e" class="w-layout-vflex vertical-flex_left space-between"><div class="w-layout-vflex vertical-flex_left gap-0"><div class="text-size-jumbo text-style-serif">Know with <span class="text-style-italic text-color-emerald">certainty</span>.</div><div>Join the prelude community:</div><div class="horizontal-flex_center margin-vertical margin-small"><a href="https://www.linkedin.com/company/preludesecurity/" target="_blank" class="w-inline-block"><div class="icon-1x1-small w-embed"><svg viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" id="Linkedin-Logo--Streamline-Radix">
  <desc>
    Linkedin Logo Streamline Icon: https://streamlinehq.com
  </desc>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M2 1c-0.55228 0 -1 0.44772 -1 1v11c0 0.5523 0.44772 1 1 1h11c0.5523 0 1 -0.4477 1 -1V2c0 -0.55228 -0.4477 -1 -1 -1H2Zm1.05 5h1.9v6h-1.9V6Zm2.025 -1.995c0 0.59371 -0.48129 1.075 -1.075 1.075 -0.5937 0 -1.075 -0.48129 -1.075 -1.075S3.4063 2.93 4 2.93c0.59371 0 1.075 0.48129 1.075 1.075ZM12 8.35713c0 -1.80505 -1.1666 -2.5068 -2.32551 -2.5068 -0.37947 -0.0187 -0.75728 0.06086 -1.09575 0.23074 -0.25702 0.129 -0.52609 0.42416 -0.73358 0.93746h-0.05337V6.00044H6v6.00426h1.90616V8.8112c-0.02756 -0.32707 0.07711 -0.74978 0.29125 -1.00133 0.21415 -0.25155 0.52048 -0.31162 0.75274 -0.34213h0.07243c0.60616 0 1.05602 0.37527 1.05602 1.32094v3.21602h1.9061L12 8.35713Z" fill="currentColor" stroke-width="1"></path>
</svg></div></a><a href="https://x.com/preludeorg" target="_blank" class="w-inline-block"><div class="icon-1x1-small w-embed"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" id="X-Twitter-Logo--Streamline-Logos-Block">
  <desc>
    X Twitter Logo Streamline Icon: https://streamlinehq.com
  </desc>
  <path fill="currentColor" fill-rule="evenodd" d="M5 1C2.79086 1 1 2.79086 1 5v14c0 2.2091 1.79086 4 4 4h14c2.2091 0 4 -1.7909 4 -4V5c0 -2.20914 -1.7909 -4 -4 -4H5Zm-0.33429 3.5c-0.17536 0.06527 -0.32332 0.19509 -0.40968 0.3683 -0.12689 0.2545 -0.09892 0.55889 0.07223 0.78601l5.61418 7.45029 -5.91591 6.344c-0.01551 0.0167 -0.03011 0.0338 -0.04382 0.0514h2.04691l4.82948 -5.179 3.7133 4.9278c0.0871 0.1155 0.2043 0.2018 0.3364 0.2512h4.4223c0.1748 -0.0654 0.3224 -0.195 0.4085 -0.3679 0.1269 -0.2545 0.099 -0.5589 -0.0722 -0.786l-5.6142 -7.4503L20.0173 4.5h-2.051l-4.8298 5.17932 -3.7133 -4.92774c-0.08729 -0.11583 -0.20496 -0.20227 -0.3375 -0.25158H4.66571ZM15.5454 18.0475 6.4315 5.95294h2.01878L17.5642 18.0475h-2.0188Z" clip-rule="evenodd" stroke-width="1"></path>
</svg></div></a><a href="mailto:marketing@preludesecurity?subject=Subscribe" class="w-inline-block"><div class="icon-1x1-small w-embed"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" id="Google-Mail-Logo--Streamline-Logos-Block">
  <desc>
    Google Mail Logo Streamline Icon: https://streamlinehq.com
  </desc>
  <path fill="currentColor" fill-rule="evenodd" d="M5 1a4 4 0 0 0 -4 4v14a4 4 0 0 0 4 4h14a4 4 0 0 0 4 -4V5a4 4 0 0 0 -4 -4H5Zm-0.5 7.25c0 -0.941 0.763 -1.705 1.705 -1.705h0.533c0.352 0 0.695 0.11 0.983 0.312l0.87 0.615v5.122L4.5 9.571V8.25Zm5.114 5.1V8.194L12 9.878l2.386 -1.684v5.156L12 15.114 9.614 13.35Zm5.795 4.104v-3.588l4.091 -3.024v6.612h-4.09Zm0 -4.86V7.472l0.87 -0.615c0.288 -0.203 0.631 -0.312 0.983 -0.312h0.534c0.94 0 1.704 0.764 1.704 1.705v1.32l-4.09 3.024Zm-6.818 4.86v-3.588L4.5 10.842v6.612h4.09Z" clip-rule="evenodd" stroke-width="1"></path>
</svg></div></a></div></div><img src="https://cdn.prod.website-files.com/686bd4d91556b08defea7e70/686bd4d91556b08defea8021_aicpa-soc-logo-freelogovectors.net_-PNG.png" loading="lazy" alt="AICPA SOC 2 certification" class="icon-1x1-jumbo"></div><div class="w-layout-grid grid_wrapper footer-column"><div class="footer-links_column"><div class="text-size-large text-style-serif">Platform</div><div class="w-layout-vflex vertical-flex_left"><a href="https://www.preludesecurity.com/platform/security-control-monitoring" class="footer-link">Monitor</a><a href="https://www.preludesecurity.com/platform/endpoint-security" class="footer-link">Defend</a><a href="https://www.preludesecurity.com/platform/integrations" class="footer-link">Integrations</a><a href="https://www.preludesecurity.com/pricing" class="footer-link">Pricing</a><a href="https://www.preludesecurity.com/platform/updates" class="footer-link">Changelog</a><a href="mailto:support@preludesecurity.com?subject=Prelude%20Support%20Request" class="footer-link">Support</a></div></div><div class="footer-links_column"><div class="text-style-serif text-size-large">Learn</div><div class="w-layout-vflex vertical-flex_left"><a href="https://www.preludesecurity.com/learn" class="footer-link">Blog</a><a href="https://www.preludesecurity.com/platform/endpoint-security" class="footer-link">Research</a><a href="https://www.preludesecurity.com/learn#case-studies" class="footer-link">Case studies</a><a href="https://www.preludesecurity.com/learn#featured" class="footer-link">Guides and videos</a></div></div><div id="w-node-_41b34cfd-7e8b-3957-be3a-7e06c4b50c4f-fe15b78e" class="footer-links_column"><div class="text-style-serif text-size-large">Company</div><div class="w-layout-vflex vertical-flex_left"><a href="https://www.preludesecurity.com/company/vision" class="footer-link">Vision</a><a href="https://www.preludesecurity.com/company/careers" class="footer-link">Careers</a><a href="https://www.preludesecurity.com/company/press" class="footer-link">Press</a></div></div></div></div><div class="w-layout-grid footer-grid_legal stroke-top"><div id="w-node-b4806781-1727-7ab7-d419-e696f54f66b7-fe15b78e" class="horizontal-flex_center gap-2"><p class="text-size-small margin-0 text-style-muted">©2025 Prelude Research,&nbsp;Inc. All rights reserved. Prelude, its logo and other trademarks are trademarks of Prelude Research, Inc. and may not be used without permission.</p></div><div id="w-node-_5fe49b44-1b13-6fd2-71cb-ec58b177dfa7-fe15b78e" class="horizontal-flex_center gap-2"><a href="https://www.preludesecurity.com/legal/privacy" class="footer-link_legal">Privacy</a><a href="https://www.preludesecurity.com/legal/detect-scm-service-terms" class="footer-link_legal">Terms</a><a href="https://www.preludesecurity.com/legal/sub-processor-list" class="footer-link_legal">Sub-processors</a></div></div></div></div></section><!-- Google Tag Manager (noscript) -->

<!-- End Google Tag Manager (noscript) -->
<!--
<script>
  var block_to_insert ;
  var container_block ;

  block_to_insert = document.createElement( 'div' );
  block_to_insert.className = "pulsating-circle";

  container_block = document.getElementById( 'crowdstrike' );
  container_block.appendChild( block_to_insert );
</script>
-->
<!--Banner Cookie-->


<div class="go2933276541 go2369186930" id="hs-web-interactives-top-anchor"><div id="hs-interactives-modal-overlay" class="go1632949049"></div></div>
<div class="go2933276541 go1348078617" id="hs-web-interactives-bottom-anchor"></div>
<div id="hs-web-interactives-floating-container">
  <div id="hs-web-interactives-floating-top-left-anchor" class="go2417249464 go613305155">
  </div>
  <div id="hs-web-interactives-floating-top-right-anchor" class="go2417249464 go471583506">
  </div>
  <div id="hs-web-interactives-floating-bottom-left-anchor" class="go2417249464 go3921366393">
  </div>
  <div id="hs-web-interactives-floating-bottom-right-anchor" class="go2417249464 go3967842156">
  </div>
</div>
</body></html>