Title:
Shellcode – Pt 1: Finding Module (DLL) Address

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post explains how position-independent shellcode can locate loaded module base addresses at runtime on Windows without relying on imported APIs.  
- It focuses on walking the Process Environment Block (PEB) via the Thread Environment Block (TEB) to reach the loader data (PEB->Ldr) and enumerate module lists.  
- The author describes the relevant structures (_PEB, _PEB_LDR_DATA, _LDR_DATA_TABLE_ENTRY) and the three module list orderings (load, memory, initialization).  
- It highlights common assumptions about default module load order (ntdll, then kernel32/kernelbase) and shows how to retrieve kernel32’s DllBase.  
- Example implementations are provided in NASM (using GS/FS segment access and offsets) and in C (iterating LIST_ENTRY and comparing BaseDllName).  
- Useful for shellcode authors, red teamers, and malware developers building PIC loaders or custom API resolution routines.

Technical Focus:
- Position Independent Code (PIC) constraints for shellcode
- TEB/PEB access via segment registers (GS:0x30, FS:0x30) and offsets
- PEB loader traversal (PEB->Ldr and module linked lists)
- LIST_ENTRY mechanics and LDR_DATA_TABLE_ENTRY parsing (DllBase, BaseDllName)
- Module enumeration strategies (order-based vs name-compare loop)
- WinDbg structure inspection (!peb, dt)

Use Cases:
- Resolve kernel32/ntdll base addresses from shellcode without imports
- Build custom GetProcAddress-style API resolvers starting from module bases
- Implement stealthy loaders that avoid static IAT references
- Debug/validate loader-walking logic using WinDbg and documented offsets

Keywords:
shellcode, position-independent code, PIC, Windows internals, TEB, PEB, PEB_LDR_DATA, LDR_DATA_TABLE_ENTRY, LIST_ENTRY, InLoadOrderModuleList, InMemoryOrderModuleList, DllBase, BaseDllName, GS segment, FS segment, __readgsqword, NtCurrentTeb, WinDbg, kernel32.dll, kernelbase.dll, ntdll.dll