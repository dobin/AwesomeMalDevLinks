Title:
Call Stacks: No More Free Passes For Malware

Type:
Blog Post

Short Summary (4–8 sentences max):
- This article explains why user-mode call stacks are high-value Windows endpoint telemetry for distinguishing *who* initiated sensitive actions, not just *what* happened.  
- It details how most “call stacks” collected in practice are approximate return-address stacks derived via stack walking, and how malware exploits this ambiguity (tail calls, trampolines, stack desync/ROP-like artifacts) to spoof provenance and evade detections.  
- Elastic describes how it enriches stack frames (module+offset, exported function names, optional public symbols) and why the “final user module” in a syscall-related stack is a key pivot for baselining and triage (hash, signature, memory protection/provenance).  
- The post provides a practical glossary of important NTDLL dispatcher/entrypoint frames (e.g., LdrInitializeThunk, KiUserExceptionDispatcher, KiUserApcDispatcher, KiUserCallbackDispatcher) and what their presence implies about execution context and abuse opportunities.  
- It also outlines behavioral tags/heuristics (direct syscall, proxy call, shellcode, RWX/unbacked, truncated stack, ROP indicators) and shows how call-stack spoofing research (e.g., SilentMoonwalk) can introduce detectable inconsistencies.  
- Useful primarily for Blue Teams/EDR engineers and threat hunters, but also valuable to red teamers for understanding which stack-manipulation tradecraft creates new detection surfaces.

Technical Focus:
- x64 stack walking vs hardware-assisted tracing (Intel LBR/BTS/AET/IPT)
- Call stack enrichment (module offsets, PE exports, public symbols)
- Syscall/Win32/Native API layering and expected ETW stack structure
- Call stack spoofing & evasion (tail calls, trampolines, stack desync gadgets, ROP-like artifacts)
- Detection pivots: “final user module”, memory protection/provenance, unbacked/RWX regions
- Windows user-mode dispatchers/callback mechanisms (APC, SEH, KernelCallbackTable)

Use Cases:
- Build higher-fidelity detections for injection, shellcode, and memory-protection manipulation (e.g., VirtualProtect/NtProtectVirtualMemory)
- Triage alerts by attributing sensitive API/syscall activity to the originating user module (hash/signature/path)
- Hunt for proxy execution patterns (timer callbacks, APC delivery, exception-driven protection fluctuation)
- Detect call stack spoofing attempts via anomalies (missing/shifted frames, ROP indicators, truncated stacks, discrepant reconstructions)
- Improve baselining of dual-use behaviors by adding provenance context to ETW-monitored syscalls

Keywords:
Windows x64, call stacks, stack walking, return address spoofing, ETW, kernel ETW, NTDLL, syscalls, Native API, Win32 API, NtProtectVirtualMemory, VirtualProtect, LdrInitializeThunk, RtlUserThreadStart, BaseThreadInitThunk, KiUserApcDispatcher, KiUserExceptionDispatcher, KiUserCallbackDispatcher, KernelCallbackTable, tail call optimization, ROP, RWX, unbacked memory, code injection, SilentMoonwalk, proxy_call, direct_syscall