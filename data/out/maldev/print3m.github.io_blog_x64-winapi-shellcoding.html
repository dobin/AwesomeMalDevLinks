# https://print3m.github.io/blog/x64-winapi-shellcoding

<!DOCTYPE html><html lang="en" data-mantine-color-scheme="dark"><body style="background-color: rgb(36, 36, 36);"><div class="m_89ab340 mantine-AppShell-root" style="--app-shell-transition-duration: 200ms; --app-shell-transition-timing-function: ease; background: var(--mantine-color-dark-7;" data-resizing="true"><main class="m_8983817 mantine-AppShell-main" style="padding-top: calc(calc(3.75rem * var(--mantine-scale)) + var(--mantine-spacing-md));"><div class="" style="margin-inline: auto; padding-top: calc(2.8125rem * var(--mantine-scale)); max-width: calc(43.75rem * var(--mantine-scale));"><a class="mantine-focus-auto mantine-active m_77c9d27d mantine-Button-root m_87cf2631 mantine-UnstyledButton-root" data-variant="subtle" data-with-left-section="true" href="https://print3m.github.io/" style="--button-bg: transparent; --button-hover: var(--mantine-color-blue-light-hover); --button-color: var(--mantine-color-blue-light-color); --button-bd: calc(0.0625rem * var(--mantine-scale)) solid transparent;"><span class="m_80f1301b mantine-Button-inner"><span class="m_a74036a mantine-Button-section" data-position="left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-arrow-back-up"><path d="M9 14l-4 -4l4 -4"></path><path d="M5 10h11a4 4 0 1 1 0 8h-1"></path></svg></span><span class="m_811560b9 mantine-Button-label">All posts</span></span></a><div class="" style="height: var(--mantine-spacing-md); min-height: var(--mantine-spacing-md);"></div><h1 class="m_8a5d1357 mantine-Title-root" data-order="1" style="--title-fw: var(--mantine-h1-font-weight); --title-lh: var(--mantine-h1-line-height); --title-fz: var(--mantine-h1-font-size);">[Shellcode x64] Find and execute WinAPI functions with Assembly</h1><div class="" style="padding-top: calc(0.375rem * var(--mantine-scale)); font-size: var(--mantine-font-size-md);">Created at: 2024-07-26</div><div class="m_d6493fad mantine-TypographyStylesProvider-root" style="padding-top: var(--mantine-spacing-xl); text-align: justify;"><p>TLDR: <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://github.com/Print3M/shellcodes/blob/main/calc-exe.asm">NASM source code here (well documented, easy to read).<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a></p>
<p>What you will learn:</p>
<ul>
<li>WinAPI function manual location with Assembly</li>
<li>PEB Structure and PEB_LDR_DATA</li>
<li>PE File Structure</li>
<li>Relative Virtual Address calculation</li>
<li>Export Address Table (EAT)</li>
<li>Windows x64 calling-convention in practice</li>
<li>Writing in Assembly like a real Giga-Chad...</li>
</ul>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/x64-winapi-shellcoding#what-limitations-does-shellcode-have"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>What limitations does shellcode have?</h2>
<p>Shellcode must be position independent. It must not assume any fixed addresses. Therefore, shellcode does not have access to functions that we normally execute in C with a single line of code. Shellcode must work everywhere without any dependencies!</p>
<p>The above statement leads us to the obvious conclusion that within a shellcode we cannot simply use <code class="MDRenderer_code___eFJE">GetProcAddress()</code> and get the address of any WinAPI function... because we don't know the address of <code class="MDRenderer_code___eFJE">GetProcAddress()</code> function itself.</p>
<p>In this post, we'll look at manually finding the address of the <code class="MDRenderer_code___eFJE">WinExec()</code> function in <code class="MDRenderer_code___eFJE">kernel32.dll</code> and executing the <code class="MDRenderer_code___eFJE">calc.exe</code> program (Windows built-in calculator) to confirm that everything works.</p>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/x64-winapi-shellcoding#overview-how-to-find-a-winapi-function-manually"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Overview: How to find a WinAPI function manually?</h2>
<p>All the basic WinAPI functions can be found in the <code class="MDRenderer_code___eFJE">kernel32.dll</code> file. This module is loaded <strong>automatically into every newly created process memory</strong> in Windows. However, the base address of the <code class="MDRenderer_code___eFJE">kernel32.dll</code> module in memory may be random.</p>
<p>Each process on Windows also contains a <strong>PEB</strong> (Process Environment Block) structure in its memory. <strong>The address of this structure is known and it all starts with it.</strong> This structure contains a lot of information about the process, including data about all loaded modules (including <code class="MDRenderer_code___eFJE">kernel32.dll</code>). There we can find, among other things, the base memory address of the <code class="MDRenderer_code___eFJE">kernel32.dll</code> module.</p>
<p>Then, by reading the structures of the PE file (<code class="MDRenderer_code___eFJE">kernel32.dll</code>), we arrive at the <strong>Export Address Table</strong>, which contains the names and addresses of all the functions exported by the file.</p>
<p><strong>This is how we find the address of the WinAPI function</strong> (<code class="MDRenderer_code___eFJE">WinExec</code>). Then we are ready to execute it based on x64 calling convention and Microsoft's documentation.</p>
<p>That's the process in a nutshell: jumping through memory structures and pointers in search of our function. Let's see what it looks like in details...</p>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/x64-winapi-shellcoding#get-address-peb-structure"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Get address PEB structure</h2>
<p>The first step is to find the address of the PEB structure. <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb">PEB<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a> (<em>Process Environment Block</em>) contains a lot of information about the current process. Key properties of the PEB include:</p>
<ul>
<li><strong>Loaded Modules</strong> (<code class="MDRenderer_code___eFJE">LDR</code> field: we want this!)</li>
<li>Environment Variables</li>
<li>Command-Line Arguments</li>
<li>Other information about the process</li>
</ul>
<p><strong>PEB structure is stored in a user-space of the process</strong>. That means, it can be manually read without any syscalls. <strong>For x64 architecture the PEB address is stored in the <code class="MDRenderer_code___eFJE">gs</code> register + 0x60 offset</strong>. The <code class="MDRenderer_code___eFJE">fs</code> and <code class="MDRenderer_code___eFJE">gs</code> segment registers have no specific uses defined by the hardware so they are used in this case by Windows internals to hold important addresses.</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="nasm" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="nasm" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span>mov rbx, gs:[0x60]  ; Get address of PEB struct</span></span></code></pre></figure>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/x64-winapi-shellcoding#get-address-of-peb_ldr_data"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Get address of PEB_LDR_DATA</h2>
<p><a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">PEB_LDR_DATA<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a> (<em>PEB Loader Data</em>) contains information about the loaded modules for the process. We need to access this structure to get an address of the <code class="MDRenderer_code___eFJE">kernel32.dll</code>.</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="c" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="c" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span style="color: rgb(247, 140, 108);">typedef</span><span style="color: rgb(199, 146, 234);"> struct</span><span style="color: rgb(187, 187, 187);"> _PEB </span><span style="color: rgb(137, 221, 255);">{</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  BYTE              </span><span style="color: rgb(238, 255, 255);">Reserved1</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">2</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">  // 2 bytes</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  BYTE              BeingDebugged</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;"> // 1 byte</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  BYTE              </span><span style="color: rgb(238, 255, 255);">Reserved2</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">1</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">  // 1 byte</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  PVOID             </span><span style="color: rgb(238, 255, 255);">Reserved3</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">2</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">  // 16 bytes</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  PPEB_LDR_DATA     Ldr</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">           // &lt;-- We want this</span></span>
<span data-line=""><span style="color: rgb(84, 110, 122); font-style: italic;">  // ...</span></span>
<span data-line=""><span style="color: rgb(137, 221, 255);">}</span></span></code></pre></figure>
<p>There are 20 bytes from the beginning of the PEB structure to the <code class="MDRenderer_code___eFJE">LDR</code> field. However, this is not true! All because of a compilation phenomenon called <strong>data structure alignment</strong>. On 64-bit Windows the alignment of memory structures is typically 16 bytes. It doesn't matter in this case. But what matters is the fact that 64-bit pointers are aligned to a 8-byte boundary. It means, the address of the pointer in memory cannot be different than multiplication of <code class="MDRenderer_code___eFJE">0x8</code>. Let's count bytes before the <code class="MDRenderer_code___eFJE">PVOID Reserved3</code> field: 4 bytes! <code class="MDRenderer_code___eFJE">Reserved4</code> pointer must be alligned with 4 bytes to round up its address to <code class="MDRenderer_code___eFJE">0x8</code> bytes. Read more about <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://en.wikipedia.org/wiki/Data_structure_alignment">data structure alignment<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a>.</p>
<p>This is how the final PEB structure looks like (with padding included):</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="c" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="c" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span style="color: rgb(199, 146, 234);">struct</span><span style="color: rgb(187, 187, 187);"> _PEB </span><span style="color: rgb(137, 221, 255);">{</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  BYTE              </span><span style="color: rgb(238, 255, 255);">Reserved1</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">2</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">  // 2 bytes</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  BYTE              BeingDebugged</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;"> // 1 byte</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  BYTE              </span><span style="color: rgb(238, 255, 255);">Reserved2</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">1</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">  // 1 byte</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  BYTE              </span><span style="color: rgb(238, 255, 255);">Padding</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">4</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">    // 4 bytes</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  PVOID             </span><span style="color: rgb(238, 255, 255);">Reserved3</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">2</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">  // 16 bytes</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  PPEB_LDR_DATA     Ldr</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">           // &lt;-- We want this</span></span>
<span data-line=""><span style="color: rgb(84, 110, 122); font-style: italic;">  // ...</span></span>
<span data-line=""><span style="color: rgb(137, 221, 255);">};</span></span></code></pre></figure>
<p>Now we can clearly see that we need 24 bytes (<code class="MDRenderer_code___eFJE">0x18</code>) to get the LDR field. We extract the value of the field by dereferencing (square brackets):</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="nasm" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="nasm" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span>mov rbx, [rbx+0x18]  ; Get PEB_LDR_DATA address</span></span></code></pre></figure>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/x64-winapi-shellcoding#get-addresses-of-loaded-modules"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Get addresses of loaded modules</h2>
<p>Now when we have the PEB_LDR_DATA structure we need the address of the <code class="MDRenderer_code___eFJE">InMemoryOrderModuleList</code> field:</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="c" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="c" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span style="color: rgb(199, 146, 234);">struct</span><span style="color: rgb(187, 187, 187);"> _PEB_LDR_DATA </span><span style="color: rgb(137, 221, 255);">{</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  BYTE       </span><span style="color: rgb(238, 255, 255);">Reserved1</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">8</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">              // 8 bytes</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  PVOID      </span><span style="color: rgb(238, 255, 255);">Reserved2</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">3</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">              // 24 bytes</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  LIST_ENTRY InMemoryOrderModuleList</span><span style="color: rgb(137, 221, 255);">;</span></span>
<span data-line=""><span style="color: rgb(137, 221, 255);">};</span></span></code></pre></figure>
<p>Get the address of InMemoryOrderModuleList (32 = 0x20 bytes):</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="nasm" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="nasm" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span>add rbx, 0x20   ; Get address of InMemoryOrderModuleList</span></span></code></pre></figure>
<p><code class="MDRenderer_code___eFJE">LIST_ENTRY</code> is actually the double-linked list. The first field (the one we've just extracted) is the pointer to the next list entry. By dereferencing addresses, we can get to individual items in the list. Go down the double-link list:</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="nasm" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="nasm" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span>mov rbx, [rbx]  ; 1st entry in InMemoryOrderModuleList (ntdll.dll)</span></span>
<span data-line=""><span>mov rbx, [rbx]  ; 2st entry in InMemoryOrderModuleList (kernelbase.dll)</span></span>
<span data-line=""><span>mov rbx, [rbx]  ; 3st entry in InMemoryOrderModuleList (kernel32.dll)</span></span></code></pre></figure>
<p>The third entry is the <code class="MDRenderer_code___eFJE">kernel32.dll</code>. I'm not sure if this is guaranteed, but this is how people have been doing it for centuries. Who am I to question that...</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="c" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="c" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span style="color: rgb(199, 146, 234);">struct</span><span style="color: rgb(187, 187, 187);"> _LDR_DATA_TABLE_ENTRY </span><span style="color: rgb(137, 221, 255);">{</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    ..</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    LIST_ENTRY  InMemoryOrderLinks</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;"> // 16 bytes</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    PVOID       </span><span style="color: rgb(238, 255, 255);">Reserved2</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">2</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">       // 16 bytes</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    PVOID       DllBase</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(187, 187, 187);">            </span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    ...</span></span>
<span data-line=""><span style="color: rgb(137, 221, 255);">};</span></span></code></pre></figure>
<p>As we go down the double-linked list (<code class="MDRenderer_code___eFJE">LIST_ENTRY</code>) we are already at an offset of the beginning of the structure. Now we have to get the <code class="MDRenderer_code___eFJE">DllBase</code> pointer. <strong>DllBase is the address of the DLL in memory!</strong>. The offset is 32 bytes (<code class="MDRenderer_code___eFJE">0x20</code>):</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="nasm" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="nasm" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span>mov r8, [rbx+0x20]   ; Get the kernel32.dll address</span></span></code></pre></figure>
<p>Now we have <code class="MDRenderer_code___eFJE">kernel32.dll</code> base address.</p>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/x64-winapi-shellcoding#get-the-address-of-exporttable-kernel32dll"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Get the address of ExportTable (kernel32.dll)</h2>
<p>We need to get to the <code class="MDRenderer_code___eFJE">ExportTable</code> of the <code class="MDRenderer_code___eFJE">kernel32.dll</code> module to get information about the WinAPI functions it exports.</p>
<p>PE file structure (simplified):</p>
<ol>
<li>IMAGE_DOS_HEADER  (we need to get <code class="MDRenderer_code___eFJE">e_lfanew</code> RVA)</li>
<li>DOS Stub (skip this)</li>
<li>PE Headers (<code class="MDRenderer_code___eFJE">kernel32.dll</code> base addr + <code class="MDRenderer_code___eFJE">e_lfanew</code> RVA)
<ul>
<li>ExportTable (offset of PE Headers addr = <code class="MDRenderer_code___eFJE">0x70</code>)</li>
</ul>
</li>
</ol>
<p>This is the path we need to follow:</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/x64-shellcoding-winapi/pe-structure.png" alt="kernel32.dll PE format structure - path to Export Table" style="cursor: pointer;"></p>
<p>Let's take a look at the <code class="MDRenderer_code___eFJE">IMAGE_DOS_HEADER</code>. It's the first structure of any PE file:</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="c" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="c" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span style="color: rgb(247, 140, 108);">typedef</span><span style="color: rgb(199, 146, 234);"> struct</span><span style="color: rgb(187, 187, 187);"> _IMAGE_DOS_HEADER </span><span style="color: rgb(137, 221, 255);">{</span><span style="color: rgb(84, 110, 122); font-style: italic;"> // DOS Header</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_magic</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">                // Magic number                      (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_cblp</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">                 // Bytes on last page of file        (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_cp</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">                   // Pages in file                     (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_crlc</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">                 // Relocations                       (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_cparhdr</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">              // Size of header in paragraphs      (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_minalloc</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">             // Minimum extra paragraphs needed   (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_maxalloc</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">             // Maximum extra paragraphs needed   (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_ss</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">                   // Initial (relative) SS value       (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_sp</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">                   // Initial SP value                  (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_csum</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">                 // Checksum                          (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_ip</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">                   // Initial IP value                  (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_cs</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">                   // Initial (relative) CS value       (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_lfarlc</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">               // File address of relocation table  (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_ovno</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">                 // Overlay number                    (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   </span><span style="color: rgb(238, 255, 255);">e_res</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">4</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">               // Reserved words                    (8)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_oemid</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">                // OEM identifier (for e_oeminfo)    (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   e_oeminfo</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">              // OEM information; e_oemid specific (2)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD   </span><span style="color: rgb(238, 255, 255);">e_res2</span><span style="color: rgb(137, 221, 255);">[</span><span style="color: rgb(247, 140, 108);">10</span><span style="color: rgb(137, 221, 255);">];</span><span style="color: rgb(84, 110, 122); font-style: italic;">             // Reserved words                    (20)</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    LONG   e_lfanew</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">               // File address of new exe header    (4)</span></span>
<span data-line=""><span style="color: rgb(137, 221, 255);"> }</span><span style="color: rgb(187, 187, 187);"> IMAGE_DOS_HEADER</span><span style="color: rgb(137, 221, 255);">,</span><span style="color: rgb(199, 146, 234);"> *</span><span style="color: rgb(187, 187, 187);">PIMAGE_DOS_HEADER</span><span style="color: rgb(137, 221, 255);">;</span></span></code></pre></figure>
<p>We need to get to a value of <code class="MDRenderer_code___eFJE">e_lfanew</code> field. It contains the RVA of the PE Headers (or <em>New EXE Headers</em>).</p>
<blockquote class="MDRenderer_blockquote__JCOCK">
<p><strong>Relative Virtual Address</strong>: Many addresses within PE file structure are written in a form of <em>Relative Virtual Address</em> (RVA). It means they are relative to the beginning of the file in memory (base address). To calculate (absolute) <em>Virtual Address</em> we need to add the RVA address to the base address of <code class="MDRenderer_code___eFJE">kernel32.dll</code>.</p>
</blockquote>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="nasm" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="nasm" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span>mov ebx, [r8+0x3c]  ; RBX = kernel32.IMAGE_DOS_HEADER.e_lfanew (PE hdrs offset)</span></span>
<span data-line=""><span>add rbx, r8         ; RBX = PeHeaders offset + &amp;kernel32.dll = &amp;PeHeaders</span></span></code></pre></figure>
<p>Now <code class="MDRenderer_code___eFJE">rbx</code> stores the address of PE Headers. At offset <code class="MDRenderer_code___eFJE">0x88</code> of PE Headers the <code class="MDRenderer_code___eFJE">ExportTable RVA</code> is placed. It's a constant value. Using ExportTable RVA and <code class="MDRenderer_code___eFJE">kernel32.dll</code> base address we are ready to access <code class="MDRenderer_code___eFJE">ExportTable</code>.</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="nasm" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="nasm" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span>xor rcx, rcx</span></span>
<span data-line=""><span>add cx, 0x88        ; RCX = 0x88 (offset of ExportTable RVA)</span></span>
<span data-line=""><span>add rbx, [rbx+rcx]  ; RBX = &amp;PeHeaders + offset of ExportTable RVA = ExportTable RVA</span></span>
<span data-line=""><span>add rbx, r8         ; RBX = ExportTable RVA + &amp;kernel32.dll = &amp;ExportTable</span></span>
<span data-line=""><span>mov r9, rbx         ; R9  = &amp;ExportTable</span></span></code></pre></figure>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/x64-winapi-shellcoding#get-the-winapi-function-address-from-eat"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Get the WinAPI function address from EAT</h2>
<p>Now we have the address of the EAT structure. This structure contains all the information about exported functions. Using this structure we want to find an address of WinAPI function <code class="MDRenderer_code___eFJE">WinExec()</code>.</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="c" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="c" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span style="color: rgb(247, 140, 108);">typedef</span><span style="color: rgb(199, 146, 234);"> struct</span><span style="color: rgb(187, 187, 187);"> _IMAGE_EXPORT_DIRECTORY </span><span style="color: rgb(137, 221, 255);">{</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    DWORD Characteristics</span><span style="color: rgb(137, 221, 255);">;</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    DWORD TimeDateStamp</span><span style="color: rgb(137, 221, 255);">;</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD  MajorVersion</span><span style="color: rgb(137, 221, 255);">;</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    WORD  MinorVersion</span><span style="color: rgb(137, 221, 255);">;</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    DWORD Name</span><span style="color: rgb(137, 221, 255);">;</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    DWORD Base</span><span style="color: rgb(137, 221, 255);">;</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    DWORD NumberOfFunctions</span><span style="color: rgb(137, 221, 255);">;</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    DWORD NumberOfNames</span><span style="color: rgb(137, 221, 255);">;</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    DWORD AddressOfFunctions</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">     // RVA</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    DWORD AddressOfNames</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">         // RVA</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">    DWORD AddressOfNameOrdinals</span><span style="color: rgb(137, 221, 255);">;</span><span style="color: rgb(84, 110, 122); font-style: italic;">  // RVA</span></span>
<span data-line=""><span style="color: rgb(137, 221, 255);">}</span><span style="color: rgb(187, 187, 187);"> IMAGE_EXPORT_DIRECTORY</span><span style="color: rgb(137, 221, 255);">,</span><span style="color: rgb(199, 146, 234);"> *</span><span style="color: rgb(187, 187, 187);">PIMAGE_EXPORT_DIRECTORY</span><span style="color: rgb(137, 221, 255);">;</span></span></code></pre></figure>
<p>Before starting the search, we need to save the string with the name of the WinAPI function we're looking for. We can't do this traditionally in the <code class="MDRenderer_code___eFJE">read-only data</code> section or something like that because all we have is just the <code class="MDRenderer_code___eFJE">.text</code> section. We have to put everything on the stack!</p>
<p>The stack grows downward, and addresses are read upward, so we have to place our string inverted (<code class="MDRenderer_code___eFJE">WinExec\0</code> -&gt; <code class="MDRenderer_code___eFJE">\0cexEniW</code>). All letters are converted to hexadecimal values. At the beginning we push the null-terminator.</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="nasm" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="nasm" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span>xor rax, rax</span></span>
<span data-line=""><span>push rax                    ; STACK + null terminator (8)</span></span>
<span data-line=""><span>mov rax, 0x00636578456E6957 ; RAX = function name = \0 + "cexEniW" (WinExec)</span></span>
<span data-line=""><span>push rax                    ; STACK + function name address (8)</span></span>
<span data-line=""><span>mov rbx, rsp                ; RSI = &amp;function_name</span></span>
<span data-line=""> </span>
<span data-line=""><span>call get_winapi_func</span></span></code></pre></figure>
<p>Now we already have a pointer to the string with the function name.</p>
<p><strong>WARNING</strong>: Now it's going to get a little complicated. I will not describe every line of assembly code. I will present the general concept and paste the code snippet at the end.</p>
<p>In general, <strong>all boils down to going through the entire array of pointers to function names (<code class="MDRenderer_code___eFJE">AddressOfNames</code>) and comparing them with the pointer to our desired function name</strong>. Probably the most interesting part is the <code class="MDRenderer_code___eFJE">repe cmpsb</code> command. It's used to compare two strings (pointers are kept in <code class="MDRenderer_code___eFJE">RDI</code> and <code class="MDRenderer_code___eFJE">RSI</code> registers).</p>
<p>Once we find the right function name, our counter (<code class="MDRenderer_code___eFJE">RAX</code> register) holds its index. Using this index, we can refer to an item in the <code class="MDRenderer_code___eFJE">AddressOfNameOrdinals</code> array. Using the Ordinal Number extracted from this array, we finally refer to the item in the array <code class="MDRenderer_code___eFJE">AddressOfFunctions</code>. Here we obtain the RVA of the <code class="MDRenderer_code___eFJE">WinExec</code> function, calculate the VA and return the address in the <code class="MDRenderer_code___eFJE">RAX</code> register. <strong>And this is it! We have the address of the function we are looking for.</strong></p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="nasm" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="nasm" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span>get_winapi_func:</span></span>
<span data-line=""><span>    ; Requirements (preserved):</span></span>
<span data-line=""><span>    ;   R8  = &amp;kernel32.dll</span></span>
<span data-line=""><span>    ;   R10 = &amp;AddressOfFunctions (ExportTable)</span></span>
<span data-line=""><span>    ;   R11 = &amp;AddressOfNames (ExportTable)</span></span>
<span data-line=""><span>    ;   R12 = &amp;AddressOfNameOrdinals (ExportTable)</span></span>
<span data-line=""><span>    ; Parameters (preserved):</span></span>
<span data-line=""><span>    ;   RBX = (char*) function_name</span></span>
<span data-line=""><span>    ;   RCX = (int)   length of function_name string</span></span>
<span data-line=""><span>    ; Returns:</span></span>
<span data-line=""><span>    ;   RAX = &amp;function</span></span>
<span data-line=""><span>    ;</span></span>
<span data-line=""><span>    ; IMPORTANT: This function doesn't handle "not found" case! </span></span>
<span data-line=""><span>    ;            Infinite loop and access violation is possible.</span></span>
<span data-line=""> </span>
<span data-line=""><span>    xor rax, rax        ; RAX = counter = 0</span></span>
<span data-line=""><span>    push rcx            ; STACK + RCX (8) = preserve length of function_name string</span></span>
<span data-line=""> </span>
<span data-line=""><span>    ; Loop through AddressOfNames array:</span></span>
<span data-line=""><span>    ;   array item = function name RVA (4 bytes)</span></span>
<span data-line=""><span>    loop:</span></span>
<span data-line=""><span>        xor rdi, rdi            ; RDI = 0</span></span>
<span data-line=""><span>        mov rcx, [rsp]          ; RCX = length of function_name string</span></span>
<span data-line=""><span>        mov rsi, rbx            ; RSI = (char*) function_name </span></span>
<span data-line=""> </span>
<span data-line=""><span>        mov edi, [r11+rax*4]    ; RDI = function name RVA </span></span>
<span data-line=""><span>        add rdi, r8             ; RDI = &amp;FunctionName = function name RVA + &amp;kernel32.dll</span></span>
<span data-line=""><span>        repe cmpsb              ; Compare byte *RDI (array item str) and *RSI (param function name)</span></span>
<span data-line=""> </span>
<span data-line=""><span>        je resolve_func_addr    ; Jump if exported function name == param function name</span></span>
<span data-line=""> </span>
<span data-line=""><span>        inc rax                 ; RAX = counter + 1</span></span>
<span data-line=""><span>        jmp short loop</span></span>
<span data-line=""> </span>
<span data-line=""><span>    resolve_func_addr:</span></span>
<span data-line=""><span>        pop rcx                 ; STACK - RCX (8) = remove length of function_name string</span></span>
<span data-line=""><span>        mov ax, [r12+rax*2]     ; RAX = OrdinalNumber = &amp;AddressOfNameOrdinals + (counter * 2) </span></span>
<span data-line=""><span>        mov eax, [r10+rax*4]    ; RAX = function RVA = &amp;AddressOfFunctions + (OrdinalNumber * 4)</span></span>
<span data-line=""><span>        add rax, r8             ; RAX = &amp;function = function RVA + &amp;kernel32.dll</span></span>
<span data-line=""><span>        ret     </span></span></code></pre></figure>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/x64-winapi-shellcoding#execute-winexec-function"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Execute WinExec function</h2>
<p>Here's what the definition of the <a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec">WinExec<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a> function looks like (below). And we have a pointer to this function. Cool, isn't it?</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="c" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="c" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span style="color: rgb(187, 187, 187);">UINT </span><span style="color: rgb(130, 170, 255);">WinExec</span><span style="color: rgb(137, 221, 255);">(</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  LPCSTR </span><span style="color: rgb(247, 140, 108);">lpCmdLine</span><span style="color: rgb(137, 221, 255);">,</span><span style="color: rgb(84, 110, 122); font-style: italic;">    // =&gt; "calc.exe",0x0</span></span>
<span data-line=""><span style="color: rgb(187, 187, 187);">  UINT   uCmdShow</span><span style="color: rgb(84, 110, 122); font-style: italic;">      // =&gt; 0x1 = SW_SHOWNORMAL</span></span>
<span data-line=""><span style="color: rgb(137, 221, 255);">);</span></span></code></pre></figure>
<p>Now we just need to perform this function keeping in mind one very important thing: <strong>Windows x64 calling convention</strong> (<a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">documentation<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a>).</p>
<p><strong>Three important requirements to work with WinAPI</strong>:</p>
<ul>
<li>Argument registers (from left to right): <code class="MDRenderer_code___eFJE">RCX</code> (<code class="MDRenderer_code___eFJE">lpCmdLine</code>), <code class="MDRenderer_code___eFJE">RDX</code> (<code class="MDRenderer_code___eFJE">uCmdShow</code>), <code class="MDRenderer_code___eFJE">R8</code>, <code class="MDRenderer_code___eFJE">R9</code>, then stack...</li>
<li>16-bytes Stack Alignment: <code class="MDRenderer_code___eFJE">and rsp, -16</code></li>
<li>Shadow space - 32 bytes long empty space allocated on stack for internal WinAPI usage: <code class="MDRenderer_code___eFJE">sub rsp, 32</code></li>
</ul>
<p>With the above rules in mind, we are preparing arguments. Again, the string with the name of the program to be executed (<code class="MDRenderer_code___eFJE">calc.exe</code>) is pushed on the stack and the address to it is passed in the first parameter. We set the second parameter to <code class="MDRenderer_code___eFJE">SW_SHOWNORMAL</code> value (<code class="MDRenderer_code___eFJE">0x1</code>), which simply means <em>show default process window</em>.</p>
<figure data-rehype-pretty-code-figure="" style="margin: 0px; padding-bottom: 20px;"><pre tabindex="0" data-language="nasm" data-theme="aurora-x" style="background-color: rgb(7, 9, 15); color: rgb(187, 187, 187);"><code data-language="nasm" data-theme="aurora-x" class="MDRenderer_code___eFJE" style="display: grid;"><span data-line=""><span>xor rcx, rcx</span></span>
<span data-line=""><span>xor rdx, rdx</span></span>
<span data-line=""> </span>
<span data-line=""><span>push rcx                    ; STACK + null terminator (8)</span></span>
<span data-line=""><span>mov rcx, 0x6578652e636c6163 ; RCX = "exe.clac" (command string: calc.exe)</span></span>
<span data-line=""><span>push rcx                    ; STACK + command string (8)</span></span>
<span data-line=""> </span>
<span data-line=""><span>mov rcx, rsp                ; RCX = LPCSTR lpCmdLine</span></span>
<span data-line=""><span>mov rdx, 0x1                ; RDX = UINT uCmdShow = 0x1 (SW_SHOWNORMAL)</span></span>
<span data-line=""> </span>
<span data-line=""><span>and rsp, -16                ; 16-byte Stack Alignment</span></span>
<span data-line=""><span>sub rsp, 32                 ; STACK + 32 bytes (shadow space)</span></span>
<span data-line=""> </span>
<span data-line=""><span>call r13                    ; WinExec("calc.exe", SW_SHOWNORMAL)</span></span></code></pre></figure>
<p>Done, we are ready to compile!</p>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/x64-winapi-shellcoding#compilation-adn-execution"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Compilation adn execution</h2>
<p>I won't elaborate much here. <strong>I wrote a simple script in Python (<a class="mantine-focus-auto m_849cf0da m_b6d8b162 mantine-Text-root mantine-Anchor-root" data-underline="hover" href="https://github.com/Print3M/shellcoder">shellcoder.py<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-external-link" style="transform: translate(1px, -5px);"><path d="M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6"></path><path d="M11 13l9 -9"></path><path d="M15 4h5v5"></path></svg></a>) that compiles the NASM code into an executable EXE format</strong>. This makes it very easy to debug our "shellcode", correct it and compile it again with one click.</p>
<p>After successful compilation, we are ready to run!</p>
<p><img class="m_9e117634 mantine-Image-root" src="https://print3m.github.io/imgs/x64-shellcoding-winapi/calc-exe-popup.png" alt="Shellcode compilation and calc.exe popup" style="cursor: pointer;"></p>
<p>Nice.</p>
<h2 class="Heading_heading__Cw6bO m_8a5d1357 mantine-Title-root" data-order="2" style="--title-fw: var(--mantine-h2-font-weight); --title-lh: var(--mantine-h2-line-height); --title-fz: var(--mantine-h2-font-size); text-align: left;"><a class="Heading_anchor__z6ZW1" href="https://print3m.github.io/blog/x64-winapi-shellcoding#conclusion"><p class="mantine-focus-auto m_b6d8b162 mantine-Text-root" style="margin-left: calc(0.375rem * var(--mantine-scale)); display: inline;"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-link"><path d="M9 15l6 -6"></path><path d="M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464"></path><path d="M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463"></path></svg></p></a>Conclusion</h2>
<p>Learning low-level access to WinAPI functions from within Assembly is extremely developmental. It allows you to better understand malware, of which shellcode is now often one of the main components. Unfortunately, for some reason, few people today are involved in writing shellcode. <strong>But those who write the shellcode themselves are Giga-Chads.</strong></p>
<p>~ Print3M</p></div></div></main></div><div data-portal="true"><div><div class="m_f11b401e mantine-Drawer-root" style="--mb-z-index: 200;"></div></div></div><next-route-announcer style="position: absolute;"><div aria-live="assertive" id="__next-route-announcer__" role="alert" style="position: absolute; border: 0px; height: 1px; margin: -1px; padding: 0px; width: 1px; clip: rect(0px, 0px, 0px, 0px); overflow: hidden; white-space: nowrap; overflow-wrap: normal;"></div></next-route-announcer></body></html>