# https://www.safebreach.com/blog/process-injection-using-windows-thread-pools/

<!DOCTYPE html><html lang="en-US">

<body class="wp-singular resource-template-default single single-resource postid-144135 wp-custom-logo wp-theme-berg-theme wp-child-theme-berg-theme-child mega-menu-top-menu mega-menu-main-menu resource-process-injection-using-windows-thread-pools notification-added">
    <!-- Google Tag Manager (noscript) -->

<!-- End Google Tag Manager (noscript) -->    
    <main role="main">

                    
<section class="wp-block-e25m-section bs-section bs-section-cbd34f7bdb05e2978ca52711176908d80ca48ac3 bs-section---default bs-section--blog-inner-banner"><div class="container">
<div class="wp-block-e25m-row bs-row row  bs-row---default">
<div class=" bs-column col-sm-12   bs-column-36f30487f5bda5ec35c1fc7a3cfb047ab332daf1 bs-column---default     ">	<div class="blog-type-wrapper">
		<p>Threat Coverage | Research</p>
	</div>
	


<div class="post-publish-date-wrapper">
    <p>Dec 6, 2023</p></div>


<h1 class="wp-block-post-title">The Pool Party You Will Never Forget: New Process Injection Techniques Using Windows Thread Pools</h1>


<p><em>See how SafeBreach Labs Researchers developed a brand new set of highly flexible process injection techniques that are able to completely bypass leading endpoint detection and response (EDR) solutions.</em></p>
</div>
</div>
</div></section>



<section class="wp-block-e25m-section bs-section bs-section-dc04248318c48948210ac47c0ebc46ca7594dcd3 bs-section---default bs-section--press-inner-main-content bs-section--blog-inner-main-content"><div class="container">
<div class="wp-block-e25m-row bs-row row  bs-row---default">
<div class=" bs-column col-sm-12 col-md-1   bs-column-9edf2ff4f266401a97cafb86a2e1539fb8e5272f bs-column---default     "><div class="heateor_sss_sharing_container heateor_sss_horizontal_sharing" data-heateor-ss-offset="0" data-heateor-sss-href="https://www.safebreach.com/blog/process-injection-using-windows-thread-pools/"><div class="heateor_sss_sharing_ul"><a aria-label="Email" class="heateor_sss_email" href="https://www.safebreach.com/blog/process-injection-using-windows-thread-pools/" title="Email" rel="noopener" style="font-size:32px!important;box-shadow:none;display:inline-block;vertical-align:middle"><span class="heateor_sss_svg" style="background-color:#649a3f;width:20px;height:20px;display:inline-block;opacity:1;float:left;font-size:32px;box-shadow:none;display:inline-block;font-size:16px;padding:0 4px;vertical-align:middle;background-repeat:repeat;overflow:hidden;padding:0;cursor:pointer;box-sizing:content-box"><svg style="display:block;" focusable="false" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="-.75 -.5 36 36"><path d="M 5.5 11 h 23 v 1 l -11 6 l -11 -6 v -1 m 0 2 l 11 6 l 11 -6 v 11 h -22 v -11" stroke-width="1" fill="#fff"></path></svg></span></a><a aria-label="Linkedin" class="heateor_sss_button_linkedin" href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fwww.safebreach.com%2Fblog%2Fprocess-injection-using-windows-thread-pools%2F" title="Linkedin" rel="nofollow noopener" target="_blank" style="font-size:32px!important;box-shadow:none;display:inline-block;vertical-align:middle"><span class="heateor_sss_svg heateor_sss_s__default heateor_sss_s_linkedin" style="background-color:#0077b5;width:20px;height:20px;display:inline-block;opacity:1;float:left;font-size:32px;box-shadow:none;display:inline-block;font-size:16px;padding:0 4px;vertical-align:middle;background-repeat:repeat;overflow:hidden;padding:0;cursor:pointer;box-sizing:content-box"><svg style="display:block;" focusable="false" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 32 32"><path d="M6.227 12.61h4.19v13.48h-4.19V12.61zm2.095-6.7a2.43 2.43 0 0 1 0 4.86c-1.344 0-2.428-1.09-2.428-2.43s1.084-2.43 2.428-2.43m4.72 6.7h4.02v1.84h.058c.56-1.058 1.927-2.176 3.965-2.176 4.238 0 5.02 2.792 5.02 6.42v7.395h-4.183v-6.56c0-1.564-.03-3.574-2.178-3.574-2.18 0-2.514 1.7-2.514 3.46v6.668h-4.187V12.61z" fill="#fff"></path></svg></span></a><a aria-label="Twitter" class="heateor_sss_button_twitter" href="https://twitter.com/intent/tweet?text=The%20Pool%20Party%20You%20Will%20Never%20Forget%3A%20New%20Process%20Injection%20Techniques%20Using%20Windows%20Thread%20Pools&amp;url=https%3A%2F%2Fwww.safebreach.com%2Fblog%2Fprocess-injection-using-windows-thread-pools%2F" title="Twitter" rel="nofollow noopener" target="_blank" style="font-size:32px!important;box-shadow:none;display:inline-block;vertical-align:middle"><span class="heateor_sss_svg heateor_sss_s__default heateor_sss_s_twitter" style="background-color:#55acee;width:20px;height:20px;display:inline-block;opacity:1;float:left;font-size:32px;box-shadow:none;display:inline-block;font-size:16px;padding:0 4px;vertical-align:middle;background-repeat:repeat;overflow:hidden;padding:0;cursor:pointer;box-sizing:content-box"><svg style="display:block;" focusable="false" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="-4 -4 39 39"><path d="M28 8.557a9.913 9.913 0 0 1-2.828.775 4.93 4.93 0 0 0 2.166-2.725 9.738 9.738 0 0 1-3.13 1.194 4.92 4.92 0 0 0-3.593-1.55 4.924 4.924 0 0 0-4.794 6.049c-4.09-.21-7.72-2.17-10.15-5.15a4.942 4.942 0 0 0-.665 2.477c0 1.71.87 3.214 2.19 4.1a4.968 4.968 0 0 1-2.23-.616v.06c0 2.39 1.7 4.38 3.952 4.83-.414.115-.85.174-1.297.174-.318 0-.626-.03-.928-.086a4.935 4.935 0 0 0 4.6 3.42 9.893 9.893 0 0 1-6.114 2.107c-.398 0-.79-.023-1.175-.068a13.953 13.953 0 0 0 7.55 2.213c9.056 0 14.01-7.507 14.01-14.013 0-.213-.005-.426-.015-.637.96-.695 1.795-1.56 2.455-2.55z" fill="#fff"></path></svg></span></a><a aria-label="Facebook" class="heateor_sss_facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwww.safebreach.com%2Fblog%2Fprocess-injection-using-windows-thread-pools%2F" title="Facebook" rel="nofollow noopener" target="_blank" style="font-size:32px!important;box-shadow:none;display:inline-block;vertical-align:middle"><span class="heateor_sss_svg" style="background-color:#0765FE;width:20px;height:20px;display:inline-block;opacity:1;float:left;font-size:32px;box-shadow:none;display:inline-block;font-size:16px;padding:0 4px;vertical-align:middle;background-repeat:repeat;overflow:hidden;padding:0;cursor:pointer;box-sizing:content-box"><svg style="display:block;" focusable="false" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 32 32"><path fill="#fff" d="M28 16c0-6.627-5.373-12-12-12S4 9.373 4 16c0 5.628 3.875 10.35 9.101 11.647v-7.98h-2.474V16H13.1v-1.58c0-4.085 1.849-5.978 5.859-5.978.76 0 2.072.15 2.608.298v3.325c-.283-.03-.775-.045-1.386-.045-1.967 0-2.728.745-2.728 2.683V16h3.92l-.673 3.667h-3.247v8.245C23.395 27.195 28 22.135 28 16Z"></path></svg></span></a><a class="heateor_sss_more" aria-label="More" title="More" rel="nofollow noopener" style="font-size: 32px!important;border:0;box-shadow:none;display:inline-block!important;font-size:16px;padding:0 4px;vertical-align: middle;display:inline;" href="https://www.safebreach.com/blog/process-injection-using-windows-thread-pools/"><span class="heateor_sss_svg" style="background-color:#ee8e2d;width:20px;height:20px;display:inline-block!important;opacity:1;float:left;font-size:32px!important;box-shadow:none;display:inline-block;font-size:16px;padding:0 4px;vertical-align:middle;display:inline;background-repeat:repeat;overflow:hidden;padding:0;cursor:pointer;box-sizing:content-box;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="-.3 0 32 32" version="1.1" width="100%" height="100%" style="display:block;" xml:space="preserve"><g><path fill="#fff" d="M18 14V8h-4v6H8v4h6v6h4v-6h6v-4h-6z" fill-rule="evenodd"></path></g></svg></span></a></div><div class="heateorSssClear"></div></div>
</div>



<div class=" bs-column col-sm-12 col-md-11 col-lg-10   bs-column-60bcc83ab680d15e56db87f8d61a192b7aff565b bs-column---default     ">
<div class="wp-block-e25m-div bs-div bs-div-47b017cd450f8f07b76aab1d2e6b297c0aca6552 bs-div---default bs-div--body-large-font-size"><div class="bs-div__inner     ">
<div class="wp-block-group"><div class="wp-block-group__inner-container is-layout-constrained wp-block-group-is-layout-constrained"><div class="multi-author-container"><span class="prefix">Authors: </span><span class="author-display-name">Alon Leviev</span></div>
</div></div>



<p>During a cyber attack, malicious actors often breach an organization’s perimeter security with tactics like vulnerability exploitation and phishing. Once inside, they attempt to navigate the organization’s network to escalate their privileges and steal or encrypt data—but here they often face sophisticated endpoint detection and response (EDR) systems designed to identify and prevent this type of activity. To evade detection, threat actors have adopted process injection techniques that allow them to inject malicious code into a computer system’s legitimate processes. The code is then executed by the target process—rather than the attacker—making it extremely difficult for organizations to identify and track from a forensics perspective.&nbsp;&nbsp;&nbsp;&nbsp;</p>



<p>While process injection techniques used to be more prevalent, most operating system (OS) and EDR vendors have tightened security measures to either block known techniques completely or severely limit their impact. As a result, fewer techniques have been seen in recent years and those still seen in the wild only work on specific process states—until now.&nbsp;</p>



<p>The SafeBreach Labs team set out to explore the viability of using Windows thread pools—an under-analyzed area of the Microsoft Windows OS—as a novel attack vector for process injection. In the process, we discovered eight new process injection techniques we dubbed Pool Party variants that were able to trigger malicious execution as a result of a completely legitimate action. The techniques were capable of working across all processes without any limitations, making them more flexible than existing process injection techniques. And, more importantly, the techniques were proven to be fully undetectable when tested against five leading EDR solutions.</p>



<p>Below we will share the details behind our research, which was first presented at <a href="https://www.blackhat.com/eu-23/briefings/schedule/index.html#the-pool-party-you-will-never-forget-new-process-injection-techniques-using-windows-thread-pools-35446">Black Hat Europe 2023</a>. We will begin first with a high-level overview about how process injection works and how endpoint security controls detect current known techniques. We will then explain the architecture and relevant components of&nbsp; Windows thread pools and discuss the research process that led us to successfully exploit them to develop eight unique process injection techniques. Finally, we will highlight the EDR solutions we tested against and identify how SafeBreach is sharing this information with the broader security community to help organizations protect themselves.</p>



<h2 class="wp-block-heading"><strong>Background&nbsp;</strong></h2>



<h2 class="wp-block-heading"><strong>Process Injection&nbsp;</strong></h2>



<p>As an evasion technique used to execute arbitrary code in a target process, process injection usually consists of a chain of three primitives:&nbsp;&nbsp;</p>



<ol class="wp-block-list">
<li>Allocation primitive: Used to allocate memory on the target process</li>



<li>Writing primitive: Used to write malicious code to the allocated memory</li>



<li>Execution primitive: used to execute the malicious code written</li>
</ol>



<figure class="wp-block-image size-large"><img fetchpriority="high" decoding="async" width="1024" height="489" src="https://www.safebreach.com/wp-content/uploads/2023/12/image16-2-1024x489.webp" alt="" class="wp-image-144194"></figure>



<p>The most basic injection technique would use VirtualAllocEX() for allocation, WriteProcessMemory() for writing, and CreateRemoteThread() for execution.This injection technique, publicly known as CreateRemoteThread injection, is very simple and powerful, but there is one downside: it is detectable by all modern EDRs. Our research sought to discover if it was possible to create process injection techniques that were fully undetectable.</p>



<p>Through this process, we sought to understand if&nbsp; EDRs could effectively distinguish the legitimate versus malicious use of a feature. We also wanted to find out if the current <a href="https://www.safebreach.com/detection-engineering-a-comprehensive-guide/">detection approach</a> used by EDRs was generic enough to detect new and never-before-seen process injections.</p>



<p></p>



<!--HubSpot Call-to-Action Code --><span class="hs-cta-wrapper" id="hs-cta-wrapper-13503515-01e1-455d-88b2-16fec1856ce8"><span class="hs-cta-node hs-cta-13503515-01e1-455d-88b2-16fec1856ce8" id="hs-cta-13503515-01e1-455d-88b2-16fec1856ce8"><!--[if lte IE 8]><div id="hs-cta-ie-element"></div><![endif]--><a href="https://cta-redirect.hubspot.com/cta/redirect/43692056/13503515-01e1-455d-88b2-16fec1856ce8"><img decoding="async" class="hs-cta-img" id="hs-cta-img-13503515-01e1-455d-88b2-16fec1856ce8" style="border-width:0px;" src="https://no-cache.hubspot.com/cta/default/43692056/13503515-01e1-455d-88b2-16fec1856ce8.png" alt="Download Our Essential Guide to the MITRE ATT&amp;CK Framework"></a></span></span><!-- end HubSpot Call-to-Action Code -->



<p></p>



<h2 class="wp-block-heading"><strong>EDR Detection Approach</strong></h2>



<p>To answer these questions, we needed to review the current detection approach employed by EDRs against process injections. Experimenting with the different primitives led us to the conclusion that EDRs base their detection mainly on the execution primitive. On top of that, write and allocate primitives—in their most basic forms—are not detected.</p>



<figure class="wp-block-image size-large"><img decoding="async" width="1024" height="466" src="https://www.safebreach.com/wp-content/uploads/2023/12/image29-1024x466.webp" alt="" class="wp-image-144207"></figure>



<p>Based on this finding, what would happen if we created an execution primitive based only on allocation and writing primitives? Furthermore, what if the execution was triggered by a legitimate action—writing to an innocent file, for example—and could trigger shellcode on a victim process? Such capabilities would make the process injection even harder to detect.</p>



<h1 class="wp-block-heading"><strong>Windows User-Mode Thread Pools</strong></h1>



<p>While searching for a suitable component that would help achieve the research goals, we came across the Windows user-mode thread pool. This ended up being the perfect target, because:</p>



<ol class="wp-block-list">
<li>All Windows processes have a thread pool by default, which means that abusing the thread pool would be applicable against all Windows processes.</li>



<li>Work items and thread pools are represented by structures, which increases the chances of having an execution primitive based on the allocation and writing primitives.</li>



<li>Multiple work item types are supported, which means more opportunities.</li>



<li>The thread pool is a considerably complex component, with both kernel and user-mode code, which widens the attack surface.</li>
</ol>



<h2 class="wp-block-heading"><strong>Architecture&nbsp;</strong></h2>



<p>The thread pool comprises three distinct work queues, each dedicated to a different type of work item. The worker threads are operating on the different queues to dequeue work items and execute them. In addition, the thread pool contains a worker factory object, which is responsible for managing the worker threads.&nbsp;</p>



<figure class="wp-block-image size-large"><img decoding="async" width="1024" height="583" src="https://www.safebreach.com/wp-content/uploads/2023/12/image9-2-1024x583.webp" alt="" class="wp-image-144189"></figure>



<p>Based on this architecture, there are few potential areas in the thread pool that could be abused for process injections:&nbsp;&nbsp;</p>



<ol class="wp-block-list">
<li>Worker factory</li>



<li>Task queue</li>



<li>I/O completion queue</li>



<li>Timer queue</li>
</ol>



<p>We know that a valid work item insertion into one of these queues would be executed by the worker threads. Other than the queues, the worker factory that serves as the worker threads manager may be used to take over the worker threads.</p>



<h1 class="wp-block-heading"><strong>Attacking Worker Factories</strong></h1>



<p>The worker factory is a Windows object responsible for managing thread pool worker threads. It manages the worker threads by monitoring active or blocking worker threads and, based on the monitoring results, it creates or terminates worker threads. The worker factory does not perform any scheduling or execution of work items; it is there to make sure that the number of worker threads is sufficient.</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="476" src="https://www.safebreach.com/wp-content/uploads/2023/12/image21-1-1024x476.webp" alt="" class="wp-image-144199"></figure>



<p>The kernel exposes seven system calls to interact with worker factory objects:&nbsp;&nbsp;</p>



<ul class="wp-block-list">
<li>NtCreateWorkerFactory</li>



<li>NtShutdownWorkerFactory</li>



<li>NtQueryInformationWorkerFactory</li>



<li>NtSetInformationWorkerFactory</li>



<li>NtWorkerFactoryWorkerReady</li>



<li>NtWaitForWorkViaWorkerFactory</li>



<li>NtReleaseWorkerFactoryWorker</li>
</ul>



<p>With the goal of taking over worker threads, the relevant target would be the start routine.The start routine is basically the entry point of the worker threads—usually this routine serves as the thread pool scheduler, responsible for dequeuing and executing work items.<br><br>The start routine can be controlled in the worker factory creation system call and, more interestingly, the system call accepts a handle to the process for which the worker factory to be created:&nbsp;&nbsp;</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="528" src="https://www.safebreach.com/wp-content/uploads/2023/12/image28-1024x528.webp" alt="" class="wp-image-144206"></figure>



<p>Looking at the implementation of the system call in the kernel, we noticed that there is a validation that makes sure no worker factories are created for processes other than the current process:&nbsp;&nbsp;</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="419" src="https://www.safebreach.com/wp-content/uploads/2023/12/image1-2-1024x419.webp" alt="" class="wp-image-144182"></figure>



<p>Generally speaking, it is a bit odd that the system call gets a parameter with only one possible value. All processes have a thread pool by default, and consequently, a worker factory by default.</p>



<p>Instead of going through the trouble of creating a worker factory, we can simply utilize the DuplicateHandle() API to gain access to a worker factory belonging to the target process.</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="473" src="https://www.safebreach.com/wp-content/uploads/2023/12/image27-1024x473.webp" alt="" class="wp-image-144205"></figure>



<p>Having access to an existing worker factory did not let us control the start routine value, as this value is constant and could not be naturally changed after the object was initialized. With that said, if we could determine the start routine value, we could overwrite the routine code with a malicious shellcode.</p>



<p>To get worker factory information, the NtQueryWorkerFactoryInformation system call could be used:</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="284" src="https://www.safebreach.com/wp-content/uploads/2023/12/image6-2-1024x284.webp" alt="" class="wp-image-144186"></figure>



<p>The only supported information class that the query system call can retrieve is basic worker factory information:&nbsp;</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="215" src="https://www.safebreach.com/wp-content/uploads/2023/12/image8-2-1024x215.webp" alt="" class="wp-image-144188"></figure>



<p>In this case this is enough, as the basic worker factory information includes the start routine value:</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="301" src="https://www.safebreach.com/wp-content/uploads/2023/12/image20-1-1024x301.webp" alt="" class="wp-image-144198"></figure>



<p>Given the start routine value, we could overwrite the start routine content with malicious shellcode.</p>



<p>The start routine is guaranteed to run at some point, but it would be even better if we could also trigger its execution instead of waiting for it. To accomplish this, we looked at the NtSetInformationWorkerFactory system call:&nbsp;</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="200" src="https://www.safebreach.com/wp-content/uploads/2023/12/image3-2-1024x200.webp" alt="" class="wp-image-144183"></figure>



<p>The set system call supports more information classes then the query system call, and the one that suited our needs the best was the WorkerFactoryThreadMinimum information class:&nbsp;&nbsp;</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="724" src="https://www.safebreach.com/wp-content/uploads/2023/12/image7-2-1024x724.webp" alt="" class="wp-image-144187"></figure>



<p>Setting the minimum worker threads number to be the current running threads number + 1 resulted in a new worker thread being created, meaning the start routine was executed:&nbsp;&nbsp;</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="501" src="https://www.safebreach.com/wp-content/uploads/2023/12/image26-1024x501.webp" alt="" class="wp-image-144204"></figure>



<p>And with that, we successfully developed our first Pool Party variant:&nbsp;</p>



<figure class="wp-block-video"><video controls="" src="https://www.safebreach.com/wp-content/uploads/2023/12/Worker-factory.mp4"></video></figure>



<p><strong><em>Pool Party Variant 1: Worker Factory Start Routine Overwrite</em></strong></p>



<h1 class="wp-block-heading"><strong>Attacking Thread Pools</strong></h1>



<p>When attacking the thread pool, our goal was to insert a work item to a target process, so we focused on how work items are inserted into the thread pool. We know that if we insert a work item correctly, it will be executed by the worker threads. We will assume that we already have access to the worker factory of the target thread pool, as we proved in the previous section that such access can be granted by duplicating the worker factory handle.</p>



<h2 class="wp-block-heading"><strong>Work Item Types</strong></h2>



<p>The supported work items can be divided into three types:&nbsp;</p>



<ul class="wp-block-list">
<li>The regular work items, which are queued right away by the queueing API call.</li>



<li>The asynchronous work items, which are queued on operation completion, for example, when a write file operation is completed.</li>



<li>The timer work items, which are queued right away by the queueing API call, but are executed when a timer expires.</li>
</ul>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="441" src="https://www.safebreach.com/wp-content/uploads/2023/12/image11-2-1024x441.webp" alt="" class="wp-image-144191"></figure>



<h2 class="wp-block-heading"><strong></strong><strong><br></strong><strong>Queue Types</strong></h2>



<p>As for the three types of work items, there are also three queues:&nbsp;</p>



<ul class="wp-block-list">
<li>The regular work items are queued to the task queue, residing in the main thread pool structure, the TP_POOL.</li>



<li>The asynchronous work items are queued to the I/O completion queue, which is a Windows object.</li>



<li>And timer work items are queued to the timer queue, also residing in the main thread pool structure.&nbsp;</li>
</ul>



<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="1004" height="451" src="https://www.safebreach.com/wp-content/uploads/2023/12/image22-1.webp" alt="" class="wp-image-144200"></figure>



<p><br>The main thread pool structure resides in user-mode in the process memory address space, so modifications to its queues can be done through memory writing primitives. The I/O completion queue is a Windows object, so the queue resides in the kernel and can be manipulated by its exposed system calls.</p>



<h2 class="wp-block-heading"><strong>Helper Structures</strong></h2>



<p>Before we dive into the queueing mechanism of each work item type, it is important to note that work item callbacks are not executed directly by the worker threads. Instead, each work item has a helper callback that is used to execute the work item callback. The structure that is queued is the helper structure.</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="552" src="https://www.safebreach.com/wp-content/uploads/2023/12/image32-1024x552.webp" alt="" class="wp-image-144209"></figure>



<h2 class="wp-block-heading"><strong>Attacking Thread Pools: TP_WORK</strong></h2>



<p>By looking at the TP_WORK work item structure, we found that its helper structure is the TP_TASK structure. Wee know that the task structure is what gets inserted into the task queue within the thread pool structure.&nbsp;</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="480" src="https://www.safebreach.com/wp-content/uploads/2023/12/image24-1024x480.webp" alt="" class="wp-image-144202"></figure>



<p>The API that is responsible for submitting the TP_WORK work item is named SubmitThreadpoolWork. Going down the call chain of SubmitThreadpoolWork, we reached the queueing API named TpPostTask.</p>



<p>The TpPostTask API is responsible for inserting a task to the task queue, which is represented by a doubly linked list. It retrieves the corresponding task queue by priority and inserts the task to the tail of the task queue.</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="346" src="https://www.safebreach.com/wp-content/uploads/2023/12/image14-2-1024x346.webp" alt="" class="wp-image-144193"></figure>



<p>Given the thread pool structure of the target process, we could tamper with its task queue to inject a malicious task into it.To get the thread pool structure of the target process, the NtQueryInformationWorkerFactory could be used. The basic worker factory information included the start parameter of the start routine, and this start parameter was essentially a pointer to the TP_POOL structure. We had our second Pool Party variant:</p>



<figure class="wp-block-video"><video controls="" src="https://www.safebreach.com/wp-content/uploads/2023/12/2023-12-01-19-19-14.mp4"></video></figure>



<p><strong><em>Pool Party Variant 2:&nbsp; Remote TP_WORK Work Item Insertion</em></strong></p>



<h2 class="wp-block-heading"><strong>Attacking Thread Pools: TP_IO</strong></h2>



<p>Recalling the queue types, asynchronous work items are queued to the I/O completion queue. The I/O completion queue is a Windows object that serves as a queue for completed I/O operations. Notifications are inserted into the queue once an I/O operation completes</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="379" src="https://www.safebreach.com/wp-content/uploads/2023/12/image23-1-1024x379.webp" alt="" class="wp-image-144201"></figure>



<p>The thread pool relies on the I/O completion queue to receive notifications when an asynchronous work item’s operation is completed.</p>



<p><strong>NOTE: </strong>Microsoft refers to I/O completion queues as I/O completion ports. This object is essentially a kernel queue (KQUEUE), so to avoid confusion we refer to it as I/O completion queue.</p>



<p>The kernel exposes eight system calls to interact with I/O competition queues:&nbsp;&nbsp;</p>



<ul class="wp-block-list">
<li>NtCreateIoCompletion</li>



<li>NtOpenIoCompletion</li>



<li>NtQueryIoCompletion</li>



<li>NtQueryIoCompletionEx</li>



<li>NtSetIoCompletion</li>



<li>NtSetIoCompletionEx</li>



<li>NtRemoveIoCompletion</li>



<li>NtRemoveIoCompletionEx</li>
</ul>



<p>Keep in mind the NtSetIoCompletion system call is used to queue a notification to the queue. We will get back to this system call later on.</p>



<p>Equipped with some I/O completion background, we can jump right into the queueing mechanism of the asynchronous work items. We will use the TP_IO work item as an example, but note that the same concepts apply to the other asynchronous work items.</p>



<p>The TP_IO work item is a work item intended to execute on completion of file operations such as read and write. The helper structure of the TP_IO work item is the TP_DIRECT structure, so we expect this structure to be queued to the completion queue.</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="546" src="https://www.safebreach.com/wp-content/uploads/2023/12/image4-2-1024x546.webp" alt="" class="wp-image-144184"></figure>



<p>As asynchronous work items were queued to the I/O completion queue, we looked for the function that associated the work item to the thread pool’s I/O completion queue. Looking at the call chain of CreateThreadpoolIo, we reached the function of interest: the TpBindFileToDirect function. This function sets the file completion queue to be the thread pool’s I/O completion queue, and the file completion key to be the direct structure:&nbsp; </p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="495" src="https://www.safebreach.com/wp-content/uploads/2023/12/image31-1024x495.webp" alt="" class="wp-image-144208"></figure>



<p>Calling TpBindFileToDirect on a file object results in the completion queue of the file object pointing to the thread pool’s I/O completion queue, and the completion key pointing to the direct structure.</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="475" src="https://www.safebreach.com/wp-content/uploads/2023/12/image5-2-1024x475.webp" alt="" class="wp-image-144185"></figure>



<p>At that point, the I/O completion queue was still empty, as no operation on the file occurred. Any operation on the file following the function call—for example, WriteFile—would cause the completion key to be queued to the I/O completion queue.</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="460" src="https://www.safebreach.com/wp-content/uploads/2023/12/image33-1024x460.webp" alt="Screenshot of file object for process injection technique" class="wp-image-144210"></figure>



<p>To conclude, asynchronous work items are queued to the I/O completion queue and the direct structure is the field that is queued. Having a handle to the I/O completion queue of the target process gave us the ability to queue notifications to it. This handle could be duplicated using the DuplicateHandle API, similarly to how we duplicated the worker factory handle. And with that, we had our third Pool Party variant:</p>



<figure class="wp-block-video"><video controls="" src="https://www.safebreach.com/wp-content/uploads/2023/12/2023-12-01-19-19-33.mp4"></video></figure>



<p><strong><em>Pool Party Variant 3:&nbsp; Remote TP_IO Work Item Insertion</em></strong></p>



<p>How did we also insert ALPC, JOB and WAIT work items? Any valid TP_DIRECT structure queued to the I/O completion queue will get executed. It is all a matter of how we queue the TP_DIRECT structure to the I/O completion queue.</p>



<p>Queuing can be done in one of the following ways:&nbsp;</p>



<ol class="wp-block-list">
<li>Utilizing Windows objects, similar to the TP_IO abuse. This will involve associating the object with the I/O completion queue of the target process, and then any operation completion on this object will queue a notification.&nbsp;</li>



<li>Utilizing NtSetIoCompletion to queue a notification directly into the completion queue.</li>
</ol>



<p>With that in mind, we can inject the rest of the asynchronous work items, the TP_WAIT, TP_ALPC and TP_JOB, by associating the underlying Windows object with the target thread pool’s I/O completion queue, and setting its completion key to point to the malicious work item. On top of that, we can inject a malicious TP_DIRECT structure directly without proxying it through a Windows object, which involves using the NtSetIoCompletion system call. This allowed us to create four more Pool Party variants:</p>



<ul class="wp-block-list">
<li>PoolParty Variant 4 – Remote TP_WAIT Work Item Insertion</li>



<li>PoolParty Variant 5 – Remote TP_ALPC Work Item Insertion</li>



<li>PoolParty Variant 6 – Remote TP_JOB Work Item Insertion</li>



<li>PoolParty Variant 7 – Remote TP_DIRECT Insertion</li>
</ul>



<p>These variants are special as the execution is triggered by a completely legitimate action, such as writing to a file, connecting to an ALPC port, assigning a process to a job object, and setting an event.</p>



<h2 class="wp-block-heading"><strong>Attacking Thread Pools:&nbsp; TP_TIMER</strong></h2>



<p>First, when looking at the creation and submission API of a timer work item, we noticed that no timer handle was supplied. The submission API, SetThreadpoolTimer, accepts some timer configuration such as DueTime, but it wasn’t clear where the actual timer object resided.</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="505" src="https://www.safebreach.com/wp-content/uploads/2023/12/image17-3-1024x505.webp" alt="" class="wp-image-144195"></figure>



<p>It turns out that timer work items operate on an existing timer object, which resides in the timer queue. Once the SubmitThreadpoolTimer API is called, the work item is inserted into the queue, and the timer object residing in the queue is configured with the user-supplied configuration.&nbsp;</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="484" src="https://www.safebreach.com/wp-content/uploads/2023/12/image13-2-1024x484.webp" alt="" class="wp-image-144192"></figure>



<p>Once the timer is expired, a dequeueing function is called, which dequeues the work item from the queue and executes it.</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="478" src="https://www.safebreach.com/wp-content/uploads/2023/12/image10-2-1024x478.webp" alt="" class="wp-image-144190"></figure>



<p>Generally speaking, timer objects do not natively support callback execution at expiration. All you need to know is that the thread pool implements it using the TP_WAIT work item, which supports timers. So if we set the timer queue to expire, the dequeuing function is called. Now the question is, how do we correctly queue a timer to the queue?</p>



<p>The connectors between a timer and a timer queue are the TP_TIMER’s WindowEndLinks and WindowStartLinks fields.</p>



<p>For the sake of simplicity, we can think of these two fields as list entries of a doubly linked list.&nbsp;</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="607" src="https://www.safebreach.com/wp-content/uploads/2023/12/image18-2-1024x607.webp" alt="" class="wp-image-144196"></figure>



<p>Going down the call chain of SetThreadpoolTimer, we reached the queueing function named TppEnqueueTimer.</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="381" src="https://www.safebreach.com/wp-content/uploads/2023/12/image25-1024x381.webp" alt="" class="wp-image-144203"></figure>



<p>TppEnqueueTimer inserts the TP_TIMER’s WindowStartLinks to the queue WindowStart field, and the WindowEndLinks to the queue WindowEnd field.</p>



<figure class="wp-block-image size-large"><img loading="lazy" decoding="async" width="1024" height="517" src="https://www.safebreach.com/wp-content/uploads/2023/12/image19-1-1024x517.webp" alt="" class="wp-image-144197"></figure>



<p>The SetThreadpoolTimer API is responsible for two actions:&nbsp;&nbsp;</p>



<ol class="wp-block-list">
<li>Queue the timer work item to the timer queue.</li>



<li>Configure the timer object residing in the queue.</li>
</ol>



<p>As a result of these two actions, once the timer object expires, the dequeuing function executes, dequeuing and executing the queued timer work item. Given the thread pool structure of the target process, we can tamper with its timer queue to inject a malicious timer work item into it. Post queueing, we need to set the timer object that the queue uses to expire. Setting the timer requires a handle to it, and such handle could be duplicated using the DuplicateHandle API. And with that, we had our eighth Pool Party variant:</p>



<figure class="wp-block-video"><video controls="" src="https://www.safebreach.com/wp-content/uploads/2023/12/2023-12-01-19-19-53.mp4"></video></figure>



<p><strong><em>Pool Party Variant 8:&nbsp; Remote TP_TIMER Work Item Insertion</em></strong></p>



<p>What’s even more astonishing about this variation is that after setting the timer, the attacker can exit the process and erase its identity from the system. As a result, the system appears clean, and the malicious code activates only when the timer runs out.</p>



<h1 class="wp-block-heading"><strong>Tested EDR Solutions</strong></h1>



<p>As part of the research process, each Pool Party variant was tested against five leading EDR solutions, including:&nbsp;</p>



<ul class="wp-block-list">
<li>Palo Alto Cortex</li>



<li>SentinelOne EDR</li>



<li>CrowdStrike Falcon</li>



<li>Microsoft Defender For Endpoint</li>



<li>Cybereason EDR</li>
</ul>



<p>We achieved a 100 percent success rate, as none of the EDRs were able to detect or prevent Pool Party attacks. We reported these findings to each vendor and believe they are making updates to better detect these types of techniques.&nbsp;</p>



<p>It is important to note that while we have done our best to test the EDR products we had access to, it is not feasible for us to test every product on the market. By making this information available to the security community, we hope to minimize the ability of malicious actors to exploit these techniques and provide EDR vendors and users with the knowledge they need to take immediate action on their own.</p>



<h1 class="wp-block-heading"><strong>Pool Party Demo</strong></h1>



<figure class="wp-block-video"><video controls="" src="https://www.safebreach.com/wp-content/uploads/2023/12/PoolParty_Demo.mp4"></video></figure>



<h1 class="wp-block-heading"><strong>Key Takeaways</strong></h1>



<p>We believe there are a few important takeaways based on the findings of this research:&nbsp;</p>



<ol class="wp-block-list">
<li>Although EDRs have evolved, the current detection approach utilized by most solutions is unable to generically detect new process injection techniques like those we have developed here. While our research demonstrates how we were able to abuse thread pools specifically, malicious actors will undoubtedly find other features to leverage in a similar way. We believe it is critical for EDR vendors to develop and implement a generic detection approach to proactively defend against these possibilities.</li>



<li>We also believe it is important for individual organizations to enhance their focus on detecting anomalies, rather than placing complete trust in processes based solely on their identity. Our research demonstrates that executing code on the behalf of a trusted process can go undetected by an EDR. This underscores the importance of deeper inspection to ensure the legitimacy of operations performed by such processes.&nbsp;&nbsp;</li>
</ol>



<h1 class="wp-block-heading"><strong>Conclusion</strong></h1>



<p>Though modern EDRs have evolved to detect known process injection techniques, our research has proven that it is still possible to develop novel techniques that are undetectable and have the potential to make a devastating impact. Sophisticated threat actors will continue to explore new and innovative methods for process injection, and security tool vendors and practitioners must be proactive in their defense against them.</p>



<p>To help mitigate the potential impact of these techniques, we have:&nbsp;&nbsp;&nbsp;</p>



<ul class="wp-block-list">
<li>Responsibly disclosed our research findings to Microsoft, Palo Alto Networks, CrowdStrike, SentinelOne, and Cybereason.</li>



<li>Shared our research openly with the broader security community here and at our recent Black Hat presentation to raise awareness about these issues.</li>



<li>Provided a&nbsp;<a href="https://github.com/SafeBreach-Labs/PoolParty" target="_blank" rel="noreferrer noopener">research GitHub repository</a>&nbsp;that includes details about our findings to serve as a basis for further research and development.</li>



<li>Added Original Attack content to the SafeBreach platform that enables our customers to validate their security controls against these flows and significantly mitigate their risk.</li>
</ul>



<p>For more in-depth information about this research, please:&nbsp;</p>



<ul class="wp-block-list">
<li>Contact your customer success representative if you are a current SafeBreach customer</li>



<li><a href="https://www.safebreach.com/request-a-demo/">Schedule a one-on-one discussion</a> with a SafeBreach expert</li>



<li>Contact Kesselring PR for media inquiries&nbsp;</li>
</ul>



<h1 class="wp-block-heading"><strong>About the Researcher</strong></h1>



<p>Alon Leviev is a self-taught security researcher with a diverse background. Alon started his professional career as a blue team operator, where he focused on the defensive side of cyber security. As his passion grew towards research, Alon joined SafeBreach as a security researcher. His main interests include operating system internals, reverse engineering, and vulnerability research. Before joining the cyber security field, Alon was a professional Brazilian jiu-jitsu athlete, where he won several world and European titles.</p>



<p></p>



<!--HubSpot Call-to-Action Code --><span class="hs-cta-wrapper" id="hs-cta-wrapper-e6521583-5785-4f84-9527-1753d742857d"><span class="hs-cta-node hs-cta-e6521583-5785-4f84-9527-1753d742857d" id="hs-cta-e6521583-5785-4f84-9527-1753d742857d"><!--[if lte IE 8]><div id="hs-cta-ie-element"></div><![endif]--><a href="https://cta-redirect.hubspot.com/cta/redirect/43692056/e6521583-5785-4f84-9527-1753d742857d"><img decoding="async" class="hs-cta-img" id="hs-cta-img-e6521583-5785-4f84-9527-1753d742857d" style="border-width:0px;" src="https://no-cache.hubspot.com/cta/default/43692056/e6521583-5785-4f84-9527-1753d742857d.png" alt="CTA-MITRE Att&amp;ck "></a></span></span><!-- end HubSpot Call-to-Action Code -->
</div></div>
</div>
</div>
</div></section>



<section class="wp-block-e25m-section bs-section bs-section-92f291c17c171722c4c489295cad896c03e51465 bs-section---default bs-section--home-resources bs-section--industry-healthcare-resources bs-section--blog-inner-post-block"><div class="container">
<div class="wp-block-e25m-row bs-row row  bs-row---default">
<div class=" bs-column col-sm-12 col-md-0   bs-column-c6e1433ccca98b012fc1a46003db94275a5c7eff bs-column---default     ">
<h2 class="wp-block-heading">You Might Also Be Interested In</h2>
</div>
</div>



<div class="wp-block-e25m-row bs-row row  bs-row---default">
<div class=" bs-column col-sm-12 col-md-4   bs-column-ddb0ca5d1fd73cb3f5e6682823076c9e17e95d12 bs-column---default     ">					<div class="bs-post bs-post-69917c7fc525e bs-single-post---default bs-single-post--common bs-single-post--no-image-post enable">
			<a class="bs-post__trigger" href="https://www.safebreach.com/blog/defender-pretender-when-windows-defender-updates-become-a-security-risk/" target="_self">			<div class="bs-post__inner">
				<div class="bs-post__image">
                            <figure class="figure">
                                <img src="https://www.safebreach.com/wp-content/uploads/2023/08/23-08-Defender-Pretender-blog-1.webp" class="img-fluid" alt="" title="23-08 Defender Pretender blog">
                                <figcaption class="figure-caption"></figcaption>
                            </figure>
                        </div><div class="bs-post__details">    <div class="bs-post__category bs-post-taxonomy_resource-type">
        <span>Research</span><span>Blog</span>    </div>
    <div class="bs-post__title">
        <h3>Defender Pretender: When Windows Defender Updates Become a Security Risk</h3>
    </div>
<div class="bs-post__learn-more">
    <span class="btn learn-more-text bs-post__learn-more-text">Read More</span></div>
</div>			</div>
			</a>		</div>
	</div>



<div class=" bs-column col-sm-12 col-md-4   bs-column-ddb0ca5d1fd73cb3f5e6682823076c9e17e95d12 bs-column---default     ">					<div class="bs-post bs-post__container bs-post__container--no-image bs-post-69917c7fc672e bs-single-post---default bs-single-post--common bs-single-post--no-image-post enable">
			<a class="bs-post__trigger" href="https://www.safebreach.com/cve-discoveries/" target="_self">			<div class="bs-post__inner">
				<div class="bs-post__details">    <div class="bs-post__title">
        <h3>SafeBreach Labs CVE Discoveries</h3>
    </div>
<div class="bs-post__learn-more">
    <span class="btn learn-more-text bs-post__learn-more-text">Read More</span></div>
</div>			</div>
			</a>		</div>
	</div>



<div class=" bs-column col-sm-12 col-md-4   bs-column-ddb0ca5d1fd73cb3f5e6682823076c9e17e95d12 bs-column---default     ">					<div class="bs-post bs-post-69917c7fc761b bs-single-post---default bs-single-post--common bs-single-post--no-image-post enable">
			<a class="bs-post__trigger" href="https://www.safebreach.com/blog/one-drive-double-agent-clouded-onedrive-turns-sides/" target="_self">			<div class="bs-post__inner">
				<div class="bs-post__image">
                            <figure class="figure">
                                <img src="https://www.safebreach.com/wp-content/uploads/2023/08/23-08-OneDrive-Double-Agent-Research-blog.png" class="img-fluid" alt="" title="23-08 OneDrive Double Agent Research blog">
                                <figcaption class="figure-caption"></figcaption>
                            </figure>
                        </div><div class="bs-post__details">    <div class="bs-post__category bs-post-taxonomy_resource-type">
        <span>Research</span><span>Blog</span>    </div>
    <div class="bs-post__title">
        <h3>One Drive, Double Agent: Clouded OneDrive Turns Sides</h3>
    </div>
<div class="bs-post__learn-more">
    <span class="btn learn-more-text bs-post__learn-more-text">Read More</span></div>
</div>			</div>
			</a>		</div>
	</div>
</div>
</div></section>



<section class="wp-block-e25m-section bs-section bs-section-152dc48c48f76276b8e59d1241e250f6f8f2d658 bs-section---default bs-section--press-inner-newsletter"><div class="container">
<div class="wp-block-e25m-row bs-row row  bs-row---default">
<div class=" bs-column col-sm-12 col-md-5 col-lg-5 col-xl-5   bs-column-ea1477cd70e80d58d5e8b21de61e7efb79aa38a6 bs-column---default     ">
<h2 class="wp-block-heading has-pure-white-color has-text-color">Get the latest<br>research and news</h2>
</div>



<div class=" bs-column col-sm-12 col-md-7 col-lg-7 col-xl-7   bs-column-fb970c0aaeee301967d24061074d9e24bb53b2a6 bs-column---default     ">
<div class="wp-block-e25m-div bs-div bs-div-24a31fdad168dfc2c1de4b9ea2b72f191f628538 bs-div---default bs-div--footer-form-block bs-div--hubspot-form-block"><div class="bs-div__inner     ">

<div class="bs-embedded-forms bs-embedded-forms---default bs-embedded-forms-2921e7f4e22cdbd4170b201c6740a77c43fe4770" id="bs-embedded-forms-2921e7f4e22cdbd4170b201c6740a77c43fe4770__form" data-hs-forms-root="true"><form id="hsForm_1830aba9-31aa-4bb4-82cc-289210cdc9e9" method="POST" accept-charset="UTF-8" enctype="multipart/form-data" novalidate="" action="https://forms.hsforms.com/submissions/v3/public/submit/formsnext/multipart/43692056/1830aba9-31aa-4bb4-82cc-289210cdc9e9" class="hs-form-private hsForm_1830aba9-31aa-4bb4-82cc-289210cdc9e9 hs-form-1830aba9-31aa-4bb4-82cc-289210cdc9e9 hs-form-1830aba9-31aa-4bb4-82cc-289210cdc9e9_599c8ac1-f4b2-46a8-b1c1-6cb7a9639f49 hs-form stacked hs-custom-style" target="target_iframe_1830aba9-31aa-4bb4-82cc-289210cdc9e9" data-instance-id="599c8ac1-f4b2-46a8-b1c1-6cb7a9639f49" data-form-id="1830aba9-31aa-4bb4-82cc-289210cdc9e9" data-portal-id="43692056" data-test-id="hsForm_1830aba9-31aa-4bb4-82cc-289210cdc9e9"><div class="hs_firstname hs-firstname hs-fieldtype-text field hs-form-field"><label id="label-firstname-1830aba9-31aa-4bb4-82cc-289210cdc9e9" class="" for="firstname-1830aba9-31aa-4bb4-82cc-289210cdc9e9"><span>First Name</span><span class="hs-form-required">*</span></label><div class="input"><input id="firstname-1830aba9-31aa-4bb4-82cc-289210cdc9e9" name="firstname" required="" placeholder="First Name" type="text" class="hs-input" inputmode="text" autocomplete="given-name" value=""></div></div><div class="hs_lastname hs-lastname hs-fieldtype-text field hs-form-field"><label id="label-lastname-1830aba9-31aa-4bb4-82cc-289210cdc9e9" class="" for="lastname-1830aba9-31aa-4bb4-82cc-289210cdc9e9"><span>Last Name</span><span class="hs-form-required">*</span></label><div class="input"><input id="lastname-1830aba9-31aa-4bb4-82cc-289210cdc9e9" name="lastname" required="" placeholder="Last Name" type="text" class="hs-input" inputmode="text" autocomplete="family-name" value=""></div></div><div class="hs_company hs-company hs-fieldtype-text field hs-form-field"><label id="label-company-1830aba9-31aa-4bb4-82cc-289210cdc9e9" class="" for="company-1830aba9-31aa-4bb4-82cc-289210cdc9e9"><span>Company name</span><span class="hs-form-required">*</span></label><div class="input"><input id="company-1830aba9-31aa-4bb4-82cc-289210cdc9e9" name="company" required="" placeholder="Company Name" type="text" class="hs-input" inputmode="text" autocomplete="organization" value=""></div></div><div class="hs_email hs-email hs-fieldtype-text field hs-form-field"><label id="label-email-1830aba9-31aa-4bb4-82cc-289210cdc9e9" class="" for="email-1830aba9-31aa-4bb4-82cc-289210cdc9e9"><span>Email Address</span><span class="hs-form-required">*</span></label><div class="input"><input id="email-1830aba9-31aa-4bb4-82cc-289210cdc9e9" name="email" required="" placeholder="Company Email Address" type="email" class="hs-input" inputmode="email" autocomplete="email" value=""></div></div><div class="legal-consent-container"><div><div class="hs-dependent-field"><div class="hs_LEGAL_CONSENT.subscription_type_272483205 hs-LEGAL_CONSENT.subscription_type_272483205 hs-fieldtype-booleancheckbox field hs-form-field"><div class="input"><ul class="inputs-list"><li class="hs-form-booleancheckbox"><label for="LEGAL_CONSENT.subscription_type_272483205-1830aba9-31aa-4bb4-82cc-289210cdc9e9" class="hs-form-booleancheckbox-display"><input id="LEGAL_CONSENT.subscription_type_272483205-1830aba9-31aa-4bb4-82cc-289210cdc9e9" class="hs-input" type="checkbox" name="LEGAL_CONSENT.subscription_type_272483205" value="true"><span>I agree to receive other communications from SafeBreach.</span></label></li></ul></div></div></div><legend class="hs-field-desc checkbox-desc" style="display: none;"></legend></div><div><div class="hs-dependent-field"><div class="hs_LEGAL_CONSENT.processing hs-LEGAL_CONSENT.processing hs-fieldtype-booleancheckbox field hs-form-field"><div class="input"><ul class="inputs-list"><li class="hs-form-booleancheckbox"><label for="LEGAL_CONSENT.processing-1830aba9-31aa-4bb4-82cc-289210cdc9e9" class="hs-form-booleancheckbox-display"><input id="LEGAL_CONSENT.processing-1830aba9-31aa-4bb4-82cc-289210cdc9e9" class="hs-input" type="checkbox" name="LEGAL_CONSENT.processing" value="true"><span><p>I agree that SafeBreach may collect and use my personal data, for providing marketing material, in accordance with the&nbsp;<a href="https://www.safebreach.com/privacy-policy/" target="_blank">SafeBreach privacy policy</a>.</p><span class="hs-form-required">*</span></span></label></li></ul></div></div></div><legend class="hs-field-desc checkbox-desc" style="display: none;"></legend></div></div><div class="hs_submit hs-submit"><div class="hs-field-desc" style="display: none;"></div><div class="actions"><input type="submit" class="hs-button primary large" value="Submit"></div></div><div name="target_iframe_1830aba9-31aa-4bb4-82cc-289210cdc9e9" style="display: none;" data-original-tag="iframe"></div></form></div>
<!-- Incluing form response options -->
</div></div>
</div>
</div>
</div></section>
        
</main>




















    






</body></html>