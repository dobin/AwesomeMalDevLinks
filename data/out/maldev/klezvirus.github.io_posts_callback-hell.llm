Title:
Callback hell: abusing callbacks, tail-calls, and proxy frames to obfuscate the stack

Type:
Blog Post

Short Summary (4–8 sentences max):
This post explores Windows call stack obfuscation by abusing callback-based execution (notably Thread Pool work items) combined with tail-calls and “proxy frames” to hide suspicious frames from stack inspection. It addresses a practical limitation of frameless/tail-call callbacks: they can remove the callback frame from the stack but typically lose the ability to recover the target function’s return value. The author introduces “frame swapping” using selected real function epilog/prolog patterns (e.g., gadgets that do `MOV [REG], RAX` before `RET`) to both conceal the callback and persist the return value into attacker-controlled memory. It also proposes chaining multiple callback mechanisms (“callback hell”) to construct highly variable, mostly legitimate-looking call stacks without loading odd DLLs. The write-up discusses constraints like x64 calling convention/stack parameter space and notes incompatibility of backward proxy frames with Intel CET, while callback chaining remains CET-friendly. It’s primarily useful for red teamers, implant developers, and researchers studying EDR call-stack-based detections and stack spoofing trade-offs.

Technical Focus:
- Windows Thread Pool callbacks (TpAllocWork/TpPostWork) as execution primitives
- Tail-call (JMP) callbacks / frameless assembly stubs to remove frames
- Proxy frames (forward/backward) and frame swapping for stack spoofing
- Return-value recovery via epilog gadgets (e.g., `MOV [RBX], RAX`)
- x64 calling convention constraints (shadow space, stack args, frame sizing)
- Detection considerations: callsite validation, CFG/XFG, CET implications

Use Cases:
- Hide threadpool callback frames during indirect execution to evade call-stack heuristics
- Preserve return values from proxied API/syscall-like invocations in callback contexts
- Build “custom” or highly variable call stacks by chaining multiple callback invokers
- Research/benchmark EDR stack-walking and “return address not preceded by CALL” detections
- Develop stack-spoofing primitives compatible/incompatible with Intel CET constraints

Keywords:
Windows thread pool, TpAllocWork, TpPostWork, callback, tail call, JMP vs CALL, stack spoofing, call stack obfuscation, proxy frame, forward edge, backward edge, ROP, JOP, COP, return address spoofing, MOV [reg], RAX gadget, wininet GlobalGetUserAndPassW, x64 calling convention, shadow space, CFG, XFG, Intel CET, EDR call stack detection, PoolParty, AlternativeShellcodeExec, Moonwalk, ThreadPoolExecChain