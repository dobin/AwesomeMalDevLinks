Title:
Your BOFs are gross, put on a mask: how to hide beacon during BOF execution

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post describes a technique to temporarily encrypt (mask) Cobalt Strike Beacon’s in-memory code while a Beacon Object File (BOF) is executing, reducing the chance of EDR-triggered memory scans detecting Beacon signatures.  
- It focuses on finding Beacon’s base address and relevant memory ranges from within a BOF by walking stack frames to obtain a Beacon return address, then using `VirtualQuery` to resolve the allocation base and size.  
- The approach accounts for Malleable C2 and User-Defined Reflective Loader (UDRL) variations that change section protections/layout, requiring additional logic to locate the executable `.text` region rather than assuming a single RWX allocation.  
- Beacon is masked by changing page protections with `VirtualProtect` and applying a simple XOR across the target region, then unmasking before resuming Beacon execution.  
- The author demonstrates reduced detections in common memory scanners (Moneta, PE-sieve) and YARA rules when masking is enabled during BOF runtime.  
- It’s primarily useful for red teams/adversary simulation operators building BOFs, and secondarily for blue teams to understand memory-scanning evasion tradeoffs and residual indicators (e.g., unbacked RX regions).  

Technical Focus:
- Beacon Object Files (BOF) execution flow and in-process loaders  
- Stack frame walking / return-address discovery to locate Beacon code  
- `VirtualQuery` memory region enumeration and allocation boundary discovery  
- Section/page protection nuances (RWX vs per-section RX/RW) with Malleable C2/UDRLs  
- In-memory masking via `VirtualProtect` + XOR and operational constraints (Beacon API calls)  
- Memory-scanner/YARA evasion and remaining IOCs (unbacked executable regions)

Use Cases:
- Reduce signature-based memory-scan detections of Cobalt Strike Beacon during BOF execution
- Integrate Beacon masking/unmasking into custom BOFs (header-file drop-in approach)
- Test and validate EDR memory scanning behavior against masked vs unmasked Beacon
- Develop defensive detections focused on unbacked RX/RWX regions and BOF-related artifacts

Keywords:
Cobalt Strike, Beacon, BOF, Beacon Object File, Sleep Mask, in-memory encryption, XOR mask, VirtualQuery, VirtualProtect, memory scanning, EDR, Malleable C2, UDRL, reflective loader, .text section, unbacked executable memory, Moneta, PE-sieve, YARA, stack walking