# https://eversinc33.com/posts/avoiding-direct-syscalls.html

Avoiding direct syscall instructions by using trampolines


Published：2022-08-30 \|
Category：

[Malware Development](https://eversinc33.com/categories/Malware-Development/)

Recently, in order to prepare for an internal penetration testing engagement, I wanted to automate my payload generation. In order to do so, I created a packer for executables and shellcodes called MATROJKA. Since I’ve been a fan of Nim for malware development for some time, the choice to write my packer in Nim was an easy one. Nim has a beautiful syntax, transpiles to C, has great C and C++ (yes, real C++) integrations and is overall very fun to write in. (EDIT in 2024: just use C/C++. Nim is great, but it does have its caveats)

There are a few publicly available packers already that are based on Nim - most notably [@chvancooten](https://github.com/chvancooten/NimPackt-v1)’s NimPackt-v1 packer and [@icyguider](https://github.com/icyguider/Nimcrypt2)’s Nimcrypt2. NimPackt-v1 is a shellcode- and dotnet-assembly packer that is [actively used by threat actors in the wild](https://twitter.com/blackorbird/status/1553685027753365505). It’s second version, NimPackt-NG improves upon v1, but is, as of now, still private. Nimcrypt2 is a packer for shellcode, dotnet-assemblies and additionally supports regular portable executables.

Both NimPackt-v1 and Nimcrypt2 use SysWhispers (as implemented by [NimlineWhispers2](https://github.com/ajpc500/NimlineWhispers2)) to invoke direct syscalls in order to avoid EDR-hooks. If you don’t know what syscalls in Windows are, and what role they play in malware development and -detection, I can highly recommend this article by [@Cn33liz](https://outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/).

In short, syscalls are undocumented functions in `NTDLL.DLL` that are the closest to the kernel that we can get. In the end, any windows-API call calls one or more of these functions. If you for example call `WriteProcessMemory`, the syscall that is executed under the hood is `NtWriteVirtualMemory`. As such, AVs and EDRs like to hook some of these syscalls that are interesting to us malware developers, in order to inspect what is executed by a program. There are several methods to “unhook” these syscalls and make sure that our calls go to the kernel without being monitored - one example would be to reload a copy of `NTDLL.DLL` from disk, that is not yet hooked by the AV/EDR. Another is to find out the syscall numbers (which are different, depending on the Windows version) in some way and insert them into assembly stubs which we can be sure are not hooked, e.g. like this:

|     |     |
| --- | --- |
| ```<br>1<br>2<br>3<br>4<br>5<br>``` | copy<br>```<br>mov r10, rcx<br>mov eax, ["SYSCALL_NUMBER_TO_INSERT"]<br>// here would be where a hook would be inserted, that jumps to code that belongs to the AV/EDR<br>syscall<br>ret<br>``` |

This is what SysWhispers does - it generates assembly code that is then filled with the syscall numbers depending on the version of Windows that the code is running on.

## [Detecting direct syscalls made through SysWhispers](https://eversinc33.com/2022/08/30/avoiding-direct-syscall-instructions-by-using-trampolines\#Detecting-direct-syscalls-made-through-SysWhispers "Detecting direct syscalls made through SysWhispers") Detecting direct syscalls made through SysWhispers

The problem with using SysWhispers1 and SysWhispers2 (not 3 though) is that by now it is heavily signatured by most AVs and EDRs and most binaries generated with tools that leverage SysWhispers are easily flagged as malicious (I assume this is why Nimcrypt2 additionally supports using GetSyscallStub instead of NimlineWhispers2).

One simple way to detect the use of syscalls generated by SysWhispers is to check for direct `syscall` instructions. Usually, each syscall goes through `NTDLL.DLL`, which acts as Windows’ interface to kernel mode, so direct `syscall` instructions should (in theory) never occur and are highly suspicious.

[![Syscall instructions](https://eversinc33.com/images/objdump_syscall.png)](https://eversinc33.com/images/objdump_syscall.png) Syscall instructions

As such, Defender instantly removes a binary that includes NimlineWhispers2 (if no further evasion is applied) upon downloading it onto a Windows host:

[![Defender](https://eversinc33.com/images/defender.png)](https://eversinc33.com/images/defender.png) Defender

That meant that I had to look for a different way to invoke direct syscalls for my packer. I did not want to use [GetSyscallStub](https://github.com/S3cur3Th1sSh1t/NimGetSyscallStub/blob/main/GetSyscallStub.nim), since it is used by Nimcrypt2 and I figured that using a different technique would make my packer’s signatures more unique and thus less detectable.

## [Retrieve syscalls with HellsGate](https://eversinc33.com/2022/08/30/avoiding-direct-syscall-instructions-by-using-trampolines\#Retrieve-syscalls-with-HellsGate "Retrieve syscalls with HellsGate") Retrieve syscalls with HellsGate

Another technique that is widely used to retrieve syscall numbers, in order to invoke unhooked syscalls is HellsGate by @smelly\_\_vx and @am0nsec. You basically traverse the [`PEB` structure](https://malwareandstuff.com/peb-where-magic-is-stored/), until you reach the module list, get `NTDLL.DLL`’s base address and then traverse its [`Export Address Table`](https://dev.to/wireless90/exploring-the-export-table-windows-pe-internals-4l47) until you find the desired function. [API Hashing](https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware) is used to find the function name. Then, all that is left is to extract the syscall number from that function and you have everything you need to call that syscall directly, by using a syscall stub like above. You can read the paper at the [Vx-Underground Github](https://github.com/vxunderground/VXUG-Papers/tree/main/Hells%20Gate), which explains it more in-depth. Luckily, [zimawhit3](https://github.com/zimawhit3/HellsGateNim) already implemented HellsGate in Nim.

However, with HellsGate the same problem arises, since the assembly stubs that are populated with the retrieved syscall numbers also use the direct `syscall` instruction to invoke the syscall.

## [Make it bounce!](https://eversinc33.com/2022/08/30/avoiding-direct-syscall-instructions-by-using-trampolines\#Make-it-bounce "Make it bounce!") Make it bounce!

To make my syscalls seem more legit, I adjusted HellsGate, by simply replacing all `syscall` instructions with a trampoline jump - in this case a `JMP` instruction that jumps to the location of a `syscall` instruction located in `NTDLL.DLL`. This makes the syscalls seem more legit, as they originate from `NTDLL.DLL` and also avoids leaving any `syscall` instructions in the resulting binary. This technique is nothing new though, and was described e.g. in a [blog post by @passthehashbrowns](https://passthehashbrowns.github.io/hiding-your-syscalls). In fact, I later found out that this is what [SysWhispers3](https://klezvirus.github.io/RedTeaming/AV_Evasion/NoSysWhisper/) and [NimlineWhispers3](https://github.com/klezVirus/NimlineWhispers3) ended up using as a remediation (well…). However, I still see it as a way to improve HellsGate. EDIT: I found out that this modification to HellsGate has already been done and is known as [RecycledGate](https://github.com/thefLink/RecycledGate)

Thanks to Nim’s ability to write inline assembly, implementing this was a breeze:

First, I parsed `NTDLL.DLL` byte by byte until a `syscall` instruction is found. In binary representation, the `syscall` instruction and its prologue are `0x75 0x03 0x0F 0x05`, as can be seen when inspecting the DLL in x64dbg:

[![x64dbg](https://eversinc33.com/images/dbg.png)](https://eversinc33.com/images/dbg.png) x64dbg

Starting from the `NTDLL.DLL` module base address it doesn’t take long for one to find such an address. We just take the first one we find and save it to the global variable `syscallJumpAddress`:

|     |     |
| --- | --- |
| ```<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>``` | copy<br>```<br>proc getSyscallInstructionAddress(ntdllModuleBaseAddr: PVOID): ByteAddress =<br>    ## Get The address of a syscall instruction from ntdll to make sure all syscalls go through ntdll<br>    echo "[*] Resolving syscall..."<br>    echo "[*] NTDDL Base: " & $cast[int](ntdllModuleBaseAddr).toHex<br>    var offset: UINT = 0<br>    while true:<br>        var currByte = cast[PDWORD](ntdllModuleBaseAddr + offset)[]<br>        if "050F0375" in $currByte.toHex:<br>            echo "[*] Found syscall in ntdll addr " & $cast[ByteAddress](ntdllModuleBaseAddr + offset).toHex & ": " & $currByte.toHex<br>            return cast[ByteAddress](ntdllModuleBaseAddr + offset) + sizeof(WORD)<br>        offset = offset + 1<br>``` |

Now all that is left is to adjust the assembly code for each syscall and add a `JMP` to our address from above:

|     |     |
| --- | --- |
| ```<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>``` | copy<br>```<br>proc NtProtectVirtualMemory(ProcessHandle: Handle, BaseAddress: PVOID, NumberOfBytesToProtect: PULONG, NewAccessProtection: ULONG, OldAccessProtection: PULONG): NTSTATUS {.asmNoStackFrame.} =<br>    asm """<br>        mov r10, rcx<br>        mov eax, `ntProtectSyscall`<br>        # syscall                     # this is what we want to avoid<br>        mov r11, `syscallJumpAddress` # move syscall address into r11<br>        jmp r11			      # jump to syscall address<br>        ret<br>    """<br>``` |

When compiling the binary, we do not have any direct syscalls left anymore, which resulted in a much smaller detection rate for my packed payloads. Neat!

[![Clean objdump](https://eversinc33.com/images/objdump.png)](https://eversinc33.com/images/objdump.png) Clean objdump

Grabbing the first one available worked fine for me. One idea for improvement that is left is to control what `syscall` instruction we jump to and use this to e.g. fool an analyst that only observes the location of the syscall. EDIT 02/08/23: I just pushed changes that fix this. Now the `syscall` instruction that is corresponding to the actual syscall is taken instead.

The code for this technique is hosted at [https://github.com/eversinc33/BouncyGate](https://github.com/eversinc33/BouncyGate). Unfortunately, as opposed to SysWhispers/NimlineWhispers, you will have to add the function definitions for each Syscall that you need yourself (but you can still use those that NimlineWhispers generates).

Happy Hacking!

[Malware](https://eversinc33.com/tags/Malware/) [Syscalls](https://eversinc33.com/tags/Syscalls/) [Nim](https://eversinc33.com/tags/Nim/)

![](https://eversinc33.com/images/spools.png)

[Prev:\\
\\
\\
Windows Access Tokens: Getting SYSTEM and demystifying Potato Exploits](https://eversinc33.com/2022/11/25/windows-access-tokens-getting-system-and-demystifying-potato-exploits)