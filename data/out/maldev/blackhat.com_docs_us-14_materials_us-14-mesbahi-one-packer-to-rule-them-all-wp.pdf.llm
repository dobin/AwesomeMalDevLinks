Title:
One packer to rule them all: Empirical identification, comparison and circumvention of current Antivirus detection techniques

Type:
Research Paper

Short Summary (4–8 sentences max):
- This whitepaper empirically analyzes how major consumer AV products (circa 2014) detect Windows malware across three stages: static scanning, pre-execution code emulation, and runtime behavioral detection.  
- It introduces a dedicated Windows PE packer (x86 and x64) built around a Reflective DLL Injection–style loader to support a flexible C/C++ unpacking stub with dynamic import resolution and relocation handling.  
- Three packing strategies are compared: an “Inline” method (new section + changed entrypoint), a “New PE” method (rebuilding a new PE where encrypted original content is embedded into a large first section), and a “Resource Packer” method (embedding the encrypted payload as a resource inside a legitimate template PE and manually mapping it at runtime).  
- The authors show that many AV engines were heavily bypassable via packing, with the Resource Packer achieving near-total static evasion in their tests, while some vendors relied more on emulation to recover detection.  
- They also document anti-emulation checks (filesystem, timing, network, and instrumentation/DBI detection) that can prevent emulators from reaching the unpacked payload, and discuss runtime evasion ideas using inline API hooking, API translation, and junk API call injection.  
- A key finding is that x64 malware/tooling was substantially less well-detected than x86 at the time, making architecture choice itself an evasion lever.  
- Useful for red team tool developers, malware analysts, and defenders building packer/emulator detections or studying PE manipulation tradeoffs.

Technical Focus:
- Windows PE/PE+ internals (headers, sections, data directories, IAT, relocations, entrypoint)
- Custom packer design and stub injection strategies
- Reflective DLL loading / in-memory PE loading (manual mapping, import resolving, relocation)
- AV detection pipeline: static signatures vs emulation vs runtime heuristics
- Anti-emulation / anti-instrumentation techniques (timing, filesystem, network, parent process/module checks)
- Runtime evasion via inline hooking, API translation, and API call sequence obfuscation

Use Cases:
- Build or evaluate packers and loaders for controlled red-team simulations
- Develop defensive detections for packed binaries and anomalous PE structures
- Test AV emulator robustness against common anti-emulation tricks
- Compare x86 vs x64 detection coverage and prioritize defensive parity
- Research manual-mapping behaviors and runtime API-hooking indicators

Keywords:
antivirus evasion, packer, PE, PE+, x86, x64, static detection, signatures, heuristics, code emulation, runtime detection, reflective DLL injection, manual mapping, import address table, relocations, AddressOfEntryPoint, resource section, entropy, inline hooking, API translation, Sleep/GetTickCount timing, LoadLibrary, SMB port 445, instrumentation detection, process hollowing