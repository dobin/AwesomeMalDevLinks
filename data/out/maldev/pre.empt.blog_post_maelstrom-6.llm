Title:
Maelstrom #6 – ETW and AMSI (Windows native protections leveraged by modern EDR)

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post explains how modern EDRs leverage two built-in Windows telemetry/protection surfaces—Event Tracing for Windows (ETW, including ETW Threat Intelligence) and the Anti-Malware Scan Interface (AMSI)—to detect and sometimes prevent C2 implant behavior.  
- It walks through ETW’s controller/provider/consumer model, demonstrates collecting .NET runtime events (e.g., assembly loads and JIT activity) using `logman`, and shows how these traces can reveal reflective loading patterns.  
- The author then demonstrates a common ETW tamper technique: patching `ntdll!EtwEventWrite` in-memory (e.g., writing a `ret`) and discusses why this can still be suspicious due to “telemetry suddenly stops” heuristics and other correlated signals.  
- ETW Threat Intelligence (ETWTi) is highlighted as a kernel-backed source of high-value events (memory/process/thread manipulation) used for injection detection, with references to bypass strategies like “drip” allocations to evade simplistic correlation.  
- For AMSI, the post covers the API surface (`AmsiScanBuffer`, sessions, initialization), shows a memory-scanning example, and explains .NET Framework 4.8+ auto-loading/triggering AMSI scans for in-memory assembly loads.  
- It reviews historical AMSI bypasses (notably patching `AmsiScanBuffer` to return benign HRESULTs) and discusses “patchless” approaches using hardware breakpoints + vectored exception handlers, noting detectability.  
- Useful for red teamers/implant developers to understand what gets logged and why common bypasses are fragile, and for defenders to prioritize ETW/ETWTi/AMSI telemetry collection and correlation.

Technical Focus:
- ETW architecture (controllers, providers, consumers) and .NET runtime ETW providers
- ETW Threat Intelligence (ETWTi) telemetry for injection/memory operations
- In-memory patching of `EtwEventWrite` and operational side effects
- AMSI API usage and .NET 4.8+ AMSI auto-scanning of loaded assemblies
- AMSI bypass patterns: `AmsiScanBuffer` patching vs “patchless” VEH/hardware breakpoint interception
- Detection considerations: integrity checks, correlation, and “telemetry drop” heuristics

Use Cases:
- Build or test detections for reflective .NET loading and process injection using ETW/ETWTi
- Validate EDR visibility by creating ETW sessions with `logman` and inspecting ETL output
- Assess risk and detectability of ETW/AMSI tampering techniques in implants
- Implement defensive telemetry pipelines (e.g., ETW collection into SIEM/ELK) and correlate with other signals
- Research evasion limits (e.g., drip allocation strategies) against ETWTi-based injection logic

Keywords:
ETW, ETL, logman, Event Tracing for Windows, ETW Threat Intelligence, ETWTi, Microsoft-Windows-DotNETRuntime, Assembly.LoadFrom, JIT, reflective loading, ntdll, EtwEventWrite, VirtualProtect, memory patching, AMSI, AmsiInitialize, AmsiOpenSession, AmsiScanBuffer, HRESULT, vectored exception handler, hardware breakpoints, process injection detection