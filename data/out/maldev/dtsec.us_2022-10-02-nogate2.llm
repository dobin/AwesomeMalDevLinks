Title:
Abusing JIT compilation with Indirect Syscalls (NoGate2)

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post updates the author’s prior “JIT Tripping” work by making syscall usage in C#/.NET more consistent and evasive.  
- It compares .NET Framework 4.x vs .NET 5/6 JIT/CLR method table layouts, showing that Framework method table entries can point directly to JITted code while .NET 5/6 often uses a stub that jumps to the JITted body.  
- The core improvement is switching from direct syscalls to indirect syscalls by aligning registers in custom shellcode and then jumping to an existing `syscall` instruction inside `ntdll`, making returns and stack traces appear to originate from legitimate NT functions.  
- The technique can also “spoof” which NT function appears in the call stack by jumping to a `syscall` instruction located in a different `Nt*` routine than the one whose syscall number is loaded.  
- The author additionally hides syscall stubs inside JITted method memory (more stable than arbitrary code caves) and restores original bytes after use to reduce in-memory IOCs.  
- Useful for red teamers/pentesters and implant developers building .NET tradecraft (e.g., Mythic agents) who want to reduce user-mode syscall detection surface.

Technical Focus:
- CLR/.NET JIT internals (MethodTable entries, stubs vs direct code pointers)
- Indirect syscalls (jumping to `ntdll`’s `syscall` instruction)
- Call stack spoofing via mismatched syscall site vs syscall number
- In-memory patching/hiding of syscall stubs in JITted code regions
- Detection considerations for manual/direct syscalls (user-mode telemetry)

Use Cases:
- Implementing stealthier NTAPI invocation in C# implants without P/Invoke hooks
- Evading user-mode detections that flag direct/manual syscalls from non-`ntdll` regions
- Building syscall wrappers compatible across .NET Framework and .NET 5/6
- Reducing forensic artifacts by restoring patched JIT memory after execution

Keywords:
.NET, .NET Framework 4.x, .NET 5, .NET 6, CLR, JIT compilation, MethodTable, MethodHandle.GetFunctionPointer, MSIL, ntdll, NTAPI, indirect syscall, direct syscall, Hell’s Gate, DInvoke, call stack spoofing, user-mode hooking, Procmon, NtCreateUserProcess, NtCreateThreadEx, 0F 05 syscall instruction, EDR evasion