Title:
Loading DLLs Reflections

Type:
Blog Post

Short Summary (4–8 sentences max):
This post explains how to implement a reflective DLL loader on Windows that maps and executes a DLL directly from memory without writing it to disk, mimicking `LoadLibrary` behavior. It walks through the PE-loading steps required to make an in-memory DLL runnable: allocating memory for the image, copying headers/sections to their virtual addresses, applying base relocations when the preferred `ImageBase` can’t be used, and resolving imports by populating the IAT via `LoadLibraryA`/`GetProcAddress`. The author demonstrates the technique in both C and C# (unsafe code), focusing on loading into the current process and calling the DLL entry point (`DllMain`). It highlights attacker advantages (reduced on-disk AV scanning, fewer obvious module artifacts vs standard DLL injection) and shows how the mapped image appears as an RWX memory region rather than a loaded module. It also briefly covers reversing the loaders with Ghidra and dnSpy and notes basic defensive ideas like hunting for suspicious RWX allocations. Useful for red teams, malware analysts, and defenders wanting to understand reflective loading tradeoffs and detection points.

Technical Focus:
- Reflective DLL loading / in-memory PE mapping
- PE structures: `IMAGE_DOS_HEADER`, `IMAGE_NT_HEADERS`, `IMAGE_SECTION_HEADER`, Data Directories
- Base relocations (`IMAGE_DIRECTORY_ENTRY_BASERELOC`) and delta patching
- Import resolution / IAT patching (`IMAGE_DIRECTORY_ENTRY_IMPORT`, thunks)
- Windows memory APIs: `VirtualAlloc`, `VirtualFree`, `ReadProcessMemory`
- Entry point execution (`AddressOfEntryPoint`, `DllMain` invocation)

Use Cases:
- Fileless payload staging by downloading a DLL into memory and executing it
- Building custom loaders for post-exploitation frameworks (e.g., modular payload delivery)
- Malware/implant tradecraft research and PE loader education
- Defensive detection engineering for anomalous executable memory regions and manual-mapped images
- Incident response understanding of why payloads may not appear in module lists

Keywords:
reflective DLL loading, manual mapping, in-memory execution, PE parsing, IMAGE_NT_HEADERS64, SizeOfImage, ImageBase, AddressOfEntryPoint, base relocations, IMAGE_DIRECTORY_ENTRY_BASERELOC, import table, IAT patching, IMAGE_IMPORT_DESCRIPTOR, IMAGE_THUNK_DATA, LoadLibraryA, GetProcAddress, VirtualAlloc, PAGE_EXECUTE_READWRITE, RWX memory, DllMain, Ghidra, dnSpy, Windows Defender, Metasploit msfvenom