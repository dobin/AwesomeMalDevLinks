Title:
Reflective DLL injection and bootstrapping in C

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post walks through implementing reflective DLL injection in C, focusing on how a DLL can load itself from memory without using the normal Windows loader path.  
- It covers the “bootstrapping” steps needed to manually map a PE image: locating the module in memory, parsing PE headers, resolving imports, applying relocations, and invoking the DLL entry point.  
- The technique is commonly used to execute a DLL payload from a raw byte buffer (e.g., shellcode, network-delivered blob) and avoid touching disk.  
- It’s useful for red team/offensive tooling authors and malware developers building custom loaders, and for blue teams wanting to understand what artifacts and behaviors manual mapping produces.  
- The interesting part is the practical, low-level PE/loader logic that mirrors what `LdrLoadDll` does, enabling in-memory execution patterns that can bypass simplistic “LoadLibrary-only” detections.

Technical Focus:
- Reflective DLL injection (in-memory DLL loading)
- Manual PE mapping (sections, headers, memory protections)
- Import Address Table (IAT) resolution and export parsing
- Base relocations and ASLR handling
- Calling `DllMain` / entry point bootstrapping

Use Cases:
- Building a custom in-memory DLL loader for implants
- Executing DLL payloads from encrypted/packed buffers without dropping to disk
- Red team tradecraft research on injection/loader telemetry
- Defensive analysis: detecting manual-mapped modules vs standard loader modules

Keywords:
reflective DLL injection, manual mapping, PE format, DOS header, NT headers, section mapping, IAT, import resolution, export table, base relocations, ASLR, DllMain, loader stub, in-memory execution, Windows internals, process injection, shellcode loader, LdrLoadDll, LoadLibrary, GetProcAddress