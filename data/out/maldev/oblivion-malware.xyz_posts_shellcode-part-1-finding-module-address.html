# https://oblivion-malware.xyz/posts/shellcode-part-1-finding-module-address/

<!DOCTYPE html><html lang="en"><body><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">Shellcode - Pt 1: Finding Module(DLL) Address</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><h1 id="position-independent-code-pic">Position Independent Code (PIC)</h1><p>Position Independent Code (PIC) refers to code that is independent of the header and other sections besides the text section. It should be developed without using statically linked APIs and without global variables. Next, we extract its text section and save it in a <code class="language-plaintext highlighter-rouge">.bin</code> file for subsequent loading.</p><h1 id="retrieving-module-address">Retrieving Module Address</h1><p>First, lets start with an explanation of how this routine works. We will access the Process Environment Block (PEB). The PEB contains information about the process, including details like <code class="language-plaintext highlighter-rouge">ProcessParameters</code>, <code class="language-plaintext highlighter-rouge">CommandLine</code>, <code class="language-plaintext highlighter-rouge">ImageFile</code>, and others. However, what matters to us is the <code class="language-plaintext highlighter-rouge">Ldr</code>, which contain elements we need such as <code class="language-plaintext highlighter-rouge">InLoadOrderModuleList</code>, <code class="language-plaintext highlighter-rouge">InMemoryOrderModuleList</code> and it will be explained later.</p><p>Well, to retrieve the <a href="https://ntdoc.m417z.com/peb">PEB</a> address, I’ll show you two straightforward methods. One is by directly fetching the offset <code class="language-plaintext highlighter-rouge">0x60</code> in the GS segment register in <code class="language-plaintext highlighter-rouge">x86_64</code>, and in <code class="language-plaintext highlighter-rouge">x86</code>, it would be <code class="language-plaintext highlighter-rouge">0x30</code> in the <code class="language-plaintext highlighter-rouge">FS</code> segment register. The second method involves accessing the <a href="https://ntdoc.m417z.com/teb">Thread Environment Block (TEB)</a>, where you can find the <a href="https://ntdoc.m417z.com/peb">PEB</a> address. In <code class="language-plaintext highlighter-rouge">x86_64</code> systems, the <a href="https://ntdoc.m417z.com/teb">TEB</a> is located at <code class="language-plaintext highlighter-rouge">GS:0x30</code>.</p><p>In C, we have another alternative by using a binding like <a href="https://learn.microsoft.com/ms-my/windows/win32/api/winnt/nf-winnt-ntcurrentteb">NtCurrentTeb()</a> which returns a struct <a href="https://ntdoc.m417z.com/teb">_TEB</a>, and we can access the field ProcessEnvironmentBlock. If you’d like to delve deeper into this topic, and I highly recommend it, visit <a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block">https://en.wikipedia.org/wiki/Win32_Thread_Information_Block</a>.</p><p>Lets see in WinDbg how our <code class="language-plaintext highlighter-rouge">Walk</code> in the PEB would be until we reach the address of <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, with the command <code class="language-plaintext highlighter-rouge">!peb</code> we can have a good visualization of the structure.</p><p></p><p>We can observe that kernel32.dll is the third module loaded in the process because it lists in the loading order. <code class="language-plaintext highlighter-rouge">Kernel32.dll</code> expands to <code class="language-plaintext highlighter-rouge">kernelbase.dll</code> where all implementation is centralized; kernel32 only contains declarations, and the logic resides in another DLL, allowing Microsoft to alter it as desired. Every time an .exe is executed, it will always load ntdll first, followed by <code class="language-plaintext highlighter-rouge">kernel32.dll</code> and <code class="language-plaintext highlighter-rouge">kernelbase.dll</code>. Knowing this, we can use this information to find it, as I will show next.</p><p>Now we will use the command <code class="language-plaintext highlighter-rouge">dt nt!_peb</code> (display type) to visualize the structure from another perspective, as they are basically structures within structures.</p><p></p><p>We see that Ldr is a structure called <a href="https://ntdoc.m417z.com/peb_ldr_data">_PEB_LDR_DATA</a> which has the three elements I mentioned earlier, they are:</p><ol><li><code class="language-plaintext highlighter-rouge">InLoadOrderModuleList</code> – The order in which the modules(exes or dlls) get loaded</li><li><code class="language-plaintext highlighter-rouge">InMemoryOrderModuleList</code> – The order in which the modules(exes or dlls) get stored in memory</li><li><code class="language-plaintext highlighter-rouge">InInitializationOrderModuleList</code> – The order in which the modules(exes or dlls) get initialized within the process environment block.</li></ol><p></p><p>The <a href="https://ntdoc.m417z.com/peb_ldr_data">_PEB_LDR_DATA</a> leads us to an array of arrays structure called <a href="https://ntdoc.m417z.com/ldr_data_table_entry">_LDR_DATA_TABLE_ENTRY</a>, which contains very important information about the loaded modules such as <code class="language-plaintext highlighter-rouge">DllBase</code>, which is the module’s address, <code class="language-plaintext highlighter-rouge">SizeOfImage</code>, which is the size of the image in memory, <code class="language-plaintext highlighter-rouge">BaseDllName</code>, which is the name of the module, and others. Within <code class="language-plaintext highlighter-rouge">InMemoryOrderModuleList</code> and <code class="language-plaintext highlighter-rouge">InLoadOrderModuleList</code>, there is the memory address of the next structure in the array. As mentioned earlier, the default loading order of modules follows a specific sequence, so <code class="language-plaintext highlighter-rouge">kernel32.dll</code> will be the third one.</p><p>In the first image, the address of <a href="https://ntdoc.m417z.com/peb_ldr_data">LDR</a> was shown as <code class="language-plaintext highlighter-rouge">00007ffa3bc353e0</code>, so we will proceed with the command <code class="language-plaintext highlighter-rouge">dt nt!_PEB_LDR_DATA 00007ffa3bc353e0</code> and we will get the following response.</p><p></p><p>With the address of the first array in hand, using this same address to access the <a href="https://ntdoc.m417z.com/ldr_data_table_entry">_LDR_DATA_TABLE_ENTRY</a> structure, we will find the array corresponding to the first loaded module.</p><p></p><p>We need to pass the -10 because it is the offset of <a href="https://learn.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-list_entry">LIST_ENTRY</a>, as I will show in the following image.</p><p></p><p>And the next one will be kernel32.dll. Now, I will demonstrate a basic implementation of how to perform all these operations in NASM. I’ll explain each line in the code comments and the text.</p><h2 id="ldrmoduleaddr-in-nasm"><span class="me-2">LdrModuleAddr in NASM</span><a href="https://oblivion-malware.xyz/posts/shellcode-part-1-finding-module-address/#ldrmoduleaddr-in-nasm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>section .text                    ; Define the text section
global _start                    ; Define the entry point

_start:                          ; Entry point
    xor rax, rax                 ; Clear the rax register for use
    mov rax, [gs:0x30]           ; Retrieve the address of TEB (Thread Environment Block)
    mov rax, [rax + 0x60]        ; Go to offset 0x60, where the PEB (Process Environment Block) is located within TEB
    mov rax, [rax + 0x18 - 0x10] ; Go to offset 0x18 where Ldr is located and subtract 0x10 which is the offset of LIST_ENTRY
    mov rax, [rax]               ; Load the first module
    mov rax, [rax]               ; Load the second module
    mov rax, [rax + 0x30]        ; Load the third module + offset of DllBase
</pre></td></tr></tbody></table></code></div></div><p>You can perform a loop with a comparison of the module name (BaseDllName), and if successful, return the address of DllBase.</p><h2 id="ldrmoduleaddr-in-c"><span class="me-2">LdrModuleAddr in C</span><a href="https://oblivion-malware.xyz/posts/shellcode-part-1-finding-module-address/#ldrmoduleaddr-in-c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="n">PVOID</span> <span class="nf">LdrModuleAddr</span><span class="p">(</span> <span class="n">_In_</span> <span class="n">LPWSTR</span> <span class="n">ModuleName</span> <span class="p">){</span>

    <span class="n">PTEB</span>                  <span class="n">pTeb</span>  <span class="o">=</span> <span class="n">__readgsqword</span><span class="p">(</span><span class="mh">0x30</span><span class="p">);</span>
    <span class="n">PLDR_DATA_TABLE_ENTRY</span> <span class="n">Data</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">PLIST_ENTRY</span>           <span class="n">Head</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">PLIST_ENTRY</span>           <span class="n">Entry</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="n">Head</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">pTeb</span><span class="o">-&gt;</span><span class="n">ProcessEnvironmentBlock</span><span class="o">-&gt;</span><span class="n">Ldr</span><span class="o">-&gt;</span><span class="n">InLoadOrderModuleList</span><span class="p">;</span>
    <span class="n">Entry</span> <span class="o">=</span> <span class="n">Head</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">Head</span> <span class="o">!=</span> <span class="n">Entry</span> <span class="p">;</span> <span class="n">Entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">Flink</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">Data</span> <span class="o">=</span> <span class="n">C_PTR</span><span class="p">(</span> <span class="n">Entry</span> <span class="p">);</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">wccmp</span><span class="p">(</span><span class="n">Data</span><span class="o">-&gt;</span><span class="n">BaseDllName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">ModuleName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">HMODULE</span><span class="p">)</span><span class="n">Data</span><span class="o">-&gt;</span><span class="n">DllBase</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><p>It’s a very similar code, but here we apply a loop that compares the module name, and if it matches the one we input, its address will be returned via <code class="language-plaintext highlighter-rouge">DllBase</code>. Here we had two options: to use _<code class="language-plaintext highlighter-rouge">_readgsqword(0x30)</code> or <a href="https://learn.microsoft.com/ms-my/windows/win32/api/winnt/nf-winnt-ntcurrentteb">NtCurrentTeb()</a> to populate the created instance of the structure.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="https://oblivion-malware.xyz/categories/malware-development/">Malware Development</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="https://oblivion-malware.xyz/tags/windows/" class="post-tag no-text-decoration">Windows</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 "><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Shellcode%20-%20Pt%201:%20Finding%20Module(DLL)%20Address%20-%20Oblivion&amp;url=%2Fposts%2Fshellcode-part-1-finding-module-address%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Shellcode%20-%20Pt%201:%20Finding%20Module(DLL)%20Address%20-%20Oblivion&amp;u=%2Fposts%2Fshellcode-part-1-finding-module-address%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fshellcode-part-1-finding-module-address%2F&amp;text=Shellcode%20-%20Pt%201:%20Finding%20Module(DLL)%20Address%20-%20Oblivion" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="https://oblivion-malware.xyz/tags/windows/">Windows</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div>
</body></html>