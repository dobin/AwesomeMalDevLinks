Title:
ReflectiveLoading And InflativeLoading

Type:
Blog Post

Short Summary (4–8 sentences max):
- This write-up analyzes how Cobalt Strike Beacon’s “RAW” payload is still a PE/DLL with a patched DOS header that acts as a shellcode stub to jump into the exported `ReflectiveLoader`, enabling position-independent execution.  
- It explains reflective DLL loading (Stephen Fewer’s approach): locating the in-memory PE base, resolving APIs via PEB walking, allocating memory, copying headers/sections, fixing the IAT and base relocations, and finally calling `DllMain`.  
- The post highlights common reflective-loading IOCs such as RWX allocations, noisy memory permission changes, and “unbacked/private” executable memory that starts with `MZ`, which stands out in call stacks and memory hunting.  
- It then proposes “InflativeLoading”: prepend a one-page (0x1000) PIC stub to a *memory-dumped* PE image and perform loader fixups in-place (IAT, relocations, delay imports), reducing reliance on a `ReflectiveLoader` export and avoiding RWX regions.  
- The approach aims to make investigation harder by ensuring RX regions don’t begin with `MZ` and by minimizing classic reflective-loader artifacts, though it still benefits from pairing with techniques like module stomping to address unbacked memory.  
- Useful for red teamers/malware developers building custom in-memory loaders and for blue teamers understanding detection surfaces around reflective PE execution.

Technical Focus:
- PE format manipulation (DOS header patching, RVA/VA, section mapping)
- Reflective DLL loading workflow (IAT + base relocation fixing)
- PEB walking and export parsing for API resolution (LoadLibrary/GetProcAddress hashing)
- Memory permissions and allocation patterns (RWX vs RW→RX transitions)
- Unbacked/private executable memory and call-stack/symbol artifacts
- Loading from memory-dumped (“inflated”) images vs on-disk PE layout differences

Use Cases:
- Build/modify reflective loaders for DLL payloads without touching disk
- Convert a DLL/PE into position-independent “shellcode-like” execution via header/stub patching
- Implement an in-place loader for memory-dumped PE images to reduce common reflective IOCs
- Develop detections/hunts for reflective loading artifacts (MZ in private RX, suspicious IAT/reloc fixups)
- Combine with module stomping/hollowing to further reduce unbacked-memory indicators

Keywords:
Cobalt Strike Beacon, reflective loading, ReflectiveLoader, Stephen Fewer, ReflectiveDLLInjection, PE format, DOS header patching, position-independent code, PEB walking, export directory parsing, API hashing, LoadLibraryA, GetProcAddress, VirtualAlloc, CreateRemoteThread, IAT fixing, base relocations, delay import table, RWX memory, unbacked memory, private RX, module stomping, DllMain, NtQueryInformationProcess, ReadProcessMemory, WinDBG, MZ signature