Title:
pyobject_inject — executing shellcode directly from a Python variable

Type:
GitHub Tool

Short Summary (4–8 sentences max):
- This repository demonstrates a technique to execute shellcode directly from a Python bytes-like object without allocating a separate buffer.  
- It leverages CPython object layout by taking the object’s address via `id()` and adding a fixed offset (~32 bytes) to skip the `PyObject` header and reach the raw byte payload.  
- The code then changes memory protections with `VirtualProtect` to mark the region executable and runs it by casting the address to a callable (`ctypes.CFUNCTYPE`) and optionally executing it in a new thread.  
- It’s primarily a proof-of-concept “toy” for understanding CPython internals and in-memory execution tradeoffs, tested on Python 3.10–3.12 with varying reliability.  
- Useful for red teamers, exploit devs, and malware researchers exploring Python-based in-memory execution and detection implications.

Technical Focus:
- CPython `PyObject` memory layout and header offsets
- `id()` as an address leak / pointer primitive in CPython
- `ctypes` function pointer casting (`CFUNCTYPE`)
- Windows memory permission changes (`VirtualProtect`)
- Threaded shellcode execution from managed runtime memory

Use Cases:
- Prototype in-memory shellcode execution from Python without explicit `VirtualAlloc`
- Research CPython object layout stability across versions (3.10–3.12)
- Explore EDR/telemetry differences between Python-managed memory execution vs classic RWX allocation
- Build minimal PoCs for payload staging inside Python processes

Keywords:
Python, CPython, PyObject, id(), bytes object, memory offset, ctypes, CFUNCTYPE, shellcode, in-memory execution, VirtualProtect, Windows API, page permissions, executable memory, thread creation, code injection, runtime internals, pointer arithmetic