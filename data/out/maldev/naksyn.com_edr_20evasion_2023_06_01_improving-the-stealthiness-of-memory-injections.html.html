# https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html

<!DOCTYPE html><!--
    So Simple Jekyll Theme 3.2.0
    Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
    Free for personal and commercial use under the MIT license
    https://github.com/mmistakes/so-simple-theme/blob/master/LICENSE
--><html lang="en-US" class="js fontawesome-i2svg-active fontawesome-i2svg-complete">



  

    

  


  <body class="layout--post  improving-the-stealthiness-of-memory-injections-techniques">
    

    
  <div class="navigation-wrapper">
    <a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#menu-toggle" id="menu-toggle">Menu</a>
    
  </div><!-- /.navigation-wrapper -->


    <!-- /.masthead -->


    <main id="main" class="main-content" aria-label="Content">
  <article class="h-entry">
    

    <div class="page-wrapper">
      

      <div class="page-sidebar">
        <div class="page-author h-card p-author"><img src="https://naksyn.com/images/milky_way_150x150.jpg" class="author-avatar u-photo" alt="Naksyn"><div class="author-info"><div class="author-name">
        <span class="p-name">Naksyn</span>
      </div><ul class="author-links"><li class="author-link">
            <a class="u-url" rel="me" href="https://twitter.com/naksyn"><svg class="svg-inline--fa fa-twitter-square fa-w-14 fa-lg" title="Twitter" aria-labelledby="svg-inline--fa-title-1" data-prefix="fab" data-icon="twitter-square" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><title id="svg-inline--fa-title-1">Twitter</title><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z"></path></svg><!-- <i class="fab fa-twitter-square fa-lg" title="Twitter"></i> --></a>
          </li><li class="author-link">
            <a class="u-url" rel="me" href="https://github.com/naksyn"><svg class="svg-inline--fa fa-github-square fa-w-14 fa-lg" title="GitHub" aria-labelledby="svg-inline--fa-title-2" data-prefix="fab" data-icon="github-square" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><title id="svg-inline--fa-title-2">GitHub</title><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM277.3 415.7c-8.4 1.5-11.5-3.7-11.5-8 0-5.4.2-33 .2-55.3 0-15.6-5.2-25.5-11.3-30.7 37-4.1 76-9.2 76-73.1 0-18.2-6.5-27.3-17.1-39 1.7-4.3 7.4-22-1.7-45-13.9-4.3-45.7 17.9-45.7 17.9-13.2-3.7-27.5-5.6-41.6-5.6-14.1 0-28.4 1.9-41.6 5.6 0 0-31.8-22.2-45.7-17.9-9.1 22.9-3.5 40.6-1.7 45-10.6 11.7-15.6 20.8-15.6 39 0 63.6 37.3 69 74.3 73.1-4.8 4.3-9.1 11.7-10.6 22.3-9.5 4.3-33.8 11.7-48.3-13.9-9.1-15.8-25.5-17.1-25.5-17.1-16.2-.2-1.1 10.2-1.1 10.2 10.8 5 18.4 24.2 18.4 24.2 9.7 29.7 56.1 19.7 56.1 19.7 0 13.9.2 36.5.2 40.6 0 4.3-3 9.5-11.5 8-66-22.1-112.2-84.9-112.2-158.3 0-91.8 70.2-161.5 162-161.5S388 165.6 388 257.4c.1 73.4-44.7 136.3-110.7 158.3zm-98.1-61.1c-1.9.4-3.7-.4-3.9-1.7-.2-1.5 1.1-2.8 3-3.2 1.9-.2 3.7.6 3.9 1.9.3 1.3-1 2.6-3 3zm-9.5-.9c0 1.3-1.5 2.4-3.5 2.4-2.2.2-3.7-.9-3.7-2.4 0-1.3 1.5-2.4 3.5-2.4 1.9-.2 3.7.9 3.7 2.4zm-13.7-1.1c-.4 1.3-2.4 1.9-4.1 1.3-1.9-.4-3.2-1.9-2.8-3.2.4-1.3 2.4-1.9 4.1-1.5 2 .6 3.3 2.1 2.8 3.4zm-12.3-5.4c-.9 1.1-2.8.9-4.3-.6-1.5-1.3-1.9-3.2-.9-4.1.9-1.1 2.8-.9 4.3.6 1.3 1.3 1.8 3.3.9 4.1zm-9.1-9.1c-.9.6-2.6 0-3.7-1.5s-1.1-3.2 0-3.9c1.1-.9 2.8-.2 3.7 1.3 1.1 1.5 1.1 3.3 0 4.1zm-6.5-9.7c-.9.9-2.4.4-3.5-.6-1.1-1.3-1.3-2.8-.4-3.5.9-.9 2.4-.4 3.5.6 1.1 1.3 1.3 2.8.4 3.5zm-6.7-7.4c-.4.9-1.7 1.1-2.8.4-1.3-.6-1.9-1.7-1.5-2.6.4-.6 1.5-.9 2.8-.4 1.3.7 1.9 1.8 1.5 2.6z"></path></svg><!-- <i class="fab fa-github-square fa-lg" title="GitHub"></i> --></a>
          </li></ul>

<span class="read-time">21 min read</span>

    <time class="page-date dt-published" datetime="2023-06-01T00:00:00-04:00"><a class="u-url" href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html">June 1, 2023</a>
</time>

  </div>
</div>

        
  <h3 class="page-taxonomies-title">Categories</h3>
  
  <ul class="page-taxonomies"><li class="page-taxonomy"><a class="p-category" href="https://naksyn.com/categories/#edr-evasion" title="Pages filed under EDR evasion">EDR evasion</a></li>
  </ul>


        
  <h3 class="page-taxonomies-title">Tags</h3>
  
  <ul class="page-taxonomies"><li class="page-taxonomy"><a href="https://naksyn.com/tags/#cobalt-strike" title="Pages tagged cobalt strike" rel="tag">cobalt strike</a></li><li class="page-taxonomy"><a href="https://naksyn.com/tags/#evasion" title="Pages tagged evasion" rel="tag">evasion</a></li><li class="page-taxonomy"><a href="https://naksyn.com/tags/#injection" title="Pages tagged injection" rel="tag">injection</a></li><li class="page-taxonomy"><a href="https://naksyn.com/tags/#module-overloading" title="Pages tagged module overloading" rel="tag">module overloading</a></li><li class="page-taxonomy"><a href="https://naksyn.com/tags/#module-stomping" title="Pages tagged module stomping" rel="tag">module stomping</a></li><li class="page-taxonomy"><a href="https://naksyn.com/tags/#pyramid" title="Pages tagged pyramid" rel="tag">pyramid</a></li><li class="page-taxonomy"><a href="https://naksyn.com/tags/#python" title="Pages tagged python" rel="tag">python</a></li><li class="page-taxonomy"><a href="https://naksyn.com/tags/#redteam" title="Pages tagged redteam" rel="tag">redteam</a></li>
  </ul>


      </div>

      <div class="page-content">
        <div class="e-content">
          <p><img src="https://naksyn.com/images/injection-meme.png" alt="image-center" title="I can haz injection" class="align-center"></p>

<div id="entry-table-of-contents" class="toc-wrapper">
  <h2 id="toc-toggle" class="no_toc">
  Table of Contents <svg class="svg-inline--fa fa-chevron-down fa-w-14 toc-toggle-icon" aria-hidden="true" data-prefix="fas" data-icon="chevron-down" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"></path></svg><!-- <i class="toc-toggle-icon fas fa-chevron-down"></i> -->
</h2>
<ol id="markdown-toc">
  <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#tldr" id="markdown-toc-tldr">TL;DR</a></li>
  <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#credits" id="markdown-toc-credits">Credits</a></li>
  <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#intro" id="markdown-toc-intro">Intro</a>    <ol>
      <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#injection-categories" id="markdown-toc-injection-categories">Injection Categories</a>        <ol>
          <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#code-injection" id="markdown-toc-code-injection">Code Injection</a></li>
          <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#pe-injection" id="markdown-toc-pe-injection">PE Injection</a></li>
          <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#process-manipulation" id="markdown-toc-process-manipulation">Process Manipulation</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#improvement-strategy" id="markdown-toc-improvement-strategy">Improvement Strategy</a>    <ol>
      <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#moving-parts---injection-technique" id="markdown-toc-moving-parts---injection-technique">Moving Parts - Injection technique</a></li>
      <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#moving-parts---loader" id="markdown-toc-moving-parts---loader">Moving Parts - Loader</a></li>
      <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#moving-parts---payload" id="markdown-toc-moving-parts---payload">Moving Parts - Payload</a></li>
      <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#testing-with-memory-scanners" id="markdown-toc-testing-with-memory-scanners">Testing with memory scanners</a></li>
      <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#starting-point---pythonmemorymodule" id="markdown-toc-starting-point---pythonmemorymodule">Starting Point - PythonMemoryModule</a></li>
      <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#module-overloading" id="markdown-toc-module-overloading">Module Overloading</a></li>
      <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#module-stomping" id="markdown-toc-module-stomping">Module Stomping</a></li>
    </ol>
  </li>
  <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#module-shifting" id="markdown-toc-module-shifting">Module Shifting</a></li>
  <li><a href="https://naksyn.com/edr%20evasion/2023/06/01/improving-the-stealthiness-of-memory-injections.html#outro" id="markdown-toc-outro">Outro</a></li>
</ol>

</div>

<p>The topic has been presented at <a href="https://www.x33fcon.com/#!s/DiegoCapriotti.md">x33fcon 2023 Talk - Improving the Stealthiness of Memory Injection Techniques</a> (slide deck is available <a href="https://github.com/naksyn/talks/">here</a>)</p>

<h3 id="tldr">TL;DR</h3>

<p>Injection techniques can be grouped in three main categories:</p>

<ol>
  <li>Code Injection</li>
  <li>PE Injection</li>
  <li>Process Manipulation</li>
</ol>

<p>This post focuses on improving Module Stomping and Module Overloading, part of the PE injection techinques, that have been chosen as candidates because they avoid the creation of dynamic memory allocation and perform a common operation (LoadLibrary) that is the cornerstone of the technique.</p>

<p>The public implementation of Module stomping till date are getting “Modified Code” IoC by <a href="https://github.com/forrest-orr/moneta">Moneta</a> because of the stomped code living on the hosting dll.</p>

<p>Moneta will compare the dll bytes on disk with in-memory bytes and the output will be the “Modified Code” IoC.
This outcome can be avoided by looking at injection techniques from a higher level and thinking about a proper improvement strategy. In fact, there are several moving parts in an injeciton techniques:</p>

<ol>
  <li>the loader</li>
  <li>the injection technique</li>
  <li>the payload</li>
</ol>

<p class="notice--info"><strong>If we can keep the payload functionally independent from the stomped bytes, we can restore the stomped bytes and get rid of the “Modified Code” IoC that some module stomping public implementations bring.</strong></p>

<p>Module Overloading, on the other hand, requires having a PE payload living on a “hosting dll” and we cannot revert the copied bytes back to their original value, otherwise this will impair the payload execution.</p>

<p>However, Module Overloading can be improved by choosing the right hosting dll section where to write the payload, and by mimicking some seemingly “strange” behaviour held by windows and third party libraries that overwrite some of their very same PE section, leading to the “Modified Code IoC” with Moneta.</p>

<p>All these improvements led to a modified Module Stomping and Module Overloading technique that has been dubbed <a href="https://github.com/naksyn/ModuleShifting">Module Shifting</a>.
 To connect these concepts to my previous <a href="https://www.naksyn.com/edr%20evasion/2022/09/01/operating-into-EDRs-blindspot.html">Python research</a> I developed the PoC in Python ctypes such that it can be used dynamically with <a href="https://github.com/naksyn/Pyramid">Pyramid</a>.</p>

<h3 id="credits">Credits</h3>

<p>A huge thank you to the amazing people that published knowledge and tools instrumental to this work:</p>

<ul>
  <li>Aleksandra Doniec (hasherezade) for <a href="https://github.com/hasherezade/module_overloading">Module Overloading</a>, <a href="https://github.com/hasherezade/pe-sieve">PE-Sieve</a>, <a href="https://github.com/hasherezade/pe-bear">PE-Bear</a> and for technical discussions</li>
  <li>Forrest Orr for <a href="https://github.com/forrest-orr/moneta">Moneta</a> and his <a href="https://www.forrest-orr.net/blog">Memory Evasion blog series</a>.</li>
  <li>Kyle Avery for <a href="https://github.com/kyleavery/AceLdr">AceLdr</a></li>
  <li>Fsecure and Bobby Cooke for their public Module Stomping implementation <a href="https://blog.f-secure.com/hiding-malicious-code-with-module-stomping/">(1)</a><a href="https://github.com/boku7/Ninja_UUID_Runner">(2)</a></li>
</ul>

<h3 id="intro">Intro</h3>

<p>The purpose of the post is to improve some injection techniques, so to better understand the process involved we’ll try to answer the following questions:</p>

<ol>
  <li>What’s important to know about an injection and how can we choose between the myriad of available techniques</li>
  <li>How can we test the stealthiness and define a benchmark</li>
  <li>How can we improve an injection technique.</li>
</ol>

<p>In the realm of Offensive Cybersecurity, injection techniques play a pivotal role in various malicious activities.</p>

<p>These techniques involve the insertion of code or payloads into the memory space of legitimate processes, often enabling attackers to execute arbitrary actions covertly.</p>

<p>Among the various techniques, three main categories stand out: Code Injection, PE Injection, and Process Manipulation.</p>

<p>In this post, we will delve into the domain of PE Injection, focusing specifically on two advanced techniques: Module Stomping and Module Overloading.
Module Stomping and Module Overloading are intriguing techniques within the realm of PE Injection due to their ability to sidestep dynamic memory allocation and rely on a fundamental operation known as LoadLibrary.</p>

<p>These techniques, while effective, have been scrutinized for leaving traces that can be detected by advanced security tools like Moneta. Moneta’s detection mechanism involves comparing on-disk DLL bytes with in-memory bytes, effectively flagging modified code as an Indicator of Compromise (IoC). 
This post addresses the challenges posed by these techniques and presents an innovative approach to enhance their stealth and effectiveness.</p>

<h4 id="injection-categories">Injection Categories</h4>

<p>Since our aim is to improve the stealthiness of injection techniques, we’ll try to group the injection technique in categories and having a focus on the IoCs that are most commonly left by techniques in a same group.
This is by far not a comprehensive description of every injection techniques but the purpose is to provide some high-level overview so that we can better identify promising injection techniques to improve. 
If you need a more detailed overview, the <a href="https://www.youtube.com/watch?v=xewv122qxnk">Blackhat 2019 presentation - Process Injection Techniques: Gotta Catch Them All</a> can be beneficial.</p>

<h5 id="code-injection">Code Injection</h5>

<p>techniques included in this group insert and execute malicious code within a target process’s memory, typically involving dynamic memory allocation.
Some of the most common techniques in this group are:</p>
<ol>
  <li>Classic shellcode injection:
    <ul>
      <li>Allocate memory in the target process</li>
      <li>Write malicious code into the allocated memory</li>
      <li>Create a remote thread or execute via callback functions</li>
    </ul>
  </li>
  <li>APC injection:
    <ul>
      <li>Allocate memory in the target process</li>
      <li>Write malicious code into it</li>
      <li>queue APC</li>
      <li>Resume thread execution</li>
    </ul>
  </li>
  <li>Hook Injection
    <ul>
      <li>Intercept API calls made by the target process</li>
      <li>Redirect the intercepted API calls to the malicious code</li>
    </ul>
  </li>
  <li>Thread Local Storage injection
    <ul>
      <li>modify the target process’ PE header (TLS callback function)</li>
      <li>Execute the injected code as a TLS callback</li>
    </ul>
  </li>
  <li>Exception-Dispatching Injection
    <ul>
      <li>Allocate memory in the target process</li>
      <li>write malicious code into it</li>
      <li>modify the target process’ exception handler</li>
      <li>Trigger an exception in the target process</li>
    </ul>
  </li>
</ol>

<p>The most prevalent IoC for the techniques listed in this group is the <strong>Dynamic memory Allocation, usually made by VirtualAlloc and HeapAlloc API calls, and subsequent changes in memory permissions</strong> (RWX, RW then RX, etc.)
There are also technique-specific IoCs that are generated by some techniques, but they are very peculiar and can generally be fingerprinted by security vendors once a technique becomes public, so for that matter we are mostly interested in the common IoCs shared by most of the techniques in a group, so that we have a simpler map of an injection category and traces left by most of the techniques.</p>

<h5 id="pe-injection">PE Injection</h5>

<p>Techniques included in this group inject a Portable Executable (PE) file such as dlls or exes into the address space of a running process.
Some of the most common techniques in this group are:</p>
<ol>
  <li>Classic dll injection:
    <ul>
      <li>Drop dll on disk</li>
      <li>allocate memory to target process and write malicious dll</li>
      <li>Load dll using LoadLibrary or similar method</li>
    </ul>
  </li>
  <li>Reflective dll injection
    <ul>
      <li>Reflective loader is part of the malicious dll</li>
      <li>the loader loads and map the malicious dll into target process without actually calling LoadLibrary or other Windows API.</li>
      <li>Resolve dependencies and perform relocations</li>
    </ul>
  </li>
  <li>MemoryModule
    <ul>
      <li>similar to reflective dll injection but the loader code is external and not embedded in the dll itself.</li>
      <li>this technique is more flexible since it allows the loading of unmodified dlls.</li>
    </ul>
  </li>
  <li>Module Stomping
    <ul>
      <li>Load a dll into the target process</li>
      <li>Overwrite dll’s section/s with shellcode and execute it</li>
    </ul>
  </li>
  <li>Module Overloading
    <ul>
      <li>Load a dll into the target process</li>
      <li>Overwrite loaded dll memory space with malicious PE</li>
    </ul>
  </li>
</ol>

<p>By injecting a PE, we are requiring that PE to run on the overwritten dlls’ bytes and this would typically mean that the PE is a “final” payload that does not load or execute further stages. On the other hand, by using shellcode (i.e. Module Stomping) an attacker can craft a more stealthier approach by using a shellcode that is loading a final payload in another area of memory.
As we’ll see later in the post, this is a key property that enables some improvements in the injection technique.</p>

<p>Injection techniques in this group mostly leverage, or mimic, a normal dll loading operation such as LoadLibrary. This is a key element that can provide an avenue for attackers to better blend into environments while injecting.</p>

<h5 id="process-manipulation">Process Manipulation</h5>

<p>Techniques included in this group are used to manipulate or modify the memory and execution context of running processes, libraries, or creating new processes with malicious payloads.
Some of the most common techniques in this group are:</p>
<ol>
  <li>Process Hollowing:
    <ul>
      <li>Create process in suspended state</li>
      <li>Replace memory contents with malicious executable</li>
      <li>Resume execution</li>
    </ul>
  </li>
  <li>Process doppelgänging
    <ul>
      <li>Abuse NTFS transactions to load a malicious executable within the context of a legitimate process</li>
    </ul>
  </li>
  <li>Sideloading
    <ul>
      <li>Drop dll on disk</li>
      <li>Abuse windows dll search order or missing dlls to load a malicious dll into a legitimate process</li>
    </ul>
  </li>
  <li>Thread Execution Hijacking
    <ul>
      <li>Suspend a thread in the target process</li>
      <li>Modify instruction pointer to execute malicious code</li>
    </ul>
  </li>
</ol>

<p>The most prevalent IoCs generated by these techniques are <strong>alterating the context or normal execution flow of a PE</strong> (suspend execution state, abuse dll search order).<br>
While this category contain some very powerful techniques, such as sideloading, we might want to first look for techniques that leverages mostly legitimate process’ operations and do not alter execution flow, in order to get more chances of blending into an environment without standing out as odd behaviour.</p>

<h3 id="improvement-strategy">Improvement Strategy</h3>

<p>Before diving into the improvement phase, we should have a proper strategy under our sleeves since the injection technique is not a single element but it is part of a <strong>chain composed by the injection technique, loader and the payload as their main moving parts</strong>.</p>

<p>The most prevalent IoC for these techniques is that <strong>the PE (dll or exe) or shellcode, is residing in memory of a (legitimate) loaded dll</strong>. This will lead to a mismatch between in-memory bytes and on-disk dll’s bytes caused by the overwriting of the loaded dll memory space with malicious code.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://naksyn.com/images/movingparts.png" alt="image-center" title="Moving parts of an injection Technique" class="align-center"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>Moving parts of an injection Technique</em></td>
    </tr>
  </tbody>
</table>

<h4 id="moving-parts---injection-technique">Moving Parts - Injection technique</h4>

<p>The injection technique should not be seen as an isolated element, because its choice can be influenced by the payload or the loader. 
For example, if your payload to be injected is a PE, you’ll basically limit your injection options to the PE injection category.
Similarly, if you choose to use an embedded loader to load a dll, you’re narrowing down to reflective dll injection.</p>

<p>An attacker should choose an injection technique primarily based on operational considerations, some common drivers might be:</p>
<ul>
  <li>use an injection to emulate a predefined Threat Actor.</li>
  <li>choose an injection that is more likely to blend into an environment</li>
  <li>use an injection that can bypass a the security solution the attacker is up against (not necessarily blending into the environment).</li>
</ul>

<p>We are mostly interested in <strong>blending into an environment</strong>, because this can bring the broadest operational depth. For this reason, two key features that the Injection technique should have are:</p>
<ol>
  <li>Avoidance of dynamic memory allocation (via VirtualAlloc or HeapAlloc).</li>
  <li>Usage of a legitimate process operation</li>
</ol>

<p>Looking for injection techniques techniques with these characteristics we can recall from the Introductory overview that Module Stomping and Module Overloading are two injection techniques that leverage the legitimate LoadLibrary operation to avoid dynamic memory allocation such that malicious shellcode or PE can be written over the loaded dll memory space.</p>

<p>For this reason we chose to <strong>target Module Stomping and Module Overloading</strong> and look for ways to improve them.</p>

<h4 id="moving-parts---loader">Moving Parts - Loader</h4>

<p>The purpose of the loader is to execute the injection technique itself, eventually loading and executing a payload. There are mainly three types of loaders:</p>

<ol>
  <li><strong>embedded</strong> - the loader is part of the payload (usually a PE). 
 For example, reflective dll injection uses an embedded loader that is coded in the dll and bootstraps the loading process of the dll itself.</li>
  <li><strong>external</strong> - the loader is not part of the payload, it’s typically a standalone PE that gets a shellcode, BOF or PE as input payload and kicks off the injection technique. The payload can be written within a section of the loader itself or can be downloaded/read from disk/pipe.</li>
  <li><strong>interpreted</strong> - this loader is coded in an interpreted language and executed by the code interpreter. This kind of loaders do not need a purposely compiled PE to run and can be executed in memory by the interpreter that need to be present or dropped on the target.</li>
</ol>

<p>Building upon my previous Python research, our strategy is adopting an interpreted loader because we’ll want to avoid the generation of suspicious PE loaders that generally have a very short life-span can be easily fingerprinted and leverage the powerful evasion properties that Python brings to the game:</p>
<ol>
  <li>Python embeddable package comes with a signed interpreter that can be dropped on the target</li>
  <li>Coding the loader using Python ctypes allows to <strong>dynamically execute wrapped C language</strong> code via Python. We can essentially execute any Windows API using Python via the signed interpreter.</li>
  <li>Combining Python with Pyramid allows to in-memory import Python modules and execute complex operations entirely in memory.</li>
  <li>We can avoid the usage of compiled PE for injection.</li>
  <li>We can avoid AMSI inspection (there’s no AMSI for Python) and AV/EDR inspection of dynamic Python code (there’s no introspection for dynamic Python code).</li>
</ol>

<h4 id="moving-parts---payload">Moving Parts - Payload</h4>

<p>The final stage of an injection technique is to achieve payload execution, that’s essentially code to be run on a target machine.
In the context of Memory Injection, payloads can come in the form of:</p>
<ol>
  <li>PE (executables or dlls)</li>
  <li>Position Independent Code (Shellcode, BOFs, etc.)</li>
</ol>

<p>PE payloads are usually less flexible than shellcode because of their size (PE Header and sections’ overhead) and they’re also rarely used to stage further malware, instead they’re often intended as “final” payloads containing the core of the malware.
Furthermore, the size constrait make PE an unviable candidate for injection techniques where little space is available.</p>

<p>On the other hand, shellcode has more flexibility and evasion properties:</p>
<ul>
  <li>Shellcode can be used to load further stages payloads (even a PE) and can be made independent from final payloads, meaning that once the shellcode loaded and started the final payload, it can be erased without impairing the functionality of the final payload itself.</li>
  <li>Shellcode can be shrank (using stagers for example) to fit small space constraints.</li>
  <li>Position Independent Code payloads can be obfuscated <a href="https://github.com/codewhitesec/Lastenzug">at the assembly level</a></li>
</ul>

<p>For this reasons we’ll choose shellcode as payload and to make it independent from further stages we’ll use a stageless Cobalt Strike generated with AceLdr shellcode.</p>

<p>AceLdr shellcode will load a copy of Beacon on the Heap and it’ll apply advanced in-memory evasion techniques. 
The scope of this blogpost is improving the injection technique rather than the payloads, so we’ll be focusing on the artifacts that the injection technique is leaving behind.</p>

<h4 id="testing-with-memory-scanners">Testing with memory scanners</h4>

<p>In the realm of cybersecurity, understanding and mitigating novel threats is paramount. For this purpose, great professionals like Aleksandra Doniec and Forrest Orr published 
<a href="https://github.com/forrest-orr/moneta">Moneta</a> and <a href="https://github.com/hasherezade/pe-sieve">Pe-Sieve</a>, that are state-of-the-art publicly available memory scanners designed to detect sophisticated memory-based attacks.</p>

<p>Moneta excels in identifying the presence of dynamic/unknown code and suspicious characteristics of the mapped PE image regions, which are often telltale signs of an attack.
On the other hand, Pe-Sieve is designed to identify suspicious memory regions based on malware IOCs and uses a variety of data analysis tricks to refine its detection criteria. 
These tools were originally designed for defenders, but could be also used by attackers to improve their craft.</p>

<p>When we delve into the intricacies of memory injection techniques like Module stomping and Module overloading, both these tools become instrumental. 
By utilizing these scanners, we can identify the improvement opportunities in these injection techniques, making it possible to enhance their efficiency when deploying shellcode and ensuring they remain undetected by modern defense mechanisms.</p>

<p>Having these tools at hand is also beneficial infinding some weird common behaviours that we can use to our advantage to better blend in. 
For example, running Moneta on all processes on a Windows 10 Operating system and inspecting its results, can lead to interesting findings.</p>

<p>In fact, some .NET dlls are known to do self-modifications on their .text section, leading to the Moneta’s “Modified Code” IoC. 
Third-party apps like Discord and Signal also have the same behaviour, it’s interesting to note that the size of the bytes that they’re overwriting is bigger in the latter cases.</p>

<p>Generally, the bigger the size the dll is self-modifying, the better, since an attacker can smuggle a bigger payload and mimick the exact same behaviour of the legitimate applications.
In particular, security solutions would probably whitelist this behaviour otherwise they’ll be overwhelmed by false positives and customers will be unhappy.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://naksyn.com/images/FP1.png" alt="image-center" title="False Positives - self-modifying behaviours done by legitimate applications" class="align-center"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>False Positives - self-modifying behaviours done by legitimate applications</em></td>
    </tr>
  </tbody>
</table>

<h4 id="starting-point---pythonmemorymodule">Starting Point - PythonMemoryModule</h4>

<p>After defining the strategy, we should start somewhere and iterate to improve. Our starting point is the MemoryModule technique, that is instrumental to the Module Overloading injection that we’ll target later on.</p>

<p>MemoryModule is a technique <a href="https://www.joachim-bauch.de/tutorials/loading-a-dll-from-memory/">firstly published</a> by Joachim Bauch and is used to map and load a dll in memory without calling the LoadLibrary Windows API.
This is achieved by executing the same operations done by the Windows Loader when issuing the LoadLibrary API call
The following image depicts its basic steps:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://naksyn.com/images/PythonMM.png" alt="image-center" title="MemoryModule technique" class="align-center"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>MemoryModule technique</em></td>
    </tr>
  </tbody>
</table>

<p>In order to use the MemoryModule technique with a Python interpreted loader, the technique has been ported to Python ctypes and is available <a href="https://github.com/naksyn/PythonMemoryModule">on my PythonMemoryModule github project</a>.</p>

<p>Combining the PythonMemoryModule project with <a href="https://github.com/naksyn/Pyramid">Pyramid</a> we can achieve the injection of a Cobalt Strike dll with MemoryModule technique using a full in-memory Python loader.
In the following video we’ll demostrate the injection and the scanning results of Moneta and PE-Sieve on the injected process.</p>

<video width="100%" preload="auto" height="auto" max-width="100px" muted="" controls="">
    <source src="https://naksyn.com/videos/PythonMM.mp4" type="video/mp4">
</video>

<p>In summary, PythonMemoryModule used with a Cobalt Strike dll is producing the following IoCs:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://naksyn.com/images/IoCMM.png" alt="image-center" title="IoCs generated by MemoryModule and Cobalt Strike dll Artifact" class="align-center"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>IoCs generated by MemoryModule and Cobalt Strike dll Artifact</em></td>
    </tr>
  </tbody>
</table>

<p>The Abnormal Private executable Memory IoC detected at 0x6bac1000 is due to the MemoryModule injection technique that copied the .text section at that address and changed its permissions to RX subsequently.</p>

<p>The other abnormal private executable memory IoC is generated because Cobalt Strike dll is self-bootstrapping Beacon in another area of memory (0x1c575a90000) so we basically here have two PEs in memory that are generating IoCs but only one is running Beacon.
Dynamic memory allocation would necessarily nead to “Abnormal Private Executable Memory” IoC at some point, se we would want to get rid of this IoC in the first place.</p>

<p>Module Overloading and Module Stomping techniques can provide us a way to avoid dynamic memory allocation.</p>

<h4 id="module-overloading">Module Overloading</h4>

<p>Module Overloading technique, firstly <a href="https://github.com/hasherezade/module_overloading">published by Aleksandra Doniec</a>, aims at avoiding the creation of dynamic memory allocation by firstly loading a hosting dll using LoadLibrary API, overwriting malicious content (PE) onto it, and loading it using the same Memory Module steps we saw earlier.</p>

<p>In this way the legitimate hosting dll is loaded via LoadLibrary API, but malicious content is loaded using the Memory Module technique over the memory space of the hosting dll that is legitimately loaded. This clever mix makes the Module Overloading Technique.</p>

<p>At a high level, Module Overloading steps (as implemented by Aleksandra Doniec) look like this:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://naksyn.com/images/moduleoverloading.png" alt="image-center" title="Module Overloading injection technique" class="align-center"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>Module Overloading injection technique</em></td>
    </tr>
  </tbody>
</table>

<p>Even though this technique is stealthier than Memory Module, we still have some IoCs to work on. Specifically, Moneta will identify “Modified Code” and “Modified Header” as IoCs after executing the injection.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://naksyn.com/images/moduleoverloadingIoCs.png" alt="image-center" title="Module Overloading IoCs" class="align-center"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>Module Overloading IoCs</em></td>
    </tr>
  </tbody>
</table>

<p>This result stems from the fact that we overwrote the hosting dll memory space with malicious content, so when Moneta and PE-Sieve are doing a comparison between on-disk bytes of the hosting dll with its memory counterpart this will mismatch and fire the “Modified Code” and “Replaced” IoC if the overwriting happen to come across the hosting dll’s mapped .text section.</p>

<p>The “Modified Header” IoC is generated because this technique implementation starts overwriting from the very top of the hosting dll memory space, thus overwriting the PE header that commonly happens to reside in the first 0x1000 bytes.</p>

<p>All things considered, we got rid of the MemoryModule’s “Abnormal Private Executable memory” IoC but we introduced other IoCs related to the hosting dll byte-by-byte comparison between on-disk and memory space.</p>

<p>However, we can improve a bit this outcome by introducing Module Stomping injection technique.</p>

<h4 id="module-stomping">Module Stomping</h4>

<p>Module stomping provides the same Module Overloading benefit of avoiding dynamic memory creation through the loading of a hosting dll to be used as “disposable space” onto which overwrite malicious content.
The main difference is that Module Stomping is way more simpler than Module Overloading because its aim is writing and executing shellcode, not a PE. So we don’t need the Windows Loader steps that both Memory Module and Module Overloading adopted, with Module Stomping we just need to write and directly executing shellcode.</p>

<p>Some Module Stomping implementations have been made publicly available by <a href="https://blog.f-secure.com/hiding-malicious-code-with-module-stomping/">F-Secure</a> and <a href="https://github.com/boku7/Ninja_UUID_Runner/">Bobby Cooke</a></p>

<p>At a high level, Module Stomping steps look like this:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://naksyn.com/images/modulestomping.png" alt="image-center" title="Module Stomping injection technique" class="align-center"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>Module Stomping injection technique</em></td>
    </tr>
  </tbody>
</table>

<p>After injecting via Module Stomping using wmp.dll as hosting dll and writing the malicious shellcode over the .rsrc section we obtain the IoCs depicted in the following image.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://naksyn.com/images/modulestompingIoCs.png" alt="image-center" title="Module Stomping IoCs" class="align-center"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>Module Stomping IoCs</em></td>
    </tr>
  </tbody>
</table>

<p>We gradually reduced the generated IoCs but “Modified Code” is still haunting us because it’s a trademark for both Module Stomping and Module Overloading technique.
The “inconsistent +x between disk and memory” is obtained because of the shellcode written over the .rsrc section and subsequent +RX permission set.
Moneta is complaining about the fact that .rsrc section originally does not have executable permission.</p>

<p>Both of these IoCs can be finally avoided with some improvements that are implemented in a technique dubbed “Module Shifting”.</p>

<h3 id="module-shifting">Module Shifting</h3>

<p>Till now we observed how some injections behave in memory and gained a bit of knowledge of how and why memory scanners identifiy suspicious memory anomalies.</p>

<p>We can use this knowledge to our advantage by asking ourself few what-if questions:</p>

<ol>
  <li>what if the writing of the shellcode is shifted to a section of a dll that is normally self-modifying the exact section?</li>
  <li>what if we inject using a self-modifying dll as host with enough space to write our shellcode and we apply some padding to look exactly as the self-modifying behaviour?</li>
  <li>what if we use a shellcode payload that is functionally independent from further stages and we overwrite the executed shellcode with the dll’s original bytes?</li>
</ol>

<p>After experimenting and answering all these questions we came up with the <a href="https://github.com/naksyn/ModuleShifting">Module Shifting technique</a> that aims at improving Module Stomping and Module Overloading by providing the following advantages:</p>

<ol>
  <li>Avoids “Modified code” between virtual memory and on disk dll leaving near to zero suspicious memory artifacts, getting no indicators on Moneta and PE-Sieve</li>
  <li>better blending into common False Positives by choosing the target section and using padding</li>
  <li>Can be used with PE and shellcode payloads</li>
  <li>Implemented in Python ctypes – full-in-memory execution available</li>
</ol>

<p>At a high level, Module Shifting steps look like this:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://naksyn.com/images/moduleshifting.png" alt="image-center" title="Module Shifting Injection technique" class="align-center"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>Module Shifting Injection technique</em></td>
    </tr>
  </tbody>
</table>

<p>The restore operation is quite simple and is done after executing the initial shellcode.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="c1"># Restore operation &nbsp; &nbsp; 
</span>        <span class="n">VirtualProtect</span><span class="p">(</span>
<span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="n">cast</span><span class="p">(</span><span class="n">tgtaddr</span><span class="p">,</span><span class="n">c_void_p</span><span class="p">),</span> 
<span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="n">mod_bytes_size</span><span class="p">,</span>
<span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="n">PAGE_READWRITE</span><span class="p">,</span> <span class="err">&nbsp;</span>
<span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="n">byref</span><span class="p">(</span><span class="n">oldProtect</span><span class="p">))</span>
<span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="err">&nbsp;</span> <span class="n">memmove</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">tgtaddress</span><span class="p">,</span><span class="n">c_void_p</span><span class="p">),</span> <span class="bp">self</span><span class="p">.</span><span class="n">targetsection_backupbuffer</span><span class="p">,</span> <span class="n">mod_bytes_size</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>After setting the shellcode memory area permissions to RW the content of <strong>targetsection_backupbuffer</strong>, containing a copy of the original dll for the same exact amount of shellcode bytes and position, gets written over the shellcode.
This effectively restores the stomped bytes to the original ones, leaving no traces of the written shellcode anymore.
In this way, Moneta and PE-Sieve will do a byte-by-byte comparison as usual and will find no mismatch between the hosting dll on-disk bytes and in-memory ones.</p>

<p>There won’t be also any inconsistent executable permissions because we set the permissions back to the section’s original values.</p>

<p>Following is a demonstration of a self-process injection with Module Shifting technique using a Cobalt Strike Beacon shellcode generated with AceLdr.
<strong>After executing Moneta and PE-Sieve we get no IoCs detected</strong> because there are no artifacts left by Module Shifting injection technique (payload is not our focus), that was our initial aim.</p>

<video width="100%" preload="auto" height="auto" max-width="100px" muted="" controls="">
    <source src="https://naksyn.com/videos/moduleshifting.mp4" type="video/mp4">
</video>

<p>Even though Moneta and PE-Sieve did not generate IoCs, a runtime inspection scanner could identify some anomalies.
In fact, overwriting a 307,2 kB payload over the .text section of mscorlib.ni.dll can be a malicious indicator because the common behaviour for this dll is to overwrite 45 kB.</p>

<p>However, this anomaly could not be spotted by scanners without runtime inspection capabilities, because Module Shifting does not leave artifacts floating around after having restored the stomped bytes.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="https://naksyn.com/images/detopp.png" alt="image-center" title="Detection Opportunities" class="align-center"></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>Detection Opportunities</em></td>
    </tr>
  </tbody>
</table>

<h3 id="outro">Outro</h3>

<p>Concluding this exploration, we dove deep into the intricacies of injection techniques, honing in on Module Stomping and Module Overloading as part of the PE injection arsenal.</p>

<p>The objective was clear: to improve these techniques, aiming for more operational stealthiness.
We delved into the journey of improving memory injection techniques
While traditional approaches like Module Stomping faced challenges with “Modified Code” IoC due to the stomped code’s residence in the hosting dll, we’ve delineated a strategy to finally circumvent these obstacles. 
The newly introduced Module Shifting technique encapsulates these enhancements, offering a more nuanced way to to operate with a greater stealthiness.</p>

<p>The key takeaways for this blog post are:</p>

<ol>
  <li>Injection Techniques have several moving parts</li>
  <li>Python can be used as a loader with Pyramid and ctypes to dynamically call windows APIs</li>
  <li>Memory IoCs can be greatly reduced with a proper injection strategy</li>
  <li>Memory scanners can be used by attackers to find False Positives candidates to blend in</li>
  <li>Functionally-independent Shellcode payloads once injected and executed can be overwritten with original dll content</li>
  <li>ModuleShifting improvements can be applied also to other injection techniques</li>
</ol>

<p>The future of injection techniques is always evolving, and the landscape will continually shift towards greater sophistication and precision.</p>

        </div>

        
          <div class="page-share">
  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2F0.0.0.0%3A4000%2Fedr%2520evasion%2F2023%2F06%2F01%2Fimproving-the-stealthiness-of-memory-injections.html" class="btn btn--facebook btn--small"><svg class="svg-inline--fa fa-facebook fa-w-14 fa-fw" aria-hidden="true" data-prefix="fab" data-icon="facebook" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M448 56.7v398.5c0 13.7-11.1 24.7-24.7 24.7H309.1V306.5h58.2l8.7-67.6h-67v-43.2c0-19.6 5.4-32.9 33.5-32.9h35.8v-60.5c-6.2-.8-27.4-2.7-52.2-2.7-51.6 0-87 31.5-87 89.4v49.9h-58.4v67.6h58.4V480H24.7C11.1 480 0 468.9 0 455.3V56.7C0 43.1 11.1 32 24.7 32h398.5c13.7 0 24.8 11.1 24.8 24.7z"></path></svg><!-- <i class="fab fa-fw fa-facebook" aria-hidden="true"></i> --> <span>Share</span></a>
  <a href="https://twitter.com/intent/tweet?text=Improving+the+stealthiness+of+memory+injections+techniques%20http%3A%2F%2F0.0.0.0%3A4000%2Fedr%2520evasion%2F2023%2F06%2F01%2Fimproving-the-stealthiness-of-memory-injections.html" class="btn btn--twitter btn--small"><svg class="svg-inline--fa fa-twitter fa-w-16 fa-fw" aria-hidden="true" data-prefix="fab" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg><!-- <i class="fab fa-fw fa-twitter" aria-hidden="true"></i> --> <span>Tweet</span></a>
  <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3A%2F%2F0.0.0.0%3A4000%2Fedr%2520evasion%2F2023%2F06%2F01%2Fimproving-the-stealthiness-of-memory-injections.html" class="btn btn--linkedin btn--small"><svg class="svg-inline--fa fa-linkedin fa-w-14 fa-fw" aria-hidden="true" data-prefix="fab" data-icon="linkedin" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg><!-- <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> --> <span>LinkedIn</span></a>
  <a href="https://reddit.com/submit?title=Improving+the+stealthiness+of+memory+injections+techniques&amp;url=http%3A%2F%2F0.0.0.0%3A4000%2Fedr%2520evasion%2F2023%2F06%2F01%2Fimproving-the-stealthiness-of-memory-injections.html" class="btn btn--reddit btn--small"><svg class="svg-inline--fa fa-reddit fa-w-16 fa-fw" aria-hidden="true" data-prefix="fab" data-icon="reddit" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M201.5 305.5c-13.8 0-24.9-11.1-24.9-24.6 0-13.8 11.1-24.9 24.9-24.9 13.6 0 24.6 11.1 24.6 24.9 0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4 0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8 0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7 0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9 0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5 0 52.6 59.2 95.2 132 95.2 73.1 0 132.3-42.6 132.3-95.2 0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6 0-2.2-2.2-6.1-2.2-8.3 0-2.5 2.5-2.5 6.4 0 8.6 22.8 22.8 87.3 22.8 110.2 0 2.5-2.2 2.5-6.1 0-8.6-2.2-2.2-6.1-2.2-8.3 0zm7.7-75c-13.6 0-24.6 11.1-24.6 24.9 0 13.6 11.1 24.6 24.6 24.6 13.8 0 24.9-11.1 24.9-24.6 0-13.8-11-24.9-24.9-24.9z"></path></svg><!-- <i class="fab fa-fw fa-reddit" aria-hidden="true"></i> --> <span>Reddit</span></a>
</div>

        

        

        

      </div>
    </div>
  </article>
</main>


    

    
  
  


<!-- MathJax -->





  



</body></html>