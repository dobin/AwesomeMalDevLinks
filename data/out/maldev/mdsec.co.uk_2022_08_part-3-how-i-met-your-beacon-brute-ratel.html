# https://www.mdsec.co.uk/2022/08/part-3-how-i-met-your-beacon-brute-ratel/

<!DOCTYPE html><!--[if lt IE 7 ]><html lang="en-GB" class="no-js ie ie6 lte7 lte8 lte9"><![endif]--><!--[if IE 7 ]><html lang="en-GB" class="no-js ie ie7 lte7 lte8 lte9"><![endif]--><!--[if IE 8 ]><html lang="en-GB" class="no-js ie ie8 lte8 lte9"><![endif]--><!--[if IE 9 ]><html lang="en-GB" class="no-js ie ie9 lte9"><![endif]--><!--[if (gt IE 9)|!(IE)]><!--><html lang="en-GB" class=" js flexbox flexboxlegacy canvas canvastext postmessage no-websqldatabase indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers no-applicationcache svg inlinesvg" dir="ltr"><!--<![endif]-->
	    
	<body class="wp-singular post-template-default single single-post postid-3031 single-format-standard wp-theme-mdsec">
    <!--[if lt IE 7]>
        <div class="browse-happy">
        	 <a href="https://www.mdsec.co.uk">
				<div id="logo">Logo</div>
			</a>
        	<p>You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        </div>    	
    <![endif]-->              
	
	<!-- Site Wrapper Start --> 
	<div class="site-wrapper">
		
	<!-- Header Start --> 
	
    <!-- Header End --> 
		
		
	<div class="subnav">
		<section class="content-wrapper">
			<ul class="service-list clearfix">
				<li class="item" style="">
					<a href="https://www.mdsec.co.uk/our-services/adversary-simulation/">
						<div class="service-icon">
							<img src="https://www.mdsec.co.uk/wp-content/themes/mdsec/img/icons/icon-adversary.svg" alt="Adversary" width="300" height="150">
						</div>
						<hgroup>
							<h2>
								Adversary Simulation
							</h2>
						</hgroup>
						<p>Our best in class red team can deliver a holistic cyber attack simulation to provide a true evaluation of your organisation’s cyber resilience.</p>
						
					</a>
				</li>
				<li class="item" style="">
					<a href="https://www.mdsec.co.uk/our-services/applicaton-security/">
						<div class="service-icon">
							<img src="https://www.mdsec.co.uk/wp-content/themes/mdsec/img/icons/icon-application-security.svg" alt="Application Security" width="300" height="150">
						</div>
						<hgroup>
							<h2>
								Application <br>Security
							</h2>
						</hgroup>
						<p>Leverage the team behind the industry-leading Web Application and Mobile Hacker’s Handbook series.</p>
					</a>
				</li>
				<li class="item" style="">
					<a href="https://www.mdsec.co.uk/our-services/penetration-testing/">
						<div class="service-icon">
							<img src="https://www.mdsec.co.uk/wp-content/themes/mdsec/img/icons/icon-penetration-testing.svg" alt="Penetration Testing" width="300" height="150">
						</div>
						<hgroup>
							<h2>
								Penetration <br>Testing
							</h2>
						</hgroup>
						<p>MDSec’s penetration testing team is trusted by companies from the world’s leading technology firms to global financial institutions.</p>
					</a>
				</li>
				<li class="item" style="">
					<a href="https://www.mdsec.co.uk/our-services/response/">
						<div class="service-icon">
							<img src="https://www.mdsec.co.uk/wp-content/themes/mdsec/img/icons/icon-response.svg" alt="Response" width="300" height="150">
						</div>
						<hgroup>
							<h2>
								Response
							</h2>
						</hgroup>
						<p>Our certified team work with customers at all stages of the Incident Response lifecycle through our range of proactive and reactive services.</p>
					</a>
				</li>
			</ul>
		</section>		
	</div>
	<div class="subnav-kc">
		<section class="content-wrapper">
			<ul class="service-list clearfix">
				<li>
					<a href="https://www.mdsec.co.uk/knowledge-centre/research/">
						<hgroup>
							<h2>
								Research
							</h2>
						</hgroup>
						<p>MDSec’s dedicated research team periodically releases white papers, blog posts, and tooling.</p>
					</a>
				</li>
				<li>
					<a href="https://www.mdsec.co.uk/knowledge-centre/training/">
						<hgroup>
							<h2>
								Training
							</h2>
						</hgroup>
						<p>MDSec’s training courses are informed by our security consultancy and research functions, ensuring you benefit from the latest and most applicable trends in the field.</p>
					</a>
				</li>
				<li>
					<a href="https://www.mdsec.co.uk/knowledge-centre/insights/">
						<hgroup>
							<h2>
								Insights
							</h2>
						</hgroup>
						<p>View insights from MDSec’s consultancy and research teams.</p>
					</a>
				</li>
			</ul>
		</section>		
	</div>		

	
	<section class="insights-single-header">
		<div class="content-wrapper">
			<div class="the-category">
			<span class="category">ActiveBreach</span>			</div>
			<h1>PART 3: How I Met Your Beacon – Brute Ratel</h1>
		</div>
	</section>

	<section class="full-width-wrapper white pad20-120">
		<div class="content-wrapper">
			<div class="breadcrumb-wrapper">
				
			</div>	

		</div>
		
		<div class="insights-content">
		
<h2 class="wp-block-heading">Introduction</h2>



<p>In <a href="https://www.mdsec.co.uk/2022/07/part-1-how-i-met-your-beacon-overview/" target="_blank" rel="noreferrer noopener">part one</a>, we introduced generic approaches to performing threat hunting of C2 frameworks and then followed it up with practical examples against Cobalt Strike in <a href="https://www.mdsec.co.uk/2022/07/part-2-how-i-met-your-beacon-cobalt-strike/" target="_blank" rel="noreferrer noopener">part two</a>.</p>



<p>In part three of this series, we will analyse Brute Ratel, a command and control framework developed by <a href="https://bruteratel.com/" target="_blank" rel="noreferrer noopener">Dark Vortex</a>. As the C2 is lesser known, we can see it describes itself as follows:</p>



<figure class="wp-block-image size-large is-style-default"><img fetchpriority="high" decoding="async" width="960" height="114" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-960x114.png" alt="" class="wp-image-3032"></figure>



<p>The framework has come under close scrutiny in the past few months, having been allegedly abused by <a href="https://unit42.paloaltonetworks.com/brute-ratel-c4-tool/" target="_blank" rel="noreferrer noopener">APT29</a> and the ransomware group <a href="https://www.sophos.com/en-us/press-office/press-releases/2022/07/blackcat-adds-brute-ratel-to-attack-tools" target="_blank" rel="noreferrer noopener">BlackCat</a> in recent times. Having an understanding of how we can generically detect this emerging C2 in our infrastructure is therefore useful intelligence for defenders.</p>



<p>Originally, all analysis was performed on Brute Ratel v1.0.7; the latest at the time of original review. However, a cursory update (contained at the end of this article) was performed discussing findings pertinent to v1.1 which was released shortly after our initial x33fcon presentation. One thing that should be noted with Brute Ratel is that the badger has only limited malleability and primarily from the perspective of the c2 channels; with the exception of v1.1 which added malleability for the sleep obfuscation techniques. As such it makes it possible to create very specific detections for the tool.</p>



<h2 class="wp-block-heading"><strong>Brute Ratel’s Loader</strong></h2>



<p>Brute Ratel’s badger comes in a number of forms, including exe, DLL and shellcode. When the badger is injected, its reflective loader will instantly load all dependencies required for the badger. As the badger bundles a large amount of post-exploitation features, this leads to a significant number of DLLs being loaded on initialisation:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-1-960x646.png" alt="" class="wp-image-3033" width="720" height="485"></figure>



<p>As we can see, the DLLs highlighted are all the DLLs that are loaded when the badger is injected. This list includes the loading of winhttp.dll and wininet.dll, which are not necessarily nefarious but are traditional loads for an egress beacon. There are however a number of less common DLLs loaded, such as dbghelp.dll, credui.dll samcli.dll and logoncli.dll amongst others.</p>



<p>This behaviour allows us to create a signature for the image loads and leads to a high signal indicator that can be hunted for through image load telemetry.</p>



<p>For example, using Elastic Query Language, we can search for the sequence of credui.dll, dbghelp.dll and winhttp.dll load events occurring in a process within 60 seconds of each other:</p>



<pre class="wp-block-code"><code class="hljs sql">sequence by Image <span class="hljs-keyword">with</span> maxspan=<span class="hljs-number">1</span>m
	[<span class="hljs-keyword">any</span> <span class="hljs-keyword">where</span> ImageLoaded == <span class="hljs-string">'C:\\Windows\\System32\\credui.dll'</span>]
	[<span class="hljs-keyword">any</span> <span class="hljs-keyword">where</span> ImageLoaded == <span class="hljs-string">'C:\\Windows\\System32\\dbghelp.dll'</span>]
	[<span class="hljs-keyword">any</span> <span class="hljs-keyword">where</span> ImageLoaded == <span class="hljs-string">'C:\\Windows\\System32\\winhttp.dll'</span>]</code></pre>



<p>Using the EQL tool, or Elastic’s cloud, we can search our event data, such as the following which was extracted from sysmon logs. Note, we’re explicitly excluding the badger executable itself so we can only identify the injected badgers:</p>



<pre class="wp-block-code"><code class="hljs sql">eql query -f sysmon-data.json "sequence by Image <span class="hljs-keyword">with</span> maxspan=<span class="hljs-number">2</span>m [<span class="hljs-keyword">any</span> <span class="hljs-keyword">where</span> ImageLoaded == <span class="hljs-string">'C:\\Windows\\System32\\credui.dll'</span> <span class="hljs-keyword">and</span> Image != <span class="hljs-string">'C:\\Users\\bob\\Desktop\\badger_x64_aws.exe'</span>] [<span class="hljs-keyword">any</span> <span class="hljs-keyword">where</span> ImageLoaded == <span class="hljs-string">'C:\\Windows\\System32\\dbghelp.dll'</span> <span class="hljs-keyword">and</span> Image != <span class="hljs-string">'C:\\Users\\bob\\Desktop\\badger_x64_aws.exe'</span>] [<span class="hljs-keyword">any</span> <span class="hljs-keyword">where</span> ImageLoaded == <span class="hljs-string">'C:\\Windows\\System32\\winhttp.dll'</span> <span class="hljs-keyword">and</span> Image != <span class="hljs-string">'C:\\Users\\bob\\Desktop\\badger_x64_aws.exe'</span>]<span class="hljs-string">"</span></code></pre>



<p>This leads to the following which shows the detection of the badger being injected in to notepad.exe:</p>



<figure class="wp-block-image size-large is-style-default"><img decoding="async" width="960" height="243" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-2-960x243.png" alt="" class="wp-image-3034"></figure>



<p>This query is particularly powerful as it allows us to retrospectively hunt for indicators of Brute Ratel badgers in the network, without directly running code on the endpoints.</p>



<h2 class="wp-block-heading"><strong>Brute Ratel In Memory</strong></h2>



<p>As most beacons remain memory resident, it is important to understand the footprint that is left behind in order to hunt for them. Reviewing the Brute Ratel documentation for the 1.0 release, it details its own implementation of obfuscate and sleep:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="119" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-3-960x119.png" alt="" class="wp-image-3035"></figure>



<p>According to the release post, BRc4 uses a mixture of “Asynchronous Procedure Calls, Windows Event Creation, Wait Objects and Timers”. However, analysis of the badger was only able to find evidence of APC based execution; more on this later.</p>



<p>In order to analyse the badger in memory, we first inject it to a process using the pcinject command, then put the badger to sleep using the sleep command:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-4-960x473.png" alt="" class="wp-image-3036" width="720" height="355"></figure>



<p>Once the badger is sleeping, we can recover the strings from the process using Process Hacker. Interestingly, while the badger is sleeping we can see strings such as the following:</p>



<figure class="wp-block-image size-full is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-5.png" alt="" class="wp-image-3038" width="603" height="217"></figure>



<p>Initially this was quite surprising given the aforementioned purported sleep and obfuscate strategies described on the Brute Ratel blog.</p>



<p>Digging deeper, we can find that some interesting design decisions have been made where by many of the strings displayed in the operator’s UI, are populated from the badger itself. For example, we can see the following in the memory of the badger while it is sleeping:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-6-960x492.png" alt="" class="wp-image-3039" width="720" height="369"></figure>



<p>And these strings are then returned to the UI as we can see below:</p>



<figure class="wp-block-image size-full is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-7.png" alt="" class="wp-image-3040" width="521" height="179"></figure>



<p>Digging deeper in to the badger, it was quickly apparent that only the .text section was being obfuscated on sleep, leaving the badger susceptible to all manner of signatures against strings and data.</p>



<p>To illustrate this, reversing the badger we can see the entry point for the loader as “bruteloader”:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="221" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-8-960x221.png" alt="" class="wp-image-3041"></figure>



<p>Searching for this string in memory while the badger is sleeping, we can quickly find it inside our notepad process:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="128" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-9-960x128.png" alt="" class="wp-image-3042"></figure>



<p>These strings provide a good point on which to base a Yara rule for memory scanning on. For example, the following rule will search for either the bruteloader or bhttp_x64.dll strings in memory of a process:</p>



<pre class="wp-block-code"><code class="hljs css"><span class="hljs-selector-tag">rule</span> <span class="hljs-selector-tag">brc4_badger_strings</span>
{
<span class="hljs-attribute">meta</span>:
    author = <span class="hljs-string">"@domchell"</span>
    description = <span class="hljs-string">"Identifies strings used in Badger v1.0.x rDLL, even while sleeping"</span>
strings:
    $a = <span class="hljs-string">"bruteloader"</span>
    $b = <span class="hljs-string">"bhttp_x64.dll"</span>
condition:
    <span class="hljs-number">1</span> of them
}</code></pre>



<p>We can test these against our notepad process while the badger is sleeping to evidence its effectiveness:</p>



<figure class="wp-block-image size-full is-style-default"><img loading="lazy" decoding="async" width="618" height="151" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-10.png" alt="" class="wp-image-3045"></figure>



<p>It is unlikely the strings will exist in other processes, and using a simple one liner we can quickly find all the injected badgers on our test system:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-11-960x479.png" alt="" class="wp-image-3046" width="720" height="359"></figure>



<p>Plugging this Yara rule in to virus total, we can quickly find <a href="https://www.virustotal.com/gui/file/c70b1fd133737a21904159ed2a867e0105060ac74937472da5e4d0e1f6fa1645" target="_blank" rel="noreferrer noopener">other samples</a>, such as:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="149" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-12-960x149.png" alt="" class="wp-image-3047"></figure>



<h2 class="wp-block-heading"><strong>Page Permissions</strong></h2>



<p>Analysis of the Brute Ratel obfuscate and sleep strategy observed the badger to shuffle the page permissions for the badger during sleep in an attempt to evade prolonging executable permissions while the badger sleeps.</p>



<p>Below, we can see the badger operating on a sleep 0, the page permissions for the badger are PAGE_EXECUTE_READ on an unmapped page; this is necessary in order to perform tasking:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="279" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-13-960x279.png" alt="" class="wp-image-3048"></figure>



<p>Putting the badger to sleep, we can see that the obfuscate and sleep strategy obfuscates the .text section and resets the page permissions for the badger to to PAGE_READWRITE:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="379" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-14-960x379.png" alt="" class="wp-image-3049"></figure>



<p>Interestingly, we however note that this behaviour is not replicated while a SMB pivot is being performed, that is when two badgers are linked. Here we can see our two badgers linked and both on a 60 second sleep:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="110" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-15-960x110.png" alt="" class="wp-image-3050"></figure>



<p>Analysis of the page permissions while two badgers are linked reveals that both remain PAGE_EXECUTE_READ, irrespective of the sleep time:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="188" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-16-960x188.png" alt="" class="wp-image-3051"></figure>



<p>The conclusion is that the obfuscate and sleep strategy is only applicable to the .text section, and while no peer-to-peer pivot is present.</p>



<p>Curious to how the obfuscate and sleep functionality worked, we began to reverse engineer it. Walking through the sleep routine in windbg, we can get an initial flavour of what’s happening; the badger is using WaitForSingleObjectEx to delay execution during a series of asynchronous procedure calls (APC), and leveraging an indirect syscall to execute NtTestAlert and force an alert on the thread:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="398" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-17-960x398.png" alt="" class="wp-image-3052"></figure>



<p>Diving in to IDA, we can get a better feel for what is happening. First it creates a new thread with the start address spoofed to a fixed location of TpReleaseCleanupGroupMembers+550:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-18-960x990.png" alt="" class="wp-image-3053" width="720" height="743"></figure>



<p>A series of context structures are then created for a number of function calls, to NtWaitForSingleObject, NtProtectVirtualMemory, , SystemFunction032, NtGetContextThread and SetThreadContext:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-19-960x990.png" alt="" class="wp-image-3054" width="720" height="743"></figure>



<p>Next, a number of APCs are queued against the NtContinue, with the intention of using it to proxy calls to the aforementioned context structures; this technique acts as a rudimentary form of ROP:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-20-960x710.png" alt="" class="wp-image-3055" width="720" height="533"></figure>



<p>Having reverse engineered the sleeping technique, we soon realised that it it was very similar to  <a href="https://twitter.com/ilove2pwn_" target="_blank" rel="noreferrer noopener">@ilove2pwn_</a>’s <a href="https://github.com/SecIdiot/FOLIAGE/blob/master/source/sleep.c" target="_blank" rel="noreferrer noopener">Foliage</a> project, with the exception of the hardcoded thread start address.</p>



<p>Despite extensive debugging and reverse engineering of the badger, we unable to reveal any evidence of the “Windows Event Creation, Wait Objects and Timers” techniques referenced in the v1.0 blog post; indeed the APIs required for these techniques did not appear to be imported via the badger’s hashed imports.</p>



<h2 class="wp-block-heading"><strong>Brute Ratels Threads</strong></h2>



<p>To analyse how Brute Ratel threads look in memory, we injected the badger in to a fresh copy of notepad. Immediately, we can see there are some suspicious indicators in the threads used by the sleeping badger.</p>



<p>Firstly, we note that there is a suspicious looking thread with a 0x0 start address, and a single frame calling WaitForSingleObjectEx in the call stack:</p>



<figure class="wp-block-image size-full is-style-default"><img loading="lazy" decoding="async" width="369" height="137" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-21.png" alt="" class="wp-image-3056"></figure>



<p>We can speculate that this thread is used for the HTTP comms based on analysis of the thread call stack while the badger is now sleeping:</p>



<figure class="wp-block-image size-full is-style-default"><img loading="lazy" decoding="async" width="407" height="190" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-22.png" alt="" class="wp-image-3057"></figure>



<p>Based on the information we gained from reverse engineering the obfuscate and sleep strategy, we noted that new threads were created with a hardcoded spoofed start address of ntdll!TpReleaseCleanupGroupMembers+0x550:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-23-960x475.png" alt="" class="wp-image-3058" width="720" height="356"></figure>



<p>We were unable to find any instances of this occurring as a start address naturally, and as such leads to a trivial indicator for hunting Brute Ratel threads. In practice this looks as follows within our injected notepad process:</p>



<figure class="wp-block-image size-full is-style-default"><img loading="lazy" decoding="async" width="719" height="313" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-24.png" alt="" class="wp-image-3059"></figure>



<p>The call stack for the thread is also slightly irregular as it not only contains calls to delay execution, but also the first frame points to ntdll.dll!NtTerminateJobObject+0x1f. A deeper look at why NtNerminateJobObject is used highlights that this is simply a ROP gadget for NtTestAlert and is used to execute pending APCs on the thread:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="398" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-25-960x398.png" alt="" class="wp-image-3060"></figure>



<h2 class="wp-block-heading"><strong>Memory Hooks</strong></h2>



<p>In our first post in this series, we detailed two potential approaches for detecting in-memory beacons based on memory hooks; by looking for signatures of known patches (e.g. ret to ntdll.dll!EtwEventWrite) and by detecting copy on write operations.</p>



<p>Applying these concepts to Brute Ratel, we note that the badger does not apply any memory hooks until its post-exploitation functionality is used by the operator. An example of this, would be the sharpinline command, which runs a .NET assembly in the current process:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="329" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-26-960x329.png" alt="" class="wp-image-3061"></figure>



<p>Once the assembly has completed and the beacon gone back to sleep, we can get a better understanding of whats going on by attaching a debugger and disassembling the values of ntdll.dll!EtwEventWrite and amsi.dll!AmsiScanBuffer:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-27-960x340.png" alt="" class="wp-image-3062" width="720" height="255"></figure>



<p>As shown above, these are simple and persistent patches to disable .NET ETW data and inhibit AMSI. As the patches are persistent, we can detect them by either of the aforementioned techniques, since not only will we receive a high signal detection due to the first instruction of EtwEventWrite being a ret, but also an indicator that the pages where EtwEventWrite resides have been modified due to the clearing of the shared bit.</p>



<p>Using BeaconHunter, we can rapidly detect these hooks based on resolving the exports on the modified pages, providing a strong indicator that malicious tampering has taken place:</p>



<figure class="wp-block-image size-full is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-28.png" alt="" class="wp-image-3063" width="571" height="473"></figure>



<h2 class="wp-block-heading"><strong>Brute Ratel C2 Server</strong></h2>



<p>Moving away from the endpoint, as hunters we also have an interest in detecting the command-and-control infrastructure as this may assist in providing us with sufficient intelligence to detect beaconing based on network telemetry.</p>



<p>The C2 server for Brute Ratel is developed in golang, and by default only allows the operator to modify the default landing page for the C2. To fingerprint the C2 server, we discovered it was possible to generate an unhandled exception when sending a POST request containing base64 to any URI. For example, consider the following base64 POST data compared with the the plaintext:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-29-960x465.png" alt="" class="wp-image-3064" width="720" height="349"></figure>



<p>It is likely this occurs as the expected input for the base64 decoded POST data should conform to the C2 traffic format. A simple Nuclei rule might help us in scanning for this kind of infrastructure:</p>



<pre class="wp-block-code"><code class="hljs http"><span class="hljs-attribute">id</span>: brc4-ts

<span class="less"><span class="hljs-attribute">info</span>:
  <span class="hljs-attribute">name</span>: Brute Ratel C2 Server Fingerprint
  <span class="hljs-attribute">author</span>: Dominic Chell
  <span class="hljs-attribute">severity</span>: info
  <span class="hljs-attribute">description</span>: description
  <span class="hljs-attribute">reference</span>:
    - <span class="hljs-attribute">https</span>:<span class="hljs-comment">//</span>
  <span class="hljs-attribute">tags</span>: tags
<span class="hljs-attribute">requests</span>:
  - <span class="hljs-attribute">raw</span>:
      - |-
        POST / HTTP/<span class="hljs-number">1.1</span>
        <span class="hljs-attribute">Host</span>: {{Hostname}}
        <span class="hljs-attribute">Content-Length</span>: <span class="hljs-number">8</span>

        Zm9vYmFy</span></code></pre>



<p>Outside of direct interaction with the C2, it is also possible to detect C2 infrastructure where the operator has not manually redefined the default landing page based on a hash of the HTML (<a href="https://www.shodan.io/search?query=http.html_hash%3A-1957161625">http.html_hash=-1957161625</a>).</p>



<p>Using a simple Shodan <a href="https://www.shodan.io/search?query=http.html_hash%3A-1957161625" target="_blank" rel="noreferrer noopener">query</a>, we can quickly find live infrastructure exposed to the Internet:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-30-960x514.png" alt="" class="wp-image-3065" width="720" height="386"></figure>



<p>Although only around 40 team servers were identified, we can get a better picture of where these are located based on the geographical spread:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-31-960x544.png" alt="" class="wp-image-3066" width="720" height="408"></figure>



<p>It is quite likely some of these techniques are already known, as based on reports against our test infrastructure, defenders are actively hunting these C2 servers:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-32-960x583.png" alt="" class="wp-image-3067" width="720" height="437"></figure>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-33-960x61.png" alt="" class="wp-image-3068" width="720" height="46"></figure>



<h2 class="wp-block-heading"><strong>Brute Ratel Configurations</strong></h2>



<p>Analysis of the Badger revealed that Brute Ratel maintains an encrypted configuration structure in memory which includes details on the C2 endpoints. Being able to extract this from either artifacts or from running processes can prove helpful for defenders. Our analysis revealed that this configuration is held in a base64 and RC4 encrypted blob using a fixed key of “bYXJm/3#M?:XyMBF” in the artifacts for the badger. While the configuration is stored plaintext in memory for the sleeping badger.</p>



<p>We developed the following config extractor that can be used against both on-disk artifacts for BRC4 v1.0.x or injected sleeping badgers with Brute Ratel 1.0.x and 1.1.x:</p>



<pre class="wp-block-code"><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">"Crypt32.lib"</span>)</span>

<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">HexDump</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* pBuffer, DWORD cbBuffer)</span>
</span>{
	PBYTE pbBuffer = (PBYTE)pBuffer;
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> strHex;

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FORMAT_APPEND_1(a)	{ char szTmp[256]; sprintf(szTmp, a); strHex += szTmp; }</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FORMAT_APPEND_2(a,b)	{ char szTmp[256]; sprintf(szTmp, a, b); strHex += szTmp; }</span>

	<span class="hljs-keyword">for</span> (DWORD i = <span class="hljs-number">0</span>; i &lt; cbBuffer;)
	{
		FORMAT_APPEND_2(<span class="hljs-string">"0x8x  "</span>, i);

		DWORD n = ((cbBuffer - i) &lt; <span class="hljs-number">16</span>) ? (cbBuffer - i) : <span class="hljs-number">16</span>;

		<span class="hljs-keyword">for</span> (DWORD j = <span class="hljs-number">0</span>; j &lt; n; j++)
		{
			FORMAT_APPEND_2(<span class="hljs-string">"%02X "</span>, pbBuffer[i + j]);
		}

		<span class="hljs-keyword">for</span> (DWORD j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-number">16</span> - n); j++)
		{
			FORMAT_APPEND_1(<span class="hljs-string">"   "</span>);
		}

		FORMAT_APPEND_1(<span class="hljs-string">" "</span>);

		<span class="hljs-keyword">for</span> (DWORD j = <span class="hljs-number">0</span>; j &lt; n; j++)
		{
			FORMAT_APPEND_2(<span class="hljs-string">"%c"</span>, (pbBuffer[i + j] &lt; <span class="hljs-number">0x20</span> || pbBuffer[i + j] &gt; <span class="hljs-number">0x7f</span>) ? <span class="hljs-string">'.'</span> : pbBuffer[i + j]);
		}

		FORMAT_APPEND_1(<span class="hljs-string">"\n"</span>);

		i += n;
	}

	<span class="hljs-keyword">return</span> strHex;
}

<span class="hljs-function">BOOL <span class="hljs-title">ReadAllBytes</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> strFile, PBYTE* ppbBuffer, UINT* puiBufferLength)</span>
</span>{
	BOOL bSuccess = FALSE;
	PBYTE pbBuffer = <span class="hljs-literal">NULL</span>;

	*ppbBuffer = <span class="hljs-literal">NULL</span>;
	*puiBufferLength = <span class="hljs-number">0</span>;

	FILE* fp = fopen(strFile.c_str(), <span class="hljs-string">"rb"</span>);
	<span class="hljs-keyword">if</span> (fp)
	{
		fseek(fp, <span class="hljs-number">0</span>, SEEK_END);
		<span class="hljs-keyword">long</span> lFile = ftell(fp);
		fseek(fp, <span class="hljs-number">0</span>, SEEK_SET);

		<span class="hljs-keyword">if</span> (!(pbBuffer = (PBYTE)<span class="hljs-built_in">malloc</span>(lFile)))
			<span class="hljs-keyword">goto</span> Cleanup;

		<span class="hljs-keyword">if</span> (fread(pbBuffer, <span class="hljs-number">1</span>, lFile, fp) != lFile)
			<span class="hljs-keyword">goto</span> Cleanup;

		*ppbBuffer = pbBuffer;
		*puiBufferLength = (UINT)lFile;

		pbBuffer = <span class="hljs-literal">NULL</span>;
		bSuccess = TRUE;
	}

Cleanup:
	<span class="hljs-keyword">if</span> (fp) fclose(fp);
	<span class="hljs-keyword">if</span> (pbBuffer) <span class="hljs-built_in">free</span>(pbBuffer);
	<span class="hljs-keyword">return</span> bSuccess;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Brc4DecodeString</span><span class="hljs-params">(BYTE* pszKey, BYTE* pszInput, BYTE* pszOutput, <span class="hljs-keyword">int</span> cchInput)</span>
</span>{
	BYTE szCharmap[<span class="hljs-number">0x100</span>];

	<span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(szCharmap); i++)
	{
		szCharmap[i] = (<span class="hljs-keyword">char</span>)i;
	}

	UINT cchKey = <span class="hljs-built_in">strlen</span>((<span class="hljs-keyword">char</span>*)pszKey);

	BYTE l = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(szCharmap); i++)
	{
		BYTE x = szCharmap[i];
		BYTE k = pszKey[i % cchKey];
		BYTE y = x + k + l;
		l = y;
		szCharmap[i] = szCharmap[y];
		szCharmap[y] = x;
	}

	l = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; cchInput; i++)
	{
		BYTE x = szCharmap[i + <span class="hljs-number">1</span>];
		BYTE y = x + l;
		l = y;
		BYTE z = szCharmap[y];
		szCharmap[i + <span class="hljs-number">1</span>] = z;
		szCharmap[y] = x;
		x = x + szCharmap[i + <span class="hljs-number">1</span>];
		x = szCharmap[x];
		x = x ^ pszInput[i];
		pszOutput[i] = x;
	}
}

<span class="hljs-function">BOOL <span class="hljs-title">MatchPattern</span><span class="hljs-params">(PBYTE pbInput, PBYTE pbSearch, DWORD cbSearch, BYTE byteMask)</span>
</span>{
	BOOL bMatch = TRUE;

	<span class="hljs-keyword">for</span> (DWORD j = <span class="hljs-number">0</span>; j &lt; cbSearch; j++)
	{
		<span class="hljs-keyword">if</span> (pbSearch[j] != byteMask &amp;&amp; pbInput[j] != pbSearch[j])
		{
			bMatch = FALSE;
			<span class="hljs-keyword">break</span>;
		}
	}

	<span class="hljs-keyword">return</span> bMatch;
}

<span class="hljs-function">PBYTE <span class="hljs-title">FindPattern</span><span class="hljs-params">(PBYTE pbInput, UINT cbInput, PBYTE pbSearch, DWORD cbSearch, BYTE byteMask, UINT* pcSkipMatches)</span>
</span>{
	<span class="hljs-keyword">if</span> (cbInput &gt; cbSearch)
	{
		<span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; cbInput - cbSearch; i++)
		{
			BOOL bMatch = MatchPattern(pbInput + i, pbSearch, cbSearch, byteMask);

			<span class="hljs-keyword">if</span> (bMatch)
			{
				<span class="hljs-keyword">if</span> (!*pcSkipMatches)
				{
					<span class="hljs-keyword">return</span> &amp;pbInput[i];
				}

				(*pcSkipMatches)--;
			}
		}
	}
	
	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-function">BOOL <span class="hljs-title">LocateBrc4Config</span><span class="hljs-params">(PBYTE pbInput, UINT cbInput, PBYTE* ppbConfig)</span>
</span>{
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XOR_RAX_RAX			0x48, 0x31, 0xC0,</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PUSH_RAX			0x50,</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_EAX_IMM32		0xB8, 0xab, 0xab, 0xab, 0xab,</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_RAX_IMM64		0x48, 0xB8, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab,</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PUSH_IMM32			0x68, 0xab, 0xab, 0xab, 0xab,</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOV_EAX_0			0xB8, 0x00, 0x00, 0x00, 0x00,</span>

	BYTE Pattern1[] =
	{
		XOR_RAX_RAX
		PUSH_RAX
		MOV_EAX_IMM32
		PUSH_RAX
		MOV_RAX_IMM64
		PUSH_RAX
		MOV_RAX_IMM64
		PUSH_RAX
		MOV_RAX_IMM64
		PUSH_RAX
		MOV_RAX_IMM64
		PUSH_RAX
		MOV_RAX_IMM64
		PUSH_RAX
		MOV_RAX_IMM64
	},
	Pattern2[] =
	{
		XOR_RAX_RAX
		PUSH_RAX
		MOV_RAX_IMM64
		PUSH_RAX
		MOV_RAX_IMM64
		PUSH_RAX
		MOV_RAX_IMM64
		PUSH_RAX
		MOV_RAX_IMM64
		PUSH_RAX
		MOV_RAX_IMM64
		PUSH_RAX
		MOV_RAX_IMM64
		PUSH_RAX
		MOV_RAX_IMM64
	};

	UINT cSkipMatches = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (cbInput &lt; <span class="hljs-number">100</span>)
	{
		<span class="hljs-keyword">return</span> FALSE;
	}

	PBYTE pbConfigStart = FindPattern(pbInput, cbInput, Pattern1, <span class="hljs-keyword">sizeof</span>(Pattern1), <span class="hljs-number">0xab</span>, &amp;cSkipMatches);

	<span class="hljs-keyword">if</span> (!pbConfigStart)
	{
		cSkipMatches = <span class="hljs-number">0</span>;

		pbConfigStart = FindPattern(pbInput, cbInput, Pattern2, <span class="hljs-keyword">sizeof</span>(Pattern2), <span class="hljs-number">0xab</span>, &amp;cSkipMatches);

		<span class="hljs-keyword">if</span> (!pbConfigStart)
		{
			<span class="hljs-keyword">return</span> FALSE;
		}
	}

	BYTE Pattern3[] = {
		PUSH_IMM32
		MOV_EAX_0
		PUSH_RAX
		MOV_EAX_0
		PUSH_RAX
		MOV_EAX_0
		PUSH_RAX
	};

	cSkipMatches = <span class="hljs-number">0</span>;

	PBYTE pbConfigEnd = FindPattern(pbConfigStart, cbInput - (pbConfigStart - pbInput), Pattern3, <span class="hljs-keyword">sizeof</span>(Pattern3), <span class="hljs-number">0xab</span>, &amp;cSkipMatches);

	<span class="hljs-keyword">if</span> (!pbConfigEnd)
	{
		<span class="hljs-keyword">return</span> FALSE;
	}

	*ppbConfig = (PBYTE)<span class="hljs-built_in">malloc</span>(pbConfigEnd - pbConfigStart);
	
	<span class="hljs-keyword">if</span> (!*ppbConfig)
	{
		<span class="hljs-keyword">return</span> FALSE;
	}

	<span class="hljs-built_in">memset</span>(*ppbConfig, <span class="hljs-number">0</span>, pbConfigEnd - pbConfigStart);

	pbConfigStart += <span class="hljs-number">4</span>; <span class="hljs-comment">// skip: XOR_RAX_RAX / PUSH_RAX</span>

	BYTE Pattern4[] = {
		MOV_EAX_IMM32
		PUSH_RAX
	},
	Pattern5[] = {
		MOV_RAX_IMM64
		PUSH_RAX
	};

	<span class="hljs-keyword">for</span> (UINT uiIndex = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>; i &lt; pbConfigEnd - pbConfigStart;)
	{
		<span class="hljs-keyword">if</span> (MatchPattern(pbConfigStart + i, Pattern4, <span class="hljs-keyword">sizeof</span>(Pattern4), <span class="hljs-number">0xab</span>))
		{
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">4</span>];
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">3</span>];
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">2</span>];
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">1</span>];

			i += <span class="hljs-keyword">sizeof</span>(Pattern4);
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MatchPattern(pbConfigStart + i, Pattern5, <span class="hljs-keyword">sizeof</span>(Pattern5), <span class="hljs-number">0xab</span>))
		{
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">9</span>];
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">8</span>];
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">7</span>];
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">6</span>];
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">5</span>];
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">4</span>];
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">3</span>];
			(*ppbConfig)[uiIndex++] = pbConfigStart[i + <span class="hljs-number">2</span>];

			i += <span class="hljs-keyword">sizeof</span>(Pattern5);
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MatchPattern(pbConfigStart + i, Pattern3, <span class="hljs-keyword">sizeof</span>(Pattern3), <span class="hljs-number">0xab</span>))
		{
			<span class="hljs-keyword">break</span>;
		}
		<span class="hljs-keyword">else</span>
		{
			<span class="hljs-keyword">return</span> FALSE;
		}
	}

	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> config = (<span class="hljs-keyword">char</span>*)*ppbConfig;
	<span class="hljs-built_in">std</span>::reverse(config.begin(), config.end());

	<span class="hljs-built_in">strcpy</span>((<span class="hljs-keyword">char</span>*)*ppbConfig, config.c_str());

	<span class="hljs-keyword">return</span> TRUE;
}

<span class="hljs-function">BOOL <span class="hljs-title">FromBase64</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* pszString, PBYTE* ppbBinary, UINT* pcbBinary)</span>
</span>{
	DWORD cbBinary = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (FAILED(CryptStringToBinaryA(pszString, <span class="hljs-number">0</span>, CRYPT_STRING_BASE64, <span class="hljs-literal">NULL</span>, &amp;cbBinary, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)))
	{
		<span class="hljs-keyword">return</span> FALSE;
	}

	*ppbBinary = (PBYTE)<span class="hljs-built_in">malloc</span>(cbBinary + <span class="hljs-number">1</span>);

	<span class="hljs-keyword">if</span> (!*ppbBinary)
	{
		<span class="hljs-keyword">return</span> FALSE;
	}

	<span class="hljs-keyword">if</span> (FAILED(CryptStringToBinaryA(pszString, <span class="hljs-number">0</span>, CRYPT_STRING_BASE64, *ppbBinary, &amp;cbBinary, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)))
	{
		<span class="hljs-keyword">return</span> FALSE;
	}

	*pcbBinary = cbBinary;

	<span class="hljs-keyword">return</span> TRUE;
}

<span class="hljs-function">BOOL <span class="hljs-title">ScanProcessForBadgerConfig</span><span class="hljs-params">(HANDLE hProcess, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; badgerId, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">wstring</span>&gt;&amp; configStrings)</span>
</span>{
	SIZE_T nBytesRead;
	PBYTE lpMemoryRegion = <span class="hljs-literal">NULL</span>, pbBadgerStateStruct = <span class="hljs-literal">NULL</span>;

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] Searching process memory for badger state ...\n"</span>);

	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
	{
		MEMORY_BASIC_INFORMATION mbi = { <span class="hljs-number">0</span> };

		<span class="hljs-keyword">if</span> (!VirtualQueryEx(hProcess, lpMemoryRegion, &amp;mbi, <span class="hljs-keyword">sizeof</span>(mbi)))
		{
			<span class="hljs-keyword">break</span>;
		}

		<span class="hljs-keyword">if</span> ((mbi.State &amp; MEM_COMMIT) &amp;&amp; !(mbi.Protect &amp; PAGE_GUARD) &amp;&amp;
			((mbi.Protect &amp; PAGE_READONLY) || (mbi.Protect &amp; PAGE_READWRITE) || (mbi.Protect &amp; PAGE_EXECUTE_READWRITE)))
		{
			<span class="hljs-comment">//printf("[+] Searching process memory at 0x%p (size 0x%x)\n", lpMemoryRegion, mbi.RegionSize);</span>

			PBYTE pbLocalMemoryCopy = (PBYTE)<span class="hljs-built_in">malloc</span>(mbi.RegionSize);

			<span class="hljs-keyword">if</span> (!ReadProcessMemory(hProcess, lpMemoryRegion, pbLocalMemoryCopy, mbi.RegionSize, &amp;nBytesRead))
			{
				<span class="hljs-comment">//printf("[!] Unable to read memory at 0x%p\n", lpMemoryRegion);</span>
			}
			<span class="hljs-keyword">else</span>
			{
				<span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0</span>; i &lt; mbi.RegionSize - <span class="hljs-number">128</span> &amp;&amp; !pbBadgerStateStruct; i++)
				{
					<span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(pbLocalMemoryCopy + i, <span class="hljs-string">"b-"</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)
					{
						<span class="hljs-keyword">char</span>* pszEndPtr = <span class="hljs-literal">NULL</span>;
						<span class="hljs-keyword">int</span> badgerId = strtoul((<span class="hljs-keyword">char</span>*)pbLocalMemoryCopy + i + <span class="hljs-number">2</span>, &amp;pszEndPtr, <span class="hljs-number">10</span>);
						
						<span class="hljs-keyword">if</span> (pszEndPtr != (<span class="hljs-keyword">char</span>*)pbLocalMemoryCopy + i + <span class="hljs-number">2</span> &amp;&amp; pszEndPtr &amp;&amp; *pszEndPtr == <span class="hljs-string">'\\'</span> &amp;&amp; strnlen(pszEndPtr, <span class="hljs-number">100</span>) &gt; <span class="hljs-number">16</span>)
						{
							pbBadgerStateStruct = lpMemoryRegion + i;
							<span class="hljs-keyword">break</span>;
						}
					}
				}
			}

			<span class="hljs-built_in">free</span>(pbLocalMemoryCopy);
			pbLocalMemoryCopy = <span class="hljs-literal">NULL</span>;
		}

		lpMemoryRegion += mbi.RegionSize;
	}

	<span class="hljs-keyword">if</span> (!pbBadgerStateStruct)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!] Failed to find badger state\n"</span>);
		<span class="hljs-keyword">return</span> FALSE;
	}

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] Found badger state at 0x%p\n"</span>, pbBadgerStateStruct);

	BYTE BadgerState[<span class="hljs-number">0x1000</span>];
	
	<span class="hljs-built_in">memset</span>(BadgerState, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(BadgerState));

	<span class="hljs-keyword">if</span> (!ReadProcessMemory(hProcess, pbBadgerStateStruct, BadgerState, <span class="hljs-number">0x1000</span>, &amp;nBytesRead))
	{
		<span class="hljs-keyword">if</span> (GetLastError() != ERROR_PARTIAL_COPY)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!] Unable to read badger state at 0x%p\n"</span>, pbBadgerStateStruct);
			<span class="hljs-keyword">return</span> FALSE;
		}
	}

	badgerId = (<span class="hljs-keyword">char</span>*)BadgerState;

	BYTE ConfigString[<span class="hljs-number">1024</span>];

	<span class="hljs-built_in">memset</span>(ConfigString, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ConfigString));

	<span class="hljs-keyword">for</span> (UINT i = <span class="hljs-number">0x100</span> + (<span class="hljs-number">0x10</span> - ((DWORD64)pbBadgerStateStruct &amp; <span class="hljs-number">0xf</span>)); i &lt; <span class="hljs-keyword">sizeof</span>(BadgerState); i += <span class="hljs-keyword">sizeof</span>(DWORD64))
	{
		DWORD64 pMem = *(DWORD64*)(BadgerState + i);

		<span class="hljs-keyword">if</span> (pMem)
		{
			ConfigString[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;

			<span class="hljs-keyword">if</span> (!ReadProcessMemory(hProcess, (LPVOID)pMem, ConfigString, <span class="hljs-number">1024</span>, &amp;nBytesRead) || nBytesRead != <span class="hljs-number">1024</span>)
			{
				<span class="hljs-keyword">continue</span>;
			}

			BOOL bIsValid = ConfigString[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>;
			<span class="hljs-built_in">std</span>::<span class="hljs-built_in">wstring</span> badgerString;

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_STRING_LENGTH	5</span>

			<span class="hljs-keyword">if</span> (bIsValid)
			{
				<span class="hljs-keyword">char</span>* pszConfigString = (<span class="hljs-keyword">char</span>*)ConfigString;
				
				<span class="hljs-keyword">for</span> (UINT j = <span class="hljs-number">0</span>; j &lt; nBytesRead &amp;&amp; pszConfigString[j] != <span class="hljs-number">0</span>; j++)
				{
					<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isprint</span>(pszConfigString[j]) &amp;&amp; !(pszConfigString[j] == <span class="hljs-string">'\t'</span> || pszConfigString[j] == <span class="hljs-string">'\r'</span> || pszConfigString[j] == <span class="hljs-string">'\n'</span>))
					{
						<span class="hljs-keyword">break</span>;
					}
					
					badgerString.push_back(pszConfigString[j]);
				}

				bIsValid = badgerString.size() &gt;= MIN_STRING_LENGTH;
			}

			<span class="hljs-keyword">if</span> (!bIsValid)
			{
				badgerString.clear();
				bIsValid = TRUE;

				WCHAR* pwszConfigString = (WCHAR*)ConfigString;

				<span class="hljs-keyword">for</span> (UINT j = <span class="hljs-number">0</span>; j &lt; nBytesRead / <span class="hljs-keyword">sizeof</span>(WCHAR) &amp;&amp; pwszConfigString[j] != <span class="hljs-number">0</span>; j++)
				{
					<span class="hljs-keyword">if</span> (!iswprint(pwszConfigString[j]) &amp;&amp; !(pwszConfigString[j] == <span class="hljs-string">'\t'</span> || pwszConfigString[j] == <span class="hljs-string">'\r'</span> || pwszConfigString[j] == <span class="hljs-string">'\n'</span>))
					{
						<span class="hljs-keyword">break</span>;
					}

					badgerString.push_back(pwszConfigString[j]);
				}

				bIsValid = badgerString.size() &gt;= MIN_STRING_LENGTH;
			}

			<span class="hljs-keyword">if</span> (bIsValid)
			{
				configStrings.push_back(badgerString);
			}
		}
	}

	<span class="hljs-keyword">return</span> TRUE;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span>
</span>{
	PBYTE key = (PBYTE)<span class="hljs-string">"bYXJm/3#M?:XyMBF"</span>;

	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"BruteRatel v1.x Config Extractor\n"</span>);

	<span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)
	{
		<span class="hljs-built_in">printf</span>(
			<span class="hljs-string">"Usage: Brc4ConfigExtractor.exe &lt;file&gt; [key]\n"</span>
			<span class="hljs-string">"    &lt;file|pid&gt; - file to scan for config, or running process ID\n"</span>
			<span class="hljs-string">"    [key]  - key if not default\n"</span>
		);

		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	}

	<span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">2</span>)
	{
		key = (PBYTE)argv[<span class="hljs-number">2</span>];
	}

	<span class="hljs-keyword">if</span> (atoi(argv[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>)
	{
		PBYTE pbBadger = <span class="hljs-literal">NULL</span>;
		UINT cbBadger = <span class="hljs-number">0</span>;

		<span class="hljs-keyword">if</span> (!ReadAllBytes(argv[<span class="hljs-number">1</span>], &amp;pbBadger, &amp;cbBadger))
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!] Input file '%s' not found\n"</span>, argv[<span class="hljs-number">1</span>]);
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		}

		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] Analysing file '%s' (%u bytes)\n"</span>, argv[<span class="hljs-number">1</span>], cbBadger);

		PBYTE pbConfigText = <span class="hljs-literal">NULL</span>;

		<span class="hljs-keyword">if</span> (!LocateBrc4Config(pbBadger, cbBadger, &amp;pbConfigText))
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!] Failed to locate BRC4 config\n"</span>);
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		}

		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] Located BRC4 config: %s\n"</span>, pbConfigText);

		PBYTE pbBinaryConfig = <span class="hljs-literal">NULL</span>;
		UINT cbBinaryConfig = <span class="hljs-number">0</span>;

		<span class="hljs-keyword">if</span> (!FromBase64((<span class="hljs-keyword">char</span>*)pbConfigText, &amp;pbBinaryConfig, &amp;cbBinaryConfig))
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!] Failed to decode BRC4 config from base64\n"</span>);
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		}

		Brc4DecodeString(key, pbBinaryConfig, pbBinaryConfig, cbBinaryConfig);

		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] Decoded config: %.*s\n"</span>, cbBinaryConfig, pbBinaryConfig);
	}
	<span class="hljs-keyword">else</span>
	{
		DWORD dwPid = atoi(argv[<span class="hljs-number">1</span>]);

		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] Analysing process with ID %u\n"</span>, dwPid);

		HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);

		<span class="hljs-keyword">if</span> (!hProcess)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!] Failed to open process\n"</span>);
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		}

		<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> badgerId;
		<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">wstring</span>&gt; configStrings;

		<span class="hljs-keyword">if</span> (!ScanProcessForBadgerConfig(hProcess, badgerId, configStrings))
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[!] Failed to locate badger configuration in memory\n"</span>);
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		}

		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"[+] Badger '%s' found...\n"</span>, badgerId.c_str());

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> configString : configStrings)
		{
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"    : %S\n"</span>, configString.c_str());
		}

		CloseHandle(hProcess);
	}

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>



<p>Running the extractor tool on either an artifact or a running process (even while sleeping), will extract the Brute Ratel configuration state for the process or artifact:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-34-960x498.png" alt="" class="wp-image-3069" width="720" height="374"></figure>



<h1 class="wp-block-heading">Updated v1.1 Analysis</h1>



<p>Shortly after our talk on this subject at x33fcon, Brute Ratel announced a new version of the software. As such, it seemed appropriate to analyse this to ensure defenders have accurate advice given the recent uptake in Brute Ratel by threat actors.</p>



<h2 class="wp-block-heading">Analysis of Obfuscate and Sleep Techniques</h2>



<p>One of the things that struck us about the v1.1 release, was the declaration that the author had discovered new sleep and obfuscate techniques. As stated in this <a href="https://www.youtube.com/watch?v=nB5QHVtN9_g&amp;t=267s" target="_blank" rel="noreferrer noopener">YouTube video</a> “<strong>Brute Ratel C4 v/s Nighthawk and Open Source Sleep Obfuscation Techniques</strong>“, the author says “I didn’t even knew (SIC) about this technique until Austin released the blog post on this. However, Brute Ratel does not use either of these two techniques that we have seen over here.” in reference to the APC technique used in <a href="https://github.com/SecIdiot/FOLIAGE" target="_blank" rel="noreferrer noopener">Foliage</a> and the Timer based technique as used in MDSec’s Nighthawk and as reverse engineered <a href="https://suspicious.actor/2022/05/05/mdsec-nighthawk-study.html" target="_blank" rel="noreferrer noopener">here</a> and a proof of concept implementation released <a href="https://github.com/Cracked5pider/Ekko/blob/main/Src/Ekko.c" target="_blank" rel="noreferrer noopener">here</a>. Noting that this video appeared a short time after the Ekko release.</p>



<p>Reverse engineering of the obfuscate in sleep techniques used within Brute Ratel v1.1 reveal that three sleeping strategies are now available. The first, as we have previously documented is an extremely similar implementation to <a href="https://twitter.com/ilove2pwn_" target="_blank" rel="noreferrer noopener">@ilove2pwn_</a>’s Foliage, if not an exact copy.</p>



<p>The second implementation, reverse engineering revealed to be an almost identical implementation of <a href="https://twitter.com/c5pider" target="_blank" rel="noreferrer noopener">@c5pider</a>’s Ekko code (and originally discovered by <a href="https://twitter.com/peterwintrsmith" target="_blank" rel="noreferrer noopener">Peter Winter-Smith</a> and used in MDSec’s Nighthawk). For example, consider the following taken from <a href="https://github.com/Cracked5pider/Ekko/blob/main/Src/Ekko.c#L97" target="_blank" rel="noreferrer noopener">Ekko</a>:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-35-960x604.png" alt="" class="wp-image-3070" width="720" height="453"></figure>



<p>Compare this with the technique implemented inside Brute Ratel:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-36-960x640.png" alt="" class="wp-image-3071" width="720" height="480"></figure>



<p>As you can see, the code is almost identical; indeed the few changes include replacing the WinApi calls for CreateTimerQueueTimer with the Rtl wrapper RtlCreateTimer, noting that the breakpoints for Rtl wrappers were avoided (likely intentionally) in the aforementioned video demonstration.</p>



<p>This brings us to the third technique used by Brute Ratel which is a variation of timers and is not publicly documented. We can see here that this technique uses a subtle variation on timers and instead proxies the timer through RtlRegisterWait:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-37-960x508.png" alt="" class="wp-image-3072" width="720" height="381"></figure>



<p>While this technique is not publicly documented, it has been available in Nighthawk for some time, coincidentally with the same values used for many of the constants. Further coincidences arise with other undocumented/unpublished features arising in the Brute Ratel v1.1 release.<br>So far, we have only discussed the sleeping techniques available in the x64 implementation of Brute Ratel. Analysis of the x86 implementation shows that the obfuscate and sleep strategies are fixed to the aforementioned APC Foliage based implementation (noting the breakpoints never hit):</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-38-960x244.png" alt="" class="wp-image-3073" width="720" height="183"></figure>



<p>To date there are no public or open source x86 implementations of obfuscate and sleep strategies that use timers, limiting the available opportunities to easily integrate such code without custom development.</p>



<h2 class="wp-block-heading"><strong>In Memory Detections</strong></h2>



<p>One of the updates in the v1.1 release implies that the .rdata section is now also obfuscated, in order to hide strings such as “[+] AMSI Patched” which were exposed in the memory of the sleeping badger. However, even cursory memory analysis shows there remains many exposed strings within the memory of the sleeping badger. As a result, this means there are many opportunities to pluck out Brute Ratel processes on an endpoint, even while the badger is sleeping. For example, consider the Brute Ratel C2 data which is stored in a JSON format, simply searching for one of its unique parameters in memory such as “chkin” will allow us to spot a badger:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-39-960x364.png" alt="" class="wp-image-3075" width="720" height="273"></figure>



<p>Or simply searching for the badger identifier (e.g. b-) will find them scattered all over both the heap and the stack. As a bonus, this can act as simple mechanism to spot the thread that Brute Ratel is operating from, for example:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="40" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-40-960x40.png" alt="" class="wp-image-3076"></figure>



<p>Here we can see the presence of the “b-4\” on the stack of thread 4344. We can confirm that is indeed the thread for Brute Ratel from the UI:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="159" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-41-960x159.png" alt="" class="wp-image-3077"></figure>



<p>With this in mind, we’re able to build a simple but effective Yara rule to pluck sleeping Brute Ratel processes from memory:</p>



<pre class="wp-block-code"><code class="hljs css"><span class="hljs-selector-tag">rule</span> <span class="hljs-selector-tag">brc4_badger_strings</span>
{
<span class="hljs-attribute">meta</span>:
    author = <span class="hljs-string">"@domchell"</span>
    description = <span class="hljs-string">"Identifies strings from Brute Ratel v1.1"</span>
strings:
    $a = <span class="hljs-string">"\"chkin\":"</span>
condition:
    $a
}</code></pre>



<p>Executing the Yara rule, we can spot the sleeping badger:</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" decoding="async" width="960" height="317" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-42-960x317.png" alt="" class="wp-image-3078"></figure>



<p>The detections documented in v1.0 for post-exploitation actions such as suspicious copy on write operations remain relevant and still offer an effective means of detection for BRC4 post-exploitation.</p>



<h2 class="wp-block-heading"><strong>Thread Stack Spoofing</strong></h2>



<p>In the v1.0 release of Brute Ratel, as we noted the start address of the thread is hardcoded to ntdll!TpReleaseCleanupGroupMembers+0x550. Version 1.1 proclaims to offer “full thread stack masquerading”. Analysis of the stack spoofing for Brute Ratel reveals a simplistic implementation of rewriting the threads call stack. This process occurs just prior to the badger going to sleep, using the aforementioned timer technique. In an attempt to make the thread appear more legitimate, a new thread stack is created with hardcoded addresses for the first two frames. The addresses hardcoded are at offsets 0xa and 0x12 from RtlUserThreadStart and BaseThreadInitThunk respectively:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-43-960x583.png" alt="" class="wp-image-3079" width="720" height="437"></figure>



<p>We were able to identify any other threads using these hardcoded start addresses, as such it becomes trivial to identify any Brute Ratel threads on a system. To detect these threads, we updated BeaconHunter accordingly to identify threads with the first two frames at RtlUserThreadStart+0xa and BaseThreadInitThunk+0x12:</p>



<figure class="wp-block-image size-large is-resized is-style-default"><img loading="lazy" decoding="async" src="https://www.mdsec.co.uk/wp-content/uploads/2022/08/image-44-960x581.png" alt="" class="wp-image-3080" width="720" height="436"></figure>



<h2 class="wp-block-heading">Updated rDLL Extraction</h2>



<p>Shortly after our analysis at x33fcon, Brute Ratel announced an update to the method in which the artifacts hide the reflective DLL. Analysis of these artifacts revealed that this is achieved using RC4 to encrypt the reflective DLL with a random key; the PE header is then stomped. The 8 byte RC4 key is appended to the encrypted reflective DLL, followed by 400 bytes of base64 configuration file.</p>



<p>We developed the following tool targeting Brute Ratel v1.1 to extract the reflective DLL from DLL and EXE artifacts:</p>



<pre class="wp-block-code"><code class="hljs cpp"><span class="hljs-comment">//</span>
<span class="hljs-comment">// only works with BRC4 1.1 binaries.</span>
<span class="hljs-comment">//</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> &lt;algorithm</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">RC4_CTX</span> {</span>
    BYTE       x, y;
    BYTE       s[<span class="hljs-number">256</span>];
} RC4_CTX, *PRC4_CTX;

<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;BYTE&gt;
<span class="hljs-title">ReadData</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> path)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::ifstream <span class="hljs-title">instream</span><span class="hljs-params">(path, <span class="hljs-built_in">std</span>::ios::in | <span class="hljs-built_in">std</span>::ios::binary)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;BYTE&gt; <span class="hljs-title">input</span><span class="hljs-params">((<span class="hljs-built_in">std</span>::istreambuf_iterator&lt;<span class="hljs-keyword">char</span>&gt;(instream)), <span class="hljs-built_in">std</span>::istreambuf_iterator&lt;<span class="hljs-keyword">char</span>&gt;())</span></span>;
    <span class="hljs-keyword">return</span> input;
}

<span class="hljs-function"><span class="hljs-keyword">bool</span>
<span class="hljs-title">WriteData</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> path, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;BYTE&gt; data)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::ofstream <span class="hljs-title">outstream</span><span class="hljs-params">(path, <span class="hljs-built_in">std</span>::ios::out | <span class="hljs-built_in">std</span>::ios::binary)</span></span>;
    <span class="hljs-built_in">std</span>::copy(data.begin(), data.end(), <span class="hljs-built_in">std</span>::ostreambuf_iterator&lt;<span class="hljs-keyword">char</span>&gt;(outstream));
    <span class="hljs-keyword">return</span> outstream.good();
}

BYTE 
start_sig[]={
#<span class="hljs-keyword">if</span> defined(_WIN64)
    <span class="hljs-number">0x55</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x41</span>,
    <span class="hljs-number">0x54</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x55</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0x48</span>, <span class="hljs-number">0x31</span>,
    <span class="hljs-number">0xC0</span>, <span class="hljs-number">0x50</span>
#<span class="hljs-keyword">else</span>
    <span class="hljs-number">0x60</span>, <span class="hljs-number">0x89</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x83</span>, <span class="hljs-number">0xE4</span>, <span class="hljs-number">0xF8</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xC0</span>, <span class="hljs-number">0x50</span>
#endif
};

BYTE
end_sig[]={
#<span class="hljs-keyword">if</span> defined(_WIN64)
    <span class="hljs-number">0x41</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x5B</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x58</span>, 
    <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0x5B</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0xC3</span>
#<span class="hljs-keyword">else</span>
    <span class="hljs-number">0x83</span>, <span class="hljs-number">0xC4</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0xC3</span>
#endif
};

<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">RC4_set_key</span><span class="hljs-params">(
    PRC4_CTX c,
    PVOID    key,
    UINT     keylen)</span>
</span>{
    UINT i;
    UCHAR j;
    PUCHAR k=(PUCHAR)key;

    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++) {
        c-&gt;s[i] = (UCHAR)i;
    }
    
    c-&gt;x = <span class="hljs-number">0</span>; c-&gt;y = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++) {
        j = (j + (c-&gt;s[i] + k[i % keylen]));
        UCHAR t = c-&gt;s[i];
        c-&gt;s[i] = c-&gt;s[j];
        c-&gt;s[j] = t;
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">RC4_crypt</span><span class="hljs-params">(
    PRC4_CTX c, 
    PUCHAR   buf, 
    UINT     len)</span>
</span>{
    UCHAR x = c-&gt;x, y = c-&gt;y, j=<span class="hljs-number">0</span>, t;

    <span class="hljs-keyword">for</span> (UINT i=<span class="hljs-number">0</span>; i&lt;len; i++) {
        x = (x + <span class="hljs-number">1</span>);
        y = (y + c-&gt;s[x]);
        t = c-&gt;s[x];
        c-&gt;s[x] = c-&gt;s[y];
        c-&gt;s[y] = t;
        j = (c-&gt;s[x] + c-&gt;s[y]);
        buf[i] ^= c-&gt;s[j];
    }
    c-&gt;x = x;
    c-&gt;y = y;
}

<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;BYTE&gt;
<span class="hljs-title">extract_encrypted_rdll</span><span class="hljs-params">(PBYTE ptr, DWORD maxlen)</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;BYTE&gt; outbuf;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Searching %ld bytes.\n"</span>, maxlen);
    
    <span class="hljs-keyword">for</span> (DWORD i=<span class="hljs-number">0</span>; i&lt;maxlen;) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">memcmp</span>(&amp;ptr[i], end_sig, <span class="hljs-keyword">sizeof</span>(end_sig))) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Reached end of signature...\n"</span>);
            <span class="hljs-keyword">break</span>;
        }
    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_WIN64)</span>
        <span class="hljs-keyword">if</span> ((ptr[i] &amp; <span class="hljs-number">0x40</span>) == <span class="hljs-number">0x40</span> &amp;&amp; (ptr[i+<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0xB0</span>) == <span class="hljs-number">0xB0</span>) 
        {
            BYTE buf[<span class="hljs-number">8</span>];
            
            buf[<span class="hljs-number">0</span>] = ptr[i + <span class="hljs-number">9</span>];
            buf[<span class="hljs-number">1</span>] = ptr[i + <span class="hljs-number">8</span>];
            buf[<span class="hljs-number">2</span>] = ptr[i + <span class="hljs-number">7</span>];
            buf[<span class="hljs-number">3</span>] = ptr[i + <span class="hljs-number">6</span>];
            buf[<span class="hljs-number">4</span>] = ptr[i + <span class="hljs-number">5</span>];
            buf[<span class="hljs-number">5</span>] = ptr[i + <span class="hljs-number">4</span>];
            buf[<span class="hljs-number">6</span>] = ptr[i + <span class="hljs-number">3</span>];
            buf[<span class="hljs-number">7</span>] = ptr[i + <span class="hljs-number">2</span>];
            
            outbuf.insert(outbuf.end(), buf, buf + <span class="hljs-keyword">sizeof</span>(buf));
            i += (ptr[i + <span class="hljs-number">10</span>] == <span class="hljs-number">0x41</span>) ? <span class="hljs-number">12</span> : <span class="hljs-number">11</span>;
        } <span class="hljs-keyword">else</span> i++;
    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        <span class="hljs-keyword">if</span> ((ptr[i] &amp; <span class="hljs-number">0xB0</span>) == <span class="hljs-number">0xB0</span> &amp;&amp; (ptr[i+<span class="hljs-number">5</span>] &amp; <span class="hljs-number">0x50</span>) == <span class="hljs-number">0x50</span>) {
            BYTE buf[<span class="hljs-number">4</span>];
            
            buf[<span class="hljs-number">0</span>] = ptr[i + <span class="hljs-number">4</span>];
            buf[<span class="hljs-number">1</span>] = ptr[i + <span class="hljs-number">3</span>];
            buf[<span class="hljs-number">2</span>] = ptr[i + <span class="hljs-number">2</span>];
            buf[<span class="hljs-number">3</span>] = ptr[i + <span class="hljs-number">1</span>];
            
            outbuf.insert(outbuf.end(), buf, buf + <span class="hljs-keyword">sizeof</span>(buf));
            i += <span class="hljs-number">6</span>;
        } <span class="hljs-keyword">else</span> i++;
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    }
	<span class="hljs-built_in">std</span>::reverse(outbuf.begin(), outbuf.end());
    <span class="hljs-keyword">return</span> outbuf;
}

<span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{
    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"usage: decrypt_brc4 &lt;DLL|EXE&gt;\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;BYTE&gt; inbuf, infile = ReadData(argv[<span class="hljs-number">1</span>]);
    DWORD len=<span class="hljs-number">0</span>, ptr=<span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">if</span> (infile.empty()) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Nothing to read.\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">auto</span> dos = (PIMAGE_DOS_HEADER)infile.data();
        <span class="hljs-keyword">auto</span> nt = (PIMAGE_NT_HEADERS)(infile.data() + dos-&gt;e_lfanew);
        <span class="hljs-keyword">auto</span> s = IMAGE_FIRST_SECTION(nt);
        
        <span class="hljs-keyword">for</span> (DWORD i=<span class="hljs-number">0</span>; i&lt;nt-&gt;FileHeader.NumberOfSections; i++) {
            <span class="hljs-keyword">char</span> Name[IMAGE_SIZEOF_SHORT_NAME + <span class="hljs-number">1</span>] = {<span class="hljs-number">0</span>};
            <span class="hljs-built_in">memcpy</span>(Name, s[i].Name, IMAGE_SIZEOF_SHORT_NAME);
            
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(Name) == <span class="hljs-string">".data"</span>) {
                len = s[i].SizeOfRawData;
                ptr = s[i].PointerToRawData;
                <span class="hljs-keyword">break</span>;
            }
        }
        
        <span class="hljs-keyword">if</span> (!len) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Unable to locate .data section.\n"</span>);
            <span class="hljs-keyword">break</span>;
        }
        
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Searching %ld bytes for loader...\n"</span>, len);
        
        <span class="hljs-keyword">for</span> (DWORD idx=<span class="hljs-number">0</span>; idx&lt;len - <span class="hljs-keyword">sizeof</span>(start_sig); idx++) {
            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">memcmp</span>(infile.data() + ptr + idx, start_sig, <span class="hljs-keyword">sizeof</span>(start_sig))) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Found signature : %08lX\n"</span>, ptr + idx);
                inbuf = extract_encrypted_rdll(infile.data() + ptr + idx, len - idx);
                <span class="hljs-keyword">break</span>;
            }
        }
        
        <span class="hljs-keyword">if</span> (inbuf.size()) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"size : %zd\n"</span>, inbuf.size());
            RC4_CTX c;
            BYTE key[<span class="hljs-number">8</span>+<span class="hljs-number">1</span>] = {<span class="hljs-number">0</span>};
            <span class="hljs-built_in">memcpy</span>((<span class="hljs-keyword">char</span>*)key, inbuf.data() + inbuf.size() - <span class="hljs-number">400</span> - <span class="hljs-number">8</span>, <span class="hljs-number">8</span>);
            
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// Decrypt RDLL. The additional 400 bytes are base64 configuration.</span>
            <span class="hljs-comment">//</span>
            RC4_set_key(&amp;c, key, <span class="hljs-number">8</span>);
            RC4_crypt(&amp;c, inbuf.data(), inbuf.size() - <span class="hljs-number">400</span>);
            
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// Fix DOS header.</span>
            <span class="hljs-comment">//</span>
            inbuf[<span class="hljs-number">0</span>] = <span class="hljs-string">'M'</span>;
            inbuf[<span class="hljs-number">1</span>] = <span class="hljs-string">'Z'</span>;
            WriteData(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(argv[<span class="hljs-number">1</span>]) + <span class="hljs-string">".dll"</span>, inbuf);
        }
    } <span class="hljs-keyword">while</span> (FALSE);
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>



<h2 class="wp-block-heading">Conclusion</h2>



<p>In summary, we’ve highlighted a number of techniques to detect Brute Ratel both in its artifacts, in-memory, through threat hunting and across the network. As this framework grows in popularity with threat actors, it is important to understand the many ways in which it can be detected. As a side note, we have also illustrated how the framework takes close inspiration from the many available open source community tools; knowledge of these can assist in reverse engineering the framework and provide a better understanding of its capabilities (and by virtue its detection points).</p>



<p>This blog post was written <a href="https://twitter.com/domchell" target="_blank" rel="noreferrer noopener">Dominic Chell</a>.</p>
		</div>
		
		<div class="author">
			<div class="content-wrapper clearfix">
				<div class="author-avatar">
					<img alt="" src="https://secure.gravatar.com/avatar/9cb7b62409a4b5ef00769dca4ba852fc49229c9729d600fc2637daf77068c31c?s=96&amp;d=wp_user_avatar&amp;r=g" class="avatar avatar-96 photo" height="96" width="96" loading="lazy" decoding="async">				</div>
				<div class="author-meta">
					<div class="author-meta__content">
						<span>written by</span>
						<h4>MDSec Research</h4>
					</div>
				</div>
			</div>
		</div>
		<section class="testing">
	<div class="content-wrapper">
		<h2>Ready to engage<br>with MDSec?</h2>
		<div class="button">
			<a href="https://www.mdsec.co.uk/contact">
				Get in touch
			</a>
		</div>
	</div>
</section>		
	</section>




	<section class="newsletter">
	<div class="content-wrapper clearfix">
		<div class="newsletter-left">
			<p>
				Stay updated with the latest <br>news from MDSec.
			</p>
		</div>
		<div class="newsletter-right">
			<div class="frm_forms  with_frm_style frm_style_formidable-style" id="frm_form_2_container">
<form enctype="multipart/form-data" method="post" class="frm-show-form  frm_js_validate " id="form_newslettersignupform">
<div class="frm_form_fields ">
<fieldset>
<legend class="frm_screen_reader">Newsletter Signup Form</legend>

<div class="frm_fields_container">





<div id="frm_field_10_container" class="frm_form_field form-field  frm_none_container frm_full">
    <label for="field_nkjbj" id="field_nkjbj_label" class="frm_primary_label">Email
        <span class="frm_required"></span>
    </label>
    <input type="email" id="field_nkjbj" name="item_meta[10]" value="" placeholder="Enter your email for updates" data-invmsg="Email is invalid" aria-invalid="false">
    
    
</div>
<div id="frm_field_11_container" class="frm_form_field form-field  frm_none_container frm_first frm_full">
    <label for="g-recaptcha-response" id="field_ah4d8_label" class="frm_primary_label" style="display: none;">
        <span class="frm_required"></span>
    </label>
    <div id="field_ah4d8" class="frm-g-recaptcha" data-sitekey="6Lc27L0ZAAAAAMV4QCtKwWRbT-Hm1FnY6IKqcSxw" data-size="invisible" data-theme="light" data-rid="0"><div class="grecaptcha-badge" data-style="bottomright" style="width: 256px; height: 60px; display: block; transition: right 0.3s; position: fixed; bottom: 14px; right: -186px; box-shadow: gray 0px 0px 5px; border-radius: 2px; overflow: hidden;"><div class="grecaptcha-logo"><div title="reCAPTCHA" width="256" height="60" role="presentation" name="a-wtcwaip0aaf3" frameborder="0" scrolling="no" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation allow-modals allow-popups-to-escape-sandbox allow-storage-access-by-user-activation" src="https://www.google.com/recaptcha/api2/anchor?ar=1&amp;k=6Lc27L0ZAAAAAMV4QCtKwWRbT-Hm1FnY6IKqcSxw&amp;co=aHR0cHM6Ly93d3cubWRzZWMuY28udWs6NDQz&amp;hl=en&amp;v=vUgXt_KV952_-5BB2jjloYzl&amp;theme=light&amp;size=invisible&amp;anchor-ms=20000&amp;execute-ms=30000&amp;cb=jrlq2evr2d9n" data-original-tag="iframe">

<title>reCAPTCHA</title>

<link rel="stylesheet" type="text/css" href="https://www.gstatic.com/recaptcha/releases/vUgXt_KV952_-5BB2jjloYzl/styles__ltr.css">


<div id="rc-anchor-alert" class="rc-anchor-alert"></div>

<div class="rc-anchor rc-anchor-invisible rc-anchor-light  rc-anchor-invisible-hover"><div id="recaptcha-accessible-status" class="rc-anchor-aria-status" aria-hidden="true">Recaptcha requires verification. </div><div class="rc-anchor-error-msg-container" style="display:none"><span class="rc-anchor-error-msg" aria-hidden="true"></span></div><div class="rc-anchor-normal-footer"><div class="rc-anchor-logo-large" role="presentation"><div class="rc-anchor-logo-img rc-anchor-logo-img-large"></div></div><div class="rc-anchor-pt"><a href="https://www.google.com/intl/en/policies/privacy/" target="_blank">Privacy</a><span aria-hidden="true" role="presentation"> - </span><a href="https://www.google.com/intl/en/policies/terms/" target="_blank">Terms</a></div></div><div class="rc-anchor-invisible-text"><span>protected by <strong>reCAPTCHA</strong></span><div class="rc-anchor-pt"><a href="https://www.google.com/intl/en/policies/privacy/" target="_blank" style="">Privacy</a><span aria-hidden="true" role="presentation"> - </span><a href="https://www.google.com/intl/en/policies/terms/" target="_blank" style="">Terms</a></div></div></div></div></div><div class="grecaptcha-error"></div><textarea id="g-recaptcha-response" name="g-recaptcha-response" class="g-recaptcha-response" style="width: 250px; height: 40px; border: 1px solid rgb(193, 193, 193); margin: 10px 25px; padding: 0px; resize: none; display: none;"></textarea></div><div style="display: none;" data-original-tag="iframe"></div></div>
    
    
</div>
	
			<div id="frm_field_29_container">
			<label for="field_8bp9l" style="display:none;">
				If you are human, leave this field blank.			</label>
			<input id="field_8bp9l" type="text" class="frm_form_field form-field frm_verify" name="item_meta[29]" value="" style="display:none;">
		</div>
		<div class="frm_submit">

<button class="frm_button_submit" type="submit">Submit</button>

</div></div>
</fieldset>
</div>

</form>
</div>
			
		</div>
	</div>
</section>

		</div>
	<!-- Site Wrapper End -->
	
	<!-- Footer Start -->	
	

	<div class="end clearfix">
		<div class="end__left">
			Copyright 2026 MDSec
		</div>
		<div class="end__right">
			<!--<a href="#">Privacy Policy</a>-->
		</div>
	</div>
	<!-- Footer End -->
	
    










	
			
	
	



    	    			




</body><!-- Body End --></html>