Title:
Avoiding Memory Scanners

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post analyzes how Windows memory scanners detect in-memory implants and presents practical evasion techniques aimed at common open-source tools (YARA-based scanners, Moneta, PE-sieve, BeaconEye, BeaconHunter, Hunt-Sleeping-Beacons, MalMemDetect).  
- It breaks scanner capabilities into pattern matching, memory attribute heuristics (e.g., executable private memory, thread start/return addresses), and stack/call-trace based detection of sleeping beacons.  
- The core approach is to use the implant sleep window to encrypt heap/config data, remove executable permissions from implant code, and avoid suspicious wait reasons while maintaining functionality.  
- Techniques include RC4 via SystemFunction032 (advapi32) to avoid custom crypto stubs in private memory, secondary-heap encryption via IAT hooking of GetProcessHeap, and context/APC-based execution redirection (FOLIAGE/Ekko) using NtContinue to flip permissions and encrypt/decrypt around sleep.  
- It also covers bypassing stack/return-address inspection using at-rest context manipulation (NtSetContextThread) and at-execution return address spoofing with gadgets/stubs so hooked APIs don’t appear to be called from private memory.  
- The research culminates in AceLdr, a user-defined reflective loader for Cobalt Strike that combines these methods to achieve “zero hits” against the referenced scanners.  
- Useful primarily for red teams/implant developers, and secondarily for defenders to understand detection gaps and how adversaries adapt to memory scanning.

Technical Focus:
- YARA/pattern matching vs encrypted/obfuscated in-memory artifacts
- Memory attribute scanning (RX/RWX, private vs image commit) and thread metadata checks
- Sleep masking via permission flipping + encryption during idle periods
- NtContinue/APC or timer-queue based context chaining (FOLIAGE, Ekko)
- Heap isolation/encryption using secondary heaps and IAT hooking (GetProcessHeap)
- Call stack / return address spoofing (at-rest and at-execution) to evade stack-tracing scanners

Use Cases:
- Building or hardening reflective loaders and in-memory implants against commodity memory scanners
- Implementing sleep-masking that avoids “DelayExecution” detections (e.g., replacing Sleep with WaitForSingleObject)
- Encrypting beacon configuration/heap allocations to defeat targeted heap scanners (e.g., BeaconEye)
- Designing evasions for thread stack/return-address based heuristics (PE-sieve, MalMemDetect)
- Blue-team validation: reproducing bypasses to improve memory scanning and stack-tracing detections

Keywords:
Windows memory scanning, YARA, PE-sieve, Moneta, BeaconEye, BeaconHunter, Hunt-Sleeping-Beacons, MalMemDetect, Cobalt Strike, reflective loader, AceLdr, sleep mask, SystemFunction032, RC4, advapi32.dll, private commit, image commit, VirtualAlloc, NtContinue, NtQueueApcThread, CreateTimerQueueTimer, NtDelayExecution, WaitForSingleObject, NtSetContextThread, KiUserApcDispatcher, return address spoofing, IAT hooking, GetProcessHeap, KsecDD