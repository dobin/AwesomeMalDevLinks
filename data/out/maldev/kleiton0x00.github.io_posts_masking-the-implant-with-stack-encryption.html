# https://kleiton0x00.github.io/posts/Masking-the-Implant-with-Stack-Encryption/

<!DOCTYPE html><html lang="en"><body data-spy="scroll" data-target="#toc"><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="https://kleiton0x00.github.io/"> Posts </a> </span> <span>Masking the Implant with Stack Encryption</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel">Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip="">Masking the Implant with Stack Encryption</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="" data-original-title="Tue, May 2, 2023, 12:00 AM +0200">May 1, 2023<i class="unloaded">2023-05-02T00:00:00+02:00</i></span> by <span class="author"> kleiton0x7e </span></div></div><div class="post-content"><p>Mirrored from <a href="https://whiteknightlabs.com/2023/05/02/masking-the-implant-with-stack-encryption/">WKL Security</a></p><h2 id="introduction">Introduction</h2><p>This article is a demonstration of memory-based detection and evasion techniques. Whenever you build a Command &amp; Control or you perform threat hunting, there will be scenarios when you might need to analyze the memory artifacts of a specific system—something that is really useful during your live forensics or when you’re going to perform an incident response on a host by segregating that host from the network. In such scenarios, it would be required to identify the payload that is currently running in memory. We will be taking a look at some of the examples of how that payload investigation can be performed, and how that investigation can be bypassed as well.</p><p>A lot of times during an engagement, an engineer might execute a payload: either Cobalt Strike, Havoc or any other open source C2s that are currently there. There are specific scenarios where the red teamer might want to execute a command on the endpoint, which gathers a lot of strings and sends that to your C2 host. These strings can be username, hostname, or even information related to your command and control server itself and the information might also be encrypted during transit. However, when the payload sleeps on the endpoint, and the red teamer adds sleep and jitter to the beacon, these commands need to be stored in an encrypted way. In this current scenario, this information can be either stored into a heap or on stack.</p><p>Regarding heap memory, usually we don’t have to worry about it because you can eventually walk a heap, extract information, and encrypt when you are sleeping. However, things change a bit when we talk about stack encryption.</p><h2 id="the-problem-with-loaders">The problem with loaders</h2><p>In a traditional shellcode loader, the shellcode is stored in stack memory since it is stored in a variable inside or outside of a function. When the shellcode is written with <code class="language-plaintext highlighter-rouge">WriteProcessMemory</code> to a local/remote process, not only is the shellcode stored in that particular memory but also it remains stored in the stack, where the variable lives.</p><p><img src="https://whiteknightlabs.com/wp-content/uploads/2023/04/Pasted-image-20230429021705-1024x342.png" data-src="https://whiteknightlabs.com/wp-content/uploads/2023/04/Pasted-image-20230429021705-1024x342.png" alt="shellcode_living_in_stack" data-loaded="true"></p><h2 id="finding-the-stack">Finding the stack</h2><p>To quickly identify where the stack is located, we need to retrieve the RSP address. This register will contain the address of the top of the stack.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rsp</span><span class="p">;</span>
<span class="n">asm</span><span class="p">(</span><span class="s">"movq %%rsp, %0;"</span> <span class="o">:</span> <span class="s">"=r"</span> <span class="p">(</span><span class="n">rsp</span><span class="p">));</span>
</pre></td></tr></tbody></table></code></div></div><p>While the top of the stack is easily identifiable, the bottom is much harder as the stack dynamically increases and/or decreases in size based on the variables that are stored and freed as the code is executed. Luckily <code class="language-plaintext highlighter-rouge">VirtualQuery</code> makes it so easy for us to retrieve information about the range of pages in the virtual address space of the calling process. So using the RSP address that we found previously allows us to determine the top and the bottom of the stack:</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">// Get the address range of the stack</span>
<span class="n">MEMORY_BASIC_INFORMATION</span> <span class="n">mbi</span><span class="p">;</span>
<span class="n">VirtualQuery</span><span class="p">(</span><span class="n">rsp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbi</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbi</span><span class="p">));</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stackRegion</span> <span class="o">=</span> <span class="n">mbi</span><span class="p">.</span><span class="n">BaseAddress</span> <span class="o">-</span> <span class="mi">8192</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stackBase</span> <span class="o">=</span> <span class="n">stackRegion</span> <span class="o">+</span> <span class="n">mbi</span><span class="p">.</span><span class="n">RegionSize</span> <span class="o">+</span> <span class="mi">8192</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><h2 id="suspending-the-thread-to-avoid-abnormal-behavior">Suspending the thread to avoid abnormal behavior</h2><p>It is required to suspend the process before encrypting or decrypting the stack. This is because modifying the stack while the process is still running can cause unpredictable behavior and potential crashes.</p><p>To suspend the process, we can use the SuspendThread function from the Windows API, which suspends the execution of a thread until it is resumed with the ResumeThread function.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EncryptThread</span><span class="p">,</span> <span class="n">rsp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">ResumeThread</span><span class="p">(</span><span class="n">hThread</span><span class="p">);</span>

<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">EncryptThread</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">lpParameter</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//...mask the stack</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><h2 id="encrypting-what-we-need-to-hide">Encrypting what we need to hide</h2><p>Encrypting from the beginning of the page to the bottom of the stack might look suspicious and is not the most OPSEC-safe approach. Instead, we will encrypt where the stack actually begins (RSP address) and the bottom of the stack (minus 8 bytes).</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">stackSize</span> <span class="o">=</span> <span class="n">stackBase</span> <span class="o">-</span> <span class="n">rsp</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">//the part that will be encrypted</span>
</pre></td></tr></tbody></table></code></div></div><p>Below is the image of the range that should be encrypted, starting from RSP address (where the plaintext strings and the shellcode is stored) until the end of the stack:</p><p><img src="https://whiteknightlabs.com/wp-content/uploads/2023/04/Pasted-image-20230429023047.png" data-src="https://whiteknightlabs.com/wp-content/uploads/2023/04/Pasted-image-20230429023047.png" alt="stack_region_between_rsp_and_base" data-loaded="true"></p><p>The encryption routine is pretty simple; XOR byte per byte until you reach the end of the stack:</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">//mask everything between the addresses of RSP and bottom of the stack</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">rsp</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stackSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="o">^=</span> <span class="mh">0x55</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><p>If we analyze the stack of the loader, we can clearly see what the stack will look like after the encryption:</p><p><img src="https://whiteknightlabs.com/wp-content/uploads/2023/05/Screenshot-from-2023-05-01-16-02-29.png" data-src="https://whiteknightlabs.com/wp-content/uploads/2023/05/Screenshot-from-2023-05-01-16-02-29.png" alt="stack_encrypted_and_decrypted" data-loaded="true"></p><h2 id="theres-no-sleepmask-without-sleeping">There’s no sleepmask without sleeping</h2><p>Some modern detection solutions possess countermeasures against a basic <code class="language-plaintext highlighter-rouge">Sleep()</code>. For example, hooking sleep functions like <code class="language-plaintext highlighter-rouge">Sleep</code> in C/C++ or <code class="language-plaintext highlighter-rouge">Thread.Sleep</code> in C# to nullify the sleep, but also fast forwarding.</p><p>There is already a nice technique that leverages CPU cycles to perform a custom sleep. I am not going to further describe how it works as it is already well-explained here in this <a href="https://shubakki.github.io/posts/2022/12/detecting-and-evading-sandboxing-through-time-based-evasion/">article</a>.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">__get_timestamp</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">UNIX_TIME_START</span> <span class="o">=</span> <span class="mh">0x019DB1DED53E8000</span><span class="p">;</span> <span class="c1">// Start of Unix epoch in ticks.</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">TICKS_PER_MILLISECOND</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="c1">// A tick is 100ns.</span>
	<span class="n">LARGE_INTEGER</span> <span class="n">time</span><span class="p">;</span>
	<span class="n">time</span><span class="p">.</span><span class="n">LowPart</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)(</span><span class="mh">0x7FFE0000</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">);</span> <span class="c1">// Read LowPart as unsigned long.</span>
	<span class="n">time</span><span class="p">.</span><span class="n">HighPart</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="mh">0x7FFE0000</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="p">);</span> <span class="c1">// Read High1Part as long.</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)((</span><span class="n">time</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">-</span> <span class="n">UNIX_TIME_START</span><span class="p">)</span> <span class="o">/</span> <span class="n">TICKS_PER_MILLISECOND</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__alt_sleepms</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="kt">size_t</span> <span class="n">x</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span> <span class="c1">// random buffer var </span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">__get_timestamp</span><span class="p">()</span> <span class="o">+</span> <span class="n">ms</span><span class="p">;</span> <span class="c1">// calculate when we shall stop sleeping</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__get_timestamp</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// increment random var by 1 till we reach our endtime</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__get_timestamp</span><span class="p">()</span> <span class="o">-</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// Fast Forward check, might need some tuning	</span>
<span class="p">}</span>

<span class="n">__alt_sleepms</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span> <span class="c1">//sleep for 5 seconds</span>
</pre></td></tr></tbody></table></code></div></div><h2 id="wrapping-everything-up">Wrapping everything up</h2><p>In conclusion, understanding memory-based detection and evasion techniques is crucial for effective threat hunting and incident response. Investigating the payloads that are running in memory can provide critical information about a system’s state, but it can also be bypassed through stack encryption techniques.</p><p>The code for this PoC can be found in this GitHub <a href="https://github.com/WKL-Sec/StackMask">repo</a>.</p><h2 id="credits">Credits</h2><p><a href="https://shubakki.github.io/posts/2022/12/detecting-and-evading-sandboxing-through-time-based-evasion/">https://shubakki.github.io/posts/2022/12/detecting-and-evading-sandboxing-through-time-based-evasion/</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Masking%20the%20Implant%20with%20Stack%20Encryption%20-%20kleiton0x7e&amp;url=protocol://domain/posts/Masking-the-Implant-with-Stack-Encryption/" data-toggle="tooltip" data-placement="top" title="" target="_blank" rel="noopener" aria-label="Twitter" data-original-title="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Masking%20the%20Implant%20with%20Stack%20Encryption%20-%20kleiton0x7e&amp;u=protocol://domain/posts/Masking-the-Implant-with-Stack-Encryption/" data-toggle="tooltip" data-placement="top" title="" target="_blank" rel="noopener" aria-label="Facebook" data-original-title="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Masking%20the%20Implant%20with%20Stack%20Encryption%20-%20kleiton0x7e&amp;url=protocol://domain/posts/Masking-the-Implant-with-Stack-Encryption/" data-toggle="tooltip" data-placement="top" title="" target="_blank" rel="noopener" aria-label="Telegram" data-original-title="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=protocol://domain/posts/Masking-the-Implant-with-Stack-Encryption/" data-toggle="tooltip" data-placement="top" title="" target="_blank" rel="noopener" aria-label="Linkedin" data-original-title="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <a href="https://kleiton0x00.github.io/posts/Masking-the-Implant-with-Stack-Encryption/" data-toggle="tooltip" data-placement="top" title="" target="_blank" rel="noopener" aria-label="" data-original-title=""> <i class="fa-fw "></i> </a> <i class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="" data-original-title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip="">Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="https://kleiton0x00.github.io/posts/Navigating-Stealthy-WMI-Lateral-Movement/"><div class="card-body"> <span class="timeago small">Jun 25, 2023<i class="unloaded">2023-06-26T00:00:00+02:00</i></span><h3 class="pt-0 mt-1 mb-3" data-toc-skip="">Navigating Stealthy WMI Lateral Movement</h3><div class="text-muted small"><p> Mirrored from WKL Security Introduction In this article, we’ll look at a Python script that uses Windows Management Instrumentation (WMI) to remotely control a target computer. The script makes u...</p></div></div></a></div><div class="card"> <a href="https://kleiton0x00.github.io/posts/Harnessing-the-Power-of-Cobalt-Strike-Profiles-for-EDR-Evasion/"><div class="card-body"> <span class="timeago small">May 22, 2023<i class="unloaded">2023-05-23T00:00:00+02:00</i></span><h3 class="pt-0 mt-1 mb-3" data-toc-skip="">Harnessing the Power of Cobalt Strike Profiles for EDR Evasion</h3><div class="text-muted small"><p> Mirrored from WKL Security. This version is an update ahead. Introduction In this blog post, we will go through the importance of each profile’s option, and explore the differences between defaul...</p></div></div></a></div><div class="card"> <a href="https://kleiton0x00.github.io/posts/Shellcodes-are-dead-long-live-fileless-shellcodes/"><div class="card-body"> <span class="timeago small">Feb 4, 2023<i class="unloaded">2023-02-05T00:00:00+01:00</i></span><h3 class="pt-0 mt-1 mb-3" data-toc-skip="">Shellcodes are dead, long live Fileless Shellcodes</h3><div class="text-muted small"><p> Recently I was developing a simple Shellcode Loader which uses Callbacks as an alternative of Shellcode execution. While it bypasses every runtime scanning, it failed to bypass the signature detect...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="https://kleiton0x00.github.io/posts/Shellcodes-are-dead-long-live-fileless-shellcodes/" class="btn btn-outline-primary"><p>Shellcodes are dead, long live Fileless Shellcodes</p></a> <a href="https://kleiton0x00.github.io/posts/Harnessing-the-Power-of-Cobalt-Strike-Profiles-for-EDR-Evasion/" class="btn btn-outline-primary"><p>Harnessing the Power of Cobalt Strike Profiles for EDR Evasion</p></a></div></div></div></div> </div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="https://kleiton0x00.github.io/posts/Masking-the-Implant-with-Stack-Encryption/#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a>    
</body></html>