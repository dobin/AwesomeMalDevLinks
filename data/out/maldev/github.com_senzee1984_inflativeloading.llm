Title:
InflativeLoading

Type:
GitHub Tool

Short Summary (4–8 sentences max):
- InflativeLoading is a Windows x64 toolchain that converts unmanaged EXE/DLL payloads into position-independent “shellcode” by dumping the PE as it exists in memory and prepending a custom loader stub.  
- It aims to improve on classic reflective loading by using an in-memory dump (reducing disk-vs-memory discrepancies), avoiding extra manual mapping work, and enabling more controlled memory permissions (avoiding RWX).  
- The generated stub walks the PEB to resolve kernel32 exports (LoadLibraryA/GetProcAddress), patches PE structures (imports, relocations, delayed imports), optionally obfuscates PE header signatures, then transfers execution to the PE entry point and exits cleanly.  
- Recent updates add PE header signature obfuscation, NOP-like padding sequences (instead of long 0x90 runs), improved relocation/import handling for edge cases (e.g., malformed relocation entries in some payloads), and support for unmanaged DLLs.  
- Includes a companion C++ utility (DumpPEFromMemory.exe) that creates a suspended process (EXE) or maps a DLL to dump the main module and suggests memory allocation layout for the final shellcode blob.  
- Useful for red teams, implant developers, and malware researchers experimenting with PE-to-shellcode conversion, loader tradecraft, and evasive in-memory execution; also relevant for blue teams studying detection opportunities around custom loaders and PE header tampering.

Technical Focus:
- PEB walking and dynamic API resolution (kernel32 export parsing)
- In-memory PE dumping (suspended process / file mapping) and module reconstruction
- Import Address Table (IAT) fixing and delayed import handling
- Base relocation processing and edge-case relocation validation
- PE header/signature obfuscation (e_lfanew and directory RVAs) and post-load wiping
- Memory layout/permissions strategy (separate regions for stub/header/.text/other sections; avoiding RWX)

Use Cases:
- Convert unmanaged EXE tools (e.g., console utilities) into PIC-like shellcode blobs for custom loaders
- Convert unmanaged DLL payloads into shellcode for in-memory execution without requiring a reflective export
- Experiment with PE header obfuscation and reduced static signatures in memory
- Build/test alternative staging formats for C2 payloads (e.g., Havoc/Cobalt Strike stageless EXE/DLL)
- Research/detect reflective-loading variants and PE-structure patching behaviors

Keywords:
Windows x64, PE, PIC shellcode, reflective loading, PEB walk, kernel32.dll, LoadLibraryA, GetProcAddress, IAT fixing, delayed imports, base relocations, PE header obfuscation, e_lfanew, VirtualAlloc, memory permissions, in-memory dumping, suspended process, DLL mapping, UPX packed EXE, Cobalt Strike, Havoc