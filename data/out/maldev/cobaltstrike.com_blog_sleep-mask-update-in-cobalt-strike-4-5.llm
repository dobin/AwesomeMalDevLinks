Title:
Sleep Mask Update in Cobalt Strike 4.5

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post describes updates to Cobalt Strike’s Sleep Mask Kit in version 4.5, which lets operators modify Beacon’s in-memory “sleep mask” routine to evade static memory signatures.  
- The main problem addressed is that defenders can detect Beacon via YARA/static patterns in memory (including Beacon configuration data living on the heap).  
- Cobalt Strike 4.5 increases the allowed sleep mask code size and adds heap address records to the sleep mask input so the kit can mask/unmask Beacon heap regions in addition to prior targets.  
- It introduces new data structures (HEAP_RECORDS) and changes the SLEEPMASKP input, breaking compatibility with 4.4 sleep mask implementations.  
- An example shows a BeaconEye-derived YARA rule detecting Beacon config in heap when unmasked, then failing once heap masking is enabled during longer sleep intervals.  
- Useful primarily for red teams/pentesters customizing Beacon OPSEC, and for blue teams understanding what memory artifacts may be intentionally obfuscated.

Technical Focus:
- Beacon sleep mask customization and in-memory obfuscation
- Heap memory masking/unmasking via HEAP_RECORDS
- YARA-based in-memory signature detection (BeaconEye-style rules)
- Cobalt Strike 4.4 vs 4.5 sleep mask interface/ABI changes (SLEEPMASKP)
- Constraints of the Sleep Mask Kit (code size, single function, no external calls)

Use Cases:
- Evade static/YARA memory signatures targeting Beacon configuration artifacts
- Reduce forensic visibility of Beacon heap-resident data during sleep
- Build conditional masking logic based on sleep duration for performance/OPSEC tradeoffs
- Validate defensive detections by testing masked vs unmasked memory regions

Keywords:
Cobalt Strike 4.5, Beacon, Sleep Mask Kit, sleep mask, in-memory obfuscation, heap masking, HEAP_RECORDS, SLEEPMASKP, YARA, BeaconEye, static signatures, Beacon configuration, Process Hacker, memory scanning, OPSEC, signature evasion, red team tooling, in-memory detection