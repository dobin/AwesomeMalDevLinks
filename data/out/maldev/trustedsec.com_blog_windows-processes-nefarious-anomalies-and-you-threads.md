# https://www.trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-threads

![Revisit consent button](https://cdn-cookieyes.com/assets/images/revisit.svg)

We value your privacy

We use cookies to enhance your browsing experience, serve personalised ads or content, and analyse our traffic. By clicking "Accept All", you consent to our use of cookies.

CustomiseReject AllAccept All

Customise Consent Preferences![Close](https://cdn-cookieyes.com/assets/images/close.svg)

We use cookies to help you navigate efficiently and perform certain functions. You will find detailed information about all cookies under each consent category below.

The cookies that are categorised as "Necessary" are stored on your browser as they are essential for enabling the basic functionalities of the site. ... Show more

NecessaryAlways Active

Necessary cookies are required to enable the basic features of this site, such as providing secure log-in or adjusting your consent preferences. These cookies do not store any personally identifiable data.

- Cookie

\_\_cf\_bm

- Duration

1 hour

- Description

This cookie, set by Cloudflare, is used to support Cloudflare Bot Management.


- Cookie

\_\_hssrc

- Duration

session

- Description

This cookie is set by Hubspot whenever it changes the session cookie. The \_\_hssrc cookie set to 1 indicates that the user has restarted the browser, and if the cookie does not exist, it is assumed to be a new session.


- Cookie

\_\_hssc

- Duration

1 hour

- Description

HubSpot sets this cookie to keep track of sessions and to determine if HubSpot should increment the session number and timestamps in the \_\_hstc cookie.


- Cookie

\_cfuvid

- Duration

session

- Description

Calendly sets this cookie to track users across sessions to optimize user experience by maintaining session consistency and providing personalized services


Functional

Functional cookies help perform certain functionalities like sharing the content of the website on social media platforms, collecting feedback, and other third-party features.

- Cookie

lidc

- Duration

1 day

- Description

LinkedIn sets the lidc cookie to facilitate data center selection.


- Cookie

li\_gc

- Duration

6 months

- Description

Linkedin set this cookie for storing visitor's consent regarding using cookies for non-essential purposes.


Analytics

Analytical cookies are used to understand how visitors interact with the website. These cookies help provide information on metrics such as the number of visitors, bounce rate, traffic source, etc.

- Cookie

\_gcl\_au

- Duration

3 months

- Description

Google Tag Manager sets the cookie to experiment advertisement efficiency of websites using their services.


- Cookie

\_ga\_\*

- Duration

1 year 1 month 4 days

- Description

Google Analytics sets this cookie to store and count page views.


- Cookie

\_ga

- Duration

1 year 1 month 4 days

- Description

Google Analytics sets this cookie to calculate visitor, session and campaign data and track site usage for the site's analytics report. The cookie stores information anonymously and assigns a randomly generated number to recognise unique visitors.


- Cookie

\_\_hstc

- Duration

6 months

- Description

Hubspot set this main cookie for tracking visitors. It contains the domain, initial timestamp (first visit), last timestamp (last visit), current timestamp (this visit), and session number (increments for each subsequent session).


- Cookie

hubspotutk

- Duration

6 months

- Description

HubSpot sets this cookie to keep track of the visitors to the website. This cookie is passed to HubSpot on form submission and used when deduplicating contacts.


Performance

Performance cookies are used to understand and analyse the key performance indexes of the website which helps in delivering a better user experience for the visitors.

- Cookie

session\_id

- Duration

1 year

- Description

This cookie is used to get or set the session id for the current session.


Advertisement

Advertisement cookies are used to provide visitors with customised advertisements based on the pages you visited previously and to analyse the effectiveness of the ad campaigns.

- Cookie

sa-user-id

- Duration

1 year

- Description

StackAdapt sets this cookie as a third party advertising cookie to record information about a user's website activity, such as the pages visited and the locations viewed, to enable us to provide users with interest-based content and personalised advertisements on external websites.


- Cookie

sa-user-id-v2

- Duration

1 year

- Description

StackAdapt sets this cookie as a third party advertising cookie to record information about a user's website activity, such as the pages visited and the locations viewed, to enable us to provide users with interest-based content and personalised advertisements on external websites.


- Cookie

bcookie

- Duration

1 year

- Description

LinkedIn sets this cookie from LinkedIn share buttons and ad tags to recognize browser IDs.


- Cookie

IDE

- Duration

1 year 24 days

- Description

Google DoubleClick IDE cookies store information about how the user uses the website to present them with relevant ads according to the user profile.


- Cookie

test\_cookie

- Duration

15 minutes

- Description

doubleclick.net sets this cookie to determine if the user's browser supports cookies.


Uncategorised

Other uncategorised cookies are those that are being analysed and have not been classified into a category as yet.

- Cookie

sa-user-id-v3

- Duration

1 year

- Description

Description is currently not available.


- Cookie

calltrk\_nearest\_tld

- Duration

1 year 1 month 4 days

- Description

Description is currently not available.


- Cookie

calltrk\_referrer

- Duration

6 months

- Description

This is a functionality cookie set by the CallRail. This cookie is used to store the referring URL. It helps to accurately attribute the visitor source when displaying a tracking phone number.


- Cookie

calltrk\_landing

- Duration

6 months

- Description

This is a functionality cookie set by the CallRail. This cookie is used to store the landing page URL. It helps to accurately attribute the visitor source when displaying a tracking phone number.


- Cookie

frontend\_lang

- Duration

1 year

- Description

No description available.


- Cookie

libsyn-paywall-s

- Duration

1 day

- Description

Description is currently not available.


Reject AllSave My PreferencesAccept All

Powered by [![Cookieyes logo](https://cdn-cookieyes.com/assets/images/poweredbtcky.svg)](https://www.cookieyes.com/product/cookie-consent/?ref=cypbcyb&utm_source=cookie-banner&utm_medium=powered-by-cookieyes)

- [Blog](https://trustedsec.com/blog)
- [Windows Processes, Nefarious Anomalies, and You: Threads](https://trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-threads)

November 03, 2022

# Windows Processes, Nefarious Anomalies, and You: Threads

Written by
Brandon McGrath


![](https://trusted-sec.transforms.svdcdn.com/production/images/Blog-Covers/WindowProcesses_Part2_WebHero.jpg?w=320&h=320&q=90&auto=format&fit=crop&dm=1767067300&s=7f92e78072b4a477a75ada679d77e2ef)

Share

- [Share URL](https://www.trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-threads "Share URL")
- [Share via Email](mailto:?subject=Check%20out%20this%20article%20from%20TrustedSec%21&body=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Threads%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads "Share via Email")
- [Share on Facebook](http://www.facebook.com/sharer.php?u=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads "Share on Facebook")
- [Share on X](http://twitter.com/share?text=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Threads%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads "Share on X")
- [Share on LinkedIn](https://www.linkedin.com/shareArticle?url=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads&mini=true "Share on LinkedIn")

Share

- [Share URL](https://www.trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-threads "Share URL")
- [Share via Email](mailto:?subject=Check%20out%20this%20article%20from%20TrustedSec%21&body=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Threads%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads "Share via Email")
- [Share on Facebook](http://www.facebook.com/sharer.php?u=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads "Share on Facebook")
- [Share on X](http://twitter.com/share?text=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Threads%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads "Share on X")
- [Share on LinkedIn](https://www.linkedin.com/shareArticle?url=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads&mini=true "Share on LinkedIn")

[In part 1 of this blog mini-series, we looked at memory regions and analyzed them to find some potential malicious behavior. In part 2, we will do the same thing with enumerating threads.](https://trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-memory-regions)

Nobody explains it better than Microsoft—here is their explanation of what a thread is:

"A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the process code, including parts currently being executed by another thread."

Essentially, a thread runs code.

If this is where the malicious code will run, it makes sense to analyze threads from time to time. But before we try to identify anomalies, we need to actually enumerate a thread—that’s up first!

## 1.  Enumerating Threads

A thread is essentially the location from which code begins running. On Windows, a thread will often start from a memory region with calls such as:

- [CreateThread](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread)
- [RtlCreateUserThread](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FExecutable%20Images%2FRtlCreateUserThread.html)
- [NtCreateThread](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtCreateThread.html)

There are other ways to execute code from a memory region, but we will focus on these for now.

As an example, the image below shows a ton of threads in `WINWORD.EXE`, as well as the call stack on thread ID 16160.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB1.png)Figure 1 WINWORD.EXE Threads

Starting from the bottom, the entry point to this thread was `ntdll.dll!RtlUserThreadStart+0x21`, which then subsequently made a few calls to do whatever that thread needs to do.

Now, let’s compare that to our implant. Remember, this implant loaded a Reflective Dynamic-Link Library (DLL), and the thread is being started on the memory region allocated for the Reflective DLL.

```cpp
hThread = ((CREATETHREAD)Api.CreateThread)(NULL, 0, pRoutine, NULL, 0, NULL);
```

In this case, `pRoutine` is the exported function from the Reflective DLL. That call stack appears as follows.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB2.png)Figure 2 Maelstrom’s Thread Entry Point

In this process, the thread (836) starts in `0x1b7ddb`. This matches up with the base address it was allocated in, `0x1b0000`.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB3.png)Figure 3 Maelstroms Base Address

This is very uncommon—clicking through other processes, it’s very unlikely to find processes with non-backed entry points. This means that the entry point isn’t a genuine function from a DLL; it's coming from the nether. In the next section, we will discuss how to identify this behavior, but for now, let’s actually identify the threads.

Enumerating threads is just as easy as enumerating the memory regions. The [CreateToolhelp32Snapshot](https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot) Application Programming Interface (API) has a `TH32CS_SNAPTHREAD` flag that will take a snapshot of all the threads on the host. Doing so will give access to the [THREADENTRY32](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-threadentry32) structure.

```cpp
typedef struct tagTHREADENTRY32 {
  DWORD dwSize;
  DWORD cntUsage;
  DWORD th32ThreadID;
  DWORD th32OwnerProcessID;
  LONG  tpBasePri;
  LONG  tpDeltaPri;
  DWORD dwFlags;
} THREADENTRY32;
```

This structure plus some other members will create the structure that we will define for each thread.

```cpp
typedef struct THREAD_
{
 std::string FullStartAddress = "";
 DWORD ThreadId = 0;
 DWORD Flags = 0;
 DWORD Size = 0;
 DWORD ProcessId = 0;
 LPVOID BaseAddress  = nullptr;
 std::vector<std::string> Callstack;
 FENNEC::Processes::Region Region;
} Thread;
```

The additional members here are the vector of functions in the call stack and a vector of `Region`structures from the previous section.

With that out of the way, the code to enumerate threads is easy. It relies on [Thread32First](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-thread32first) and [Thread32Next](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-thread32next). Additionally, Microsoft has provided an example: " [Traversing the Thread List](https://docs.microsoft.com/en-us/windows/win32/toolhelp/traversing-the-thread-list)".

As a base, this is the core logic to work through each thread if it matches a given process ID.

```csharp
HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

THREADENTRY32 te = { 0 };

te.dwSize = sizeof(te);

if (Thread32First(hSnapshot, &te))
{
do
{
    if (te.dwSize >= FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(te.th32OwnerProcessID))
    {
        if (te.th32OwnerProcessID == 0 && te.th32ThreadID == 0) continue;
        if (te.th32OwnerProcessID != dwProcessId) continue;
    }

    te.dwSize = sizeof(te);

} while (Thread32Next(hSnapshot, &te));
```

We simply loop through every thread in the snapshot by iterating with `Thread32Next`.

Using `WINWORD.EXE` as an example again, the information inside the thread structure appears as follows.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB4.png)Figure 4 Thread Structure

There are two additional members we need to fill out that aren’t in the snapshots structure:

- The thread start address
- The call stack

Let’s start with the thread start address. To obtain this, the [NtQueryInformationThread](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationthread) from NTDLL is used with the [THREADINFOCLASS](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ps/psquery/class.htm) structure—specifically `ThreadQuerySetWin32StartAddress`.

```cpp
typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    MaxThreadInfoClass
} THREADINFOCLASS;
```

Using the call:

```cpp
PVOID lpStartAddress = nullptr;

NTSTATUS status = NtQueryInformationThread(hThread, static_cast<THREADINFOCLASS>(9), &lpStartAddress, static_cast<ULONG>(sizeof(PVOID)), NULL);
if (!NT_SUCCESS(status))
{
    continue;
}

if (lpStartAddress == nullptr)
{
    continue;
}
```

`lpStartAddress` will now hold the base address of the thread. This is cool, and it will let us track down the location from which the thread operated, as we discussed earlier. With that, we can now track down the call stack, which is slightly more complicated.

To “walk the stack,” a few things are needed. First of all, we initial the symbol handler for the process with [SymInitialize](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-syminitialize).

```css
BOOL IMAGEAPI SymInitialize(
  [in]           HANDLE hProcess,
  [in, optional] PCSTR  UserSearchPath,
  [in]           BOOL   fInvadeProcess
);
```

Like so:

```objectivec
HANDLE hProcess = OpenProcess(MAXIMUM_ALLOWED, FALSE, dwProcessId);
if (hProcess == nullptr)
{
    return Threads;
}
SymInitialize(hProcess, NULL, TRUE);
```

In order to walk the stack, we must use a few functions:

- [StackWalk64](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-stackwalk64)
- [SymFunctionTableAccess](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symfunctiontableaccess)
- [SymGetModuleBase64](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symgetmodulebase64)
- [SymFromAddr](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symfromaddr)

The theory in this particular section is quite long, so we will not go into too much detail, but these posts are recommended:

- [Walking the call stack](https://www.codeproject.com/Articles/11132/Walking-the-callstack-2)
- [Walking the stack of the current thread](https://jpassing.com/2008/03/12/walking-the-stack-of-the-current-thread/)
- [StackWalker - Walking the call stack](https://github.com/JochenKalmbach/StackWalker)

First, we set up the [STACKFRAME64](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/ns-dbghelp-stackframe64) structure obtaining a [CONTEXT](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context) structure of the threads registers.

```objectivec
CONTEXT context = {};

context.ContextFlags = CONTEXT_FULL;

if (GetThreadContext(hThread, &context) == FALSE)
{
    goto cleanup;
}

frame.AddrPC.Offset = context.Rip;
frame.AddrPC.Mode = AddrModeFlat;
frame.AddrStack.Offset = context.Rsp;
frame.AddrStack.Mode = AddrModeFlat;
frame.AddrFrame.Offset = context.Rbp;
frame.AddrFrame.Mode = AddrModeFlat;
```

Now, the thread’s stack is ready to be walked!

This is done by calling `StackWalk64` until it fails.

```objectivec
do
{
    if (StackWalk64(IMAGE_FILE_MACHINE_AMD64, hProcess, hThread, &frame, &context, NULL, SymFunctionTableAccess64, SymGetModuleBase64, NULL) == FALSE)
    {
        break;
    }
} while (true);
```

Inside this do/while, a [SYMBOL\_INFO](https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/ns-dbghelp-symbol_info) structure is set up.

```csharp
DWORD64 dwOffset = 0;
char Buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(WCHAR)] = { 0 };
PSYMBOL_INFO Symbol = (PSYMBOL_INFO)Buffer;
Symbol->SizeOfStruct = sizeof(SYMBOL_INFO);
Symbol->MaxNameLen = MAX_SYM_NAME;
```

At this point, we’re ready to query what this address actually is with `SymFromAddr`. If this works, then cool, we have a function name. If it fails, then we have just an address, which is one of the detections we discussed earlier.

```rust
if (SymFromAddr(hProcess, frame.AddrPC.Offset, &dwOffset, Symbol))
{
    call = Symbol->Name;
    Callstack.push_back(call);
}
else
{
    Callstack.push_back(FENNEC::Strings::LPVOID2StringA(reinterpret_cast<LPVOID>(frame.AddrPC.Offset)));
}
```

Each item is appended to the vector, whether it is a valid function or just an address. Then we let it run against Maelstrom.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB5.png)Figure 5 Call Stack of Maelstrom in VS

In this vector, we see `NtDelayExecution`, `SleepEx`, and then an address—this is what we see in Process Hacker, too. We add a final check here to validate it. This is easy enough with a wraparound [GetProcAddress](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) whilst looping over all the modules in the current process.

```ruby
for (FENNEC::Processes::Module& Module : Modules)
{
    if (GetProcAddress((HMODULE)Module.BaseAddress, FirstCallStackEntry.c_str()) != nullptr)
    {
        ModuleStart = Module.ModuleName;
        break;
    }
}
```

If GetProcAddress returns an address, then this is where the function belongs, so we can track the module's name.

At this point, we have a vector of enumerated threads with most of the information we will need ( _foreshadowing_). Next, we need to parse the information to identify malicious attributes.

## 2.  Identifying Malicious Attributes in Threads

When looking at threads, there are a few indicators that the process may be up to something nefarious. The easiest indicators to find are specific calls on the call stack, like `NtDelayExecution`. Or, we can figure out if the thread has originated from private memory. For the more adventurous, Debug Registers can be found on the thread, as seen [here](https://gist.github.com/olliencc/90f6e040dfef1dccb61f5b3fdc62fa00).

### 2.1.   Sleeping Threads

In this section we will focus on the latter: specific calls on the call stack and thread originating from private memory.

As a lot of attention has been given to the data structure, checking if these calls are on the call stack is as simple as checking if the vector contains a string:

```css
if (FENNEC::Strings::VectorContainsStringA(Thread.Callstack, "NtDelayExecution"))
{
    Scanner::LogThreadDelay(Thread, Common);
}
```

If the function is in the call stack, then log it. Obviously, this is quite naive, but it’s just a proof-of-concept.

This is great and all, but let’s build something that relies on Windows determining if the process is in a delayed state. This will require [NtQuerySystemInformation](https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation).

```css
__kernel_entry NTSTATUS NtQuerySystemInformation(
  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,
  [in, out]       PVOID                    SystemInformation,
  [in]            ULONG                    SystemInformationLength,
  [out, optional] PULONG                   ReturnLength
);
```

To get the information we need, we will need to give it the `SystemProcessInformation` flag. This returns [SYSTEM\_PROCESS\_INFORMATION](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/process.htm).

This function is a bit of a nightmare to use. To get a better understanding of this, [threads\_util.cpp](https://github.com/hasherezade/pe-sieve/blob/2cd8269ac2d685d1db6600ee00779ab24406a056/utils/threads_util.cpp) from [pe-sieve](https://github.com/hasherezade/pe-sieve/) is a great reference, alongside " [Unique Technique for Iterating through Processes](http://jgrunzweig.github.io/posts/2014/12/unique-technique-for-iterating-through-processes/)." Let’s look at the code.

In a while loop, `NtQuerySystemInformation` is called until `STATUS_INFO_LENGTH_MISMATCH`is hit. When it is, the buffer is set the length of the return length, and the call is reattempted. The goal here is to determine the actual size required, essentially via brute-force. This will appear as follows.

```cpp
while (status != STATUS_SUCCESS)
{
    status = NtQuerySystemInformation(SystemProcessInformation, SystemInformation, SystemInformationLength, &ReturnLength);

    if (status == 0xC0000004)
    {
        free(SystemInformation);
        SystemInformation = nullptr;
        SystemInformationLength = 0;
        SystemInformation = (LPVOID)calloc(ReturnLength, 1);
        if (!SystemInformation) {
            return Thread;
        }
        SystemInformationLength = ReturnLength;
        continue;
    }
    break;
};
```

This is a bit confusing, but once it has iterated and found the correct size, it will no longer hit the mismatch error, thus breaking out of the loop.

Once that is done, the buffer returned from `NtQuerySystemInformation` can be cast.

```undefined
SYSTEM_PROCESS_INFORMATION* ProcessInfo = (SYSTEM_PROCESS_INFORMATION*)SystemInformation;
```

_ANOTHER_ while loop is entered. This now iterates through the `SYSTEM_PROCESS_INFORMATION` object by incrementing over the `NextEntryOffset`.

```rust
while (ProcessInfo)
{
    ProcessInfo = (SYSTEM_PROCESS_INFORMATION*)((ULONG_PTR)ProcessInfo + ProcessInfo->NextEntryOffset);
}
```

We almost have the data we need.

Next, we need to iterate over the number of threads in the structure, while checking if the thread ID is what we are need

```rust
for (size_t i = 0; i < ProcessInfo->NumberOfThreads; i++) {
    if (((ULONGLONG)ProcessInfo->Threads[i].ClientId.UniqueThread & 0xffffffff) == Tid)
    {

    }
}
```

Note the ‘`bitwise AND`’ operation, which is shifting the `UniqueThread` by `0xffffffff`.

After all of that, we get the following information.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB6.png)Figure 6 Thread Data

By doing all that, we get access to the [SYSTEM\_THREAD\_INFORMATION](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/thread.htm) structure.

```objectivec
typedef struct _SYSTEM_THREAD_INFORMATION
{
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    KTHREAD_STATE ThreadState;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;
```

The full function appears as follows.

```rust
FENNEC::Processes::Thread FENNEC::Processes::GetExtendedThreadInfo(DWORD Tid)
{
    FENNEC::Processes::Thread Thread;
    LPVOID SystemInformation = nullptr;
    ULONG SystemInformationLength = 0;
    ULONG ReturnLength = 0;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    while (status != STATUS_SUCCESS)
    {
        status = NtQuerySystemInformation(SystemProcessInformation, SystemInformation, SystemInformationLength, &ReturnLength);

        if (status == 0xC0000004)
        {
            free(SystemInformation);
            SystemInformation = nullptr;
            SystemInformationLength = 0;
            SystemInformation = (LPVOID)calloc(ReturnLength, 1);
            if (!SystemInformation) {
                return Thread;
            }
            SystemInformationLength = ReturnLength;
            continue;
        }
        break;
    };

    if (status != STATUS_SUCCESS)
    {
        free(SystemInformation);
        return Thread;
    }

    SYSTEM_PROCESS_INFORMATION* ProcessInfo = (SYSTEM_PROCESS_INFORMATION*)SystemInformation;

    bool bFound = false;

    while (ProcessInfo)
    {
        ProcessInfo = (SYSTEM_PROCESS_INFORMATION*)((ULONG_PTR)ProcessInfo + ProcessInfo->NextEntryOffset);

        for (size_t i = 0; i < ProcessInfo->NumberOfThreads; i++) {
            if (((ULONGLONG)ProcessInfo->Threads[i].ClientId.UniqueThread & 0xffffffff) == Tid)
            {
                Thread.ThreadState = FENNEC::Strings::StateToString(ProcessInfo->Threads[i].ThreadState);
                Thread.WaitReason = FENNEC::Strings::WaitReasonToString(ProcessInfo->Threads[i].WaitReason);
                Thread.WaitTime = ProcessInfo->Threads[i].WaitTime;
                bFound = true;
                break;
            }
        }
        if (bFound == true)
        {
            break;
        }
    }
    return Thread;
}
```

Letting this run against the implant, we now have the `DelayExecution` enum.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB7.png)Figure 7 DelayExecution Enum

Now the detection code can be simplified to the following.

```cpp
if (Thread.WaitReason, "DelayExecution")
{
    Scanner::LogThreadDelay(Thread, Common);
}
```

We didn’t save much code, but we’ve determined that the thread is 100% in a delayed state, as opposed to checking the call stack.

If we switch the sleep to `WaitForSingleObject`, it fits in with the noise a lot more, as it is harder to determine that the thread is sleeping.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB8.png)Figure 8 Thread Sleeping With WaitForSingleObject

### 2.2.      Thread Origin

Checking the origins is slightly more complicated. First, we check if the first item in the call stack starts with 0x, as that’s how strings are being formatted. If that matches, get the actual address from the string.

```ruby
if (FENNEC::Strings::StringAContainsA(Call, "0x"))
{
    LPVOID lpAddress = FENNEC::Strings::StringA2LPVOID(Call);
}
```

With that, next up is looping over all regions and checking if the thread address is within the specific page.

```php
bool bPrivateMem = false;

for (FENNEC::Processes::Region& Region : Process.Regions)
{
    if (FENNEC::Processes::IsMemoryInRegion(lpAddress, Region.BaseAddress, Region.Size) == true)
    {
        if (Region.Use.empty())
        {
            bPrivateMem = true;
            break;
        }
    }
}
```

If it’s within the range, then check if the region structure has a use applied to it. In the case of the data structure, this means it is associated with a DLL.

If it’s set to 'true', then we can log it. As an example, the Reflective DLL’s thread starts at `0x1b7da9`.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB9.png)Figure 9 Thread Starting at 0x1b7da9

This is within the RWX region allocated for the Reflective DLL.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath10-1.png)Figure 10 Maelstrom RWX Region at 0x1b0000

Finally, note how there is no DLL and it is `Private: Commit`.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath11-1.png)Figure 11 RWX with no Use

There’s a big _however_ here: tons of false positives.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB13.png)Figure 12 2088 Entries for Addresses in the Call Stack

Tracking this down, it’s because .NET does not live by any of the natural rules. This bit was quite interesting dive into the PEB, so I will leave this as a task for the reader. However, here is the reference: [The CLR Header](https://jstdev.wordpress.com/2014/02/16/clr-header/).

After eradicating .NET, the line count is down to 58. With a new bug, devenv.exe:

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB14.png)Figure 13 Devenv.exe

This will remain a bug for another day!

Here is the log for detecting `NtDelayExecution`.

```swift
{
  "data": {
    "allocation_base": "0x00000000001B0000",
    "base_address": "0x00000000001B7000",
    "callstack": [\
      "NtDelayExecution",\
      "SleepEx",\
      "0x00000000001B7DA9"\
    ],
    "flags": "0",
    "method": "Thread Sleeping (NtDelayExecution)",
    "partition_id": "0",
    "process_id": "27184",
    "region_allocation_initial": "PAGE_EXECUTE_READWRITE",
    "region_protection_active": "PAGE_EXECUTE_READWRITE",
    "region_size": "45056",
    "region_state": "MEM_COMMIT",
    "region_type": "MEM_PRIVATE",
    "start_address": "0x00000000001B76F0",
    "thread_id": "836",
    "use": ""
  },
  "event_category": "Memory Scanner",
  "event_time": "Wed Sep  7 11:39:13 2022",
  "guid": "a098d87b-808a-42dd-8997-0d69355914e2",
  "image_name": "maelstrom.unsafe.x64.exe",
  "image_path": "\\Device\\HarddiskVolume11\\maelstrom\\agent\\stage0\\bin\\maelstrom.unsafe.x64.exe",
  "parent_procecess": 18056,
  "process_id": 27184
}
```

Here is the log for tor threads origin.

```swift
{
  "data": {
    "allocation_base": "0x00000000001B0000",
    "base_address": "0x00000000001B7000",
    "callstack": [\
      "NtDelayExecution",\
      "SleepEx",\
      "0x00000000001B7DA9"\
    ],
    "flags": "0",
    "method": "Thread Origin is Memory Region",
    "partition_id": "0",
    "process_id": "27184",
    "region_allocation_initial": "PAGE_EXECUTE_READWRITE",
    "region_protection_active": "PAGE_EXECUTE_READWRITE",
    "region_size": "45056",
    "region_state": "MEM_COMMIT",
    "region_type": "MEM_PRIVATE",
    "start_address": "0x00000000001B76F0",
    "thread_id": "836",
    "use": ""
  },
  "event_category": "Memory Scanner",
  "event_time": "Wed Sep  7 11:39:13 2022",
  "guid": "a098d87b-808a-42dd-8997-0d69355914e2",
  "image_name": "maelstrom.unsafe.x64.exe",
  "image_path": "\\Device\\HarddiskVolume11\\maelstrom\\agent\\stage0\\bin\\maelstrom.unsafe.x64.exe",
  "parent_procecess": 18056,
  "process_id": 27184
}
```

## 3.  Conclusion

[In the first part of this mini-series](https://www.trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-memory-regions/), we covered anomalies within memory regions and found some ways to determine if that region had some nefarious qualities. In this post, we did the same thing for threads. There are many more of these techniques to add to something like this, but this will cover the low-hanging fruits.

As a bonus, here are some visualizations generated from Kibana based on the JSON gathered throughout this process, which are quite interesting—they show the general statistics with no implants running on a development machine. Make of it what you will.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB15.png)Figure 14 Tree Map of Methods![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB16.png)Figure 15 Method to Process Name![](https://www.trustedsec.com/wp-content/uploads/2022/10/McgrathB17.png)Figure 16 No Results for RW to RX

Share

- [Share URL](https://www.trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-threads "Share URL")
- [Share via Email](mailto:?subject=Check%20out%20this%20article%20from%20TrustedSec%21&body=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Threads%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads "Share via Email")
- [Share on Facebook](http://www.facebook.com/sharer.php?u=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads "Share on Facebook")
- [Share on X](http://twitter.com/share?text=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Threads%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads "Share on X")
- [Share on LinkedIn](https://www.linkedin.com/shareArticle?url=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-threads&mini=true "Share on LinkedIn")

CloseShow Transcript