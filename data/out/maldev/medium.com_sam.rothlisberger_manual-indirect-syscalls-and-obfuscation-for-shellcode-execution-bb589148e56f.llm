Title:
Manual Indirect Syscalls and Obfuscation for Shellcode Execution

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post walks through building a Windows x64 shellcode loader PE that combines byte-shuffling obfuscation (to reduce static signature hits) with manual indirect syscalls (to reduce user-mode API hook visibility) for shellcode execution.  
- It stages payloads by generating a small msfvenom reverse_https “stage 1” shellcode that downloads a larger Havoc C2 “stage 2” shellcode.  
- For static evasion, it uses RedSiege’s Jigsaw to randomize shellcode bytes and reconstruct them at runtime via a lookup table/stub, aiming to avoid obvious raw-shellcode signatures without large entropy spikes.  
- For EDR evasion, it explains indirect syscalls by preparing registers (e.g., SSN in EAX, R10 setup) and jumping into the `syscall` instruction inside `ntdll` past common hook stubs, making the syscall’s apparent origin look like `ntdll.dll`.  
- It modifies an existing indirect-syscall loader to keep the process alive by repeatedly calling `NtWaitForSingleObject` via indirect syscalls rather than exiting quickly.  
- The author includes basic delivery/transfer evasion ideas (certutil encode/decode, simple XOR) and notes limitations when defenders validate deeper call stacks, pointing to call stack spoofing as a next step.  
- Useful primarily for red teamers/pentesters and malware researchers studying practical tradeoffs of syscall-based evasion and lightweight obfuscation against commodity AV/EDR.

Technical Focus:
- Indirect syscalls via `ntdll` syscall instruction reuse (SSN + trampoline)
- User-mode API hooking and syscall return-address inspection assumptions
- Shellcode obfuscation via byte shuffling + runtime reconstruction (Jigsaw)
- Staged payload delivery (msfvenom stage 1 → Havoc C2 stage 2)
- Shellcode execution primitives (memory allocation, thread creation, waiting)
- Basic on-disk transfer evasion (certutil encoding, XOR pack/unpack)

Use Cases:
- Build a custom shellcode loader that avoids common static signatures
- Experiment with indirect syscalls to bypass simplistic user-mode hooks
- Stage a small downloader shellcode to fetch larger C2 payloads
- Test AV/EDR detection boundaries (static vs behavioral vs stack-based)
- Prototype loader modifications (thread wait loops, execution flow control)

Keywords:
Windows x64, shellcode loader, indirect syscalls, manual syscalls, NTAPI, ntdll.dll, syscall instruction, SSN, EDR hooks, user-mode hooking, call stack inspection, Jigsaw, shellcode obfuscation, runtime reconstruction, msfvenom, reverse_https, Havoc C2, NtWaitForSingleObject, certutil, XOR encryption