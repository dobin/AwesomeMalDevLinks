Title:
Hiding In PlainSight – Indirect Syscall is Dead! Long Live Custom Call Stacks

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post (Part II) describes evading EDR stack-tracing/ETW-TI detections by making sensitive NTAPI calls (e.g., `NtAllocateVirtualMemory`) appear to originate from legitimate `ntdll.dll` call stacks rather than from user-allocated RX memory.  
- It argues indirect syscalls are insufficient because they may only “clean” the immediate return address near the `syscall` instruction while the rest of the stack still unwinds back into suspicious RX regions.  
- The author reverses `ntdll` threadpool callback internals and uses `TpAllocWork` to execute a custom assembly callback that sets up a correct x64 calling convention (register args + stack args) without breaking stack unwinding.  
- A struct is passed as callback context containing the target NTAPI pointer and arguments; the callback populates `RCX/RDX/R8/R9` and writes remaining args into the existing stack frame “home space” before jumping to the NTAPI.  
- The result is a fully unwindable, “clean” stack trace that looks consistent with normal `ntdll` behavior, reducing anomaly-based detections.  
- Useful for red teams, implant/tooling developers, and researchers studying ETW-TI stack-based detections and countermeasures.

Technical Focus:
- ETW-TI / kernel syscall stack tracing and anomaly detection
- x64 Windows calling convention (fastcall regs + shadow/home space)
- Threadpool callbacks (`TpAllocWork`/`TppWorkpExecuteCallback`) as execution primitives
- Custom stack argument placement without breaking unwinding
- NTAPI invocation (`NtAllocateVirtualMemory`, `NtProtectVirtualMemory`) vs WinAPI wrappers
- Shellcode constraints (no globals, struct-based argument passing)

Use Cases:
- Building stealthier loaders/reflective DLL injectors that need `NtAllocateVirtualMemory`/`NtProtectVirtualMemory`
- Replacing indirect-syscall patterns with “legit-looking” `ntdll`-origin call stacks
- Researching and testing EDR detections based on full-stack provenance to RX memory
- Developing callback-based execution chains that preserve unwindability for evasion

Keywords:
ETW-TI, stack tracing, call stack unwinding, indirect syscalls, NtAllocateVirtualMemory, NtProtectVirtualMemory, ntdll.dll, VirtualAllocEx, VirtualProtectEx, threadpool, TpAllocWork, TppWorkpExecuteCallback, x64 calling convention, shadow space, reflective DLL injection, RX memory, syscall telemetry, stack-based detection, assembly stub