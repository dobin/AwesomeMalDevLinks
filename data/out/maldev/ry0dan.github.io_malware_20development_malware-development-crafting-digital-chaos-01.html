# https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/

<!DOCTYPE html><!--
  Minimal Mistakes Jekyll Theme 4.19.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
--><html lang="en" class=" js "><body class="layout--single wide"><a href="https://buymeacoffee.com/ry0d4n" target="_blank"><img src="https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png" alt="Buy Me A Coffee" style="height: 41px !important;width: 174px !important;box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;"></a>


  

  
    

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  



  <article class="page" itemscope="" itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        
      

      <section class="page__content" itemprop="text">
        
          
        
        <h1 id="what-programming-language-should-be-used-to-develop-malware">What programming language should be used to develop Malware?<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#what-programming-language-should-be-used-to-develop-malware" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>

<p>There isn’t such a standard called “Best language for Malware”, Malware are essentialy a software that does malicious actions, but it’s a software!, every programming language that you can use to develop a software (regardless of how the software works) can be used to write harmful malware, what makes the difference and can be a key part of deciding which language to use is the question: What are you targeting?</p>

<p>Your understanding of your target will help you decide what language to use, for example if we are targeting Windows, it won’t be the best choice to use JavaScript, C and C++ are more suitable here, and so on..</p>

<p>This series of posts will focus on <mark>Windows Malware</mark>, and I’ll be using C and C++ throughout the lessons, so pack your bags and tools and let’s start!.</p>

<p>Note: if you are not familiar with C it’s not the best time to read this article now, learn C first and comeback when you at-least know the basics.</p>

<h1 id="tools-required-to-start">Tools required to start<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#tools-required-to-start" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>

<p>In order to start developing Malware you need to install Visual Studio and install C++ on it, also it is good to have some disassemblers and debuggers like IDA Pro, XDBG, Process Hacker (Process Monitoring tool) and so on..</p>

<p>Apparently all this should be on a VIRTUAL MACHINE, you weren’t thinking that you’d work on you host machine’s VS were you?</p>

<h1 id="coding-basics-and-winapi">Coding basics and WINAPI<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#coding-basics-and-winapi" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>

<p>WINAPI or “Windows API,” which is a set of functions and data structures provided by Microsoft for use in writing applications for the Windows operating system. It provides developers with access to the underlying features and functionality of Windows, allowing them to create software that interacts with the operating system.</p>

<p>Developers use WINAPI functions in programming languages like C and C++ to create Windows applications.</p>

<p>We will be utilizing WINAPI features to write our Malware.</p>

<h2 id="winapi-header-file">WINAPI header file<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#winapi-header-file" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>All the WINAPI functions, data types, macros, constants are embeded in a header file, to start using WINAPI inside your project you need to include its headers file.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="c1"> </span><span class="cp">
</span></code></pre></div></div>

<h2 id="winapi-data-types">WINAPI Data Types<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#winapi-data-types" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Here is a list of some popular WINAPI data types:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOL: A Boolean variable (should be TRUE or FALSE).
BYTE: A byte (8 bits).
DWORD: A 32-bit unsigned integer.
CHAR: An 8-bit Windows (ANSI) character.
DWORD: A 32-bit unsigned integer.
FLOAT: A floating-point variable.
HANDLE: A handle to a module. This is the base address of the module in memory.
HKEY: A handle to a registry key.
INT: A 32-bit signed integer.
LPCSTR: A pointer to a constant null-terminated string of 8-bit Windows (ANSI) characters.
LPWSTR: A pointer to a constant null-terminated string of 16-bit Unicode characters.
LPTSTR: An LPWSTR if UNICODE is defined, an LPSTR otherwise.
LPVOID: A pointer to any type.
PDWORD: A pointer to a DWORD.
</code></pre></div></div>
<p>The full list can be found <a href="https://learn.microsoft.com/en-us/windows/win32/winprog/windows-data-types">here</a>, I recommend taking a look.</p>

<h2 id="winapi-functions">WINAPI functions<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#winapi-functions" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>WINAPI provides functions for a wide range of tasks, including:</p>

<ol>
  <li>User input handling:</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GetMessage</span><span class="p">()</span>
<span class="n">MessageBox</span><span class="p">()</span>
<span class="n">TranslateMessage</span><span class="p">()</span>
</code></pre></div></div>
<ol>
  <li>File I/O:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">WriteFile</span><span class="p">()</span>
<span class="n">ReadFile</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>Memory management:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VirtualAlloc</span><span class="p">()</span>
<span class="n">VirtualProtect</span><span class="p">()</span>
<span class="n">VirtualAllocEx</span><span class="p">()</span>
<span class="n">HeapAlloc</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>Process and thread management:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">CreateProcess</span><span class="p">()</span>
 <span class="n">WriteProcessMemory</span><span class="p">()</span>
 <span class="n">OpenProcess</span><span class="p">()</span>
 <span class="n">CreateRemoteThread</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>When we want to use any function we need first to read it’s MSDN documentation, Microsoft has done a great work documenting each detail of the inner workings, parameters, return value of the API calls, however we will be exploring some undocumented structures and functions in the upcoming posts!.</p>

<h1 id="portable-executable-format">Portable Executable format<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#portable-executable-format" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>

<p>Portable executable or PE files are a file format used in 32-bit and 64-bit versions of Windows operating systems for executable programs, DLLs (Dynamic Link Libraries), device drivers, and other types of executable files. PE files are the standard binary format for Windows executables and are used by the Windows operating system loader to load and execute programs.</p>

<p>Learning PE file format is important, knowing the inner components and headers will give us more control on our malware.</p>

<h2 id="pe-file-structure">PE file structure<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#pe-file-structure" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p><img src="https://ry0dan.github.io/assets/images/malware-development/1.png" alt="P1"></p>

<p>Header: PE files begin with a header that contains information about the file, including the number and placement of sections within the file, machine type (e.g., x86, x64), and signature.</p>

<p>Optional Header: This header, which comes after the main header, contains other details about the executable, like the image base address, the size of the code and data sections, and the entry point address.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_IMAGE_OPTIONAL_HEADER</span> <span class="p">{</span>
  <span class="n">WORD</span>                 <span class="n">Magic</span><span class="p">;</span>
  <span class="n">BYTE</span>                 <span class="n">MajorLinkerVersion</span><span class="p">;</span>
  <span class="n">BYTE</span>                 <span class="n">MinorLinkerVersion</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">SizeOfCode</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">SizeOfInitializedData</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">SizeOfUninitializedData</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">AddressOfEntryPoint</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">BaseOfCode</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">BaseOfData</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">ImageBase</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">SectionAlignment</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">FileAlignment</span><span class="p">;</span>
  <span class="n">WORD</span>                 <span class="n">MajorOperatingSystemVersion</span><span class="p">;</span>
  <span class="n">WORD</span>                 <span class="n">MinorOperatingSystemVersion</span><span class="p">;</span>
  <span class="n">WORD</span>                 <span class="n">MajorImageVersion</span><span class="p">;</span>
  <span class="n">WORD</span>                 <span class="n">MinorImageVersion</span><span class="p">;</span>
  <span class="n">WORD</span>                 <span class="n">MajorSubsystemVersion</span><span class="p">;</span>
  <span class="n">WORD</span>                 <span class="n">MinorSubsystemVersion</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">Win32VersionValue</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">SizeOfImage</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">SizeOfHeaders</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">CheckSum</span><span class="p">;</span>
  <span class="n">WORD</span>                 <span class="n">Subsystem</span><span class="p">;</span>
  <span class="n">WORD</span>                 <span class="n">DllCharacteristics</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">SizeOfStackReserve</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">SizeOfStackCommit</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">SizeOfHeapReserve</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">SizeOfHeapCommit</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">LoaderFlags</span><span class="p">;</span>
  <span class="n">DWORD</span>                <span class="n">NumberOfRvaAndSizes</span><span class="p">;</span>
  <span class="n">IMAGE_DATA_DIRECTORY</span> <span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_NUMBEROF_DIRECTORY_ENTRIES</span><span class="p">];</span>
<span class="p">}</span> <span class="n">IMAGE_OPTIONAL_HEADER32</span><span class="p">,</span> <span class="o">*</span><span class="n">PIMAGE_OPTIONAL_HEADER32</span><span class="p">;</span>
</code></pre></div></div>

<p>Data Directories: A data directory pointing to different PE file data structures, including the import table, export table, and debug information, is also included in the optional header.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_IMAGE_DATA_DIRECTORY</span> <span class="p">{</span>
  <span class="n">DWORD</span> <span class="n">VirtualAddress</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">Size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">IMAGE_DATA_DIRECTORY</span><span class="p">,</span> <span class="o">*</span><span class="n">PIMAGE_DATA_DIRECTORY</span><span class="p">;</span>
</code></pre></div></div>

<p>Section Table: PE files are organized into sections, each of which holds a particular kind of data, such as resources, code, data, or import/export details. Text or code (.text), data (.data), resource (.rsrc), and import/export (.idata/.edata) sections are examples of common sections.</p>

<p>Import Table: The import table contains information about the external functions and libraries that the executable depends on. It includes the names of the imported functions and the addresses of the corresponding functions in the loaded libraries.</p>

<p>Export Table: If the PE file is a DLL, it may contain an export table that lists the functions and variables that are exported by the DLL for use by other programs.</p>

<p>For more information about the PE file structure <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format">check this documentation</a></p>

<h1 id="function-call-process">Function call process<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#function-call-process" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>

<p>The kernel in Windows is responsible for completing all the tasks in Windows (writing - opening files, network connections, etc.), so every application call needs to go through a process in order to invoke certain functionality from the kernel.</p>

<p><img src="https://ry0dan.github.io/assets/images/malware-development/2.png" alt="P1"></p>

<p>The picture above describes that process, first when an application requests to open a process using <mark>OpenProcess()</mark> API call from kernel32.dll it first goes to kernelbase.dll then ntdll.dll (The NATIVE API) which is the lowest layer in user mode and most of the APIs are implemented inside it, NTDLL is responsible for transferring the execution to kernel mode.</p>

<p>The last stage is done inside the kernel mode as the kernel uses its drivers and resources to complete that specific task and return back an output.</p>

<h2 id="user-mode">User Mode<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#user-mode" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<ul>
  <li>User mode is the least privileged mode of operation.</li>
  <li>Applications and most user-level software run in user mode.</li>
  <li>In user mode, software has limited access to system resources and cannot directly access hardware or sensitive system data.</li>
  <li>User mode processes rely on system calls to request services from the operating system kernel.</li>
  <li>User mode processes are isolated from each other to prevent one process from interfering with another.</li>
</ul>

<h2 id="kernel-mode">Kernel Mode<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#kernel-mode" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<ul>
  <li>Kernel mode is the most privileged mode of operation.</li>
  <li>The operating system kernel runs in kernel mode.</li>
  <li>In kernel mode, software has full access to system resources, including hardware and sensitive system data.</li>
  <li>Kernel mode components have unrestricted access to system memory and can execute privileged instructions.</li>
  <li>Device drivers and critical system services run in kernel mode to perform low-level tasks and manage hardware resources.</li>
  <li>Direct access to kernel mode is restricted to prevent unauthorized access and protect the stability and security of the system.</li>
</ul>

<p>An important thing to remind is that applications can directly make Syscalls or invoke NTDLL functions but it is a bit more complicated to use, however being a Malware developer you need to explore this technique because it is more stealthy when it come to obfuscating or hiding the functionality of your malware.</p>

<h1 id="memory-management-in-windows">Memory management in Windows<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#memory-management-in-windows" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>

<p>The address space in Windows differs based on the architecture, 32-bit processes can view up to 4 GB of memory and each process has 8-terabyte address space on 64-bit Windows.</p>

<h2 id="x32">X32<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#x32" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Virtual Address Space:</p>
<ul>
  <li>Each 32-bit process in Windows has a 4 GB virtual address space.</li>
  <li>This address space is divided into two main regions: user mode and kernel mode.</li>
</ul>

<p>User Mode:</p>
<ul>
  <li>The user mode portion of the virtual address space typically ranges from 0x00000000 to 0x7FFFFFFF (2 GB).</li>
  <li>User mode contains the memory allocated for user-mode processes, including executable code, data, heap, and stack.</li>
</ul>

<p>Kernel Mode:</p>
<ul>
  <li>The kernel mode portion of the virtual address space resides above the user mode portion, starting at 0x80000000.</li>
  <li>Kernel mode contains memory allocated for the Windows kernel, device drivers, and other kernel-mode components</li>
</ul>

<h2 id="x64">X64<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#x64" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Virtual Address Space:</p>
<ul>
  <li>Each 64-bit process in Windows has a vast 64-bit virtual address space, theoretically allowing access to up to 2^64 bytes of memory.</li>
  <li>This address space enables the operating system to address much larger amounts of physical memory and provides more room for user-mode processes.</li>
</ul>

<p>User Mode:</p>
<ul>
  <li>User mode typically ranges from 0x0000000000000000 to 0x7FFFFFFFFFFFFFFF.</li>
  <li>User mode contains the memory allocated for user-mode processes, including executable code, data, heap, and stack.</li>
</ul>

<p>Kernel Mode:</p>
<ul>
  <li>The kernel mode portion of the virtual address space resides above the user mode portion.</li>
  <li>Kernel mode typically starts at 0x8000000000000000 and extends upwards.</li>
</ul>

<h2 id="memory-allocation-example">Memory Allocation example<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#memory-allocation-example" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="c1">// Method 1: Using GlobalAlloc / GlobalFree</span>
    <span class="c1">// Allocate memory</span>
    <span class="n">HGLOBAL</span> <span class="n">hGlobal</span> <span class="o">=</span> <span class="n">GlobalAlloc</span><span class="p">(</span><span class="n">GMEM_FIXED</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span> <span class="c1">// Allocating 1 KB of memory</span>

    <span class="c1">// Use the allocated memory</span>
    <span class="c1">// ...</span>

    <span class="c1">// Free the memory</span>
    <span class="n">GlobalFree</span><span class="p">(</span><span class="n">hGlobal</span><span class="p">);</span>

    <span class="c1">// Method 2: Using VirtualAlloc / VirtualFree</span>
    <span class="c1">// Allocate memory</span>
    <span class="n">LPVOID</span> <span class="n">lpMemory</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span> <span class="c1">// Allocating 1 KB of memory</span>

    <span class="c1">// Use the allocated memory</span>
    <span class="c1">// ...</span>

    <span class="c1">// Free the memory</span>
    <span class="n">VirtualFree</span><span class="p">(</span><span class="n">lpMemory</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEM_RELEASE</span><span class="p">);</span>

    <span class="c1">// Method 3: Using HeapAlloc / HeapFree</span>
    <span class="c1">// Get the process heap handle</span>
    <span class="n">HANDLE</span> <span class="n">hHeap</span> <span class="o">=</span> <span class="n">GetProcessHeap</span><span class="p">();</span>

    <span class="c1">// Allocate memory</span>
    <span class="n">LPVOID</span> <span class="n">lpHeapMemory</span> <span class="o">=</span> <span class="n">HeapAlloc</span><span class="p">(</span><span class="n">hHeap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span> <span class="c1">// Allocating 1 KB of memory</span>

    <span class="c1">// Use the allocated memory</span>
    <span class="c1">// ...</span>

    <span class="c1">// Free the memory</span>
    <span class="n">HeapFree</span><span class="p">(</span><span class="n">hHeap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lpHeapMemory</span><span class="p">);</span>

</code></pre></div></div>

<h2 id="memory-pages">Memory pages<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#memory-pages" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Memory pages refers to chunks or blocks of allocated memory with each page typically being 4 KB in size, although larger page sizes are also valid.</p>

<p>Memory pages protection constants:</p>

<ul>
  <li>PAGE_EXECUTE: Enables execute access to the committed region of pages. An attempt to write to the committed region results in an access violation.</li>
  <li>PAGE_EXECUTE_READ: Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation.</li>
  <li>PAGE_EXECUTE_READWRITE: Enables execute, read-only, or read/write access to the committed region of pages.</li>
  <li>PAGE_READONLY: Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation.</li>
  <li>PAGE_READWRITE: Enables read-only or read/write access to the committed region of pages.</li>
</ul>

<p>For more information check <a href="https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants">Microsoft’s documentation</a>.</p>

<h2 id="memory-protection" class="active">Memory protection<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-01/#memory-protection" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<ol>
  <li>Data Execution Prevention (DEP):
  Prevents execution of code in non-executable memory regions, mitigating buffer overflow attacks.</li>
  <li>Address Space Layout Randomization (ASLR):
  Randomizes memory addresses to prevent predictable memory layouts, making it harder for attackers to exploit vulnerabilities.</li>
</ol>

        
      </section>

      

      

      
  

    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term...">
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    

    
  
  














  

</body></html>