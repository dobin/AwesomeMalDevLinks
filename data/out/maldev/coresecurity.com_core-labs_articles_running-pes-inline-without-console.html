# https://www.coresecurity.com/core-labs/articles/running-pes-inline-without-console

<!DOCTYPE html><html lang="en" dir="ltr" prefix="content: http://purl.org/rss/1.0/modules/content/  dc: http://purl.org/dc/terms/  foaf: http://xmlns.com/foaf/0.1/  og: http://ogp.me/ns#  rdfs: http://www.w3.org/2000/01/rdf-schema#  schema: http://schema.org/  sioc: http://rdfs.org/sioc/ns#  sioct: http://rdfs.org/sioc/types#  skos: http://www.w3.org/2004/02/skos/core#  xsd: http://www.w3.org/2001/XMLSchema# " class=" js" style="--headerHeight: 926.1875px;"><body class="layout-no-sidebars page-node-105019 path-node node--type-article" style="background-color:transparent"><div id="consent_blackbar" lang="en">
            
            <div id="truste-consent-track" style="position: relative; z-index: 999999; border-top: 1px solid rgb(102, 102, 102);" class="ta-show ta-display-block">  <div id="truste-consent-content" style="overflow: hidden;">    <div id="truste-consent-text" class="truste-messageColumn" data-nosnippet="data-nosnippet">      <span class="hstitle">This website uses cookies. You may change your settings at any time.</span>    </div>    <div id="truste-consent-buttons" class="truste-buttonsColumn" data-nosnippet="data-nosnippet">      <span id="truste-repop-msg" style="padding: 7px 10px; background: #F9EDBE; border:1px solid #F0C36D; margin: 11px 0px 13px;font-size:11; line-height: 16px;color: #AF7501; display:none;"></span>       <button id="truste-consent-button">Accept</button>      <button id="truste-consent-required">Reject All</button>      <button id="truste-show-consent" aria-haspopup="dialog">Manage Cookies</button>    </div>  </div></div></div>


      <!-- start Omniconvert.com code -->
      
  <!-- Content Group 1 -->
   <!-- End Content Group 2 -->
    <!-- Google Tag Manager start -->
  
  <!-- Google Tag Manager end -->
      


    <!-- Google Tag Manager (noscript) -->
  
  <!-- End Google Tag Manager (noscript) -->
    <a href="https://www.coresecurity.com/core-labs/articles/running-pes-inline-without-console#main-content" class="visually-hidden focusable skip-link">
    Skip to main content
  </a>
  
    <div class="dialog-off-canvas-main-canvas" data-off-canvas-main-canvas="">
    <div id="page-wrapper">
  <div id="page">
    

    <div id="main-wrapper" class="layout-main-wrapper clearfix">
      <div id="main" class="main">
      

      
<!--Header type = "header-5"-->
      
          
      <!-- progress bar - currently shows only for product page-->
      <div class="progress-bar-container" style="top: 952.188px;">
        <div class="progress-bar"></div>
      </div>
      



    <div class="container-fluid">
    <div class="row row-offcanvas row-offcanvas-left clearfix">
      <main class="main-content col" id="content" role="main">
                  <a id="main-content" tabindex="-1"></a>
                                 <div data-drupal-messages-fallback="" class="hidden"></div><div id="block-coresecurity-content" class="block block-system block-system-main-block">
  
    
      <div class="content">
      

<article data-history-node-id="105019" about="/core-labs/articles/running-pes-inline-without-console" typeof="schema:Article" class="node node--type-article node--promoted node--view-mode-full article-sidebar clearfix">
        

      
<!--Header type = "header-5"-->
      
          
      <!-- progress bar - currently shows only for product page-->
      <div class="progress-bar-container" style="top: 952.188px;">
        <div class="progress-bar"></div>
      </div>
      



    <div class="node__content clearfix">
    <div class="node-content-container container">
      <div class="row">
                        <div class="col-lg-8">                    <div property="schema:text" class="field field--name-body field--type-text-with-summary field--label-hidden section field__item"><p>While reading the amazing <a href="https://github.com/Octoberfest7/Inline-Execute-PE">Inline-Execute-PE</a> by <a href="https://twitter.com/octoberfest73">Octoberfest7</a>, I noticed that to obtain the output from the PE being executed, the author needed to allocate a console, which results in a process being created (conhost.exe).<o:p></o:p></p>
<p class="MsoNormal">Interestingly, the readme also states that a commercial C2 managed to avoid spawning a conhost.exe process by "fooling Windows into thinking it had a console." After reading this, I thought I might give it a try and attempt to achieve the same.<o:p></o:p></p>
<p class="MsoNormal">This blogpost is the result of that research project, which took me three weeks of demanding work and led to some interesting results.<o:p></o:p></p>
<h2>A Brief Introduction to How Consoles Work<o:p></o:p></h2>
<p class="MsoNormal">To put it simply, a console is the black box you see when you run CMD. Programs can get user input from it and print output to it.<o:p></o:p></p>
<p class="MsoNormal">In Windows, the console is run by a separate process called conhost.exe, which interacts with the actual executable via a series of APIs. But not all processes have a console, some have a GUI like notepad or run in detached mode like lsass. If a process wants to allocate a console, all it must do is call <a href="https://learn.microsoft.com/en-us/windows/console/allocconsole">AllocConsole</a>, which will create the conhost.exe process, initialize the standard input, output and error streams, and save a handle to the console under <samp>PEB-&gt;ProcessParameters-&gt;ConsoleHandle.</samp></p>
<p class="MsoNormal">Given that different binaries interact with the console in diverse ways, convincing binaries that we already have a console (when we do not) and redirecting its output to a pipe will require not just one trick, but several. I will go over the techniques that were used for each binary going from the simplest to the most complex.<o:p></o:p></p>
<h2>Hello World with MinGW<o:p></o:p></h2>
<p class="MsoNormal">I started with a simple ‚Äúhello world‚Äù project in C which I cross-compiled from Linux to Windows with the MinGW compiler.<o:p></o:p></p>
<p class="MsoNormal">Before loading and running this PE inline (meaning, in the same process as Beacon), I allocated a console with <em>AllocConsole</em>. This created a conhost.exe process; initialized the standard input, output, and error streams; and set the new <em>ConsoleHandle&nbsp;</em>on the PEB. Also, I updated the standard output and error streams by calling <a href="https://learn.microsoft.com/en-us/windows/console/setstdhandle"><em>SetStdHandle</em></a><em> </em>with the write handle of the anonymous pipe I created previously.<o:p></o:p></p>
<pre><code class="language-plaintext">AllocConsole();
SetStdHandle(STD_OUTPUT_HANDLE, hPipeWrite);
SetStdHandle(STD_ERROR_HANDLE, hPipeWrite);
<o:p></o:p></code></pre><p class="MsoNormal">Next, I invalidated the <em>ConsoleHandle </em>on the PEB so that the program could not interact with the console anymore.<o:p></o:p></p>
<pre><code class="language-plaintext">PEB-&gt;ProcessParameters-&gt;ConsoleHandle = 0x123;<o:p></o:p></code></pre><p class="MsoNormal">After running the program, I noticed that the redirection still worked, which seemed to indicate that the program did not actually interact with the console directly.<o:p></o:p></p>
<p class="MsoNormal">Knowing this, I decided to modify the <em>stdout </em>FILE* structure in memory, which is defined below:<o:p></o:p></p>
<pre><code class="language-plaintext">struct _iobuf {
    char *_ptr;
    int _cnt;
    char *_base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char *_tmpfname;
};
typedef struct _iobuf FILE;<o:p></o:p></code></pre><p class="MsoNormal">The<em> _file </em>attribute is supposed to be the file descriptor, but because we are using an anonymous pipe, we only have a handle. To convert the <a name="_Int_ZDgEfiu6">pipe</a> write handle to a file descriptor I called <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/open-osfhandle?view=msvc-170"><em>_open_osfhandle</em></a><em> </em>and used the resulting descriptor to set <em>stdout-&gt;_file</em>.<o:p></o:p></p>
<p class="MsoNormal">The last change needed was to set the flags<em> (_flag) </em>to<em> _IOWRT </em>(file descriptor is writeable) and<em> _IONBF </em>(disable buffering).<o:p></o:p></p>
<p class="MsoNormal">After this, I successfully redirected the output without having to allocate a console.</p>
<div class="align-center media-default">
  
  
  <div class="field field--name-field-media-image field--type-image field--label-visually_hidden">
    <div class="field__label visually-hidden">Image</div>
              <div class="field__item">  <img loading="lazy" src="https://www.coresecurity.com/sites/default/files/2023-11/running_pes_inline_without_console_img_01_redirect_output.png" width="392" height="104" alt="redirect output" typeof="foaf:Image">

</div>
          </div>

</div>
<p class="MsoNormal"><o:p></o:p></p>
<p class="MsoNormal"><o:p></o:p></p>
<h2>Hello World with MSVC<o:p></o:p></h2>
<p class="MsoNormal">When compiling the ‚ÄúHello World‚Äù program with the Microsoft compiler, I tried the same trick from before and it seemed to work fine, but when I tried to run a more complicated program (nanodump compiled with the MSVC compiler) I noticed that I got no output.<o:p></o:p></p>
<p class="MsoNormal">It appears that if you compile your program like this, it works:</p>
<pre><code class="language-plaintext">cl.exe helloworld.c /Fe:helloworld.exe<o:p></o:p></code></pre><p class="MsoNormal">However, if you compiled like this, it does not:<o:p></o:p></p>
<pre><code class="language-plaintext">cl.exe helloworld.c -c ‚Äìnologo
link.exe /OUT:helloworld.exe -nologo libvcruntime.lib libcmt.lib ucrt.lib kernel32.lib /MACHINE:X64 -subsystem:console -nodefaultlib helloworld.obj<o:p></o:p></code></pre><p class="MsoNormal">When compiled like the second instance, the binary uses the new C Runtime implementation from <em>ucrtbase </em>instead of the legacy <em>msvcrt</em>. While investigating the issue in <a href="https://ghidra-sre.org/"><em>Ghidra</em></a>, I realized that the definition of the function <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/fileno?view=msvc-170"><em>fileno</em></a><em> </em>is different between <em>msvcrt.dll </em>and <em>ucrtbase.dll</em>.<o:p></o:p></p>
<pre><code class="language-plaintext">msvcrt!fileno
‚Ä¶
mov&nbsp;    eax, dword ptr [rcx+1Ch]
add&nbsp;    rsp, 38h
ret<o:p></o:p>
ucrtbase!_fileno:
‚Ä¶
mov&nbsp;    eax,dword ptr [rcx+18h]
add&nbsp;    rsp,28h
ret<o:p></o:p></code></pre><p class="MsoNormal">The offset of the <em>_file</em> attribute inside the FILE structure in <em>msvcrt.dll</em> is 0x1C and in<em> ucrtbase.dll&nbsp;</em>it is 0x18, which means that the FILE structures are not the same. This explains why the previous approach was not working, I was writing the<em> _file </em>and<em> _flag </em>values at the wrong offsets.<o:p></o:p></p>
<p class="MsoNormal">I reverse engineered&nbsp;the definition of the FILE structure as it is used in <em>ucrtbase.dll</em>:<o:p></o:p></p>
<pre><code class="language-plaintext">typedef struct _UCRTBASE_FILE {
/*0x00 0x08*/ PVOID&nbsp; _ptr;
/*0x08 0x08*/ PVOID&nbsp; _base;
/*0x10 0x04*/ UINT32 _cnt;
/*0x14 0x04*/ UINT32 _flags;
/*0x18 0x04*/ UINT32 _file;
/*0x1c 0x04*/ UINT32 _bufsiz;
/*0x20 0x08*/ PVOID&nbsp; _charbuf;
/*0x28 0x08*/ LPSTR&nbsp; _tmpfname;
/*0x30 0x28*/ CRITICAL_SECTION _lock;
} UCRTBASE_FILE, * PUCRTBASE_FILE;<o:p></o:p></code></pre><p class="MsoNormal">Just updating the FILE definition is not enough though, because the flags changed as well. After some debugging, I determined that the flags need to be 0x2402. Also, as per Window‚Äôs <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2003/december/break-free-of-code-deadlocks-in-critical-sections-under-windows">documentation</a>, we need to set the <em>LockCount </em>attribute on the<em> _lock structure </em>to ‚Äì1.<o:p></o:p></p>
<p class="MsoNormal">Finally, I realized that I needed to call the function <em>_open_osfhandle</em>, which is defined at <em>ucrtbase.dll </em>instead of the old <em>msvcrt.dll</em>, for the redirection to work.<o:p></o:p></p>
<p class="MsoNormal">With all these changes, I managed to reproduce the previous technique to a binary compiled with MSVC.<o:p></o:p></p>
<div class="align-center media-default">
  
  
  <div class="field field--name-field-media-image field--type-image field--label-visually_hidden">
    <div class="field__label visually-hidden">Image</div>
              <div class="field__item">  <img loading="lazy" src="https://www.coresecurity.com/sites/default/files/2023-11/running_pes_inline_without_console_img_02_reproduce_previous_technique.png" width="386" height="103" alt="reproduce previous technique" typeof="foaf:Image">

</div>
          </div>

</div>
<p class="MsoNormal"><o:p></o:p></p>
<h2>CMD<o:p></o:p></h2>
<p class="MsoNormal">An important binary that I wanted to support is <em>cmd.exe</em>, which has its own set of challenges, because when one runs <em>cmd.exe /c whoami</em>, this is not the <em>cmd.exe</em> that resolves who the current user is, but the<em> whoami.exe </em>binary which is located at C:\Windows\System32\whoami.exe. So, we want to be able to obtain the output of the processes that <em>cmd.exe </em>creates.<o:p></o:p></p>
<p class="MsoNormal">If we allocate a console and set the write handle of the pipe as the StandardOutput and StandardError, we actually do get the output of the <em>whoami.exe </em>process.<o:p></o:p></p>
<pre><code class="language-plaintext">AllocConsole();
SetStdHandle(STD_OUTPUT_HANDLE, hPipeWrite);
SetStdHandle(STD_ERROR_HANDLE, hPipeWrite);<o:p></o:p></code></pre><p class="MsoNormal">This means that <em>cmd.exe</em> is indeed capable of communicating both the current console and our desired output handles to its child processes. However, what we want is<em> cmd.exe </em>to pass over our output handles without needing to allocate a console. To do this, we need to set the <em>ConsoleHandle </em>on the child processes to ‚Äì1, indicating that there is no console allocated, only the output handles.<o:p></o:p></p>
<p class="MsoNormal">To prepare the parameters that will be passed onto the new process, <em>CreateProcessW </em>will call <em>BasepCreateProcessParameters</em>. This function will read some values from an undocumented internal structure called <em>ConsoleConnectionState</em>, which is populated by <em>AllocConsole</em>. I have reverse engineered its fields:<o:p></o:p></p>
<pre><code class="language-plaintext">typedef struct _CONSOLE_CONNECTION_STATE {
/*0x00 0x01*/ BYTE&nbsp;  Flags;
/*0x08 0x08*/ HANDLE ConsoleHandle;
/*0x10 0x08*/ HANDLE ConsoleReference;
/*0x18 0x08*/ HANDLE StandardInput;
/*0x20 0x08*/ HANDLE StandardOutput;
/*0x28 0x08*/ HANDLE StandardError;
/*0x30 0x01*/ BYTE&nbsp; IsConnected;
} CONSOLE_CONNECTION_STATE, * PCONSOLE_CONNECTION_STATE;
<o:p></o:p></code></pre><p class="MsoNormal">Now, let's see an illustrative code snippet from <em>BasepCreateProcessParameters </em>where the <em>ConsoleHandle </em>for the child process is set:<o:p></o:p></p>
<pre><code class="language-plaintext">ChildProcParams-&gt;ConsoleHandle = ConsoleConnectionState.ConsoleReference;
if (ChildProcParams-&gt;ConsoleHandle == NULL) {
    ChildProcParams-&gt;ConsoleHandle = PEB-&gt;ProcessParameters-&gt;ConsoleHandle;
}<o:p></o:p></code></pre><p class="MsoNormal">The ConsoleHandle is set to <em>ConsoleConnectionState.ConsoleReference </em>and if that is NULL, then it is set to the ConsoleHandle of the current process.<o:p></o:p></p>
<p class="MsoNormal">Meaning, we want the <em>ConsoleReference </em>to be NULL and our own ConsoleHandle to be ‚Äì1. To put it even more simply, set the <em>ConsoleReference </em>to ‚Äì1. The question is, how can we get the base address of this internal structure?<o:p></o:p></p>
<p class="MsoNormal">To find it, I relied on a function called BaseGetConsoleReference, which returns the ConsoleReference, like so:<o:p></o:p></p>
<pre><code class="language-plaintext">HANDLE BaseGetConsoleReference(void)
{
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ConsoleConnectionState.ConsoleReference;
}</code></pre><p><o:p></o:p></p>
<p><o:p></o:p>But we do not care about the value of the ConsoleReference, we care about the address of the ConsoleConnectionState structure. So, I simply parsed the assembly of this function to find it.<o:p></o:p></p>
<pre><code class="language-plaintext">48 8b 05 f9 94 19 00&nbsp;   mov&nbsp;   rax,QWORD PTR [rip+0x1994f9]
c3&nbsp;                              ret</code></pre><p>To obtain its address, we need to extract the offset used by the mov instruction, which in this case is 0x1994f9. Then we add the address of the ret instruction (this is because the function uses RIP-relative addressing). The result will be the address of the ConsoleReference, so to get the base of the entire structure, we just subtract the offset of the field, which is 0x10 bytes.<o:p></o:p></p>
<p class="MsoNormal">Once we know where this structure is, we set the <em>ConsoleReference </em>to ‚Äì1, set the StandardOutput and StandardError to the write handle of our pipe and we can now get the output of the commands we run via<em> cmd.exe</em>.</p>
<div class="align-center media-default">
  
  
  <div class="field field--name-field-media-image field--type-image field--label-visually_hidden">
    <div class="field__label visually-hidden">Image</div>
              <div class="field__item">  <img loading="lazy" src="https://www.coresecurity.com/sites/default/files/2023-11/running_pes_inline_without_console_img_03_console_reference.png" width="480" height="323" alt="console reference" typeof="foaf:Image">

</div>
          </div>

</div>
<p class="MsoNormal"><o:p></o:p></p>
<h2>PowerShell<o:p></o:p></h2>
<p class="MsoNormal">This project would not be complete without the ability to run PowerShell without a console.<o:p></o:p></p>
<p class="MsoNormal">This is by far the most complicated piece of the puzzle, as the PowerShell process is intimately related to the console and decoupling them is no easy task.<o:p></o:p></p>
<p class="MsoNormal">First, I allocated a console, and invalidated the <em>ConsoleHandle</em>.<o:p></o:p></p>
<pre><code class="language-plaintext">AllocConsole();
SetStdHandle(STD_OUTPUT_HANDLE, hWrite);
SetStdHandle(STD_ERROR_HANDLE, hWrite);
PEB-&gt;ProcessParameters-&gt;ConsoleHandle = 0x123;<o:p></o:p></code></pre><p class="MsoNormal">After doing this, I got no output, which means that the PowerShell process truly needs the console to be valid, or we get no output.<o:p></o:p></p>
<p class="MsoNormal">To understand exactly where the handle is used, I configured a hardware breakpoint on WinDbg that will break upon read access to the <em>ConsoleHandle</em>. The <em>ConsoleHandle </em>is stored in the <a href="https://www.vergiliusproject.com/kernels/x64/Windows%2011/22H2%20(2022%20Update)/_RTL_USER_PROCESS_PARAMETERS">ProcessParameters</a> structure, which is referenced by the <a href="https://www.vergiliusproject.com/kernels/x64/Windows%2011/22H2%20(2022%20Update)/_PEB">PEB</a>, so I got its address (which in my case, was 0xF1F40) and configured the hardware breakpoint, like so:<o:p></o:p></p>
<pre><code class="language-plaintext">0:005&gt; ba r 8 0xF1F40 "k;g"<o:p></o:p></code></pre><p class="MsoNormal">Every time that a function reads the console handle, the stack trace is going to be printed on the screen and then it is going to continue executing.<o:p></o:p></p>
<p class="MsoNormal">After a few seconds, I had the full list of functions that read the ConsoleHandle. After some cleaning up, I got the following list:<o:p></o:p></p>
<ul>
<li class="MsoListParagraphCxSpFirst" style="mso-list:l3 level1 lfo1;">SetThreadUILanguage<o:p></o:p></li>
<li class="MsoListParagraphCxSpMiddle" style="mso-list:l3 level1 lfo1;">SetThreadPreferredUILanguages2<o:p></o:p></li>
<li class="MsoListParagraphCxSpMiddle" style="mso-list:l3 level1 lfo1;">GetConsoleCP<o:p></o:p></li>
<li class="MsoListParagraphCxSpMiddle" style="mso-list:l3 level1 lfo1;">GetCurrentConsoleFontEx<o:p></o:p></li>
<li class="MsoListParagraphCxSpMiddle" style="mso-list:l3 level1 lfo1;">GetConsoleMode<o:p></o:p></li>
<li class="MsoListParagraphCxSpMiddle" style="mso-list:l3 level1 lfo1;">GetConsoleScreenBufferInfo<o:p></o:p></li>
<li class="MsoListParagraphCxSpMiddle" style="mso-list:l3 level1 lfo1;">GetConsoleScreenBufferInfo<o:p></o:p></li>
<li class="MsoListParagraphCxSpMiddle" style="mso-list:l3 level1 lfo1;">GetConsoleMode<o:p></o:p></li>
<li class="MsoListParagraphCxSpMiddle" style="mso-list:l3 level1 lfo1;">SetConsoleMode<o:p></o:p></li>
<li class="MsoListParagraphCxSpMiddle" style="mso-list:l3 level1 lfo1;">GetConsoleMode<o:p></o:p></li>
<li class="MsoListParagraphCxSpMiddle" style="mso-list:l3 level1 lfo1;">GetConsoleMode<o:p></o:p></li>
<li class="MsoListParagraphCxSpLast" style="mso-list:l3 level1 lfo1;">GetConsoleMode<o:p></o:p></li>
</ul>
<p class="MsoNormal">Once I knew which functions used the ConsoleHandle, I patched them in memory and replaced them with my own dummy implementation, that did nothing and returned successfully.<o:p></o:p></p>
<p class="MsoNormal">To be sure my modifications did not break the inner workings of PowerShell, I ran the following test:<o:p></o:p></p>
<pre><code class="language-plaintext">AllocConsole();
SetStdHandle(STD_OUTPUT_HANDLE, hWrite);
SetStdHandle(STD_ERROR_HANDLE, hWrite);
patchKernelbase();<o:p></o:p></code></pre><p class="MsoNormal">After a few bug fixes, I managed to obtain the PowerShell output, which meant my dummy implementations were working properly. I then re-ran the previous test, but this time, I invalidated the ConsoleHandle:<o:p></o:p></p>
<pre><code class="language-plaintext">AllocConsole();
SetStdHandle(STD_OUTPUT_HANDLE, hWrite);
SetStdHandle(STD_ERROR_HANDLE, hWrite);
patchKernelbase();
PEB-&gt;ProcessParameters-&gt;ConsoleHandle = 0x123;<o:p></o:p></code></pre><p class="MsoNormal">I was confident this was going to work, but to my surprise, it did not.<o:p></o:p></p>
<p class="MsoNormal">I thought I was surely missing some API, so I re-ran the test with the previous hardware breakpoint and got zero hits, which meant no API was reading the <em>ConsoleHandle</em>. How can it be that modifying a memory address that no one reads breaks the output redirection? I figured WinDbg was missing a read somehow and decided to continue testing.<o:p></o:p></p>
<p class="MsoNormal">Instead of invalidating the <em>ConsoleHandle </em>before running PowerShell, I decided to do it inside one of my dummy functions, which meant that the handle would be invalidated during the execution of PowerShell and not before.<o:p></o:p></p>
<p class="MsoNormal">I tried this on all the dummy functions, one by one, and realized that some functions allowed me to invalidate the handle (meaning I managed to redirect the output) and some did not.<o:p></o:p></p>
<p class="MsoNormal">After some cleanup, I ended up with the following list:<o:p></o:p></p>
<ul>
<li><strong>X </strong>SetThreadUILanguage<strong><o:p></o:p></strong></li>
<li><strong>X </strong>SetThreadPreferredUILanguages2<strong><o:p></o:p></strong></li>
<li><strong>X </strong>GetConsoleCP<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetCurrentConsoleFontEx<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleMode<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleScreenBufferInfo<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleScreenBufferInfo<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleMode<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>SetConsoleMode<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleTitleW<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleMode<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleTitleW<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleMode<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>SetTEBLangID<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>SetConsoleTitleW<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleMode<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>SetThreadUILanguage<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleOutputCP<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleScreenBufferInfo<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleOutputCP<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>SetThreadUILanguage<strong><o:p></o:p></strong></li>
<li><strong>‚úì </strong>GetConsoleOutputC<o:p></o:p></li>
</ul>
<p class="MsoNormal">From the output above, it was evident that something had to be happening in between <em>GetConsoleCP </em>and <em>GetCurrentConsoleFontEx</em>. And if we analyze the stack trace for both these function calls, we learn that they are called by the same function:<o:p></o:p></p>
<pre><code class="language-plaintext"># Child-SP RetAddr Call Site
00 KERNELBASE!GetConsoleCP
01 Microsoft_PowerShell_ConsoleHost_ni+0x71563
02&nbsp;Microsoft_PowerShell_ConsoleHost_ni!Microsoft.PowerShell.ConsoleControl.UpdateLocaleSpecificFont+0x24
...<o:p></o:p>
# Child-SP RetAddr Call Site
00 KERNELBASE!GetCurrentConsoleFontEx
01 Microsoft_PowerShell_ConsoleHost_ni+0x73912
02 Microsoft_PowerShell_ConsoleHost_ni!Microsoft.PowerShell.ConsoleControl.GetConsoleFontInfo+0x78
03 Microsoft_PowerShell_ConsoleHost_ni!Microsoft.PowerShell.ConsoleControl.UpdateLocaleSpecificFont+0x5a
...<o:p></o:p></code></pre><p class="MsoNormal" style="margin-bottom:12.0pt;">Interestingly, the code for <em>UpdateLocaleSpecificFont </em>is public and can be found&nbsp;<a href="https://github.com/microsoft/DbgShell/blob/master/DbgShell/ConsoleControl.cs#L2666">here</a>. The relevant code snippet is:</p>
<div class="align-center media-default">
  
  
  <div class="field field--name-field-media-image field--type-image field--label-visually_hidden">
    <div class="field__label visually-hidden">Image</div>
              <div class="field__item">  <img loading="lazy" src="https://www.coresecurity.com/sites/default/files/2023-11/running_pes_inline_without_console_img_04_updatelocalespecificfont.png" width="480" height="312" alt="updatelocalespecificfont" typeof="foaf:Image">

</div>
          </div>

</div>
<p class="MsoNormal" style="margin-bottom:12.0pt;"><o:p></o:p><o:p></o:p></p>
<p class="MsoNormal">At the start, we can see the call to <em>GetConsoleCP</em>, and at the end, the call to <em>GetCurrentConsoleFontEx</em>. This means that the issue lies in whatever <em>GetActiveScreenBufferHandle </em>is doing.<o:p></o:p></p>
<p class="MsoNormal">After we inspect its code, we learn that it calls this function right&nbsp;<a href="https://github.com/microsoft/DbgShell/blob/master/DbgShell/ConsoleControl.cs#L592-L615">here</a>:<o:p></o:p></p>
<div class="align-center media-default">
  
  
  <div class="field field--name-field-media-image field--type-image field--label-visually_hidden">
    <div class="field__label visually-hidden">Image</div>
              <div class="field__item">  <img loading="lazy" src="https://www.coresecurity.com/sites/default/files/2023-11/running_pes_inline_without_console_img_05_consolehandle.png" width="480" height="242" alt="console handle" typeof="foaf:Image">

</div>
          </div>

</div>
<p class="MsoNormal"><o:p></o:p></p>
<p class="MsoNormal">The documentation from <a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a> reads:<o:p></o:p></p>
<p class="MsoQuote" style="text-align:left;" align="left"><em>CONOUT$ gets a handle to the active screen buffer, even if </em><a href="https://learn.microsoft.com/en-us/windows/console/setstdhandle"><em>SetStdHandle</em></a><em> redirects the standard output handle.<o:p></o:p></em></p>
<p class="MsoNormal">This actually makes a lot of sense. PowerShell is calling <em>CreateFile </em>with CONOUT$, which will end up calling <em>NtCreateFile</em>, which will be handled by the Windows kernel. Apparently, the kernel reads the <em>ConsoleHandle </em>of the calling process to service this call, which explains why the hardware breakpoint was not being triggered‚Äîit was being read from kernel-land.<o:p></o:p></p>
<p class="MsoNormal">If the <em>ConsoleHandle </em>is invalid (which it is in our case), <em>CreateFile </em>fails and returns INVALID_HANDLE which will make <em>GetActiveScreenBufferHandle </em>throw a ‚ÄúHostException‚Äù which <em>UpdateLocaleSpecificFont </em>will not catch. This means that the call to CreateFile has to succeed if we want to be able to redirect PowerShell‚Äôs output.<o:p></o:p></p>
<p class="MsoNormal">Now that we know which functions are important, let's discuss our options of how we can redirect the output of PowerShell without allocating a console.<o:p></o:p></p>
<h3>Memory Patching<o:p></o:p></h3>
<p class="MsoNormal">We already know that directly modifying the instructions from the functions that want to spoof works, but that would mean that memory scanners like <a href="https://github.com/forrest-orr/moneta">Moneta</a> would be able to detect the loader very easily.&nbsp;</p>
<div class="align-center media-default">
  
  
  <div class="field field--name-field-media-image field--type-image field--label-visually_hidden">
    <div class="field__label visually-hidden">Image</div>
              <div class="field__item">  <img loading="lazy" src="https://www.coresecurity.com/sites/default/files/2023-11/running_pes_inline_without_console_img_06_moneta.png" width="480" height="95" alt="moneta" typeof="foaf:Image">

</div>
          </div>

</div>
<p class="MsoNormal"><o:p></o:p></p>
<p class="MsoNormal">So, we will leave this approach as a last resource.<o:p></o:p></p>
<h3>IAT Hooking<o:p></o:p></h3>
<p class="MsoNormal">A viable alternative is IAT hooking, which means that while loading the PowerShell binary, we do not resolve the addresses of the relevant APIs correctly. Instead, we set their addresses to our own implementations that will simply mimic the real ones.<o:p></o:p></p>
<p class="MsoNormal">However, PowerShell does not directly import the functions that we need to hook, which means that traditional IAT hooking will not work. Nonetheless, I decided to dig deeper and try to understand how function address resolution works within PowerShell.<o:p></o:p></p>
<p class="MsoNormal">I selected, at random, one of the functions that use the<em> ConsoleHandle (SetConsoleMode)</em> and configured a software breakpoint on it. Once it got hit, I got out of the current function to inspect the function that called it.<o:p></o:p></p>
<pre><code class="language-plaintext">0:008&gt; bp KERNELBASE!SetConsoleMode
0:008&gt; g
Breakpoint 1 hit
KERNELBASE!SetConsoleMode:
00007ffc`f5477640 4053&nbsp;           push&nbsp;   rbx
0:008&gt; gu
Microsoft_PowerShell_ConsoleHost_ni+0x72d6e<o:p></o:p></code></pre><p class="MsoNormal">After some inspection, I determined how this function calls <em>SetConsoleMode</em>. This is done with the following instructions:<o:p></o:p></p>
<pre><code class="language-plaintext">00007ffc`c6e82d08 4c8955c0&nbsp;        mov&nbsp;   qword ptr [rbp-40h], r10
‚Ä¶
00007ffc`c6e82d44 488b4dc0&nbsp;       mov&nbsp;    rcx, qword ptr [rbp-40h]
00007ffc`c6e82d48 488b4920&nbsp;       mov&nbsp;    rcx, qword ptr [rcx+20h]
00007ffc`c6e82d4c 488b01&nbsp;         mov&nbsp;    rax, qword ptr [rcx]
‚Ä¶
00007ffc`c6e82d6c ffd0&nbsp;           call&nbsp;   rax &lt;-- calls SetConsoleMode<o:p></o:p></code></pre><p class="MsoNormal">The register r10 contained a pointer to some unknown structure that stores the address of <em>SetConsoleMode</em>. We can replicate this on WinDbg to find the address where the pointer of <em>SetConsoleMode </em>is stored in memory.<o:p></o:p></p>
<pre><code class="language-plaintext">0:007&gt; dq rbp-40h L 1
00000000`00cfe310&nbsp;00007ffc`c6e236a0 &lt;-- start of unknown struct
0:007&gt; dq 00007ffc`c6e236a0+20h L 1
00007ffc`c6e236c0&nbsp;00007ffc`c6e28490 &lt;-- pointer stored at offset 0x20
0:007&gt; dq 00007ffc`c6e28490 L 1
00007ffc`c6e28490&nbsp;00007ffc`f68356b0 &lt;-- address of SetConsoleMode
0:007&gt; u 00007ffc`f68356b0
KERNEL32!SetConsoleMode:
00007ffc`f68356b0 ff2532b50500&nbsp;   jmp&nbsp;   qword ptr [KERNEL32!_imp_SetConsoleMode (00007ffc`f6890be8)]<o:p></o:p></code></pre><p class="MsoNormal">Ok, so we now know that <em>0x7ffcc6e28490 </em>stores the address of <em>SetConsoleMode</em>. But who sets this memory address? To find that out, I once again used a hardware breakpoint, which triggered when someone writes to that address.<o:p></o:p></p>
<p class="MsoNormal">After I reran everything with the hardware breakpoint set, I got a hit:<o:p></o:p></p>
<pre><code class="language-plaintext">0:007&gt; ba w 8&nbsp;00007ffc`c6e28490
0:007&gt; g
Breakpoint 1 hit
clr!NDirectMethodDesc::SetNDirectTarget+0x3c<o:p></o:p></code></pre><p class="MsoNormal">This means that the NDirectMethodDesc function on the CLR (and not PowerShell) is the one who resolves the address of SetConsoleMode. The exact process of how the resolution works is not terribly important, so I will just explain the general idea behind it.<o:p></o:p></p>
<p class="MsoNormal">The CLR calls clr!NDirect::NDirectLink, which obtains the address of the API by calling clr!NDirectMethodDesc::FindEntryPoint and saves it in the aforementioned structure by calling clr!NDirectMethodDesc::SetNDirectTarget. The function clr!NDirectMethodDesc::FindEntryPoint works by calling KERNEL32!GetProcAddressForCaller.<o:p></o:p></p>
<p class="MsoNormal">We can observe how the CLR resolves the all the relevant functions in real time by setting a breakpoint on GetProcAddressForCaller and printing the second arguments as a string on each hit:<o:p></o:p></p>
<pre><code class="language-plaintext">0:013&gt; bp kernelbase!GetProcAddressForCaller "da rdx;g"&nbsp;
0:013&gt; g&nbsp;
00007ffa`7229dff3 "GetConsoleTitle"&nbsp;
00000000`1ca7eb71 "GetConsoleTitleW"&nbsp;
00007ffa`7229e0ad "SetConsoleCtrlHandler"&nbsp;
00000000`03d3dbb1 "SetConsoleCtrlHandlerW"&nbsp;
00007ffa`75ce2af5 "GetStdHandle"&nbsp;
00007ffa`767c56ce "GetConsoleMode"&nbsp;
00007ffa`7229e003 "SetConsoleTitle"&nbsp;
00000000`1ca7eb81 "SetConsoleTitleW"
...<o:p></o:p></code></pre><p class="MsoNormal">Now that we have a decent understanding of how resolving the address of these functions works, can we abuse it somehow? The answer is yes, because when the CLR resolves the address of <em>SetConsoleMode </em>(or any other function), it stores the pointer in a region of memory that is RW (readable and writeable), meaning we can search for these pointers and replace them with our own.<o:p></o:p></p>
<p class="MsoNormal">However, this approach is not straightforward given that we would need to find and modify these pointers while PowerShell is running, but only after they are resolved and before they are used. This complicates things quite a bit, so I decided to continue searching for other alternatives.<o:p></o:p></p>
<h3>Hardware Breakpoints<o:p></o:p></h3>
<p class="MsoNormal">Using hardware breakpoints would allow us to redirect the execution of any function without patching its memory (so memory scanners will not be a concern), but the main issue with this approach is that each thread only has 4 slots for hardware breakpoints, and we need to hook more than 10 functions.<o:p></o:p></p>
<p class="MsoNormal">Given that the order in which the functions are called seems to be the same every time, we could simply set a hardware breakpoint in the first function and once it is called, unset it and set it in the second function and so on. This is feasible but also unnecessary, given that there is a better way.<o:p></o:p></p>
<p class="MsoNormal">All the functions that we need to hook, except for <em>CreateFile</em>, are just a wrapper to a lower-level API called <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntdeviceiocontrolfile"><em>NtDeviceIoControlFile</em></a>. So instead of worrying about more than ten functions, we only need to worry about <em>NtDeviceIoControlFile </em>and <em>CreateFile</em>.<o:p></o:p></p>
<p class="MsoNormal">The second issue is that we can only set hardware breakpoints on the main thread. PowerShell will create other threads which will not have any hardware breakpoint set.</p>
<p class="MsoNormal">Moreover, threads created by PowerShell do indeed read the <em>ConsoleHandle </em>as can be seen next (notice the call stack does not begin in unbacked memory from Beacon):<o:p></o:p></p>
<pre><code class="language-plaintext"># Child-SP&nbsp;         RetAddr&nbsp;              Call Site
00 KERNELBASE!GetConsoleTitleInternal+0x67 &lt;-- function that reads the ConsoleHandle
01 KERNELBASE!GetConsoleTitleW+0x20
02 Microsoft_PowerShell_ConsoleHost_ni+0x72008
03 Microsoft_PowerShell_ConsoleHost_ni+0x5a9e8
04 Microsoft_PowerShell_ConsoleHost_ni+0x6d752
05 mscorlib_ni+0x588c87
06 mscorlib_ni+0x55fbe8
07 mscorlib_ni+0x55fad5
08 mscorlib_ni+0x589d01
09 mscorlib_ni+0x588dd1
0a mscorlib_ni+0x59ae56
0b clr!CallDescrWorkerInternal+0x83
0c clr!CallDescrWorkerWithHandler+0x47
0d clr!MethodDescCallSite::CallTargetWorker+0xfa
0e clr!QueueUserWorkItemManagedCallback+0x2a
0f clr!ManagedThreadBase_DispatchInner+0x33
10 clr!ManagedThreadBase_DispatchMiddle+0x83
11 clr!ManagedThreadBase_DispatchOuter+0x87
12 clr!ManagedThreadBase_FullTransitionWithAD+0x2f
13 clr!ManagedPerAppDomainTPCount::DispatchWorkItem+0x9a
14 clr!ThreadpoolMgr::ExecuteWorkRequest+0x51
15 clr!ThreadpoolMgr::WorkerThreadStart+0xe9
16 clr!Thread::intermediateThreadProc+0x8a
17 KERNEL32!BaseThreadInitThunk+0x14
18 ntdll!RtlUserThreadStart+0x21<o:p></o:p></code></pre><p class="MsoNormal">To deal with this, we could set a hardware breakpoint on <em>CreateThread </em>so that we can configure the new thread each time that function is called. Luckily, it turns out that is not necessary because these threads do not need to work at all to recover the output. We can let them fail safely and we still get our output back.<o:p></o:p></p>
<p class="MsoNormal">So, I only needed to set a hardware breakpoint in <em>NtDeviceIoControlFile </em>and <em>CreateFile </em>on the main thread to successfully redirect the output for PowerShell.<o:p></o:p></p>
<p class="MsoNormal">When I detect a call to <em>CreateFile</em>, I check the first parameter. If it is ‚ÄúCONOUT$‚Äù, I immediately return a value other than ‚Äì1. If not, I let the execution continue.</p>
<p class="MsoNormal">If <em>NtDeviceIoControFile </em>is called instead, I check the first parameter. If it is the (fake) <em>ConsoleHandle</em>, I imitate the behavior of <em>NtDeviceIoControFile </em>when a console is present. If not, I let the execution continue.<o:p></o:p></p>
<p class="MsoNormal">After all this, I successfully spoofed a console on PowerShell and redirected its output.<o:p></o:p></p>
<div class="align-center media-default">
  
  
  <div class="field field--name-field-media-image field--type-image field--label-visually_hidden">
    <div class="field__label visually-hidden">Image</div>
              <div class="field__item">  <img loading="lazy" src="https://www.coresecurity.com/sites/default/files/2023-11/running_pes_inline_without_console_img_07_spoofed_console.png" width="480" height="239" alt="spoofed console" typeof="foaf:Image">

</div>
          </div>

</div>
<p class="MsoNormal"><o:p></o:p></p>
<h3>Modifying the ConsoleHandle<o:p></o:p></h3>
<p class="MsoNormal">Another idea that came to my mind that I wanted to share was setting the <em>ConsoleHandle </em>to a handle owned by my own loader. In theory, every time <em>NtDeviceIoControleFile </em>gets called, I would receive the message and answer it the same way the console would.<o:p></o:p></p>
<p class="MsoNormal">However, according to Microsoft‚Äôs <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntdeviceiocontrolfile">documentation</a>, what this function does is:<o:p></o:p></p>
<p class="MsoQuote" style="text-align:left;" align="left"><em>Builds descriptors for the supplied buffer(s) and passes the untyped data to the device driver associated with the file handle.<o:p></o:p></em></p>
<p class="MsoNormal">The description is not terribly clear, but it means that this function allows processes to interact with a device driver which can be associated with a file, a USB, or in this case a console.<o:p></o:p></p>
<p class="MsoNormal">In other words, <em>NtDeviceIoControFile </em>was not designed for inter-process communication, the syscall expects a handle to a device driver and not something like a pipe or a socket, so this option is not feasible, unless someone proves me wrong üòä.<o:p></o:p></p>
<h2>Running PowerShell Multiple Times<o:p></o:p></h2>
<p class="MsoNormal">An interesting caveat that I found during the development of this tool was that while the redirection for PowerShell worked perfectly the first time, all subsequent calls failed.<o:p></o:p></p>
<div class="align-center media-default">
  
  
  <div class="field field--name-field-media-image field--type-image field--label-visually_hidden">
    <div class="field__label visually-hidden">Image</div>
              <div class="field__item">  <img loading="lazy" src="https://www.coresecurity.com/sites/default/files/2023-11/running_pes_inline_without_console_img_08_failed_calls.png" width="480" height="139" alt="failed calls" typeof="foaf:Image">

</div>
          </div>

</div>
<p class="MsoNormal"><o:p></o:p></p>
<p class="MsoNormal">This turned out to be because I was creating a new anonymous pipe on each run and closing it upon cleanup. PowerShell caches the first handle it uses for standard output and when it gets closed, the output redirection breaks down.<o:p></o:p></p>
<p class="MsoNormal">To counter that, I created the anonymous pipe once and reused it on all subsequent runs. To ‚Äúremember‚Äù the pipe handles in between executions, I used the new key/value storage feature that Cobalt Strike launched in <a href="https://www.cobaltstrike.com/blog/cobalt-strike-49-take-me-to-your-loader">release 4.9</a>.<o:p></o:p></p>
<div class="align-center media-default">
  
  
  <div class="field field--name-field-media-image field--type-image field--label-visually_hidden">
    <div class="field__label visually-hidden">Image</div>
              <div class="field__item">  <img loading="lazy" src="https://www.coresecurity.com/sites/default/files/2023-11/running_pes_inline_without_console_img_09_key_value_storage.png" width="480" height="111" alt="key value storage" typeof="foaf:Image">

</div>
          </div>

</div>
<p class="MsoNormal"><o:p></o:p></p>
<p class="MsoNormal">Lastly, this blogpost would not be complete without a screenshot of mimikatz running:</p>
<div class="align-center media-default">
  
  
  <div class="field field--name-field-media-image field--type-image field--label-visually_hidden">
    <div class="field__label visually-hidden">Image</div>
              <div class="field__item">  <img loading="lazy" src="https://www.coresecurity.com/sites/default/files/2023-11/running_pes_inline_without_console_img_10_mimikatz.png" width="480" height="345" alt="mimikatz" typeof="foaf:Image">

</div>
          </div>

</div>
<p>&nbsp;</p>
<p class="MsoNormal"><o:p></o:p></p>
<p class="MsoNormal"><o:p></o:p></p>
<h2>Conclusion<o:p></o:p></h2>
<p class="MsoNormal">This is a good example of how a deeper understanding of Windows internals can help us improve our tradecraft. While this loader is by no means undetectable, it empowers others to build upon it as I built on top of other people‚Äôs work while developing it.<o:p></o:p></p>
<p class="MsoNormal">Each time we get mess with undocumented Windows structures and functions, we risk crashing in past and future Windows versions, given that they might change without a warning. Consider that before running this or any other tool on your Beacon, always test locally before running anything on your client‚Äôs network.<o:p></o:p></p>
<p class="MsoNormal">Check out the tool that implements all of this <a href="https://github.com/fortra/No-Consolation">here</a>.<o:p></o:p></p>
<p class="MsoNormal">Thank you for reading and happy hacking!<o:p></o:p></p>
</div>
             </div>
              <div class="col-lg-4">
                  
      <div class="field field--name-field-author field--type-entity-reference field--label-hidden field__items">
              <div class="field__item">

<article data-history-node-id="104559" about="/profile/santiago-pecin" class="node node--type-author node--view-mode-teaser clearfix">
  <div class="node__content clearfix">
    <div class="node-content-container container">
      <div class="row">
        <div class="col-4">
            <div class="field field--name-field-media field--type-entity-reference field--label-hidden field__item">  <a href="https://www.coresecurity.com/profile/santiago-pecin"><img loading="lazy" src="https://www.coresecurity.com/sites/default/files/styles/thumbnail/public/2023-08/santiago-pecin-circle-outline.png?itok=BZedGfr0" width="100" height="98" alt="Santiago Pecin" typeof="foaf:Image" class="image-style-thumbnail">

</a>
</div>
      </div>
        <div class="col-8 pl-0">
          <div class="block-title text-uppercase">Meet the Author</div>
          <h3 class="node__title"><a href="https://www.coresecurity.com/profile/santiago-pecin" rel="bookmark"><span class="field field--name-title field--type-string field--label-hidden">Santiago Pecin </span>
</a></h3>
          
            <div class="field field--name-field-position-title field--type-string field--label-hidden field__item">Cybersecurity Consultant</div>
      
          
        </div>
      </div>
      <div class="row">
        <div class="col-12">
          <div class="author-link">
            <a href="https://www.coresecurity.com/profile/santiago-pecin" rel="bookmark">View Profile <span class="arrow right" aria-hidden="true"></span></a>
          </div>
        </div>
      </div>
    </div>
  </div>
</article>
</div>
          </div>
  
                  <div class="related-nodes">
                    
      <div class="field field--name-field-related-content field--type-entity-reference field--label-hidden field__items">
              <div class="field__item">

<article data-history-node-id="104762" about="/core-labs/articles/creating-processes-using-system-calls" typeof="schema:Article" class="node node--type-article node--promoted node--view-mode-related-content clearfix">
    <div class="node__content clearfix">
        <div class="node-content-container container">
            <div class="row">
                                    <div class="col-12">
                        <div class="node--type text-uppercase">Article</div>
                        <div class="node--title"><a href="https://www.coresecurity.com/core-labs/articles/creating-processes-using-system-calls" rel="bookmark"><span property="schema:name" class="field field--name-title field--type-string field--label-hidden">Creating Processes Using System Calls</span>
</a></div>
                    </div>
                            </div>
        </div>
    </div>
</article>
</div>
              <div class="field__item">

<article data-history-node-id="104591" about="/core-labs/articles/writing-beacon-object-files-flexibie-stealthy-and-compatible" typeof="schema:Article" class="node node--type-article node--promoted node--view-mode-related-content clearfix">
    <div class="node__content clearfix">
        <div class="node-content-container container">
            <div class="row">
                                    <div class="col-12">
                        <div class="node--type text-uppercase">Article</div>
                        <div class="node--title"><a href="https://www.coresecurity.com/core-labs/articles/writing-beacon-object-files-flexibie-stealthy-and-compatible" rel="bookmark"><span property="schema:name" class="field field--name-title field--type-string field--label-hidden">Writing Beacon Object Files: Flexible, Stealthy, and Compatible</span>
</a></div>
                    </div>
                            </div>
        </div>
    </div>
</article>
</div>
              <div class="field__item">

<article data-history-node-id="104560" about="/core-labs/articles/nanodump-red-team-approach-minidumps" typeof="schema:Article" class="node node--type-article node--promoted node--view-mode-related-content clearfix">
    <div class="node__content clearfix">
        <div class="node-content-container container">
            <div class="row">
                                    <div class="col-12">
                        <div class="node--type text-uppercase">Article</div>
                        <div class="node--title"><a href="https://www.coresecurity.com/core-labs/articles/nanodump-red-team-approach-minidumps" rel="bookmark"><span property="schema:name" class="field field--name-title field--type-string field--label-hidden">Nanodump: A Red Team Approach to Minidumps </span>
</a></div>
                    </div>
                            </div>
        </div>
    </div>
</article>
</div>
          </div>
  
                  </div>
              </div>
                </div>
    </div>
            <div class="paragraph paragraph--type--section paragraph--view-mode--default section row dark-arrow">
        <div class="col-sm-12">
      <div class="container">
                                             
      <div class="paragraph paragraph--type--cta paragraph--view-mode--default hs-page-cta cta-type--primary">
                        <h3 class="cta-headline">
            
            <div class="field field--name-field-cta-headline field--type-string field--label-hidden field__item"> Interested in other Red Teaming techniques? </div>
      
          </h3>
                          
            <div class="clearfix text-formatted field field--name-field-cta-text field--type-text-long field--label-hidden field__item"><p>Learn more in our article, <em>Writing Beacon Object Files: Flexible, Stealthy, and Compatible</em>.</p>
</div>
      
                                    
                                
          
          
          <a href="https://www.coresecurity.com/core-labs/articles/writing-beacon-object-files-flexibie-stealthy-and-compatible" class="btn btn-4">
            READ ARTICLE
          </a>
                  </div>
  



          
              </div>
    </div>
  </div>




  </div>
</article>

    </div>
  </div>


              </main>
                </div>
  </div>
</div>
    </div>
        
  </div>
</div>

  </div>

  
  





















<div id="addtoany" style="position: static;"><div style="height: 1px; width: 1px; position: absolute; z-index: 100000; top: 0px; visibility: hidden;"><div id="a2a_sm_ifr" title="AddToAny Utility Frame" aria-hidden="true" src="https://static.addtoany.com/menu/sm.25.html#type=core&amp;event=load" style="height: 1px; width: 1px; border: 0px; left: 0px; top: 0px; position: absolute; z-index: 100000; display: none;" data-original-tag="iframe"><title>A2A</title></div></div></div>

<div height="1" width="1" style="position: absolute; top: 0px; left: 0px; border: none; visibility: hidden;" data-original-tag="iframe"></div>

<div class="ta-display-none" name="trustarc_notice" id="trustarcNoticeFrame" title="Trustarc Cross-Domain Consent Frame" src="https://consent.trustarc.com/get?name=crossdomain.html&amp;domain=helpsystems.com" data-original-tag="iframe"></div></body></html>