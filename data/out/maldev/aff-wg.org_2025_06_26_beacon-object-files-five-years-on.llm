Title:
Beacon Object Files, Five Years On

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post is an oral-history and technical rationale for Beacon Object Files (BOFs), introduced in Cobalt Strike 4.1, and why they emerged as an alternative to fork&run and memory-injected reflective DLL post-execution.  
- It frames late-2010s pressures from EDR detections on process injection chains and reflective DLL “tells,” motivating a smaller, more controllable in-memory execution format.  
- The author describes an initial attempt using position-independent code (PIC) carved from DLLs, why it was error-prone, and how parsing/using COFF object files enabled more reliable inline execution (globals/strings/function pointers) across x86/x64.  
- Key design elements include Dynamic Function Resolution (MODULE$Function), argument packing/unpacking integrated with Aggressor Script/Sleep, and controller-side COFF preprocessing to keep the Beacon-side loader minimal.  
- It also documents limitations/omissions (e.g., early lack of .bss support, no plan for long-running tasks until later async BOFs, constraints for multi-module projects) and points to community evolutions like COFFLoader, boflink, and PE-BOF proposals.  
- Useful for red team toolsmiths and C2 developers designing post-execution modules, and for defenders seeking to understand the trade-offs and artifacts of BOF-style execution.

Technical Focus:
- COFF object parsing/loading and lightweight in-memory “linking”
- Beacon Object File (BOF) execution model vs fork&run and reflective DLLs
- Position-independent code (PIC) trade-offs and reliability pitfalls
- Dynamic Function Resolution (MODULE$Function) and API resolution strategies
- Argument packing/unpacking conventions and glue-language integration (Sleep/Aggressor)
- Memory layout/detection implications (.text/data separation, minimal agent loader)

Use Cases:
- Building small post-execution capabilities (enum, priv-esc helpers, lateral movement primitives) without spawning/injecting helper processes
- Implementing custom BOF runners/loaders (agent-side vs controller-side preprocessing)
- Porting existing utilities into BOF form for reduced footprint and simpler builds
- Evaluating detection opportunities around COFF/BOF loading, relocations, and API resolution patterns
- Extending BOFs to support larger projects (e.g., boflink) or alternative formats (PE-BOF)

Keywords:
Beacon Object Files, BOF, Cobalt Strike, COFF, inline-execute, fork&run, reflective DLL, process injection, EDR evasion, position-independent code, PIC, Dynamic Function Resolution, MODULE$Function, GetProcAddress, LoadLibraryA, relocations, .bss section, Aggressor Script, Sleep language, COFFLoader, boflink, PE-BOF, asynchronous BOFs