Title:
bof-launcher (Beacon Object File launcher)

Type:
GitHub Tool

Short Summary (4–8 sentences max):
- bof-launcher is a standalone library for loading and executing Cobalt Strike–style Beacon Object Files (BOFs) outside of Beacon, on Windows and Linux across multiple architectures (x86/x64, ARM/AArch64 on Linux).  
- It solves the problem of reliably running COFF (Windows) and ELF (Linux) BOF modules in custom tooling by handling object parsing, relocations, symbol resolution, argument passing, and output capture.  
- The project provides clean C and Zig APIs, supports integration from C/C++/Zig/Rust/Go, and aims for zero dependencies (including avoiding libc).  
- It includes features for operational flexibility such as asynchronous/long-running BOFs in separate threads, “sacrificial process” patterns for risky modules, and “BOF chaining” via a flexible API.  
- The repo also ships a growing BOF collection (many written in Zig) plus build tooling to cross-compile and test (including QEMU-assisted foreign-arch tests).  
- It’s useful for red teams, implant/C2 developers, and BOF authors who want portable post-ex modules and a non-Beacon execution environment.

Technical Focus:
- COFF and ELF object loading (parsing, relocations, symbol resolution)
- Cross-platform BOF execution runtime (Windows/Linux; x86/x64/ARM/AArch64)
- Zero-dependency loader design (no libc)
- Zig-based build/cross-compilation and QEMU test execution
- BOF execution patterns: threading, sacrificial process, chaining
- BOF documentation extraction to YAML for tooling (cli4bofs integration)

Use Cases:
- Embed BOF execution into custom implants/C2 agents on Windows and Linux
- Rapidly test/debug third-party BOFs without Cobalt Strike Beacon (via cli4bofs)
- Build cross-platform post-ex modules in Zig (or C) and run them as BOFs
- Execute higher-risk modules (e.g., privesc) in a sacrificial process to reduce blast radius
- Chain multiple BOFs as modular tasking in an operator workflow

Keywords:
Beacon Object File, BOF, Cobalt Strike, COFF, ELF, in-memory execution, relocations, symbol resolution, Win32 API, Linux, x86, x64, ARM, AArch64, Zig, C API, Rust FFI, Go integration, QEMU, post-exploitation