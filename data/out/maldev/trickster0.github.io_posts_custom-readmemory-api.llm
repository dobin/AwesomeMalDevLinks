Title:
Custom ReadMemory API

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post explores building a custom “ReadProcessMemory-like” primitive on x64 by abusing the NTAPI function `RtlFirstEntrySList` in `ntdll.dll`, inspired by prior x86 research.  
- The author analyzes the x64 implementation and identifies two issues that prevent straightforward memory reads: an argument offset (`rcx+8`) and an `and al, 0F0h` instruction that corrupts the fetched byte/address.  
- The first issue is handled by adjusting the passed pointer (subtracting 8), while the second requires patching two bytes in `RtlFirstEntrySList` to remove the masking operation.  
- A proof-of-concept uses `WriteProcessMemory` to patch `ntdll` and then executes the modified routine to retrieve memory bytes (noting little-endian output handling).  
- Useful for red teamers, exploit devs, and malware researchers interested in alternative memory-read primitives and NTAPI/ntdll patching tradeoffs, as well as defenders studying suspicious in-memory patching patterns.

Technical Focus:
- `RtlFirstEntrySList` internals (x64 vs x86 behavior)
- NTAPI-based memory read primitives
- In-memory patching of `ntdll.dll`
- Instruction-level analysis (argument handling, bitmask side effects)
- `WriteProcessMemory` for runtime code modification

Use Cases:
- Implementing non-standard memory read primitives in offensive tooling
- Researching EDR/userland API monitoring bypass angles (and their limitations)
- Developing detections for `ntdll` code patching and anomalous NTAPI usage
- Educational reverse engineering of `ntdll` routines and calling conventions

Keywords:
RtlFirstEntrySList, ntdll.dll, NTAPI, x64 calling convention, ReadProcessMemory, WriteProcessMemory, in-memory patching, userland hooking, instruction patch, AND mask, little-endian, process memory access, Windows internals, red team tradecraft, PoC, reverse engineering