# https://www.elastic.co/security-labs/false-file-immutability

<!DOCTYPE html><html lang="en"><body><div id="__next"><main class="__variable_0351a5 __variable_a475ec __variable_ead7f7 flex flex-col min-h-screen"><div class="scroll-percentage-container"><div class="scroll-percentage-bar" style="width:0%"></div></div><div class="UtilityHeader_utilityHeader__T_Eto"><div class="UtilityHeader_utilityHeader__container__exgwf"></div></div><main class="mb-20 flex-1 flex flex-col"><div class="h-48 md:h-64" style="will-change: transform; transform: translateY(87.624px);"><div class="after:absolute after:block after:bg-blue-400 after:blur-3xl after:content-[' '] after:h-96 after:opacity-5 after:right-0 after:rounded-full after:top-20 after:w-1/2 after:z-0 before:absolute before:block before:blur-3xl before:bg-orange-400 before:content-[' '] before:h-96 before:left-0 before:opacity-5 before:rounded-full before:w-1/2 before:z-0 w-full h-full relative"><div class="relative z-10 w-full h-[125%] -top-[25%] bg-no-repeat bg-cover bg-bottom flex items-center justify-center" style="background-image:url(/security-labs/grid.svg)"></div></div></div><article class="px-4"><div class="max-w-7xl mx-auto relative z-10 flex flex-col space-y-4"><div class="eyebrow break-words"><time class="block mb-2 md:mb-0 md:inline-block article-published-date" datetime="2024-07-11T00:00:00.000Z">10 July 2024</time><span class="hidden md:inline-block md:mx-2">•</span><a class="hover:text-blue-400 text-xs md:text-sm whitespace-nowrap author-name" href="https://www.elastic.co/security-labs/author/gabriel-landau">Gabriel Landau</a></div><h1 class="font-bold leading-tighter text-3xl md:text-5xl"><span>Introducing a New Vulnerability Class: False File&nbsp;Immutability</span></h1><p class="text-zinc-200 text-base md:text-xl">This article introduces a previously-unnamed class of Windows vulnerability that demonstrates the dangers of assumption and describes some unintended security consequences.</p><div class="flex items-center mt-4 text-zinc-200 text-sm space-x-4 border-t border-white/25 pt-4"><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><span>25 min read</span></span><span class="flex items-center space-x-1"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" class="h-4 w-4 text-zinc-400"><path stroke-linecap="round" stroke-linejoin="round" d="M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M6 6h.008v.008H6V6z"></path></svg><span><a class="hover:text-blue-400 whitespace-nowrap" href="https://www.elastic.co/security-labs/category/internals">Internals</a>, </span><span><a class="hover:text-blue-400 whitespace-nowrap" href="https://www.elastic.co/security-labs/category/product-updates">Product Updates</a></span></span></div></div><div class="max-w-7xl mx-auto"><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 sm:p-8 md:p-10 rounded-3xl mt-5 md:mt-10"><div class="relative w-full rounded-lg overflow-hidden aspect-video"><img alt="Introducing a New Vulnerability Class: False File Immutability" fetchpriority="high" decoding="async" data-nimg="fill" class="object-cover absolute h-full w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2FSecurity%20Labs%20Images%2036.jpg&amp;w=3840&amp;q=75"><div class="absolute border border-white/50 inset-0 mix-blend-overlay rounded-lg z-10"></div></div></div></div><div class="lg:max-w-7xl mx-auto relative mt-12 lg:grid lg:grid-cols-4 lg:gap-8 items-start"><div class="flex justify-center lg:col-span-3"><div class="prose lg:prose-lg prose-invert w-full article-content"><div><h2 class="font-bold text-2xl md:text-4xl relative"><span id="introduction" class="absolute -top-32"></span>Introduction</h2>
<p>This article will discuss a previously-unnamed vulnerability class in Windows, showing how long-standing incorrect assumptions in the design of core Windows features can result in both undefined behavior and security vulnerabilities. We will demonstrate how one such vulnerability in the Windows 11 kernel can be exploited to achieve arbitrary code execution with kernel privileges.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="windows-file-sharing" class="absolute -top-32"></span>Windows file sharing</h2>
<p>When an application opens a file on Windows, it typically uses some form of the Win32 <a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><strong>CreateFile</strong></a> API.</p>
<pre><div class="p-0 pr-8 relative -my-3 -mx-4"><button class="absolute right-2 z-10 top-2 opacity-60 hover:opacity-100 transition-opacity cursor-pointer text-white p-1" title="Copy code block"><svg class="w-4 h-4" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"></path></svg></button><div class="overflow-auto px-4 py-3"><code class="prism-code language-c++ relative" style="color: rgb(156, 220, 254); background-color: rgb(30, 30, 30);"><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">HANDLE CreateFileW(</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">  [in]           LPCWSTR               lpFileName,</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">  [in]           DWORD                 dwDesiredAccess,</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">  [in]           DWORD                 dwShareMode,</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">  [in]           DWORD                 dwCreationDisposition,</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">  [in]           DWORD                 dwFlagsAndAttributes,</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">  [in, optional] HANDLE                hTemplateFile</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">);</span></div></code></div></div></pre>
<p>Callers of <strong>CreateFile</strong> specify the access they want in <strong>dwDesiredAccess</strong>. For example, a caller would pass <strong>FILE_READ_DATA</strong> to be able to read data, or <strong>FILE_WRITE_DATA</strong> to be able to write data. The full set of access rights are <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/file-access-rights-constants">documented</a> on the Microsoft Learn website.</p>
<p>In addition to passing <strong>dwDesiredAccess</strong>, callers must pass a “sharing mode” in <strong>dwShareMode</strong>, which consists of zero or more of <strong>FILE_SHARE_READ</strong>, <strong>FILE_SHARE_WRITE</strong>, and <strong>FILE_SHARE_DELETE</strong>. You can think of a sharing mode as the caller declaring “I’m okay with others doing X to this file while I’m using it,” where X could be reading, writing, or renaming. For example, a caller that passes <strong>FILE_SHARE_WRITE</strong> allows others to write the file while they are working with it.</p>
<p>As a file is opened, the caller’s <strong>dwDesiredAccess</strong> is tested against the <strong>dwShareMode</strong> of all existing file handles. Simultaneously, the caller’s <strong>dwShareMode</strong> is tested against the previously-granted <strong>dwDesiredAccess</strong> of all existing handles to that file. If either of these tests fail, then <strong>CreateFile</strong> fails with a sharing violation.</p>
<p>Sharing isn’t mandatory. Callers can pass a share mode of zero to obtain exclusive access. Per Microsoft <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/creating-and-opening-files">documentation</a>:</p>
<blockquote>
<p>An open file that is not shared (dwShareMode set to zero) cannot be opened again, either by the application that opened it or by another application, until its handle has been closed. This is also referred to as exclusive access.</p>
</blockquote>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="sharing-enforcement" class="absolute -top-32"></span>Sharing enforcement</h3>
<p>In the kernel, sharing is enforced by filesystem drivers. As a file is opened, it’s the responsibility of the filesystem driver to call <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iocheckshareaccess"><strong>IoCheckShareAccess</strong></a> or <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iochecklinkshareaccess"><strong>IoCheckLinkShareAccess</strong></a> to see whether the requested <strong>DesiredAccess</strong>/<strong>ShareMode</strong> tuple is compatible with any existing handles to the file being opened. <a href="https://learn.microsoft.com/en-us/windows-server/storage/file-server/ntfs-overview">NTFS</a> is the primary filesystem on Windows, but it’s closed-source, so for illustrative purposes we’ll instead look at Microsoft’s FastFAT sample code performing <a href="https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L6822-L6884">the same check</a>. Unlike an IDA decompilation, it even comes with comments!</p>
<pre><div class="p-0 pr-8 relative -my-3 -mx-4"><button class="absolute right-2 z-10 top-2 opacity-60 hover:opacity-100 transition-opacity cursor-pointer text-white p-1" title="Copy code block"><svg class="w-4 h-4" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"></path></svg></button><div class="overflow-auto px-4 py-3"><code class="prism-code language-c++ relative" style="color: rgb(156, 220, 254); background-color: rgb(30, 30, 30);"><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//  Check if the Fcb has the proper share access.</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain" style="display: inline-block;">
</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">return IoCheckShareAccess( *DesiredAccess,</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">                           ShareAccess,</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">                           FileObject,</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">                           &amp;FcbOrDcb-&gt;ShareAccess,</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">                           FALSE );</span></div></code></div></div></pre>
<p>In addition to traditional read/write file operations, Windows lets applications map files into memory. Before we go deeper, it’s important to understand that <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views">section objects</a> are kernel parlance for <a href="https://learn.microsoft.com/en-us/windows/win32/memory/file-mapping">file mappings</a>; they are the same thing. This article focuses on the kernel, so it will primarily refer to them as section objects.</p>
<p>There are two types of section objects - data sections and executable image sections. Data sections are direct 1:1 mappings of files into memory. The file’s contents will appear in memory exactly as they do on disk. Data sections also have uniform memory permissions for the entire memory range. With respect to the underlying file, data sections can be either read-only or read-write. A read-write view of a file enables a process to read or write the file’s contents by reading/writing memory within its own address space.</p>
<p>Executable image sections (sometimes abbreviated to image sections) prepare <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format">PE files</a> to be executed. Image sections must be created from PE files. Examples of PE files include EXE, DLL, SYS, CPL, SCR, and OCX files. The kernel processes the PEs specially to prepare them to be executed. Different PE regions will be mapped in memory with different page permissions, depending on their metadata. Image views are <a href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a>, meaning any changes in memory will be saved to the process’s private working set — never written to the backing PE.</p>
<p>Let’s say application A wants to map a file into memory with a data section. First, it opens that file with an API such as <strong>ZwCreateFile</strong>, which returns a file handle. Next, it passes this file handle to an API such as <strong>ZwCreateSection</strong> which creates a section object that describes how the file will be mapped into memory; this yields a section handle. The process then uses the section handle to map a “view” of that section into the process address space, completing the memory mapping.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Diagram showing how a file is mapped into memory" loading="lazy" width="1440" height="308" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage9.png&amp;w=3840&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Diagram showing how a file is mapped into memory</figcaption></figure><p></p>
<p>Once the file is successfully mapped, process A can close both the file and section handles, leaving zero open handles to the file. If process B later wants to use the file without the risk of it being modified externally, it would omit <strong>FILE_SHARE_WRITE</strong> when opening the file. <strong>IoCheckLinkShareAccess</strong> looks for open file handles, but since the handles were previously closed, it will not fail the operation.</p>
<p>This creates a problem for file sharing. Process B thinks it has a file open without risk of external modification, but process A can modify it through the memory mapping. To account for this, the filesystem must also call <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-mmdoesfilehaveuserwritablereferences"><strong>MmDoesFileHaveUserWritableReferences</strong></a>. This checks whether there are any active writable file mappings to the given file. We can see this check in the FastFAT example <a href="https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L6858-L6870">here</a>:</p>
<pre><div class="p-0 pr-8 relative -my-3 -mx-4"><button class="absolute right-2 z-10 top-2 opacity-60 hover:opacity-100 transition-opacity cursor-pointer text-white p-1" title="Copy code block"><svg class="w-4 h-4" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"></path></svg></button><div class="overflow-auto px-4 py-3"><code class="prism-code language-c++ relative" style="color: rgb(156, 220, 254); background-color: rgb(30, 30, 30);"><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//  Do an extra test for writeable user sections if the user did not allow</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//  write sharing - this is neccessary since a section may exist with no handles</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//  open to the file its based against.</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain" style="display: inline-block;">
</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">if ((NodeType( FcbOrDcb ) == FAT_NTC_FCB) &amp;&amp;</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">    !FlagOn( ShareAccess, FILE_SHARE_WRITE ) &amp;&amp;</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">    FlagOn( *DesiredAccess, FILE_EXECUTE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA | DELETE | MAXIMUM_ALLOWED ) &amp;&amp;</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">    MmDoesFileHaveUserWritableReferences( &amp;FcbOrDcb-&gt;NonPaged-&gt;SectionObjectPointers )) {</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain" style="display: inline-block;">
</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">    return STATUS_SHARING_VIOLATION;</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">}</span></div></code></div></div></pre>
<p>Windows requires PE files to be immutable (unmodifiable) while they are running. This prevents EXEs and DLLs from being changed on disk while they are running in memory. Filesystem drivers must use the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-mmflushimagesection"><strong>MmFlushImageSection</strong></a> function to check whether there are any active image mappings of a PE before allowing <strong>FILE_WRITE_DATA</strong> access. We can see this in the <a href="https://github.com/Microsoft/Windows-driver-samples/blob/622212c3fff587f23f6490a9da939fb85968f651/filesys/fastfat/create.c#L3572-L3593">FastFAT example code</a>, and on <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/executable-images">Microsoft Learn</a>.</p>
<pre><div class="p-0 pr-8 relative -my-3 -mx-4"><button class="absolute right-2 z-10 top-2 opacity-60 hover:opacity-100 transition-opacity cursor-pointer text-white p-1" title="Copy code block"><svg class="w-4 h-4" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"></path></svg></button><div class="overflow-auto px-4 py-3"><code class="prism-code language-c++ relative" style="color: rgb(156, 220, 254); background-color: rgb(30, 30, 30);"><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//  If the user wants write access access to the file make sure there</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//  is not a process mapping this file as an image. Any attempt to</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//  delete the file will be stopped in fileinfo.c</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//  If the user wants to delete on close, we must check at this</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//  point though.</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">//</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain" style="display: inline-block;">
</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">if (FlagOn(*DesiredAccess, FILE_WRITE_DATA) || DeleteOnClose) {</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain" style="display: inline-block;">
</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">    Fcb-&gt;OpenCount += 1;</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">    DecrementFcbOpenCount = TRUE;</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain" style="display: inline-block;">
</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">    if (!MmFlushImageSection( &amp;Fcb-&gt;NonPaged-&gt;SectionObjectPointers,</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">                              MmFlushForWrite )) {</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain" style="display: inline-block;">
</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">        Iosb.Status = DeleteOnClose ? STATUS_CANNOT_DELETE :</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">                                      STATUS_SHARING_VIOLATION;</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">        try_return( Iosb );</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">    }</span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">}</span></div></code></div></div></pre>
<p>Another way to think of this check is that <strong>ZwMapViewOfSection(SEC_IMAGE)</strong> implies no-write-sharing as long as the view exists.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="authenticode" class="absolute -top-32"></span>Authenticode</h2>
<p>The <a href="https://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/authenticode_pe.docx">Windows Authenticode Specification</a> describes a way to employ cryptography to “sign” PE files. A “digital signature” cryptographically attests that the PE was produced by a particular entity. Digital signatures are tamper-evident, meaning that any material modification of signed files should be detectable because the digital signature will no longer match. Digital signatures are typically appended to the end of PE files.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Authenticode specification diagram showing a signature embedded within a PE" loading="lazy" width="864" height="1024" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage19.png&amp;w=1920&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Authenticode specification diagram showing a signature embedded within a PE</figcaption></figure><p></p>
<p>Authenticode can’t apply traditional hashing (e.g. <strong>sha256sum</strong>) in this case, because the act of appending the signature would change the file’s hash, breaking the signature it just generated. Instead, the Authenticode specification describes an algorithm to skip specific portions of the PE file that will be changed during the signing process. This algorithm is called <strong>authentihash</strong>. You can use authentihash with any hashing algorithm, such as SHA256. When a PE file is digitally signed, the file’s authentihash is what’s actually signed.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="code-integrity" class="absolute -top-32"></span>Code integrity</h3>
<p>Windows has a few different ways to validate Authenticode signatures. User mode applications can call <a href="https://learn.microsoft.com/en-us/windows/win32/api/wintrust/nf-wintrust-winverifytrust"><strong>WinVerifyTrust</strong></a> to validate a file’s signature in user mode. The Code Integrity (CI) subsystem, residing in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ci.dll</code>,  validates signatures in the kernel. If <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/bringup/device-guard-and-credential-guard">Hypervisor-Protected Code Integrity</a> is running, the Secure Kernel employs <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">skci.dll</code> to validate Authenticode. This article will focus on Code Integrity (<code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ci.dll</code>) in the regular kernel.</p>
<p>Code Integrity provides both Kernel Mode Code Integrity and User Mode Code Integrity, each serving a different set of functions.</p>
<p>Kernel Mode Code Integrity (KMCI):</p>
<ul>
<li>Enforces <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/install/driver-signing">Driver Signing Enforcement</a> and the <a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/microsoft-recommended-driver-block-rules#microsoft-vulnerable-driver-blocklist">Vulnerable Driver Blocklist</a></li>
</ul>
<p>User Mode Code Integrity (UMCI):</p>
<ul>
<li>CI validates the signatures of EXEs and DLLs before allowing them to load</li>
<li>Enforces <a href="https://learn.microsoft.com/en-us/windows/security/threat-protection/overview-of-threat-mitigations-in-windows-10#protected-processes">Protected Processes and Protected Process Light</a> signature requirements</li>
<li>Enforces <strong>ProcessSignaturePolicy</strong> mitigation (<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy"><strong>SetProcessMitigationPolicy</strong></a>)</li>
<li>Enforces <a href="https://learn.microsoft.com/en-us/cpp/build/reference/integritycheck-require-signature-check?view=msvc-170">INTEGRITYCHECK</a> for <a href="https://x.com/GabrielLandau/status/1668353640833114131">FIPS 140-2 modules</a>.</li>
<li>Exposed to consumers as <a href="https://learn.microsoft.com/en-us/windows/apps/develop/smart-app-control/overview">Smart App Control</a></li>
<li>Exposed to businesses as <a href="https://learn.microsoft.com/en-us/mem/intune/protect/endpoint-security-app-control-policy">App Control for Business</a> (formerly WDAC)</li>
</ul>
<p>KMCI and UMCI implement different policies for different scenarios. For example, the policy for Protected Processes is different from that of INTEGRITYCHECK.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="incorrect-assumptions" class="absolute -top-32"></span>Incorrect assumptions</h2>
<p>Microsoft <a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">documentation</a> implies that files successfully opened without write sharing can’t be modified by another user or process.</p>
<pre><code>FILE_SHARE_WRITE
0x00000002
Enables subsequent open operations on a file or device to request write access. Otherwise, other processes cannot open the file or device if they request write access.</code></pre>
<p>If this flag is not specified, but the file or device has been opened for write access or has a file mapping with write access, the function fails.</p>
<p><em>Above, we discussed how sharing is enforced by the filesystem, but what if the filesystem doesn’t know that the file’s been modified?</em></p>
<p>Like most user mode memory, the Memory Manager (MM) in the kernel may page-out portions of file mappings when it deems necessary, such as when the system needs more free physical memory. Both data and executable image mappings may be paged-out. Executable image sections can never modify the backing file, so they’re effectively treated as read-only with respect to the backing PE file. As mentioned before, image sections are copy-on-write, meaning any in-memory changes immediately create a private copy of the given page.</p>
<p>When the memory manager needs to page-out a page from an image section, it can use the following decision tree:</p>
<ul>
<li>Never modified?  Discard it. We can read the contents back from the immutable file on disk.</li>
<li>Modified?  Save private copy it to the pagefile.<!-- -->
<ul>
<li>Example: If a security product hooks a function in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">ntdll.dll</code>, MM will create a private copy of each modified page. Upon page-out, private pages will be written to the pagefile.</li>
</ul>
</li>
</ul>
<p>If those paged-out pages are later touched, the CPU will issue a page fault and the MM will restore the pages.</p>
<ul>
<li>Page never modified?  Read the original contents back from the immutable file on disk.</li>
<li>Page private?  Read it from the pagefile.</li>
</ul>
<p>Note the following exception: The memory manager may treat PE-relocated pages as unmodified, dynamically reapplying relocations during page faults.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="page-hashes" class="absolute -top-32"></span>Page hashes</h3>
<p>Page hashes are a list of hashes of each 4KB page within a PE file. Since pages are 4KB, page faults typically occur on 4KB of data at a time. Full Authenticode verification requires the entire contiguous PE file, which isn’t available during a page fault. Page hashes allow the MM to validate hashes of individual pages during page faults.</p>
<p>There are two types of page hashes, which we’ve coined static and dynamic. Static page hashes are stored within a PE’s digital signature if the developer passes <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">/ph</code> to <a href="https://learn.microsoft.com/en-us/windows/win32/seccrypto/signtool"><code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">signtool</code></a>. By pre-computing these, they are immediately available to the MM and CI upon module load.</p>
<p>CI can also compute them on-the-fly during signature validation, a mechanism we’re calling dynamic page hashes. Dynamic page hashes give CI flexibility to enforce page hashes even for files that were never signed with them.</p>
<p>Page hashes are not free - they use CPU and slow down page faults. They’re not used in most cases.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="attacking-code-integrity" class="absolute -top-32"></span>Attacking code integrity</h2>
<p>Imagine a scenario where a ransomware operator wants to ransom a hospital, so they send a phishing email to a hospital employee. The employee opens the email attachment and enables macros, running the ransomware. The ransomware employs a UAC bypass to immediately elevate to admin, then attempts to terminate any security software on the system so it can operate unhindered. Anti-Malware services run as <a href="https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-">Protected Process Light</a> (PPL), protecting them from tampering by malware with admin rights, so the ransomware can’t terminate the Anti-Malware service.</p>
<p>If the ransomware could also run as a PPL, it could terminate the Anti-Malware product. The ransomware can’t launch itself directly as a PPL because UMCI prevents improperly-signed EXEs and DLLs from loading into PPL, as we discussed above. The ransomware might try to inject code into a PPL by modifying an EXE or DLL that’s already running, but the aforementioned <strong>MmFlushImageSection</strong> ensures in-use PE files remain immutable, so this isn’t possible.</p>
<p>We previously discussed how the filesystem is responsible for sharing checks. <em>What would happen if an attacker were to move the filesystem to another machine?</em></p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/what-is-a-network-redirector-">Network redirectors</a> allow the use of network paths with any API that accepts file paths. This is very convenient, allowing users and applications to easily open and memory-map files over the network. Any resulting I/O is transparently redirected to the remote machine. If a program is launched from a network drive, the executable images for the EXE and its DLLs will be transparently pulled from the network.</p>
<p>When a network redirector is in use, the server on the other end of the pipe needn’t be a Windows machine. It could be a Linux machine running <a href="https://en.wikipedia.org/wiki/Samba_(software)">Samba</a>, or even a python <a href="https://github.com/fortra/impacket/blob/d71f4662eaf12c006c2ea7f5ec09b418d9495806/examples/smbserver.py">impacket script</a> that “speaks” the <a href="https://learn.microsoft.com/en-us/windows-server/storage/file-server/file-server-smb-overview">SMB network protocol</a>. This means the server doesn’t have to honor Windows filesystem sharing semantics.</p>
<p>An attacker can employ a network redirector to modify a PPL’s DLL server-side, bypassing sharing restrictions. This means that PEs backing an executable image section are incorrectly assumed to be immutable. This is a class of vulnerability that we are calling <strong>False File Immutability</strong> (FFI).</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="paging-exploitation" class="absolute -top-32"></span>Paging exploitation</h3>
<p>If an attacker successfully exploits False File Immutability to inject code into an in-use PE, wouldn’t page hashes catch such an attack?  The answer is: sometimes. If we look at the following table, we can see that page hashes are enforced for kernel drivers and Protected Processes, but not for PPL, so let’s pretend we’re an attacker targeting PPL.</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th></th><th>Authenticode</th><th>Page hashes</th></tr></thead><tbody><tr><td>Kernel drivers</td><td>✅</td><td>✅</td></tr><tr><td>Protected Processes (PP-Full)</td><td>✅</td><td>✅</td></tr><tr><td>Protected Process Light (PPL)</td><td>✅</td><td>❌</td></tr></tbody></table></div>
<p>Last year at Black Hat Asia 2023 (<a href="https://www.blackhat.com/asia-23/briefings/schedule/#ppldump-is-dead-long-live-ppldump-31052">abstract</a>, <a href="http://i.blackhat.com/Asia-23/AS-23-Landau-PPLdump-Is-Dead-Long-Live-PPLdump.pdf">slides</a>, <a href="https://www.youtube.com/watch?v=5xteW8Tm410">recording</a>), we disclosed a vulnerability in the Windows kernel, showing how bad assumptions in paging can be exploited to inject code into PPL, defeating security features like <a href="https://learn.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection">LSA</a> &amp; <a href="https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-">Anti-Malware Process Protection</a>. The attack leveraged False File Immutability assumptions for DLLs in PPLs, as we just described, though we hadn’t yet named the vulnerability class.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="A diagram of the PPLFault exploit" loading="lazy" width="1334" height="563" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage5.png&amp;w=3840&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">A diagram of the PPLFault exploit</figcaption></figure><p></p>
<p>Alongside the presentation, we released the <a href="https://github.com/gabriellandau/PPLFault">PPLFault exploit</a> which demonstrates the vulnerability by dumping the memory of an otherwise-protected PPL. We also released the GodFault exploit chain, which combines the PPLFault Admin-to-PPL exploit with the AngryOrchard PPL-to-kernel exploit to achieve full read/write control of physical memory from user mode. We did this to motivate Microsoft to take action on a vulnerability that MSRC <a href="https://www.elastic.co/security-labs/forget-vulnerable-drivers-admin-is-all-you-need">declined to fix</a> because it did not meet their <a href="https://www.microsoft.com/en-us/msrc/windows-security-servicing-criteria">servicing criteria</a>. Thankfully, the Windows Defender team at Microsoft stepped up, <a href="https://x.com/GabrielLandau/status/1757818200127946922">releasing a fix</a> in February 2024 that enforces dynamic page hashes for executable images loaded over network redirectors, breaking PPLFault.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="new-research" class="absolute -top-32"></span>New research</h2>
<p>Above, we discussed Authenticode signatures embedded within PE files. In addition to embedded signatures, Windows supports a form of detached signature called a <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/install/catalog-files">security catalog</a>. Security catalogs (.cat files) are essentially a list of signed authentihashes. Every PE with an authentihash in that list is considered to be signed by that signer. Windows keeps a large collection of catalog files in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">C:\Windows\System32\CatRoot</code> which CI loads, validates, and caches.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Simplified structure of a security catalog" loading="lazy" width="1440" height="42" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage7.png&amp;w=3840&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Simplified structure of a security catalog</figcaption></figure><p></p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="A security catalog rendered through Windows Explorer" loading="lazy" width="810" height="511" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage21.png&amp;w=1920&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">A security catalog rendered through Windows Explorer</figcaption></figure><p></p>
<p>A typical Windows system has over a thousand catalog files, many containing dozens or hundreds of authentihashes.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Security catalogs on a Windows 11 23H2 system" loading="lazy" width="1012" height="502" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage16.png&amp;w=2048&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Security catalogs on a Windows 11 23H2 system</figcaption></figure><p></p>
<p>To use a security catalog, Code Integrity must first load it. This occurs in a few discrete steps. First, CI maps the file into kernel memory using <strong>ZwOpenFile</strong>, <strong>ZwCreateSection</strong>, and <strong>ZwMapViewOfSection</strong>. Once mapped, it validates the catalog’s digital signature using <strong>CI!MinCrypK_VerifySignedDataKModeEx</strong>. If the signature is valid, it parses the hashes with <strong>CI!I_MapFileHashes</strong>.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="The Code Integrity catalog parsing process" loading="lazy" width="1000" height="402" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage10.png&amp;w=2048&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">The Code Integrity catalog parsing process</figcaption></figure><p></p>
<p>Breaking this down, we see a few key insights. First, <strong>ZwCreateSection(SEC_COMMIT)</strong> tells us that CI is creating a data section, not an image section. This is important because there is no concept of page hashes for data sections.</p>
<p>Next, the file is opened without <strong>FILE_SHARE_WRITE</strong>, meaning write sharing is denied. This is intended to prevent modification of the security catalog during processing. However, as we have shown above, this is a bad assumption and another example of False File Immutability. It should be possible, in theory, to perform a PPLFault-style attack on security catalog processing.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="planning-the-attack" class="absolute -top-32"></span>Planning the attack</h3>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="" loading="lazy" width="1440" height="738" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage11.png&amp;w=3840&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"></figure><p></p>
<p>The general flow of the attack is as follows:</p>
<ol>
<li>The attacker will plant a security catalog on a storage device that they control. They will install a symbolic link to this catalog in the <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">CatRoot</code> directory, so Windows knows where to find it.</li>
<li>The attacker asks the kernel to load a malicious unsigned kernel driver.</li>
<li>Code Integrity attempts to validate the driver, but it can’t find a signature or trusted authentihash, so it re-scans the CatRoot directory and finds the attacker’s new catalog.</li>
<li>CI maps the catalog into kernel memory and validates its signature. This generates page faults which are sent to the attacker’s storage device. The storage device returns a legitimate Microsoft-signed catalog.</li>
<li>The attacker empties the system working set, forcing all the previously-fetched catalog pages to be discarded.</li>
<li>CI begins parsing the catalog, generating new page faults. This time, the storage device injects the authentihash of their malicious driver.</li>
<li>CI finds the malicious driver’s authentihash in the catalog and loads the driver. At this point, the attacker has achieved arbitrary code execution in the kernel.</li>
</ol>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="implementation-and-considerations" class="absolute -top-32"></span>Implementation and considerations</h3>
<p>The plan is to use a PPLFault-style attack, but there are some important differences in this situation. PPLFault used an <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/opportunistic-locks">opportunistic lock</a> (oplock) to deterministically freeze the victim process’s initialization. This gave the attacker time to switch over to the payload and flush the system working set. Unfortunately, we couldn’t find any good opportunities for oplocks here. Instead, we’re going to pursue a probabilistic approach: rapidly toggling the security catalog between the malicious and benign versions.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="The catalog being toggled between benign and malicious versions; only one hash changes" loading="lazy" width="1051" height="763" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage12.png&amp;w=3840&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">The catalog being toggled between benign and malicious versions; only one hash changes</figcaption></figure><p></p>
<p>The verification step touches every page of the catalog, which means all of those pages will be resident in memory when parsing begins. If the attacker changes the catalog on their storage device, it won’t be reflected in memory until after a subsequent page fault. To evict these pages from kernel memory, the attacker must empty the working set between <strong>MinCrypK_VerifySignedDataKModeEx</strong> and <strong>I_MapFileHashes</strong>.</p>
<p>This approach is inherently a race condition. There’s no built-in delays between signature verification and catalog parsing - it’s a tight race. We’ll need to employ several techniques to widen our window of opportunity.</p>
<p>Most security catalogs on the system are small, a few kilobytes. By choosing a large 4MB catalog, we can greatly increase the amount of time that CI spends parsing. Assuming catalog parsing is linear, we can choose an authentihash near the end of the catalog to maximize the time between signature verification and when CI reaches our tampered page. Further, we will create threads for each CPU on the system whose sole purpose is to consume CPU cycles. These threads run at higher priority than CI, so CI will be starved of CPU time. There will be one thread dedicated to repeatedly flushing pages from the system’s working set, and one thread repeatedly attempting to load the unsigned driver.</p>
<p>This attack has two main failure modes. First, if the payload Authentihash is read during the signature check, then the signature will be invalid and the catalog will be rejected.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Code Integrity rejecting a tampered security catalog" loading="lazy" width="1440" height="85" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage17.png&amp;w=3840&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Code Integrity rejecting a tampered security catalog</figcaption></figure><p></p>
<p>Next, if an even number of toggles occur (including zero) between signature validation and parsing, then CI will parse the benign hash and reject our driver.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Passing the signature check, but the benign catalog is parsed" loading="lazy" width="1113" height="257" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage6.png&amp;w=3840&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Passing the signature check, but the benign catalog is parsed</figcaption></figure><p></p>
<p>The attacker wins if CI validates a benign catalog then parses a malicious one.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Code Integrity validating a benign catalog, then parsing a malicious one" loading="lazy" width="1112" height="271" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage20.png&amp;w=3840&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Code Integrity validating a benign catalog, then parsing a malicious one</figcaption></figure><p></p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="exploit-demo" class="absolute -top-32"></span>Exploit demo</h3>
<p>We named the exploit <strong>ItsNotASecurityBoundary</strong> as an homage to MSRC's <a href="https://www.microsoft.com/en-us/msrc/windows-security-servicing-criteria">policy</a> that "Administrator-to-kernel is not a security boundary.”  The code is in GitHub <a href="https://github.com/gabriellandau/ItsNotASecurityBoundary">here</a>.</p>
<p>Demo video <a href="https://drive.google.com/file/d/13Uw38ZrNeYwfoIuD76qlLgyXP8kRc8Nz/view?usp=sharing">here</a>.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="understanding-these-vulnerabilities" class="absolute -top-32"></span>Understanding these vulnerabilities</h2>
<p>In order to properly defend against these vulnerabilities, we first need to understand them better.</p>
<p>A double-read (aka double-fetch) vulnerability can occur when victim code reads the same value out of an attacker-controlled buffer more than once. The attacker may change the value of this buffer between the reads, resulting in unexpected victim behavior.</p>
<p>Imagine there is a page of memory shared between two processes for an IPC mechanism. The client and server send data back and forth using the following struct. To send an IPC request, a client first writes a request struct into the shared memory page, then signals an event to notify the server of a pending request.</p>
<pre><div class="p-0 pr-8 relative -my-3 -mx-4"><button class="absolute right-2 z-10 top-2 opacity-60 hover:opacity-100 transition-opacity cursor-pointer text-white p-1" title="Copy code block"><svg class="w-4 h-4" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"></path></svg></button><div class="overflow-auto px-4 py-3"><code class="prism-code language-c relative" style="color: rgb(156, 220, 254); background-color: rgb(30, 30, 30);"><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token keyword" style="color: rgb(86, 156, 214);">struct</span><span class="token plain"> </span><span class="token class-name" style="color: rgb(78, 201, 176);">IPC_PACKET</span><span class="token plain"></span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain"></span><span class="token punctuation" style="color: rgb(212, 212, 212);">{</span><span class="token plain"></span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">    SIZE_T length</span><span class="token punctuation" style="color: rgb(212, 212, 212);">;</span><span class="token plain"></span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain">    UCHAR data</span><span class="token punctuation" style="color: rgb(212, 212, 212);">[</span><span class="token punctuation" style="color: rgb(212, 212, 212);">]</span><span class="token punctuation" style="color: rgb(212, 212, 212);">;</span><span class="token plain"></span></div><div class="token-line" style="color: rgb(156, 220, 254);"><span class="token plain"></span><span class="token punctuation" style="color: rgb(212, 212, 212);">}</span><span class="token punctuation" style="color: rgb(212, 212, 212);">;</span></div></code></div></div></pre>
<p>A double-read attack could look something like this:</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="An example of a double-read exploit using shared memory" loading="lazy" width="1137" height="557" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage18.png&amp;w=3840&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">An example of a double-read exploit using shared memory</figcaption></figure><p></p>
<p>First, the attacking client sets a packet’s structure’s length field to 16 bytes, then signals the server to indicate that a packet is ready for processing.  The victim server wakes up and allocates a 16-byte buffer using <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">malloc(pPacket-&gt;length)</code>.  Immediately afterwards, the attacker changes the length field to 32.  Next, the victim server attempts to copy the packet’s contents into the the new buffer by calling <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">memcpy(pBuffer, pPacket-&gt;data, pPacket-&gt;length)</code>, re-reading the value in <code class="px-1.5 py-1 rounded not-prose bg-[var(--tw-prose-invert-pre-bg)] whitespace-break-spaces text-[85%] text-emerald-600">pPacket-&gt;length</code>, which is now 32.  The victim ends up copying 32 bytes into a 16-byte buffer, overflowing it.</p>
<p>Double-read vulnerabilities frequently apply to shared-memory scenarios. They commonly occur in drivers that operate on user-writable buffers. Due to False File Immutability, developers need to be aware that their scope is actually much wider, and includes all files writable by attackers. Denying write sharing does not necessarily prevent file modification.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="affected-operations" class="absolute -top-32"></span>Affected Operations</h3>
<p>What types of operations are affected by False File Immutability?</p>
<div class="table-container"><table style="width:100%;table-layout:fixed;word-wrap:break-word"><thead><tr><th>Operation</th><th>API</th><th>Mitigations</th></tr></thead><tbody><tr><td>Image Sections</td><td><strong>CreateProcess</strong> <strong>LoadLibrary</strong></td><td>1. Enable Page Hashes</td></tr><tr><td>Data Sections</td><td><strong>MapViewOfFile</strong> <strong>ZwMapViewOfSection</strong></td><td>1. Avoid double reads\ 2. Copy the file to a heap buffer before processing\ 3. Prevent paging via MmProbeAndLockPages/VirtualLock</td></tr><tr><td>Regular I/O</td><td><strong>ReadFile</strong> <strong>ZwReadFile</strong></td><td>1. Avoid double reads\  2. Copy the file to a heap buffer before processing</td></tr></tbody></table></div>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="what-else-could-be-vulnerable" class="absolute -top-32"></span>What else could be vulnerable?</h3>
<p>Looking for potentially-vulnerable calls to <strong>ZwMapViewOfSection</strong> in the NT kernel yields quite a few interesting functions:</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Potentially-vulnerable uses of ZwMapViewOfSection within the NT kernel" loading="lazy" width="710" height="485" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage8.png&amp;w=1920&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Potentially-vulnerable uses of ZwMapViewOfSection within the NT kernel</figcaption></figure><p></p>
<p>If we expand our search to regular file I/O, we find even more candidates. An important caveat, however, is that <strong>ZwReadFile</strong> may be used for more than just files. Only uses on files (or those which could be coerced into operating on files) could be vulnerable.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Potentially-vulnerable uses of ZwReadFile within the NT kernel" loading="lazy" width="711" height="520" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage14.png&amp;w=1920&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Potentially-vulnerable uses of ZwReadFile within the NT kernel</figcaption></figure><p></p>
<p>Looking outside of the NT kernel, we can find other drivers to investigate:</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Potentially-vulnerable uses of ZwReadFile in Windows 11 kernel drivers" loading="lazy" width="579" height="606" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage2.png&amp;w=1200&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Potentially-vulnerable uses of ZwReadFile in Windows 11 kernel drivers</figcaption></figure><p></p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Potentially-vulnerable uses of ZwMapViewOfSection in Windows 11 kernel drivers" loading="lazy" width="651" height="340" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage1.png&amp;w=1920&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Potentially-vulnerable uses of ZwMapViewOfSection in Windows 11 kernel drivers</figcaption></figure><p></p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="dont-forget-about-user-mode" class="absolute -top-32"></span>Don’t forget about user mode</h3>
<p>We’ve mostly been discussing the kernel up to this point, but it’s important to note that any user mode application that calls <strong>ReadFile</strong>, <strong>MapViewOfFile</strong>, or <strong>LoadLibrary</strong> on an attacker-controllable file, denying write sharing for immutability, may be vulnerable. Here’s a few hypothetical examples.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="mapviewoffile" class="absolute -top-32"></span>MapViewOfFile</h4>
<p>Imagine an application that is split into two components - a low-privileged worker process with network access, and a privileged service that installs updates. The worker downloads updates and stages them to a specific folder. When the privileged service sees a new update staged, it first validates the signature before installing the update. An attacker could abuse FFI to modify the update after the signature check.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="readfile" class="absolute -top-32"></span>ReadFile</h4>
<p>Since files are subject to double-read vulnerabilities, anything that parses complex file formats may be vulnerable, including antivirus engines and search indexers.</p>
<h4 class="font-bold leading-tight text-lg md:text-2xl relative"><span id="loadlibrary" class="absolute -top-32"></span>LoadLibrary</h4>
<p>Some applications rely on UMCI to prevent attackers from loading malicious DLLs into their processes. As we’ve shown with PPLFault, FFI can defeat UMCI.</p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="stopping-the-exploit" class="absolute -top-32"></span>Stopping the exploit</h2>
<p>Per their official servicing guidelines, MSRC won’t service Admin -&gt; Kernel vulnerabilities by default. In this parlance, servicing means “fix via security update.”  This type of vulnerability, however, allows malware to bypass <a href="https://learn.microsoft.com/en-us/windows/win32/services/protecting-anti-malware-services-">AV Process Protections</a>, leaving AV and EDR vulnerable to instant-kill attacks.</p>
<p>As a third-party, we can’t patch Code Integrity, so what can we do to protect our customers? To mitigate <strong>ItsNotASecurityBoundary</strong>, we created <strong>FineButWeCanStillEasilyStopIt</strong>, a filesystem minifilter driver that prevents Code Integrity from opening security catalogs over network redirectors. You can find it on GitHub <a href="https://github.com/gabriellandau/ItsNotASecurityBoundary/tree/main/FineButWeCanStillEasilyStopIt">here</a>.</p>
<p>FineButWeCanStillEasilyStopIt has to jump through some hoops to correctly identify the problematic behavior while minimizing false positives. Ideally, CI itself could be fixed with a few small changes. Let’s look at what that would take.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Fixing catalog processing by copying the catalog to the heap" loading="lazy" width="1000" height="494" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage13.png&amp;w=2048&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Fixing catalog processing by copying the catalog to the heap</figcaption></figure><p></p>
<p>As mentioned above in the Affected Operations section, applications can mitigate double-read vulnerabilities by copying the file contents out of the file mapping into the heap, and exclusively using that heap copy for all subsequent operations. The kernel heap is called the <a href="https://learn.microsoft.com/en-us/windows/win32/memory/memory-pools">pool</a>, and the corresponding allocation function is <strong>ExAllocatePool</strong>.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Fixing catalog processing by locking the pages into RAM" loading="lazy" width="1000" height="493" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage15.png&amp;w=2048&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Fixing catalog processing by locking the pages into RAM</figcaption></figure><p></p>
<p>An alternative mitigation strategy to break these types of exploits is to pin the pages of the file mapping into physical memory using an API such as <strong>MmProbeAndLockPages</strong>. This prevents eviction of those pages when the attacker empties the working set.</p>
<h3 class="font-bold leading-tight text-xl md:text-3xl relative"><span id="end-user-detection-and-mitigation" class="absolute -top-32"></span>End-user detection and mitigation</h3>
<p>Fortunately, there is a way for end-users to mitigate this exploit without changes from Microsoft – Hypervisor Protected Code Integrity (HVCI). If HVCI is enabled, CI.dll doesn’t do catalog parsing at all. Instead, it sends the catalog contents to the Secure Kernel, which runs in a separate virtual machine on the same host. The Secure Kernel stores the received catalog contents in its own heap, from which signature validation and parsing are performed. Just like with the <strong>ExAllocatePool</strong> mitigation described above, the exploit is mitigated because file changes have no effect on the heap copy.</p>
<p>The probabilistic nature of this attack means that there are likely many failed attempts. Windows records these failures in the <strong>Microsoft-Windows-CodeIntegrity/Operational</strong> event log. Users can check this log for evidence of exploitation.</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Microsoft-Windows-CodeIntegrity/Operational event log showing an invalid driver signature" loading="lazy" width="626" height="438" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage23.png&amp;w=1920&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Microsoft-Windows-CodeIntegrity/Operational event log showing an invalid driver signature</figcaption></figure><p></p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="Microsoft-Windows-CodeIntegrity/Operational event log showing an invalid security catalog" loading="lazy" width="626" height="438" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage4.png&amp;w=1920&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">Microsoft-Windows-CodeIntegrity/Operational event log showing an invalid security catalog</figcaption></figure><p></p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="disclosure" class="absolute -top-32"></span>Disclosure</h2>
<p>The disclosure timeline is as follows:</p>
<ul>
<li>2024-02-14: We reported ItsNotASecurityBoundary and FineButWeCanStillEasilyStopIt to MSRC as VULN-119340, suggesting <strong>ExAllocatePool</strong> and <strong>MmProbeAndLockPages</strong> as simple low-risk fixes</li>
<li>2024-02-29: The Windows Defender team reached out to coordinate disclosure</li>
<li>2024-04-23: Microsoft releases <a href="https://support.microsoft.com/en-us/topic/april-23-2024-kb5036980-os-builds-22621-3527-and-22631-3527-preview-5a0d6c49-e42e-4eb4-8541-33a7139281ed">KB5036980</a> Preview with the <strong>MmProbeAndLockPages</strong> fix</li>
<li>2024-05-14: Fix reaches GA for Windows 11 23H2 as <a href="https://support.microsoft.com/en-us/topic/may-14-2024-kb5037771-os-builds-22621-3593-and-22631-3593-e633ff2f-a021-4abb-bd2e-7f3687f166fe">KB5037771</a>; we have not tested any other platforms (Win10, Server, etc).</li>
<li>2024-06-14: MSRC closed the case, stating "We have completed our investigation and determined that the case doesn't meet our bar for servicing at this time. As a result, we have opened a next-version candidate bug for the issue, and it will be evaluated for upcoming releases. Thanks, again, for sharing this report with us."</li>
</ul>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="fixing-code-integrity" class="absolute -top-32"></span>Fixing Code Integrity</h2>
<p>Looking at the original implementation of <strong>CI!I_MapAndSizeDataFile</strong>, we can see the legacy code calling <strong>ZwCreateSection</strong> and <strong>ZwMapViewOfSection</strong>:</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="The vulnerable CI!I_MapAndSizeDataFile implementation" loading="lazy" width="682" height="556" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage22.png&amp;w=1920&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">The vulnerable CI!I_MapAndSizeDataFile implementation</figcaption></figure><p></p>
<p>Contrast that with the new <strong>CI!CipMapAndSizeDataFileWithMDL</strong>, which follows that up with <strong>MmProbeAndLockPages</strong>:</p>
<p></p><figure style="display: flex; flex-direction: column; align-items: center;"><img alt="The new CI!CipMapAndSizeDataFileWithMDL has a mitigation" loading="lazy" width="394" height="501" decoding="async" data-nimg="1" class="cursor-zoom-in" src="https://www.elastic.co/security-labs/_next/image?url=%2Fsecurity-labs%2Fassets%2Fimages%2Ffalse-file-immutability%2Fimage3.png&amp;w=828&amp;q=90" style="color: transparent; object-fit: contain; position: relative;"><figcaption style="color: lightgray; font-style: italic;">The new CI!CipMapAndSizeDataFileWithMDL has a mitigation</figcaption></figure><p></p>
<h2 class="font-bold text-2xl md:text-4xl relative"><span id="summary-and-conclusion" class="absolute -top-32"></span>Summary and conclusion</h2>
<p>Today we discussed and named a bug class: <strong>False File Immutability</strong>. We are aware of two public exploits that leverage it, PPLFault and ItsNotASecurityBoundary.</p>
<p><a href="https://github.com/gabriellandau/PPLFault">PPLFault</a>: Admin -&gt; PPL [-&gt; Kernel via GodFault]</p>
<ul>
<li>Exploits bad immutability assumptions about image section in CI/MM</li>
<li>Reported September 2022</li>
<li>Patched February 2024 (~510 days later)</li>
</ul>
<p><a href="https://github.com/gabriellandau/ItsNotASecurityBoundary">ItsNotASecurityBoundary</a>: Admin -&gt; Kernel</p>
<ul>
<li>Exploits bad immutability assumptions about data sections in CI</li>
<li>Reported February 2024</li>
<li>Patched May 2024 (~90 days later)</li>
</ul>
<p>If you are writing Windows code that operates on files, you need to be aware of the fact these files may be modified while you are working on them, even if you deny write sharing. See the Affected Operations section above for guidance on how to protect yourselves and your customers against these types of attacks.</p>
<p>ItsNotASecurityBoundary is not the end of FFI. There are other exploitable FFI vulnerabilities out there. My colleagues and I at Elastic Security Labs will continue exploring and reporting on FFI and beyond. We encourage you to follow along on X <a href="https://x.com/GabrielLandau">@GabrielLandau</a> and <a href="https://x.com/elasticseclabs">@ElasticSecLabs</a>.</p></div></div></div><div class="hidden lg:flex lg:col-span-1 text-sm lg:flex-col lg:space-y-6"><div class="toc"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Jump to section</h4><ul class="flex flex-col space-y-2"><li><a class="flex items-center space-x-1 hover:text-white" href="https://www.elastic.co/security-labs/false-file-immutability#introduction"><span>Introduction</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="https://www.elastic.co/security-labs/false-file-immutability#windows-file-sharing"><span>Windows file&nbsp;sharing</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="https://www.elastic.co/security-labs/false-file-immutability#sharing-enforcement"><span>Sharing&nbsp;enforcement</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="https://www.elastic.co/security-labs/false-file-immutability#authenticode"><span>Authenticode</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="https://www.elastic.co/security-labs/false-file-immutability#code-integrity"><span>Code&nbsp;integrity</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="https://www.elastic.co/security-labs/false-file-immutability#incorrect-assumptions"><span>Incorrect&nbsp;assumptions</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="https://www.elastic.co/security-labs/false-file-immutability#page-hashes"><span>Page&nbsp;hashes</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="https://www.elastic.co/security-labs/false-file-immutability#attacking-code-integrity"><span>Attacking code&nbsp;integrity</span></a></li><li><a class="flex items-center space-x-1 hover:text-white ml-4" href="https://www.elastic.co/security-labs/false-file-immutability#paging-exploitation"><span>Paging&nbsp;exploitation</span></a></li><li><a class="flex items-center space-x-1 hover:text-white" href="https://www.elastic.co/security-labs/false-file-immutability#new-research"><span>New&nbsp;research</span></a></li></ul><button class="border-t border-white/20 w-full mt-3 py-2 flex items-center space-x-1 text-xs font-medium uppercase tracking-wide hover:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="w-3 h-3"><path d="M10.75 4.75a.75.75 0 00-1.5 0v4.5h-4.5a.75.75 0 000 1.5h4.5v4.5a.75.75 0 001.5 0v-4.5h4.5a.75.75 0 000-1.5h-4.5v-4.5z"></path></svg><span>Show more</span></button></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl"><h4 class="font-bold leading-tight text-lg md:text-2xl mb-3">Elastic Security Labs&nbsp;Newsletter</h4><div><a target="_blank" class="button inline-flex" href="https://www.elastic.co/elastic-security-labs/newsletter?utm_source=security-labs">Sign Up</a></div></div></div></div><div class="bg-zinc-900 border border-zinc-800 drop-shadow-lg p-5 md:p-2 sm:p-4 md:px-6 md:py-4 rounded-xl my-5 md:my-10 max-w-3xl mx-auto flex flex-col items-center shadow-2xl"><h4 class="font-bold leading-tight text-lg md:text-2xl">Share this article</h4><div class="flex flex-wrap items-center justify-center mt-4 space-x-4"><a class="flex items-center space-x-2 button" href="https://twitter.com/intent/tweet?text=Introducing%20a%20New%20Vulnerability%20Class:%20False%20File%20Immutability&amp;url=https://www.elastic.co/security-labs/false-file-immutability" target="_blank" rel="noopener noreferrer" aria-label="Share this article on X" title="Share this article on X"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M23.954 4.569c-.885.389-1.83.653-2.825.772a4.98 4.98 0 002.187-2.746 9.955 9.955 0 01-3.157 1.204 4.98 4.98 0 00-8.49 4.54A14.128 14.128 0 011.69 3.05a4.98 4.98 0 001.54 6.638A4.94 4.94 0 011.2 8.62v.06a4.98 4.98 0 004 4.87 4.94 4.94 0 01-2.24.086 4.98 4.98 0 004.64 3.45A9.97 9.97 0 010 20.35a14.075 14.075 0 007.59 2.22c9.16 0 14.17-7.583 14.17-14.17 0-.217-.005-.434-.015-.65a10.128 10.128 0 002.485-2.58l-.001-.001z"></path></svg><span>X</span></a><a class="flex items-center space-x-2 button" href="https://www.facebook.com/sharer/sharer.php?u=https://www.elastic.co/security-labs/false-file-immutability" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Facebook" title="Share this article on Facebook"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M22.5 12c0-5.799-4.701-10.5-10.5-10.5S1.5 6.201 1.5 12c0 5.301 3.901 9.699 9 10.401V14.4h-2.7v-2.7h2.7v-2.1c0-2.7 1.8-4.2 4.2-4.2 1.2 0 2.1.1 2.4.2v2.4h-1.5c-1.2 0-1.5.6-1.5 1.5v1.8h3l-.3 2.7h-2.7V22C18.599 21.3 22.5 17.301 22.5 12z"></path></svg><span>Facebook</span></a><a class="flex items-center space-x-2 button" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://www.elastic.co/security-labs/false-file-immutability&amp;title=Introducing%20a%20New%20Vulnerability%20Class:%20False%20File%20Immutability" target="_blank" rel="noopener noreferrer" aria-label="Share this article on LinkedIn" title="Share this article on LinkedIn"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill="currentColor" d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"></path></svg><span>LinkedIn</span></a><a class="flex items-center space-x-2 button" href="https://reddit.com/submit?url=https://www.elastic.co/security-labs/false-file-immutability&amp;title=Introducing%20a%20New%20Vulnerability%20Class:%20False%20File%20Immutability" target="_blank" rel="noopener noreferrer" aria-label="Share this article on Reddit" title="Share this article on Reddit"><svg class="w-4 h-4" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM19.6879 11.0584C19.8819 11.3352 19.9916 11.6622 20.004 12C20.0091 12.3306 19.9205 12.656 19.7485 12.9384C19.5765 13.2208 19.3281 13.4488 19.032 13.596C19.0455 13.7717 19.0455 13.9483 19.032 14.124C19.032 16.812 15.9 18.996 12.036 18.996C8.172 18.996 5.04 16.812 5.04 14.124C5.02649 13.9483 5.02649 13.7717 5.04 13.596C4.80919 13.49 4.6042 13.335 4.43923 13.1419C4.27427 12.9487 4.15327 12.722 4.08462 12.4775C4.01598 12.2329 4.00133 11.9764 4.04169 11.7256C4.08205 11.4748 4.17646 11.2358 4.31837 11.0251C4.46028 10.8145 4.6463 10.6372 4.86354 10.5056C5.08078 10.3739 5.32404 10.2911 5.57646 10.2629C5.82889 10.2346 6.08444 10.2616 6.32541 10.3419C6.56638 10.4222 6.78701 10.5539 6.972 10.728C8.35473 9.79023 9.98146 9.27718 11.652 9.252L12.54 5.088C12.55 5.03979 12.5694 4.99405 12.5972 4.95341C12.625 4.91277 12.6605 4.87805 12.7018 4.85127C12.7431 4.82448 12.7894 4.80615 12.8378 4.79735C12.8862 4.78855 12.9359 4.78945 12.984 4.8L15.924 5.388C16.0676 5.14132 16.2944 4.9539 16.5637 4.85937C16.833 4.76484 17.1272 4.7694 17.3934 4.87222C17.6597 4.97505 17.8806 5.1694 18.0164 5.42041C18.1523 5.67141 18.1942 5.96262 18.1348 6.24177C18.0753 6.52092 17.9182 6.76972 17.6918 6.94352C17.4654 7.11732 17.1845 7.20473 16.8995 7.19006C16.6144 7.1754 16.3439 7.05962 16.1366 6.8635C15.9292 6.66738 15.7985 6.40378 15.768 6.12L13.2 5.58L12.42 9.324C14.0702 9.3594 15.6749 9.87206 17.04 10.8C17.2839 10.566 17.5902 10.4074 17.9221 10.3436C18.254 10.2797 18.5973 10.3132 18.9106 10.4401C19.2239 10.5669 19.4939 10.7817 19.6879 11.0584ZM8.20624 12.5333C8.07438 12.7307 8.004 12.9627 8.004 13.2C8.004 13.5183 8.13043 13.8235 8.35547 14.0485C8.58051 14.2736 8.88574 14.4 9.204 14.4C9.44134 14.4 9.67335 14.3296 9.87068 14.1978C10.068 14.0659 10.2218 13.8785 10.3127 13.6592C10.4035 13.4399 10.4272 13.1987 10.3809 12.9659C10.3346 12.7331 10.2204 12.5193 10.0525 12.3515C9.8847 12.1836 9.67089 12.0694 9.43811 12.0231C9.20533 11.9768 8.96405 12.0005 8.74478 12.0913C8.52551 12.1822 8.33809 12.336 8.20624 12.5333ZM12.012 17.424C13.0771 17.4681 14.1246 17.1416 14.976 16.5V16.548C15.0075 16.5173 15.0327 16.4806 15.05 16.4402C15.0674 16.3997 15.0766 16.3563 15.0772 16.3122C15.0777 16.2682 15.0696 16.2245 15.0533 16.1837C15.0369 16.1428 15.0127 16.1055 14.982 16.074C14.9513 16.0425 14.9146 16.0173 14.8742 16C14.8337 15.9826 14.7903 15.9734 14.7462 15.9728C14.7022 15.9723 14.6585 15.9804 14.6177 15.9967C14.5768 16.0131 14.5395 16.0373 14.508 16.068C13.7797 16.5904 12.895 16.8487 12 16.8C11.1061 16.8399 10.2255 16.5732 9.504 16.044C9.44182 15.993 9.36289 15.9669 9.28256 15.9708C9.20222 15.9748 9.12622 16.0085 9.06935 16.0653C9.01247 16.1222 8.97879 16.1982 8.97484 16.2786C8.97089 16.3589 8.99697 16.4378 9.048 16.5C9.89937 17.1416 10.9469 17.4681 12.012 17.424ZM14.0933 14.2458C14.2907 14.3776 14.5227 14.448 14.76 14.448L14.748 14.496C14.9107 14.4978 15.0721 14.4664 15.2223 14.4038C15.3725 14.3413 15.5084 14.2488 15.6218 14.1321C15.7352 14.0154 15.8236 13.8768 15.8818 13.7248C15.9399 13.5728 15.9665 13.4106 15.96 13.248C15.96 13.0107 15.8896 12.7787 15.7578 12.5813C15.6259 12.384 15.4385 12.2302 15.2192 12.1393C14.9999 12.0485 14.7587 12.0248 14.5259 12.0711C14.2931 12.1174 14.0793 12.2316 13.9115 12.3995C13.7436 12.5673 13.6294 12.7811 13.5831 13.0139C13.5368 13.2467 13.5605 13.4879 13.6513 13.7072C13.7422 13.9265 13.896 14.1139 14.0933 14.2458Z" fill="currentColor"></path></svg><span>Reddit</span></a></div></div></article></main></main></div><next-route-announcer><p aria-live="assertive" id="__next-route-announcer__" role="alert" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; top: 0px; width: 1px; white-space: nowrap; overflow-wrap: normal;"></p></next-route-announcer></body></html>