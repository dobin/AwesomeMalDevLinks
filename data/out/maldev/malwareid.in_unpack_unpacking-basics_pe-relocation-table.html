# http://malwareid.in/unpack/unpacking-basics/pe-relocation-table

<!DOCTYPE html><html lang="en">
	<body class="optimize-text pa2">

		<svg style="position: absolute; width: 0; height: 0; overflow: hidden" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
			<defs>
				<symbol id="icon-user" viewBox="0 0 20 28">
					<path d="M20 21.859c0 2.281-1.5 4.141-3.328 4.141h-13.344c-1.828 0-3.328-1.859-3.328-4.141 0-4.109 1.016-8.859 5.109-8.859 1.266 1.234 2.984 2 4.891 2s3.625-0.766 4.891-2c4.094 0 5.109 4.75 5.109 8.859zM16 8c0 3.313-2.688 6-6 6s-6-2.688-6-6 2.688-6 6-6 6 2.688 6 6z"></path>
				</symbol>
				<symbol id="icon-pencil" viewBox="0 0 32 32">
					<path d="M27 0c2.761 0 5 2.239 5 5 0 1.126-0.372 2.164-1 3l-2 2-7-7 2-2c0.836-0.628 1.874-1 3-1zM2 23l-2 9 9-2 18.5-18.5-7-7-18.5 18.5zM22.362 11.362l-14 14-1.724-1.724 14-14 1.724 1.724z"></path>
				</symbol>
				<symbol id="icon-printer" viewBox="0 0 32 32">
					<path d="M8 2h16v4h-16v-4z"></path>
					<path d="M30 8h-28c-1.1 0-2 0.9-2 2v10c0 1.1 0.9 2 2 2h6v8h16v-8h6c1.1 0 2-0.9 2-2v-10c0-1.1-0.9-2-2-2zM4 14c-1.105 0-2-0.895-2-2s0.895-2 2-2 2 0.895 2 2-0.895 2-2 2zM22 28h-12v-10h12v10z"></path>
				</symbol>
			</defs>
		</svg>

		
		
			
		
<main class="file w-100 pb5 bl br bb">

	<div class="w-100 center grid-container">

		

		<div class="grid-main ph3 ph4-l pv3 lh-copy f4-l f5 fw3">

			

			<article>
				

				
<figure class="center"><img src="https://malwareid.in/unpack/media/live/screen-shot-2023-10-26-124421-am.jpeg" alt="" loading="lazy" width="300" height="198"></figure>
<p>The Portable Executable (PE) base relocation table is crucial in Windows executable files. It handles memory addresses for functions and data, making sure the program runs well no matter where it's loaded in memory.</p>
<p>For malware analysis, the PE base relocation table is vital. When we study suspicious files, malicious software often tries to hide by changing memory addresses. The base relocation table helps us catch these changes. By checking this table, we can find clues about tampering, helping us understand what the malware is up to. So, knowing the PE base relocation table is a big part of figuring out how malware works, and it helps us defend against it.</p>
<p>I this I will go thought the relocation table in depth and also provide with some tools to parse and manipulate PE files via relocation table </p>
<h2 id="h-so-what-are-pe-relocations">So what are PE relocations ?</h2>
<p>In order to understand relocation, we need to grasp a basic memory management concept in Windows. The main executable in a program is a fragmented part of the whole program. It also includes other parts known as DLLs, which are loadable modules. For the program to work correctly, the main executable and the required DLLs must be loaded into virtual memory.</p>
<figure><img src="https://malwareid.in/unpack/media/live/virtualaddressspace02.png" alt="" loading="lazy"></figure>
<p>In a 64-bit Windows operating system, the user space virtual memory typically spans from <code>0x0000000000000000</code> to <code>0x00007FFFFFFFFFFF</code> in hexadecimal notation. This is equivalent to a range of 0 to <code>140,737,488,355,327</code> in decimal notation, covering a vast address space of 128 terabytes (TB).</p>
<p>In a 32-bit Windows operating system, the user space virtual memory typically spans from <code>0x00000000</code> to <code>0x7FFFFFFF</code> in hexadecimal notation. This is equivalent to a range of 0 to 2,147,483,647 in decimal notation, covering a total of 2 gigabytes (GB) of addressable memory space</p>
<figure><img src="https://malwareid.in/unpack/media/live/img-d6f2b3185f91-1.jpeg" alt="" loading="lazy"></figure>
<p>The variable <code>Relocation</code> will always be hardcoded with the base address as <code>ImageBase</code>. So, if <code>ImageBase</code> is at <code>0x4000000</code>, and the <code>.CODE</code> section happens to be loaded at <code>0x1000</code> relative to the base, then the variable will be located at <code>0x4001000</code> whenever it is used. This is in contrast to stack variables, which are always addressed using the relative offset of <code>EBP/RBP</code> stack pointer or <code>RCX/RDX/R8/R9</code> (for 64-bit).</p>
<blockquote>
<p>However, a crucial question arises: what happens if the <code>ImageBase</code> is not available or is already occupied by another image loaded at the same address?</p>
</blockquote>
<p>In such a scenario, Windows provides a mechanism known as image base relocations. In this case, the <code>.reloc</code> section of the binary (which could possibly have any other name as well) contains the information necessary for relocation to occur. During relocation, all the hard-coded addresses used will be relocated to the new image base where the image was loaded.</p>
<p>This is particularly useful for malware, as with process injection techniques, malware binaries often get a randomly allocated memory region from which they have to relocate the binary further. So, this is a very important topic to cover for malware unpacking.</p>
<p>Let's see how the relocation table looks when compiled on a 32-bit Windows system.</p>
<figure><img src="https://malwareid.in/unpack/media/live/screen-shot-2023-10-24-21720-pm.png" alt="" loading="lazy"></figure>
<p>A relocation entry has one entry with one block and a slot count of 4. Slots refer to the number of similar relocations on the same page.</p>
<p>According to online documentation, Base Image relocations are represented in a structure as follows:</p>
<pre class="hljs-copy-wrapper" style="--hljs-theme-background: rgb(221, 221, 221);"><code class="language-c hljs"><table class="hljs-ln"><tbody><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="1"><div class="hljs-ln-n" data-line-number="1"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="1">  <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_BASE_RELOCATION</span> {</span></td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="2"><div class="hljs-ln-n" data-line-number="2"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="2">      DWORD VirtualAddress;</td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="3"><div class="hljs-ln-n" data-line-number="3"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="3">      DWORD SizeOfBlock;</td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="4"><div class="hljs-ln-n" data-line-number="4"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="4">      WORD TypeOffset[];</td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="5"><div class="hljs-ln-n" data-line-number="5"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="5">    } IMAGE_BASE_RELOCATION;</td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="6"><div class="hljs-ln-n" data-line-number="6"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="6">    <span class="hljs-keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED *PIMAGE_BASE_RELOCATION;</td></tr></tbody></table></code><button class="hljs-copy-button" data-copied="false">Copy</button></pre>
<p><code>TypeOffset</code> is a variable size array base on the (<code>SizeOfBlock</code> - <code>IMAGE_SIZEOF_BASE_RELOCATION</code> )</p>
<p>looking at the .reloc binary we find the following hex data </p>
<blockquote>
<p>As the program was compiled without any libc requirements, that's why the relocation section is so small. The /nodefaultlib parameter was used to keep the content concise.</p>
</blockquote>
<p><code>00 10 00 00 10 00 00 00 10 30 1E 30 24 30 38 30</code></p>
<p>To put this binary block into perspective, we will map it with the structure above</p>
<div class="tm-table"><table>
<thead>
<tr>
<th>Virtual Address</th>
<th>Size of Block</th>
<th>Type Offset</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00001000</td>
<td>0x00000010</td>
<td>1E30 2430 3830</td>
</tr>
</tbody>
</table></div>
<p>size of block is <code>0x10</code> bytes , this includes the structure itself </p>
<p>The absolute address where the relocation needs to happen can be obtained using the combination of <code>VirtualAddress</code> and extracting the offset from the <code>TypeOffset</code> field.</p>
<figure class="center"><img src="https://malwareid.in/unpack/media/live/img-d5d781ea6003-1.jpeg" alt="" loading="lazy" width="300" height="319"></figure>
<blockquote>
<p>There isn't much documentation available about the actual process of parsing the relocation table. It is mostly an opaque structure with a plethora of relocation entry types.</p>
</blockquote>
<pre class="hljs-copy-wrapper" style="--hljs-theme-background: rgb(221, 221, 221);"><code class="language-c hljs"><table class="hljs-ln"><tbody><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="1"><div class="hljs-ln-n" data-line-number="1"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="1"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_ABSOLUTE 0</span></td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="2"><div class="hljs-ln-n" data-line-number="2"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="2"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_HIGH 1</span></td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="3"><div class="hljs-ln-n" data-line-number="3"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="3"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_LOW 2</span></td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="4"><div class="hljs-ln-n" data-line-number="4"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="4"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_HIGHLOW 3</span></td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="5"><div class="hljs-ln-n" data-line-number="5"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="5"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_HIGHADJ 4</span></td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="6"><div class="hljs-ln-n" data-line-number="6"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="6"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_MIPS_JMPADDR 5</span></td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="7"><div class="hljs-ln-n" data-line-number="7"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="7"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_ARM_MOV32 5</span></td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="8"><div class="hljs-ln-n" data-line-number="8"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="8"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_THUMB_MOV32 7</span></td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="9"><div class="hljs-ln-n" data-line-number="9"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="9"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_MIPS_JMPADDR16 9</span></td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="10"><div class="hljs-ln-n" data-line-number="10"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="10"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_IA64_IMM64 9</span></td></tr><tr><td class="hljs-ln-line hljs-ln-numbers" data-line-number="11"><div class="hljs-ln-n" data-line-number="11"></div></td><td class="hljs-ln-line hljs-ln-code" data-line-number="11"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_REL_BASED_DIR64 10</span></td></tr></tbody></table></code><button class="hljs-copy-button" data-copied="false">Copy</button></pre>
<p>How each of them actually processes the relocation is not documented. Let's take the challenging path and reverse-engineer the kernel to figure out how these types of relocations are processed.</p>
<p>A text search for <code>RelocateImage</code> yields the following function where the image relocation is precisely processed.</p>
<figure><img src="https://malwareid.in/unpack/media/live/screen-shot-2023-10-24-91717-pm.png" alt="" loading="lazy"><figcaption>So the function where this takes place in the kernel happens to be <code>LdrRelocateImageWithBias()</code> . </figcaption>
</figure>
<figure class="center"><img src="https://malwareid.in/unpack/media/live/screen-shot-2023-10-24-92321-pm.png" alt="" loading="lazy" width="620" height="482"></figure>
<p>As we see in the <code>LdrProcessRelocationBlockLongLong()</code>, quite interestingly, the code also processes the ARM processor instruction set, i.e., ARM v7 and AArch32/64. I believe it is precisely there because of the support for x64 emulation on Windows ARM OS (<a href="https://blogs.windows.com/windows-insider/2020/12/10/introducing-x64-emulation-in-preview-for-Windows-10-on-ARM-PCs-to-the-Windows-Insider-program/">https://blogs.windows.com/windows-insider/2020/12/10/introducing-x64-emulation-in-preview-for-Windows-10-on-ARM-PCs-to-the-Windows-Insider-program/</a>).</p>
<figure><img src="https://malwareid.in/unpack/media/live/screen-shot-2023-10-24-94711-pm.png" alt="" loading="lazy"></figure>
<p>It functions similarly to the WOW64 Layer, but it operates by translation or emulation.</p>
<p>Two functions responsible for this behavior are:</p>
<ul>
<li><code>LdrpThumbProcessRelocation()</code></li>
<li><code>LdrpArmProcessRelocation()</code></li>
</ul>
<p>For generic x86 and x64, <code>LdrpGenericProcessRelocation()</code> is used. To trigger the relocation block, <code>LdrpThumbProcessRelocation()</code> or <code>LdrpArmProcessRelocation()</code>, <code>TypeOffset</code> is checked against the following parameters:</p>
<figure class="center"><img src="https://malwareid.in/unpack/media/live/img-c47ac7b3fe7d-1.jpeg" alt="" loading="lazy" width="580" height="543"></figure>
<p><code>NtHeader.Machine</code> is compared against following values </p>
<ul>
<li>IMAGE_FILE_MACHINE_ARM </li>
<li>IMAGE_FILE_MACHINE_ARMV7 </li>
<li>IMAGE_FILE_MACHINE_ARM64</li>
</ul>
<h2>And for X86/X64 following reloc types are supported </h2>
<ul>
<li>IMAGE_REL_BASED_HIGH</li>
<li>IMAGE_REL_BASED_LOW</li>
<li>IMAGE_REL_BASED_HIGHLOW</li>
<li>IMAGE_REL_BASED_HIGHADJ</li>
<li>
<h2>IMAGE_REL_BASED_DIR64</h2>
<h2 id="h-image-rel-based-high">IMAGE_REL_BASED_HIGH</h2>
</li>
</ul>
<p><code>IMAGE_REL_BASED_HIGH</code> is an x86 relocation type. In <code>IMAGE_REL_BASED_HIGH</code>, the higher part, in terms of linear access, is modified by changing the lower two bytes of the address with the <code>delta</code>. The <code>delta</code> represents the scalar difference between the new base and the referenced base.</p>
<figure class="center"><img src="https://malwareid.in/unpack/media/live/img-39137b9dbce0-1.jpeg" alt="" loading="lazy" width="300" height="360"><figcaption>---</figcaption>
</figure>
<h2 id="h-image-rel-based-low">IMAGE_REL_BASED_LOW</h2>
<p><code>IMAGE_REL_BASED_LOW</code> is a relocation type for x86. In this type, the lower half of the <code>delta</code> is added to the location of the relocation.</p>
<pre><code class="language-asm">mov     ax, word ptr [ebp+Delta] (delta Lower)
add     [esi], ax
</code></pre>
<p>For 64bit </p>
<pre><code class="language-asm">add     [r9], r8w ; Delta (lower)</code></pre>
<figure class="center"><img src="https://malwareid.in/unpack/media/live/img-e6d60c28affc-1.jpeg" alt="" loading="lazy" width="300" height="292"><figcaption>---</figcaption>
</figure>
<h2 id="h-image-rel-based-highlow">IMAGE_REL_BASED_HIGHLOW</h2>
<p><code>IMAGE_REL_BASED_HIGHLOW</code> is a relocation type used in both x86 and x64. In this type, a simple <code>delta</code> is added to the location. This addition may affect the higher half of a 64-bit address, which is why it is considered for both 64-bit and 32-bit platforms.</p>
<pre><code class="language-asm">add     [r9], r8d</code></pre>
<figure class="center"><img src="https://malwareid.in/unpack/media/live/img-d5d781ea6003-1-1.jpeg" alt="" loading="lazy" width="300" height="319"><figcaption>---</figcaption>
</figure>
<h2 id="h-image-rel-based-highadj">IMAGE_REL_BASED_HIGHADJ</h2>
<p><code>IMAGE_REL_BASED_HIGHADJ</code> is a more complex relocation type. This type occupies two slots, meaning that two <code>TypeOffset</code> elements are used to process it.</p>
<p>The process involves:</p>
<ol>
<li>Adding the lower bits at the relocation to <code>Delta</code>.</li>
<li>Adding the lower half with sign extension from the second slot.</li>
<li>Adding this value to <code>Delta</code> again.</li>
<li>Finally, adjusting the lower half back to the relocation.</li>
</ol>
<figure class="center"><img src="https://malwareid.in/unpack/media/live/img-5a62708afca3-1.jpeg" alt="" loading="lazy" width="300" height="374"></figure>
<hr>

					
					<div class="f5 pv1 flex justify-between">
						<div class="byline">
																						<adress class="pr2"> Raashid Bhat</adress>
													</div>
						<div class="funcicons">
																				</div>
					</div>
				
			</article>

			
				
					<div id="bottompager" class="f5 pv5 flex-l flex-m justify-between BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif">
													
																			
											</div>

							
			
			
		</div>

		

	</div>

</main>	
		
			
		
	


<div class="w-100 center f6">
			<p><a href="https://malwareid.in/unpack/unpacking-basics/twitter.com/malwareid_"> MalwareID </a></p>
	</div>
		
			
			
			
			
			






		
		
	

</body></html>