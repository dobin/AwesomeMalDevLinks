Title:
Hells Gate Rust – EDR Evasion with Syscalls

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post covers implementing the “Hell’s Gate” direct-syscall technique in Rust to bypass user-mode EDR hooks that commonly patch NTDLL stubs.  
- It focuses on resolving syscall numbers at runtime and invoking Windows syscalls directly (rather than calling hooked WinAPI/NTAPI exports), reducing visibility to user-mode API monitoring.  
- The write-up is positioned as offensive development content and is part of a broader Rust-on-Windows series that includes injection and other evasion primitives.  
- It is most useful for red teamers, pentesters doing tradecraft R&D, and malware developers building Rust implants/loaders on Windows.  
- It’s interesting because it demonstrates modern Windows evasion tradecraft in Rust, where many public examples are still C/C++, and highlights the fragility/version-dependence of syscall interfaces.

Technical Focus:
- Direct syscalls / Hell’s Gate technique
- NTDLL syscall stub parsing and hook bypass
- Runtime syscall number resolution
- Rust FFI to Windows (NTAPI) and low-level calling conventions
- User-mode EDR hooking evasion

Use Cases:
- Building Rust-based loaders/implants that avoid user-mode API hooks
- Researching and validating EDR user-mode syscall-hooking coverage
- Creating PoCs for direct-syscall execution paths (e.g., memory allocation, thread creation)
- Developing detection ideas around anomalous syscall invocation patterns

Keywords:
Hell’s Gate, direct syscall, Windows syscalls, NTDLL, NTAPI, user-mode hooking, EDR evasion, syscall stub, syscall number, runtime resolution, Rust FFI, calling convention, inline assembly, Zw/Nt functions, Windows internals, implant development, loader, anti-hooking, red team tradecraft