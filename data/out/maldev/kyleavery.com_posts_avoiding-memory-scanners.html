# https://kyleavery.com/posts/avoiding-memory-scanners/

<!DOCTYPE html><html data-beasties-container="" lang="en-US" class="light" data-theme="light"><body data-centered="true" style="max-width:45rem;--content-width:45rem" data-copy-code="enabled"><div class="layout-wrapper" id="transition-wrapper" data-astro-transition-scope="astro-3aq4ytkg-1"><div class="post-container" data-astro-cid-gjtny2mx=""><main data-astro-cid-gjtny2mx=""><div class="prose" data-astro-cid-gjtny2mx=""><div class="gradient-mask" data-astro-cid-5gze4ep5="" style="opacity: 0;"></div><a href="https://kyleavery.com/" class="back-button fixed-position" data-astro-cid-cjjlykpo="" style="left: 383.5px;"><svg data-astro-cid-cjjlykpo="" fill="none" height="16" viewBox="0 0 16 16" width="16" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 6.5H9.5C11.1569 6.5 12.5 7.84315 12.5 9.5V9.5C12.5 11.1569 11.1569 12.5 9.5 12.5H7.5M2.5 6.5L5.5 9.5M2.5 6.5L5.5 3.5" data-astro-cid-cjjlykpo="" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.25"></path></svg> index</a><div class="toc-container fixed-position" id="toc" style="display: block; left: 383.5px;"></div><div class="title" data-astro-cid-gjtny2mx=""><h1 data-astro-cid-gjtny2mx="">Avoiding Memory Scanners</h1><div class="date" data-astro-cid-gjtny2mx=""><time class="" data-astro-cid-5mzstg4p="" datetime="2022-09-09T00:00:00.000Z"><span class="month">September</span> 9, 2022</time></div></div><p>Mirrored from <a href="https://www.blackhillsinfosec.com/avoiding-memory-scanners/">BHIS</a>.</p><h1 id="introduction">Introduction</h1><p>This post complements a <a href="https://www.youtube.com/watch?v=edIMUcxCueA">presentation</a> I gave at DEF CON 30 - “Avoiding Memory Scanners: Customizing Malware to Evade YARA, PE-sieve, and More” which included the public release of a new tool called <a href="https://github.com/kyleavery/AceLdr">AceLdr</a>. The slides for this presentation are available on the <a href="https://media.defcon.org/DEF%20CON%2030/DEF%20CON%2030%20presentations/Kyle%20Avery%20-%20Avoiding%20Memory%20Scanners%20Customizing%20Malware%20to%20Evade%20YARA%20PE-sieve%20and%20More.pdf">conference website</a>.</p><p>As open-source tools and commercial security products improve their ability to scan process memory for malware on Windows, red teams are forced to improve their tradecraft to evade them consistently.</p><p>Typically, beaconing C2 implants follow a common paradigm in which the malware executes an instruction and then sleeps for a period. This process presents a set of opportunities for detection and evasion, which this post aims to detail.</p><h1 id="memory-scanner-capabilities">Memory Scanner Capabilities</h1><p>Open-source memory scanners have varying features that can be defined into the following categories.</p><h2 id="pattern-matching">Pattern Matching</h2><p>Signature or pattern matching may be the most recognized feature of memory scanners and commercial security products. A prime example of this technique is <a href="https://github.com/VirusTotal/yara">YARA</a>. YARA can perform string and byte pattern matching with conditional logic. For example, consider the following example rule:</p><pre class="copy-code-block" data-language="js" style="background-color:var(--astro-code-background);color:var(--astro-code-foreground);overflow-x:auto" tabindex="0"><button aria-label="Copy code" class="copy-button" type="button" style="opacity: 0; pointer-events: none;">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="14" height="14" fill="currentColor">
        <path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path>
        <path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path>
      </svg>
    </button><code><span class="line"><span style="color:var(--astro-code-foreground)">rule Example</span></span>
<span class="line"><span style="color:var(--astro-code-foreground)">{</span></span>
<span class="line"><span style="color:var(--astro-code-foreground)">  strings</span><span style="color:var(--astro-code-token-punctuation)">:</span></span>
<span class="line"><span style="color:var(--astro-code-foreground)">    $a </span><span style="color:var(--astro-code-token-keyword)">=</span><span style="color:var(--astro-code-token-string-expression)"> "This program cannot"</span><span style="color:var(--astro-code-foreground)"> xor</span></span>
<span class="line"><span style="color:var(--astro-code-foreground)">    $b </span><span style="color:var(--astro-code-token-keyword)">=</span><span style="color:var(--astro-code-foreground)"> { </span><span style="color:var(--astro-code-token-constant)">41</span><span style="color:var(--astro-code-token-constant)"> 42</span><span style="color:var(--astro-code-foreground)"> ( </span><span style="color:var(--astro-code-token-constant)">43</span><span style="color:var(--astro-code-foreground)"> | </span><span style="color:var(--astro-code-token-constant)">44</span><span style="color:var(--astro-code-foreground)"> ) ?? </span><span style="color:var(--astro-code-token-constant)">46</span><span style="color:var(--astro-code-foreground)"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:var(--astro-code-foreground)">  condition</span><span style="color:var(--astro-code-token-punctuation)">:</span></span>
<span class="line"><span style="color:var(--astro-code-foreground)">    $a or $bsa</span></span>
<span class="line"><span style="color:var(--astro-code-foreground)">}</span></span></code></pre><p>In this rule, the target must contain one of the following to match:</p><ul><li>The string “This program cannot” or any single-byte XOR encrypted variation.</li><li>The bytes 41 and 42, either 43 or 44, any single byte, and 46.</li></ul><p>This simple example should provide a good picture of what is possible with YARA. Anything from simple string or byte patterns to relatively complex combinations of these primitives can be defined.</p><p>Since YARA scans all memory allocated by a target process, many projects build off YARA to create more efficient scanners with specific goals. For example, <a href="https://github.com/CCob/BeaconEye">BeaconEye</a> only scans heap memory in search of Cobalt Strike configuration structures which are dynamically allocated at initialization.</p><p>Commercial security products like AV and EDR are also known to use YARA. Namely, <a href="https://developer.carbonblack.com/reference/enterprise-response/connectors/cb-yara-connector/">Carbon Black</a> and <a href="https://www.crowdstrike.com/products/threat-intelligence/falcon-x-automated-intelligence/">CrowdStrike</a> explicitly mention using YARA, and other vendors will likely use it.</p><p>A quick Google search can find many YARA rules for Cobalt Strike. For example, the following demonstration scans two cmd.exe processes with a set of rules targeting Cobalt Strike: one benign and one injected with an implant.</p><figure class="image-caption-wrapper"><img alt="Detecting Cobalt Strike with YARA" src="https://kyleavery.com/assets/avoiding_memory_scanners_1.Bfag1e7-_ZzS061.webp" class="" data-preview="true" decoding="async" fetchpriority="high" height="450" loading="lazy" width="800" style="cursor: zoom-in;"><figcaption class="img-caption">Detecting Cobalt Strike with YARA</figcaption></figure><h2 id="memory-attributes">Memory Attributes</h2><p>Attributes of memory such as permissions and mapping information can also be used to identify potentially malicious code. Memory can be readable, writeable, or executable and mapped as image commit or private commit data. Memory is “image commit” if it was created by loading a file from disk such as an EXE or DLL. Memory is “private commit” if the process dynamically allocated it through API calls such as VirtualAlloc.</p><p><a href="https://github.com/forrest-orr/moneta">Moneta</a> scans memory pages to look for both executable and private commit memory. All code must be executable, but code on Windows tends to be loaded from disk. Executable private memory occurs legitimately in JIT environments such as the .NET runtime or web browsers. Additionally, Moneta will check the start address of all threads for private commit memory addresses. This check is simple enough to evade since the start address of a thread is not changed after creation. A new thread with an image commit start address can be created in a suspended state, modified to execute the target shellcode, and resumed.</p><p><a href="https://github.com/hasherezade/pe-sieve">PE-sieve</a> will scan executable, non-executable, or inaccessible memory for patterns that typically occur in shellcode, depending on the usage. In addition, PE-sieve will check the return address of all threads for private commit memory addresses.</p><figure class="image-caption-wrapper"><img alt="Detecting Cobalt Strike with Moneta and PE-sieve" src="https://kyleavery.com/assets/avoiding_memory_scanners_2.DovJ3ReL_Z1QuOyd.webp" class="img-placeholder" data-preview="true" decoding="async" fetchpriority="high" height="450" loading="lazy" width="800" style="cursor: zoom-in;"><figcaption class="img-caption">Detecting Cobalt Strike with Moneta and PE-sieve</figcaption></figure><h2 id="stack-tracing">Stack Tracing</h2><p>Finally, more recent memory scanners have introduced tracing of thread call stacks to identify potentially malicious code. Tools like <a href="https://github.com/3lp4tr0n/BeaconHunter">BeaconHunter</a> and <a href="https://github.com/thefLink/Hunt-Sleeping-Beacons">Hunt-Sleeping-Beacons</a> operate on a simple premise: identify any thread with a wait reason of “DelayExecution”. Since Cobalt Strike and many other implants use the Sleep API call, this method can reliably detect malware implants. Unfortunately, there are often many false positives associated with the technique.</p><p>Since the initial release of AceLdr, Hunt-Sleeping-Beacons has been updated with a new method to detect FOLIAGE (more on this in the next section). The scanner now looks for threads with a wait reason of “UserRequest” which also have a return address to KiUserApcDispatcher somewhere on their call stack. This will be covered in further detail below.</p><p>An interesting variation of stack tracing can be found in <a href="https://github.com/waldo-irc/MalMemDetect">MalMemDetect</a>. This scanner hooks API calls such as RtlAllocateHeap to check the return address at execution time. When Beacon calls one of these APIs, the return address on the stack will point to the implant shellcode, which resides in private commit memory.</p><figure class="image-caption-wrapper"><img alt="Detecting Cobalt Strike with MalMemDetect" src="https://kyleavery.com/assets/avoiding_memory_scanners_3.CNTtJE9w_xFqvn.webp" class="img-placeholder" data-preview="true" decoding="async" fetchpriority="high" height="450" loading="lazy" width="800" style="cursor: zoom-in;"><figcaption class="img-caption">Detecting Cobalt Strike with MalMemDetect</figcaption></figure><p>The tools discussed above have capabilities outside this post’s scope. I’d recommend looking through the code of each scanner if you’re interested in learning more.</p><h1 id="bypassing-memory-scanners">Bypassing Memory Scanners</h1><p>Developers can take advantage of their C2 implant’s sleep period to implement protections that obfuscate the malware to reduce the likelihood that a scanner will detect it. The longer an implant’s sleep time, the less likely it will be found by scanners evaded by said protections.</p><p>A bypass in the context of this post does not generate false positives. It is not meant to confuse analysts or blend in with existing results. A true bypass results in zero results from a memory scanner before and after an implant is injected.</p><h2 id="encrypting-data">Encrypting Data</h2><p>The first technique that comes to mind for encrypting data is often single-byte XOR. Single-byte XOR is conveniently easy to implement, doesn’t require API calls, and runs relatively quickly. Unfortunately, tools like YARA and PE-sieve realized this and found ways to detect this encryption method with ease.</p><p>An alternative solution might implement functions that perform multi-byte XOR, AES, or RC4. However, it will become apparent in the following sections that this is not a viable option either. To completely evade scanners like Moneta, which search for any executable private memory, the code used for encrypting data must reside in image commit memory.</p><p>You can perform AES encryption using Windows APIs, but it requires a combination of multiple API calls to encrypt and decrypt data. An excellent solution for this problem is hinted at in <a href="https://github.com/gentilkiwi/mimikatz/blob/e10bde5b16b747dc09ca5146f93f2beaf74dd17a/modules/kull_m_crypto_system.h#L97">Mimikatz</a>. The author implements SystemFunction032: a system function that can be resolved from advapi32.dll to perform RC4 encryption and decryption. This API call accepts two arguments that contain the target memory and a key, allowing us to dynamically generate a key and encrypt data without executing code in private commit memory. Technically, SystemFunction032 is for encryption, and SystemFunction033 is for decryption. The RC4 cipher is bidirectional, though, so you can use either API for encryption or decryption.</p><h2 id="heap-encryption">Heap Encryption</h2><p>Now that we’ve identified a method of encrypting data, we must decide which data should be encrypted. The beginning of this post referenced BeaconEye, a tool that scans dynamically allocated memory for Cobalt Strike configuration data structures.</p><p>Heap encryption is probably best performed in one of two ways:</p><ul><li>Tracking heap entries created by Beacon</li><li>Utilizing a secondary heap for Beacon’s allocations</li></ul><p>The official <a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/artifacts-antivirus_sleep-mask-kit.htm">Sleep Mask Kit</a> from Cobalt Strike provides a list of memory addresses for encryption. Their solution is clean, but it requires the use of Sleep Mask Kit, which, as described in the following section, prevents us from bypassing some scanners.</p><p>Last year, I released a <a href="https://github.com/kyleavery/TitanLdr/tree/heapencrypt">fork of TitanLdr</a>, which creates a new heap before Beacon is loaded. The GetProcessHeap API is hooked in the implant’s IAT to force it to resolve that heap when resolving the process heap to allocate memory. This allows us to encrypt all entries on the secondary heap since only the implant should use it. The following demonstration uses this fork to bypass BeaconEye.</p><figure class="image-caption-wrapper"><img alt="Avoiding BeaconEye" src="https://kyleavery.com/assets/avoiding_memory_scanners_4.DwkRO0JG_275R7t.webp" class="img-placeholder" data-preview="true" decoding="async" fetchpriority="high" height="450" loading="lazy" width="800" style="cursor: zoom-in;"><figcaption class="img-caption">Avoiding BeaconEye</figcaption></figure><h2 id="obfuscating-executable-code">Obfuscating Executable Code</h2><p>Consistently bypassing tools like Moneta and PE-sieve requires a combination of encryption to evade pattern matching and memory permission control to evade attribute scanning.</p><h3 id="executable-masking-stub">Executable Masking Stub</h3><p>An executable stub such as that used in Sleep Mask Kit or <a href="https://github.com/mgeeky/ShellcodeFluctuation">Shellcode Fluctuation</a> can encrypt the implant code at rest and make it non-executable. Both examples require at least one executable region to remain unchanged, though. There will always be at least one point of detection from scanners using the “masking stub” technique, and YARA rules can be created to detect the stub itself.</p><h3 id="return-oriented-programming-rop">Return Oriented Programming (ROP)</h3><p>The <a href="https://github.com/JLospinoso/gargoyle">Gargoyle</a> PoC influenced the creation of the other techniques discussed in this section. The author used asynchronous procedure calls to queue and execute a series of ROP gadgets that run while the initiating code is non-executable.</p><p>Gargoyle is only provided for 32-bit Windows, and the PoC only executes a message box. Earlier this year, Waldo-irc released <a href="https://github.com/waldo-irc/YouMayPasser">YouMayPasser</a>: a 64-bit implementation of Gargoyle, ready to use with Cobalt Strike.</p><h3 id="redirecting-execution-with-contexts">Redirecting Execution with Contexts</h3><p>Gargoyle and YouMayPasser achieve our goal of changing the implant code to non-executable. Still, they suffer the same issues as many ROP exploits: different versions of Windows require modifications to the gadget offsets. There are ways to solve this problem, but they can introduce significant complexity.</p><p>Inspired by Gargoyle, Austin Hudson released <a href="https://github.com/SecIdiot/FOLIAGE">FOLIAGE</a>: an alternative to traditional ROP, which uses the NtContinue API call to control execution during sleep. NtContinue is typically used in error handling to restore the execution context of a thread. It accepts a new context as the single argument and modifies the current thread to use this context. A context structure specifies values for CPU registers, including the instruction pointer, so it can redirect execution to a specified address. FOLIAGE queues a series of APCs which execute NtContinue to switch contexts repeatedly. A new context structure is used for each of the following steps in a chain that obfuscates the implant.</p><ol><li>Waits on a new event to keep the thread from exiting</li><li>Changes the implant memory to be non-executable</li><li>Instructs the KsecDD driver to encrypt the implant memory</li><li>Saves the context of the original thread</li><li>Sets the context of the original thread to a fake context (more on this later)</li><li>Sleeps for the specified time with NtDelayExecution</li><li>Instructs the KsecDD driver to decrypt the implant memory</li><li>Restores the original thread context</li><li>Changes the implant memory to be executable</li><li>Exits the new thread</li></ol><p>This process can be further examined by reviewing <a href="https://github.com/SecIdiot/FOLIAGE/blob/master/source/sleep.c#L217-L512">lines 217-512 of sleep.c</a> in FOLIAGE.</p><p>A couple of months ago, C5pider claimed to have reversed <a href="https://www.mdsec.co.uk/nighthawk/">MDSec NightHawk</a> to create <a href="https://github.com/Cracked5pider/Ekko">Ekko</a>: an alternative to FOLIAGE which uses CreateTimerQueueTimer instead of NtQueueApcThread to queue calls to NtContinue.</p><p>The following demonstration uses FOLIAGE to bypass Moneta and PE-sieve.</p><figure class="image-caption-wrapper"><img alt="Avoiding Moneta and PE-sieve" src="https://kyleavery.com/assets/avoiding_memory_scanners_5.p3LKZx88_ZFx2Td.webp" class="img-placeholder" data-preview="true" decoding="async" fetchpriority="high" height="450" loading="lazy" width="800" style="cursor: zoom-in;"><figcaption class="img-caption">Avoiding Moneta and PE-sieve</figcaption></figure><p>NtContinue is not the only API call that forcefully changes execution with context structures. It conveniently requires only one argument, but there are also viable alternatives.</p><h2 id="avoiding-sleep">Avoiding Sleep</h2><p>Tools like BeaconHunter and Hunt-Sleeping-Beacons alert on threads with a wait reason of “DelayExecution”. This detection can be easily evaded using an alternative method of delaying execution which does not set this wait reason. WaitForSingleObject is an API that fits this requirement and sets a wait reason of “UserRequest”. The following demonstration replaces the Sleep API call with WaitForSingleObject to bypass these tools.</p><figure class="image-caption-wrapper"><img alt="Avoiding Hunt-Sleeping-Beacons" src="https://kyleavery.com/assets/avoiding_memory_scanners_6.KR2NbL0d_ZDcrC4.webp" class="img-placeholder" data-preview="true" decoding="async" fetchpriority="high" height="450" loading="lazy" width="800" style="cursor: zoom-in;"><figcaption class="img-caption">Avoiding Hunt-Sleeping-Beacons</figcaption></figure><h2 id="return-address-spoofing">Return Address Spoofing</h2><p>Spoofing the return address involves modifying the call stack return address, so it does not point to private commit memory. This section can be split into two distinct techniques: at rest and execution return address spoofing.</p><h3 id="spoofing-at-rest">Spoofing at Rest</h3><p>The term “at rest” refers to the implant during sleep. Most of the techniques discussed so far focus on this time as well. Commercial security products do not appear to be scanning the thread call stacks at rest, but open-source scanners such as PE-sieve will check return addresses when scanning.</p><p>This detection is partially evaded using a technique such as <a href="https://github.com/mgeeky/ThreadStackSpoofer">ThreadStackSpoofer</a>. This PoC hides the return address by overwriting it with zero, effectively truncating the stack. Then, Depending on the state of the stack, this technique may leak arguments onto the stack. These arguments may resemble memory addresses to create an indicator for scanners that inspect return addresses.</p><p>A more stable technique is demonstrated in FOLIAGE. The author uses NtSetContextThread to overwrite the original thread’s context with a manufactured context that sets the desired return address. The usage of NtSetContextThread is relatively rare and may be a point of detection. The author had not observed open-source scanners or commercial security products raising alerts on this behavior at the time of release.</p><h3 id="spoofing-at-execution">Spoofing at Execution</h3><p>The other time a thread’s call stack may be captured is “at execution”. This is demonstrated most clearly in MalMemDetect, as described above. Our return address must point to image commit memory when we make hooked API calls to evade tools like this.</p><p>The <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/268039-x64-return-address-spoofing-source-explanation.html">x64 Return Address Spoofing</a> PoC accomplishes this nicely. A ROP gadget from a loaded DLL is stored as the return address before the API call is made, which jumps to a stub that restores the context necessary to continue execution.</p><figure class="image-caption-wrapper"><img alt="Avoiding MalMemDetect" src="https://kyleavery.com/assets/avoiding_memory_scanners_7.D1tXfYTW_25huIl.webp" class="img-placeholder" data-preview="true" decoding="async" fetchpriority="high" height="450" loading="lazy" width="800" style="cursor: zoom-in;"><figcaption class="img-caption">Avoiding MalMemDetect</figcaption></figure><p>Since the release of AceLdr, Hunt-Sleeping-Beacons has been updated to detect FOLIAGE. The scanner will now check all threads with a wait reason of “UserRequest” which also have a return address to KiUserApcDispatcher somewhere on their call stack. This cannot be easily bypassed with the public implementation of FOLIAGE as it requires call stack spoofing of API calls in the sleep chain at execution. Since FOLIAGE is obfuscating the shellcode used for return address spoofing, it cannot be called by the APC thread to spoof return addresses.</p><h1 id="aceldr">AceLdr</h1><p>As a part of this research, I released an implementation of the previously discussed techniques called AceLdr. This tool is a user defined reflective loader (UDRL) for Cobalt Strike with the following features at the time of release.</p><ul><li>Bypasses every referenced scanner</li><li>Easy to use - import a single CNA script</li><li>Encryption using SystemFunction032</li><li>Dynamic memory encryption using a secondary heap</li><li>Code obfuscation and encryption using FOLIAGE</li><li>Delayed execution using WaitForSingleObject</li><li>Return address spoofing at execution for InternetConnectA, NtWaitForSingleObject, and RtlAllocateHeap</li></ul><p>Black Hills Information Security used this tool for approximately one year before releasing it publicly. Below is a demonstration of AceLdr bypassing several memory scanners.</p><figure class="image-caption-wrapper"><img alt="Avoiding Memory Scanners with AceLdr" src="https://kyleavery.com/assets/avoiding_memory_scanners_8.C9GwqoqR_Z2toAhG.webp" class="img-placeholder" data-preview="true" decoding="async" fetchpriority="high" height="450" loading="lazy" width="800" style="cursor: zoom-in;"><figcaption class="img-caption">Avoiding Memory Scanners with AceLdr</figcaption></figure><h1 id="closing-thoughts">Closing Thoughts</h1><p>While AceLdr is made explicitly for Cobalt Strike, the techniques demonstrated in this post can be easily ported to many other projects. Each method presented here bypasses existing scanners. However, this does not guarantee they will evade future implementations, as we’ve already seen with Hunt-Sleeping-Beacons.</p><p>Memory scanners and commercial security products are not the same, but they share many characteristics. For example, evading open-source scanners does not guarantee security product evasion. In addition, security product evasion often does not require a complete memory scanner bypass since system resources and development costs limit vendors.</p><h2 id="credits">Credits</h2><ul><li><a href="https://github.com/SecIdiot/FOLIAGE">FOLIAGE</a></li><li><a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/268039-x64-return-address-spoofing-source-explanation.html">x64 Return Address Spoofing</a></li><li><a href="https://github.com/waldo-irc/YouMayPasser">YouMayPasser</a></li><li><a href="https://github.com/Cracked5pider/Ekko">Ekko</a></li><li><a href="https://github.com/waldo-irc/MalMemDetect">MalMemDetect</a></li></ul></div></main><div class="image-viewer" id="image-viewer" data-astro-cid-66hmb7oq="" style="visibility: hidden;"><img alt="" src="https://kyleavery.com/posts/avoiding-memory-scanners/" data-astro-cid-66hmb7oq="" id="image-viewer-img"></div></div></div>
</body></html>