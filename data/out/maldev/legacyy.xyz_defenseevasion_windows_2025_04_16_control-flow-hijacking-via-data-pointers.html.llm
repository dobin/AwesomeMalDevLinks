Title:
Control Flow Hijacking via Data Pointers (abusing combase.dll CFG function pointer for process injection)

Type:
Blog Post

Short Summary (4–8 sentences max):
This post walks through a Windows process-injection technique that gains execution by overwriting “data pointers” (function pointers stored in writable sections) instead of creating a new thread or directly jumping to shellcode. The author focuses on pointers in KnownDlls so the target pointer address is consistent across processes, reducing per-target discovery work. It shows how to enumerate hijackable pointers (manual reversing and an automated Binary Ninja LLIL pattern scan for tailcalls) and then weaponizes a high-fanout pointer in combase.dll: `__guard_check_icall_fptr` (Control Flow Guard indirect-call check). A PoC locates the pointer cross-version by egghunting an instruction sequence inside an exported COM proxy stub (`NdrProxyForwardingFunction13`) and resolving the RIP-relative call target. The injector writes a position-independent stub + payload into the remote process and overwrites the pointer so normal COM activity triggers execution. A stub restores the original pointer and spawns the payload in a new thread to avoid hangs/crashes and repeated callbacks. Useful for red team/capability developers exploring lower-noise control-flow transfer primitives and for defenders modeling new injection IOCs around CFG pointer tampering.

Technical Focus:
- Function-pointer (“data pointer”) control-flow hijacking in Windows modules
- KnownDlls / shared module base addresses across processes
- Control Flow Guard internals: `__guard_check_icall_fptr` redirection
- Binary Ninja LLIL pattern-based discovery of hijack gadgets (tailcall/indirect call patterns)
- RIP-relative call target resolution + egghunting in exported functions
- Remote memory write + pointer overwrite with `WriteProcessMemory` / `VirtualAllocEx` (and `VirtualProtectEx` when needed)

Use Cases:
- Process injection without `CreateRemoteThread`/APC-style execution transfer
- Building cross-Windows-version pointer-hijack primitives using exported-function pattern matching
- Enumerating candidate hijackable pointers in common system DLLs (ntdll/combase/etc.)
- Developing shellcode stubs that restore state/pointers and execute payload asynchronously
- Defensive research: detecting CFG pointer modification and unusual writes to combase/CFG-related globals

Keywords:
Windows process injection, control-flow hijack, data pointer, function pointer overwrite, KnownDlls, combase.dll, ntdll.dll, Control Flow Guard, CFG, __guard_check_icall_fptr, _guard_check_icall_nop, COM proxying, MIDL, NdrProxyForwardingFunction13, RIP-relative addressing, egghunt, Binary Ninja, LLIL, tailcall(rax), VirtualAllocEx, WriteProcessMemory, VirtualProtectEx, CreateThread, position-independent code, mingw-w64, shellcode stub