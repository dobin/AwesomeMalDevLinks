# https://www.outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/

<!DOCTYPE html><html lang="en-US" itemscope="" itemtype="https://schema.org/Article" class="chrome"><body class="wp-singular post-template-default single single-post postid-777 single-format-standard wp-embed-responsive wp-theme-outflank mega-menu-main-menu"><div id="consent_blackbar" lang="en">
            
            <div id="truste-consent-track" style="position: relative; z-index: 999999; border-top: 1px solid rgb(102, 102, 102);" class="ta-show ta-display-block">  <div id="truste-consent-content" style="overflow: hidden;">    <div id="truste-consent-text" class="truste-messageColumn" data-nosnippet="data-nosnippet">      <span class="hstitle">This website uses cookies. You may change your settings at any time.</span>    </div>    <div id="truste-consent-buttons" class="truste-buttonsColumn" data-nosnippet="data-nosnippet">      <span id="truste-repop-msg" style="padding: 7px 10px; background: #F9EDBE; border:1px solid #F0C36D; margin: 11px 0px 13px;font-size:11; line-height: 16px;color: #AF7501; display:none;"></span>       <button id="truste-consent-button">Accept</button>      <button id="truste-consent-required">Reject All</button>      <button id="truste-show-consent" aria-haspopup="dialog">Manage Cookies</button>    </div>  </div></div></div>
<div id="teconsent" consent="undefined" aria-label="Open Cookie Preferences Modal" class="truste_caIcon_display" role="complementary"><a role="link" id="icon-id08265193145361083" tabindex="0" lang="en" aria-haspopup="dialog" aria-label="Cookie Preferences, opens a dedicated popup modal window" class="truste_cursor_pointer">Cookie Preferences</a></div>


  <!-- TrustArc tag end -->

<!-- Google Tag Manager start -->
        
        <!-- End Google Tag Manager -->
        
        
	
	
	<!-- This site is optimized with the Yoast SEO plugin v26.9 - https://yoast.com/product/yoast-seo-wordpress/ -->
	<title>Red Team Tactics: Combining Direct System Calls and sRDI to bypass AV/EDR | Outflank</title>
	
	<link rel="canonical" href="https://www.outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/">
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<!-- / Yoast SEO plugin. -->


<link rel="alternate" type="application/rss+xml" title="Outflank ¬ª Feed" href="https://www.outflank.nl/feed/">
<link rel="alternate" type="application/rss+xml" title="Outflank ¬ª Comments Feed" href="https://www.outflank.nl/comments/feed/">
<link rel="alternate" type="application/rss+xml" title="Outflank ¬ª Red Team Tactics: Combining Direct System Calls and sRDI to bypass AV/EDR Comments Feed" href="https://www.outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/feed/">



<link rel="stylesheet" id="wp-block-library-css" href="https://www.outflank.nl/wp-includes/css/dist/block-library/style.min.css?ver=6.8.3" type="text/css" media="all">


<link rel="stylesheet" id="megamenu-css" href="https://www.outflank.nl/wp-content/uploads/maxmegamenu/style.css?ver=0c5a55" type="text/css" media="all">
<link rel="stylesheet" id="dashicons-css" href="https://www.outflank.nl/wp-includes/css/dashicons.min.css?ver=6.8.3" type="text/css" media="all">
<link rel="stylesheet" id="outflank-style-css" href="https://www.outflank.nl/wp-content/themes/outflank/style.css?ver=6.8.3" type="text/css" media="all">
<link rel="stylesheet" id="slick-css" href="https://www.outflank.nl/wp-content/themes/outflank/assets/css/slick.css?ver=6.8.3" type="text/css" media="all">


<link rel="https://api.w.org/" href="https://www.outflank.nl/wp-json/"><link rel="alternate" title="JSON" type="application/json" href="https://www.outflank.nl/wp-json/wp/v2/posts/777"><link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://www.outflank.nl/xmlrpc.php?rsd">
<link rel="shortlink" href="https://www.outflank.nl/?p=777">
<link rel="alternate" title="oEmbed (JSON)" type="application/json+oembed" href="https://www.outflank.nl/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.outflank.nl%2Fblog%2F2019%2F06%2F19%2Fred-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr%2F">
<link rel="alternate" title="oEmbed (XML)" type="text/xml+oembed" href="https://www.outflank.nl/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.outflank.nl%2Fblog%2F2019%2F06%2F19%2Fred-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr%2F&amp;format=xml">

<link rel="stylesheet" id="294-css" href="https://www.outflank.nl/wp-content/uploads/custom-css-js/294.css?v=3883" type="text/css" media="all">

<link rel="stylesheet" id="17-css" href="https://www.outflank.nl/wp-content/uploads/custom-css-js/17.css?v=8269" type="text/css" media="all">
<link rel="pingback" href="https://www.outflank.nl/xmlrpc.php">
<link rel="icon" href="https://www.outflank.nl/wp-content/uploads/2022/03/cropped-outflank-favicon-32x32.png" sizes="32x32">
<link rel="icon" href="https://www.outflank.nl/wp-content/uploads/2022/03/cropped-outflank-favicon-192x192.png" sizes="192x192">
<link rel="apple-touch-icon" href="https://www.outflank.nl/wp-content/uploads/2022/03/cropped-outflank-favicon-180x180.png">


        <link href="https://www.outflank.nl/wp-content/themes/outflank/assets/fontawesome/css/all.min.css" rel="stylesheet">
    
    
        <div id="consent_blackbar"></div>
        <!-- Google Tag Manager (noscript) -->
        
        <!-- End Google Tag Manager (noscript) -->
        <a href="https://www.outflank.nl/blog/2019/06/19/red-team-tactics-combining-direct-system-calls-and-srdi-to-bypass-av-edr/#content" class="skip-link screen-reader-text">Skip to the content</a><!-- start Simple Custom CSS and JS -->
<!-- Google Tag Manager (noscript) -->

<!-- End Google Tag Manager (noscript) -->

<!-- end Simple Custom CSS and JS -->
        
        <div id="container">    <section class="medium-header">
        <div class="dots"></div>
        <div class="gradient"></div>
        <div class="container big-header-text">
        <h1 class="color--white">Publications</h1>
        </div>
    </section>


    <section class="container ">
        <div class="wordpress">

            <div class="row">
                <div class="col-s-12 margin-bottom--lg text--intro">
                    <main id="content" role="main">
                                        <article id="post-777" class="post-777 post type-post status-publish format-standard hentry category-uncategorized">

<div class="entry-content" itemprop="mainEntityOfPage">

<p>In this blog post we will explore the use of <em>direct system calls</em>, restore hooked API calls and ultimately combine this with a shellcode injection technique called&nbsp;<em>sRDI</em>. We will combine these techniques in proof of concept code which can be used to create a LSASS memory dump using Cobalt Strike, while not touching disk and evading AV/EDR monitored user-mode API calls.</p>



<span id="more-777"></span>



<p>As companies grow in their cybersecurity maturity level, attackers also evolve in their attacking capabilities. As a red team we try to offer the best value to our customers, so we also need to adapt to more advanced tactics and techniques attackers are using to bypass modern defenses and detection mechanisms. Recent <a rel="noreferrer noopener" aria-label=" (opens in a new tab)" href="https://www.cyberbit.com/blog/endpoint-security/malware-mitigation-when-direct-system-calls-are-used/" target="_blank">malware research</a> shows that there is an increase in malware that is using direct system calls to evade user-mode API hooks used by security products. So time for us to sharpen our offensive tool development skills.</p>



<p>Source code of the PoC can be found here: </p>



<p><a rel="noreferrer noopener" aria-label="https://github.com/outflanknl/Dumpert (opens in a new tab)" href="https://github.com/outflanknl/Dumpert" target="_blank">https://github.com/outflanknl/Dumpert</a></p>



<h2 class="wp-block-heading"><strong>What are direct system calls?</strong></h2>



<p>In order to understand what system calls really are, we first have to dig a little bit into Operating System architecture, specifically Windows. </p>



<p>If you are old (not like me‚Ä¶ üòâ ) and have a MS-DOS background, you probably remember that a simple application crash could result in a complete system crash. This was due to the fact that the operating system was running in <em>real mode,</em> which means that the processor is running in a mode in which no memory isolation and protection is applied. A bad program or bug could result in a complete crash of the Operating System due to critical system memory corruption, as there was no restriction in what memory regions could be accessed or not. </p>



<p>This all changed with newer processors and Operating Systems supporting the so-called&nbsp;<em>protected mode</em>. This mode introduced many safeguards and could protect the system from crashes by isolating running programs from each other using virtual memory and privilege levels or rings. On a Windows system two of these rings are actually used. Application are running in&nbsp;<em>user-mode</em>, which is the equivalent of ring 3 and critical system components like the kernel and device drivers are running in&nbsp;<em>kernel-mode</em> which corresponds to ring 0.&nbsp;</p>


<div class="wp-block-image">
<figure class="aligncenter is-resized"><img fetchpriority="high" decoding="async" width="420" height="306" src="https://outflank.nl/wp-content/uploads/2019/06/Picture1.png" alt="" class="wp-image-784" style="width:315px;height:230px"></figure></div>


<p>Using these protection rings makes sure that applications are isolated and cannot directly access critical memory sections and system resources running in&nbsp;<em>kernel-mode</em>. When an application needs to execute a privileged system operation, the processor first needs to switch into ring 0 to handover the execution flow into&nbsp;<em>kernel-mode</em>. This is where&nbsp;<em>system calls</em> come into place. </p>



<p>Let‚Äôs demonstrate this privilege mode switching while monitoring a notepad.exe process and saving a simple text file:</p>


<div class="wp-block-image">
<figure class="aligncenter"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture2.png"><img decoding="async" width="954" height="470" src="https://outflank.nl/wp-content/uploads/2019/06/Picture2.png" alt="" class="wp-image-786"></a><figcaption class="wp-element-caption">WriteFile call stack in Process Monitor . </figcaption></figure></div>


<p>The screenshot shows the program flow (call stack) from the notepad.exe process when we save a file. We can see the Win32 API WriteFile call following the Native API NtWriteFile call (more on APIs later). </p>



<p>For a program to save a file on disk, the Operating System needs access to the filesystem and device drivers. These are privileged operations and not something the application itself should be allowed to do. Accessing device drivers directly from an application could result in very bad things. So, the last API call before entering <em>kernel-mode</em> is responsible for pulling the dip switch into kernel land. <br></p>



<p>The CPU instruction for entering&nbsp;<em>kernel-mode </em>is the&nbsp;<em>syscall</em> instruction (at least on x64 architecture, which we will discuss in this blog only). We can see this in the following WinDBG screenshot, which shows the unassembled NtWriteFile instruction:</p>


<div class="wp-block-image">
<figure class="aligncenter"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture3.png"><img decoding="async" width="954" height="318" src="https://outflank.nl/wp-content/uploads/2019/06/Picture3.png" alt="" class="wp-image-790"></a><figcaption class="wp-element-caption">Disassembled NtWriteFile API call in WinDBG. </figcaption></figure></div>


<p>The NtWriteFile API from ntdll.dll is responsible for setting up the relevant function call arguments on the stack, then moving the system call number from the NtWriteFile call in the EAX register and executing the <em>syscall</em> instruction. After that, the CPU will jump into&nbsp;<em>kernel-mode </em>(ring 0). The kernel uses the dispatch table (SSDT) to find the right API call belonging to the system call number, copies the arguments from the <em>user-mode </em>stack into the&nbsp;<em>kernel-mode </em>stack and executes the kernel version of the API call (in this case ZwWriteFile). When the kernel routines are finished, the program flow will return back into <em>user-mode </em>almost the same way, but will return the return values from the kernel API calls (for example a pointer to received data, or a handle to a file). </p>



<p>This (user-mode) is also the place where many security products like AV, EDR and sandbox software put their hooks, so they can detour the execution flow into their engines to monitor and intercept API calls and block anything suspicious. As you have seen in the disassembled view of the NtWriteFile instruction you may have noticed that it only uses a few assembly instructions, from which the <em>syscall number </em>and the&nbsp;<em>syscall </em>instruction itself are the most important. The only important thing before executing a direct system call is that the stack is setup correctly with the expected arguments and using the right calling convention. </p>



<p>So, having this knowledge‚Ä¶ why not execute the system calls directly and bypass the Windows and Native API, so that we also bypass any user-mode hooks that might be in place? Well this is exactly what we are going to do, but first a little bit more about the Windows programming interfaces.</p>



<h2 class="wp-block-heading"><strong>The Windows programming interfaces</strong></h2>



<p>In the following screenshot we see a high-level overview of the Windows OS Architecture:</p>


<div class="wp-block-image">
<figure class="aligncenter is-resized"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture4.png"><img loading="lazy" decoding="async" width="518" height="577" src="https://outflank.nl/wp-content/uploads/2019/06/Picture4.png" alt="" class="wp-image-793" style="width:428px;height:476px"></a></figure></div>


<p>For a&nbsp;<em>user-mode</em> application to interface with the underlying operating system, it uses an application programming interface (API). If you are a Windows developer writing C/C++ application, you would normally use the Win32 API. This is Microsoft‚Äôs <a rel="noreferrer noopener" aria-label=" (opens in a new tab)" href="https://docs.microsoft.com/en-us/windows/desktop/api/" target="_blank">documented programming interfaces</a> which consists of several DLLs (so called Win32 subsystem DLLs). </p>



<p>Underneath the Win32 API sits the Native API (ntdll.dll), which is actually the real interface between the&nbsp;<em>user-mode</em> applications and the underlying operating system. This is the most important programming interface but ‚Äúnot officially‚Äù documented and should be avoided by programmers in most circumstances. </p>



<p>The reason why Microsoft has put another layer on top of the Native API is that the real magic occurs within this Native API layer as it is the lowest layer between user-mode and the kernel. Microsoft probably decided to shield off the documented APIs using an extra layer, so they could make architectural OS changes without affecting the Win32 programming interface. </p>



<p>So now we know a bit more about&nbsp;<em>system calls</em> and the Windows programming APIs, let‚Äôs see how we can actually skip the programming APIs and invoke the APIs directly using their system call number or restore potentially hooked API calls.</p>



<h2 class="wp-block-heading"><strong>Using system calls directly</strong></h2>



<p>We already showed how to disassemble native API calls to identify the corresponding&nbsp;<em>system call</em> numbers. Using a debugger this could take a lot of time. So, the same can be done using IDA (or <a href="https://ghidra-sre.org/" target="_blank" rel="noreferrer noopener" aria-label="Ghidra (opens in a new tab)">Ghidra</a>) by opening a copy of ntdll.dll and lookup the needed function:</p>


<div class="wp-block-image">
<figure class="aligncenter"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture5.png"><img loading="lazy" decoding="async" width="954" height="295" src="https://outflank.nl/wp-content/uploads/2019/06/Picture5.png" alt="" class="wp-image-816"></a><figcaption class="wp-element-caption">Disassembled NtWriteFile API call in IDA. </figcaption></figure></div>


<p>One slight problem‚Ä¶ system call numbers change between OS versions and sometimes even between service pack/built numbers.</p>



<p>Fortunately <a href="https://twitter.com/j00ru" target="_blank" rel="noreferrer noopener" aria-label="@j00ru (opens in a new tab)">@j00ru</a> from Google project Zero comes to the rescue with his <a rel="noreferrer noopener" aria-label=" (opens in a new tab)" href="https://j00ru.vexillium.org/syscalls/nt/64/" target="_blank">online system call tables</a>. </p>



<p>j00ru did an amazing job keeping up with all system call numbers in use by different Windows versions and between builds. So now we have a great resource to look up all the system calls we want to use.</p>



<p>In our code, we want to invoke the system calls directly using assembly. Within Visual Studio we can enable assembly code support using the <em>masm</em> build dependency, which allows us to add .asm files and code within our project.</p>


<div class="wp-block-image">
<figure class="aligncenter is-resized"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture6-3.png"><img loading="lazy" decoding="async" width="510" height="608" src="https://outflank.nl/wp-content/uploads/2019/06/Picture6-3.png" alt="" class="wp-image-858" style="width:395px;height:471px"></a><figcaption class="wp-element-caption">Assembly system call functions in .asm file.</figcaption></figure></div>


<p>All we need to do is gather OS version information from the system we are using and create references between the native API function definitions and OS version specific system call functions in assembly language. For this we can use the Native API&nbsp;<a rel="noreferrer noopener" aria-label="RtlGetVersion (opens in a new tab)" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-rtlgetversion" target="_blank">RtlGetVersion</a> routine and save this information into a version info structure.</p>


<div class="wp-block-image">
<figure class="aligncenter"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture7.png"><img loading="lazy" decoding="async" width="791" height="352" src="https://outflank.nl/wp-content/uploads/2019/06/Picture7.png" alt="" class="wp-image-832"></a><figcaption class="wp-element-caption">Reference function pointers based on OS info.</figcaption></figure></div>

<div class="wp-block-image">
<figure class="aligncenter"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture8.png"><img loading="lazy" decoding="async" width="791" height="329" src="https://outflank.nl/wp-content/uploads/2019/06/Picture8.png" alt="" class="wp-image-833"></a><figcaption class="wp-element-caption">Exported OS specific assembly functions + native API function definitions.</figcaption></figure></div>


<p>Now we can use the system call functions in our code as if they are normal native API functions:</p>


<div class="wp-block-image">
<figure class="aligncenter"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture9.png"><img loading="lazy" decoding="async" width="760" height="252" src="https://outflank.nl/wp-content/uploads/2019/06/Picture9.png" alt="" class="wp-image-835"></a><figcaption class="wp-element-caption">Using ZwOpenProcess systemcall function as a Native API call.  </figcaption></figure></div>


<h2 class="wp-block-heading"><strong>Restoring hooked API calls with direct system calls</strong></h2>



<p>Writing advanced malware that only uses direct system calls and completely evades user-mode API calls is practically impossible or at least extremely cumbersome. Sometimes you just want to use an API call in your malicious code. But what if somewhere in the call stack there is a user-mode hook by AV/EDR? Let‚Äôs have a look how we can remove the hook using direct system calls.</p>



<p>Basic user-mode API hooks by AV/EDR are often created by modifying the first 5 bytes of the API call with a jump (JMP) instruction to another memory address pointing to the security software. The technique of unhooking this method has already been documented within two great blog posts by <a href="https://medium.com/@fsx30/bypass-edrs-memory-protection-introduction-to-hooking-2efb21acffd6">@</a><a rel="noreferrer noopener" aria-label="SpecialHoang (opens in a new tab)" href="https://medium.com/@fsx30/bypass-edrs-memory-protection-introduction-to-hooking-2efb21acffd6" target="_blank">SpecialHoang</a>, and by&nbsp;<a rel="noreferrer noopener" aria-label="MDsec‚Äôs (opens in a new tab)" href="https://www.mdsec.co.uk/2019/03/silencing-cylance-a-case-study-in-modern-edrs/" target="_blank">MDsec‚Äôs</a> <a rel="noreferrer noopener" aria-label="Adam Chester (opens in a new tab)" href="https://twitter.com/_xpn_" target="_blank">Adam Chester</a> and <a rel="noreferrer noopener" aria-label="Dominic Chell (opens in a new tab)" href="https://twitter.com/domchell" target="_blank">Dominic Chell</a>. </p>



<p>If you study these methods carefully, you will notice the use of API calls such as VirtualProtectEx and WriteProcessMemory to unhook Native API functions. But what if the first API calls are hooked and monitored already somewhere in the call stack? Inception, get it? Direct system calls to the rescue!</p>



<p>In the PoC code we created we basically use the same unhooking technique by restoring the first 5 bytes with the original assembly instructions, including the system call number. The only difference is that the API calls we use to unhook the APIs are direct systems call functions (ZwProtectVirtualMemory and ZwWriteVirtualMemory).</p>


<div class="wp-block-image">
<figure class="aligncenter"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture10.png"><img loading="lazy" decoding="async" width="954" height="335" src="https://outflank.nl/wp-content/uploads/2019/06/Picture10.png" alt="" class="wp-image-836"></a><figcaption class="wp-element-caption">Using direct system call function to unhook APIs.</figcaption></figure></div>


<h2 class="wp-block-heading"><strong>Proof of concept</strong></h2>



<p>In our operations we sometimes need Mimikatz to get access to credentials, hashes and Kerberos tickets on a target system. Endpoint detection software and threat hunting instrumentation are pretty good in detection and prevention of Mimikatz nowadays. So, if you are in an assessment and your scenario requires to stay under the radar as much as possible, using Mimikatz on an endpoint is not best practice (even in-memory). Also, dumping LSASS memory with tools such as procdump is often caught by modern AV/EDR using API hooks.</p>



<p>So, we need an alternative to get access to LSASS memory and one option is to create a memory dump of the LSASS process after unhooking relevant API functions. This technique was also documented in <a rel="noreferrer noopener" aria-label="@SpecialHoang (opens in a new tab)" href="https://medium.com/@fsx30/bypass-edrs-memory-protection-introduction-to-hooking-2efb21acffd6" target="_blank">@SpecialHoang</a> blog.&nbsp;</p>



<p>As a proof of concept, we created a LSASS memory dump tool called ‚Äú<em>Dumpert</em>‚Äù. This tool combines direct system calls and API unhooking and allows you to create a LSASS minidump. This might help bypassing defenses of modern AV and EDR products.</p>


<div class="wp-block-image">
<figure class="aligncenter"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture11.png"><img loading="lazy" decoding="async" width="670" height="489" src="https://outflank.nl/wp-content/uploads/2019/06/Picture11.png" alt="" class="wp-image-861"></a></figure></div>


<p>The minidump file can be used in Mimikatz to extract credential information without running Mimikatz on the target system.</p>


<div class="wp-block-image">
<figure class="aligncenter"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture12.png"><img loading="lazy" decoding="async" width="675" height="400" src="https://outflank.nl/wp-content/uploads/2019/06/Picture12.png" alt="" class="wp-image-862"></a><figcaption class="wp-element-caption">Mimikatz minidump import.</figcaption></figure></div>


<p>Of course, dropping executable files on a target is probably something you want to avoid during an engagement, so let‚Äôs take this a step further‚Ä¶</p>



<h2 class="wp-block-heading"><strong>sRDI ‚Äì Shellcode Reflective DLL Injection</strong></h2>



<p>If we do not want to touch disk, we need some sort of injection technique. We can create a <a href="https://github.com/stephenfewer/ReflectiveDLLInjection">reflective loadable DLL</a> from our code, but reflective DLL injection leaves memory artefacts behind that can be detected. My colleague <a rel="noreferrer noopener" aria-label="@StanHacked (opens in a new tab)" href="https://twitter.com/stanhacked" target="_blank">@StanHacked</a> recently pointed me to an interesting DLL injection technique called shellcode Reflective DLL Injection. </p>



<p>sRDI allows for the conversion of DLL files to position independent shellcode.&nbsp;This technique is developed by Nick Landers (<a rel="noreferrer noopener" aria-label="@monoxgas (opens in a new tab)" href="https://twitter.com/monoxgas" target="_blank">@monoxgas</a>) from Silent Break Security and is basically a new version of RDI.&nbsp;</p>



<p>Some advantages of using sRDI instead of standard RDI:</p>



<ul class="wp-block-list">
<li>You can convert any DLL to position independent shellcode and use standard shellcode injection techniques.</li>



<li>Your DLL does not need to be reflection-aware as the reflective loader is implemented in shellcode outside of your DLL.</li>



<li>Uses proper Permissions, no massive RWX blob.</li>



<li>Optional PE Header Cleaning.</li>
</ul>



<p>More detailed information about sRDI can be found in <a rel="noreferrer noopener" aria-label="this blog (opens in a new tab)" href="https://silentbreaksecurity.com/srdi-shellcode-reflective-dll-injection" target="_blank">this blog</a>.</p>



<h2 class="wp-block-heading"><strong>Let our powers combine!</strong></h2>



<p>Okay with all the elements in place, let‚Äôs see if we can combine these elements and techniques and create something more powerful that could be useful during Red Team operations:</p>


<div class="wp-block-image">
<figure class="aligncenter is-resized"><img loading="lazy" decoding="async" width="635" height="427" src="https://outflank.nl/wp-content/uploads/2019/06/Picture13-1.png" alt="" class="wp-image-889" style="width:433px;height:291px"></figure></div>


<ul class="wp-block-list">
<li>We created a DLL version of the ‚Äúdumpert‚Äù tool using the same direct system calls and unhooking techniques. This DLL can be run standalone using the following command line: ‚Äú<em><strong>rundll32.exe C:\Dumpert\Outflank-Dumpert.dll,Dump</strong>‚Äù</em>, but in this case we are going to convert it to a sRDI shellcode.</li>



<li>Compile the DLL version using Visual Studio and turn it into a position independent shellcode. This can be done using the&nbsp;<em><a rel="noreferrer noopener" aria-label="ConvertToShellcode.py (opens in a new tab)" href="https://github.com/monoxgas/sRDI/tree/master/Python" target="_blank">ConvertToShellcode.py</a></em> script from the sRDI project: <strong>‚Äú</strong><em><strong>python3 ConvertToShellcode.py Outflank-Dumpert.dl</strong>l‚Äù</em></li>



<li>To inject the shellcode into a remote target, we can use Cobalt Strike‚Äôs&nbsp;<em>shinject</em> command. <a rel="noreferrer noopener" aria-label="Cobalt Strike (opens in a new tab)" href="https://www.cobaltstrike.com/" target="_blank">Cobalt Strike</a> has a powerful scripting language called aggressor script which allows you to automate this step.&nbsp;&nbsp;To make this easier we provided an <a href="https://github.com/outflanknl/Dumpert/tree/master/Dumpert-Aggressor" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)">aggressor script</a> which enables a ‚Äúdumpert‚Äù command in the beacon menu to do the dirty job.</li>
</ul>


<div class="wp-block-image">
<figure class="aligncenter"><a href="https://outflank.nl/wp-content/uploads/2019/06/Picture14.png"><img loading="lazy" decoding="async" width="931" height="272" src="https://outflank.nl/wp-content/uploads/2019/06/Picture14.png" alt="" class="wp-image-869"></a></figure></div>


<ul class="wp-block-list">
<li>The dumpert script uses shinject to inject the sRDI shellcode version of the dumpert DLL into the current process (to avoid CreateRemoteThread API). Then it waits a few seconds for the lsass minidump to finish and finally download the minidump file from the victim host.</li>



<li>Now you can use Mimikatz on another host to get access to the lsass memory dump including credentials, hashes e.g. from our target host. For this you can use the following command: <em>‚Äú<strong>sekurlsa::minidump C:\Dumpert\dumpert.dmp</strong>‚ÄùÔªø</em></li>
</ul>



<h2 class="wp-block-heading"><strong>Conclusion</strong></h2>



<p>Malware that evades security product hooks is increasing and we need to be able to embed such techniques in our projects. </p>



<p>In this blog we used references between the native API function definitions and OS version specific system call functions in assembly. This allows us to use direct system calls function as if they were normal Native API functions. We combined this technique together with an API unhooking technique to create a minidump from the LSASS process and used sRDI in combination with Cobalt Strike to inject the <em>dumpert</em> shellcode into memory of a target system.</p>



<p>Detecting malicious use of system calls is difficult. Because user-mode programming interfaces are bypassed, the only place to look for malicious activity is the kernel itself. But with kernel <a href="https://en.wikipedia.org/wiki/Kernel_Patch_Protection">PatchGuard</a> protection it is infeasible for security products to create hooks or modification in the running kernel.</p>



<p>I hope this blogpost is useful in understanding the advanced techniques attackers are using nowadays and provides a useful demonstration on how to emulate these techniques during Red Team operations.If you have any feedback or additional ideas, <a href="https://twitter.com/Cneelis">let me know</a>. </p>



<p>Lastly, in order to help other red teams easily implement these techniques and more, we‚Äôve developed Outflank Security Tooling (<a href="https://outflank.nl/services/outflank-security-tooling/">OST</a>), a broad set of evasive tools that allow users to safely and easily perform complex tasks. If you‚Äôre interested in seeing the diverse offerings in OST, we recommend scheduling an expert led demo.</p>



<div class="wp-block-buttons is-content-justification-center is-layout-flex wp-container-core-buttons-is-layout-16018d1d wp-block-buttons-is-layout-flex">
<div class="wp-block-button"><a class="wp-block-button__link wp-element-button" href="https://outflank.nl/demo-request/">Schedule a Demo</a></div>
</div>



<p><br></p>
<div class="entry-links"></div>
</div>
</article>                                                                
                    </main>
                </div>
            </div>
        </div>
    </section>
        </div>
        <div class="incident-overlay js-incident-overlay">
            
            <div class="dots"></div>
            <div class="gradient"></div>

            <button class="incident-overlay__close js-incident-overlay-trigger">
                <span></span>
                <span></span>
            </button>
            <section class="incident-overlay__content"><h2 class="widgettitle">Need help right away?<br>Call our emergency number</h2>
			<div class="textwidget"><p><a class="button button--highlight" href="tel:0202618996">+31 20 2618996</a></p>
<p>Or send us an <a href="mailto:info@outflank.nl?subject=[Incident%20-%20www.outflank.nl]">email</a> and we‚Äôll get back to you as soon as possible</p>
</div>
		</section>        </div>
        
        
    

<div class="ta-display-none" name="trustarc_notice" id="trustarcNoticeFrame" title="Trustarc Cross-Domain Consent Frame" src="https://consent.trustarc.com/get?name=crossdomain.html&amp;domain=helpsystems.com" data-original-tag="iframe"></div>





    
</body></html>