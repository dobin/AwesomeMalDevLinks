# https://0xdarkvortex.dev/hiding-in-plainsight/

<!DOCTYPE html><html lang="en">

<body id="page-top"><div class="grain-header"></div>
  
    
    <!-- Navigation Minimal -->
    
    

    <!-- End Navigation -->

    <!-- Show content -->
    
    <div class="content animated fadeInDown fast">

    <!-- Open container -->
        <div class="blog-container"> 
            <div class="postbox">
                <h1>Hiding In PlainSight - Indirect Syscall is Dead! Long Live Custom Call Stacks</h1>               
                <p>Posted on 29 Jan 2023 by Paranoid Ninja</p>
                


    
    <link rel="stylesheet" href="https://0xdarkvortex.dev/assets/styles/poststyle.css">


<hr>

<p>NOTE: <strong><em>This is a PART II blog on Stack Tracing evasion. PART I can be found <a href="https://0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/">here</a>.</em></strong></p>

<p>This is the second part of the blog I wrote 3 days back on proxying DLL loads to hide suspicious stack traces leading to a user allocated RX region. I wonâ€™t be going in depth on how stack works, because I already covered that in the previous blog which can be accessed from the above link. We previously saw that we can manipulate the <code class="highlighter-rouge">call</code> and <code class="highlighter-rouge">jmp</code> instructions to request windows callbacks into calling <code class="highlighter-rouge">LoadLibrary</code> API call. However, stack tracing detections go far beyond just hunting DLL loads. When you inject a reflective DLL into local or remote process, you have to call API calls such as <code class="highlighter-rouge">VirtualAllocEx</code>/<code class="highlighter-rouge">VirtualProtectEx</code> which indirectly calls <code class="highlighter-rouge">NtAllocateVirtualMemory</code>/<code class="highlighter-rouge">NtProtectVirtualMemory</code>. However, when you check the call stack of the legitimate API calls, you will notice that WINAPIs like <code class="highlighter-rouge">VirtualAlloc/VirtualProtect</code> are mostly called by non-windows DLL functions. Majority of windows DLLs will call <code class="highlighter-rouge">NtAllocateVirtualMemory</code>/<code class="highlighter-rouge">NtProtectVirtualMemory</code> directly. Below is a quick example of the callstack for <code class="highlighter-rouge">NtProtectVirtualMemory</code> when you call <code class="highlighter-rouge">RtlAllocateHeap</code>.</p>


    <div class="center-row">
        <div class="mobile">
            <a href="https://0xdarkvortex.dev/assets/images/2023-01-29-Hiding-In-Plainsight/rtlprotectheap.png">
                <img class="mobile-image img-fluid" src="https://0xdarkvortex.dev/assets/images/2023-01-29-Hiding-In-Plainsight/rtlprotectheap.png">
        </a>
    </div>
</div>


<p>This means that since ntdll.dll is not dependent on any other DLL, all functions in ntdll which require playing around with permissions for memory regions will call the NTAPIs directly. Thus, it means that if we are able to reroute our <code class="highlighter-rouge">NtAllocateVirtualMemory</code> call via a clean stack from ntdll.dll itself, we wont have to worry about detections at all. Most red teams rely on indirect syscalls to avoid detections. In case of indirect syscalls, you simply jump to the address of <code class="highlighter-rouge">syscall</code> instruction after carefully creating the stack, but the issue here is that indirect syscalls will only change the <code class="highlighter-rouge">return address</code> for the <code class="highlighter-rouge">syscall</code> instruction in ntdll.dll. <code class="highlighter-rouge">Return Address</code> in this case is the location where the syscall instruction needs to return to, after the syscall is complete. But the rest of the stack below the return address will still be suspicious as they emerge out from the RX region. If an EDR checks the full stack of the NTAPI, it can easily identify that the return address eventually reaches back to the user allocated RX region. This means, a return address to ntdll.dll region, but stack originating from RX region is a 100% anomaly with zero chances of being a false positive. This is an easy win for EDRs who utilize ETW for syscall tracing in the kernel.</p>

<p>Thus in order to evade this, I spent some time reversing several ntdll.dll functions and found that with a little bit of assembly knowledge and how windows callbacks work, we should be able to manipulate the callback into calling any NTAPI function. For this blog, we will take an example of <code class="highlighter-rouge">NtAllocateVirtualMemory</code> and we will <a href="https://github.com/paranoidninja/Proxy-DLL-Loads">pick the code from our part I blog</a> and modify it. We will take an example of the same API <code class="highlighter-rouge">TpAllocWork</code> which can execute a call back function. But instead of passing on a pointer to a string like we did in the case of Dll Proxying, we will pass on a pointer to a structure this time. We will also avoid any global variables this time by making sure all the necessary information goes within the struct as we cannot have global variables when we write our shellcodes. The definition of <code class="highlighter-rouge">NtAllocateVirtualMemory</code> as per msdn is:</p>

<pre class="hljs" style="display: block; overflow-x: auto; background: rgb(29, 31, 33); color: rgb(197, 200, 198); padding: 0.5em;">__<span class="hljs-function">kernel_entry NTSYSCALLAPI NTSTATUS <span class="hljs-title" style="color: rgb(129, 162, 190);">NtAllocateVirtualMemory</span><span class="hljs-params" style="color: rgb(222, 147, 95);">(
  [in]      HANDLE    ProcessHandle,
  [in, out] PVOID     *BaseAddress,
  [in]      ULONG_PTR ZeroBits,
  [in, out] PSIZE_T   RegionSize,
  [in]      ULONG     AllocationType,
  [in]      ULONG     Protect
)</span></span>;</pre>

<p>This means, we need to pass on a pointer for <code class="highlighter-rouge">NtAllocateVirtualMemory</code> and its arguments inside a structure to the callback so that our callback can extract these information from the structure and execute it. We will ignore the arguments which stay static such as <code class="highlighter-rouge">ULONG_PTR ZeroBits</code> which is always zero and <code class="highlighter-rouge">ULONG AllocationType</code> which is always <code class="highlighter-rouge">MEM_RESERVE|MEM_COMMIT</code> which in hex is <code class="highlighter-rouge">0x3000</code>. Thus adding in the remaining arguments, the structure will look like this:</p>

<pre class="hljs" style="display: block; overflow-x: auto; background: rgb(29, 31, 33); color: rgb(197, 200, 198); padding: 0.5em;"><span class="hljs-keyword" style="color: rgb(178, 148, 187);">typedef</span> <span class="hljs-keyword" style="color: rgb(178, 148, 187);">struct</span> _NTALLOCATEVIRTUALMEMORY_ARGS {
    UINT_PTR pNtAllocateVirtualMemory;   <span class="hljs-comment" style="color: rgb(150, 152, 150);">// pointer to NtAllocateVirtualMemory - rax</span>
    HANDLE hProcess;                     <span class="hljs-comment" style="color: rgb(150, 152, 150);">// HANDLE ProcessHandle - rcx</span>
    PVOID* address;                      <span class="hljs-comment" style="color: rgb(150, 152, 150);">// PVOID *BaseAddress - rdx; ULONG_PTR ZeroBits - 0 - r8</span>
    PSIZE_T size;                        <span class="hljs-comment" style="color: rgb(150, 152, 150);">// PSIZE_T RegionSize - r9; ULONG AllocationType - MEM_RESERVE|MEM_COMMIT = 3000 - stack pointer</span>
    ULONG permissions;                   <span class="hljs-comment" style="color: rgb(150, 152, 150);">// ULONG Protect - PAGE_EXECUTE_READ - 0x20 - stack pointer</span>
} NTALLOCATEVIRTUALMEMORY_ARGS, *PNTALLOCATEVIRTUALMEMORY_ARGS;</pre>

<p>We will then initialize the structure with the required arguments and pass it as a pointer to <code class="highlighter-rouge">TpAllocWork</code> and call our function <code class="highlighter-rouge">WorkCallback</code> which is written in assembly.</p>

<pre class="hljs" style="display: block; overflow-x: auto; background: rgb(29, 31, 33); color: rgb(197, 200, 198); padding: 0.5em;"><span class="hljs-meta" style="color: rgb(222, 147, 95);">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta" style="color: rgb(222, 147, 95);">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword" style="color: rgb(178, 148, 187);">typedef</span> <span class="hljs-title" style="color: rgb(129, 162, 190);">NTSTATUS</span> <span class="hljs-params" style="color: rgb(222, 147, 95);">(NTAPI* TPALLOCWORK)</span><span class="hljs-params" style="color: rgb(222, 147, 95);">(PTP_WORK* ptpWrk, PTP_WORK_CALLBACK pfnwkCallback, PVOID OptionalArg, PTP_CALLBACK_ENVIRON CallbackEnvironment)</span></span>;
<span class="hljs-function"><span class="hljs-keyword" style="color: rgb(178, 148, 187);">typedef</span> <span class="hljs-title" style="color: rgb(129, 162, 190);">VOID</span> <span class="hljs-params" style="color: rgb(222, 147, 95);">(NTAPI* TPPOSTWORK)</span><span class="hljs-params" style="color: rgb(222, 147, 95);">(PTP_WORK)</span></span>;
<span class="hljs-function"><span class="hljs-keyword" style="color: rgb(178, 148, 187);">typedef</span> <span class="hljs-title" style="color: rgb(129, 162, 190);">VOID</span> <span class="hljs-params" style="color: rgb(222, 147, 95);">(NTAPI* TPRELEASEWORK)</span><span class="hljs-params" style="color: rgb(222, 147, 95);">(PTP_WORK)</span></span>;

<span class="hljs-keyword" style="color: rgb(178, 148, 187);">typedef</span> <span class="hljs-keyword" style="color: rgb(178, 148, 187);">struct</span> _NTALLOCATEVIRTUALMEMORY_ARGS {
    UINT_PTR pNtAllocateVirtualMemory;   <span class="hljs-comment" style="color: rgb(150, 152, 150);">// pointer to NtAllocateVirtualMemory - rax</span>
    HANDLE hProcess;                     <span class="hljs-comment" style="color: rgb(150, 152, 150);">// HANDLE ProcessHandle - rcx</span>
    PVOID* address;                      <span class="hljs-comment" style="color: rgb(150, 152, 150);">// PVOID *BaseAddress - rdx; ULONG_PTR ZeroBits - 0 - r8</span>
    PSIZE_T size;                        <span class="hljs-comment" style="color: rgb(150, 152, 150);">// PSIZE_T RegionSize - r9; ULONG AllocationType - MEM_RESERVE|MEM_COMMIT = 3000 - stack pointer</span>
    ULONG permissions;                   <span class="hljs-comment" style="color: rgb(150, 152, 150);">// ULONG Protect - PAGE_EXECUTE_READ - 0x20 - stack pointer</span>
} NTALLOCATEVIRTUALMEMORY_ARGS, *PNTALLOCATEVIRTUALMEMORY_ARGS;

<span class="hljs-function"><span class="hljs-keyword" style="color: rgb(178, 148, 187);">extern</span> VOID CALLBACK <span class="hljs-title" style="color: rgb(129, 162, 190);">WorkCallback</span><span class="hljs-params" style="color: rgb(222, 147, 95);">(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work)</span></span>;

<span class="hljs-function"><span class="hljs-keyword" style="color: rgb(178, 148, 187);">int</span> <span class="hljs-title" style="color: rgb(129, 162, 190);">main</span><span class="hljs-params" style="color: rgb(222, 147, 95);">()</span> </span>{
    LPVOID allocatedAddress = <span class="hljs-literal" style="color: rgb(222, 147, 95);">NULL</span>;
    SIZE_T allocatedsize = <span class="hljs-number" style="color: rgb(222, 147, 95);">0x1000</span>;

    NTALLOCATEVIRTUALMEMORY_ARGS ntAllocateVirtualMemoryArgs = { <span class="hljs-number" style="color: rgb(222, 147, 95);">0</span> };
    ntAllocateVirtualMemoryArgs.pNtAllocateVirtualMemory = (UINT_PTR) GetProcAddress(GetModuleHandleA(<span class="hljs-string" style="color: rgb(181, 189, 104);">"ntdll"</span>), <span class="hljs-string" style="color: rgb(181, 189, 104);">"NtAllocateVirtualMemory"</span>);
    ntAllocateVirtualMemoryArgs.hProcess = (HANDLE)<span class="hljs-number" style="color: rgb(222, 147, 95);">-1</span>;
    ntAllocateVirtualMemoryArgs.address = &amp;allocatedAddress;
    ntAllocateVirtualMemoryArgs.size = &amp;allocatedsize;
    ntAllocateVirtualMemoryArgs.permissions = PAGE_EXECUTE_READ;

    FARPROC pTpAllocWork = GetProcAddress(GetModuleHandleA(<span class="hljs-string" style="color: rgb(181, 189, 104);">"ntdll"</span>), <span class="hljs-string" style="color: rgb(181, 189, 104);">"TpAllocWork"</span>);
    FARPROC pTpPostWork = GetProcAddress(GetModuleHandleA(<span class="hljs-string" style="color: rgb(181, 189, 104);">"ntdll"</span>), <span class="hljs-string" style="color: rgb(181, 189, 104);">"TpPostWork"</span>);
    FARPROC pTpReleaseWork = GetProcAddress(GetModuleHandleA(<span class="hljs-string" style="color: rgb(181, 189, 104);">"ntdll"</span>), <span class="hljs-string" style="color: rgb(181, 189, 104);">"TpReleaseWork"</span>);

    PTP_WORK WorkReturn = <span class="hljs-literal" style="color: rgb(222, 147, 95);">NULL</span>;
    ((TPALLOCWORK)pTpAllocWork)(&amp;WorkReturn, (PTP_WORK_CALLBACK)WorkCallback, &amp;ntAllocateVirtualMemoryArgs, <span class="hljs-literal" style="color: rgb(222, 147, 95);">NULL</span>);
    ((TPPOSTWORK)pTpPostWork)(WorkReturn);
    ((TPRELEASEWORK)pTpReleaseWork)(WorkReturn);

    WaitForSingleObject((HANDLE)<span class="hljs-number" style="color: rgb(222, 147, 95);">-1</span>, <span class="hljs-number" style="color: rgb(222, 147, 95);">0x1000</span>);
    <span class="hljs-built_in" style="color: rgb(222, 147, 95);">printf</span>(<span class="hljs-string" style="color: rgb(181, 189, 104);">"allocatedAddress: %p\n"</span>, allocatedAddress);
    getchar();

    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">return</span> <span class="hljs-number" style="color: rgb(222, 147, 95);">0</span>;
}
</pre>

<p>Now this is where things get interesting. In case of DLL proxy, we executed <code class="highlighter-rouge">LoadLibrary</code> with only one argument i.e. the name of the DLL to load which is passed on to the <code class="highlighter-rouge">RCX</code> register. But in the case of <code class="highlighter-rouge">NtAllocateVirtualMemory</code>, we have a total of 6 arguments. This means the first four arguments go into the fastcall registers i.e. <code class="highlighter-rouge">RCX, RDX, R8</code> and <code class="highlighter-rouge">R9</code>. However, the remaining two arguments will have to be pushed to stack after allocating some homing space for our 4 registers. Make note that our top of the stack currently contains the return value for an internal NTAPI function <code class="highlighter-rouge">TppWorkpExecuteCallback</code> at 0ffset 0x130. This is how the callstack looks like when the callback function <code class="highlighter-rouge">WorkCallback</code> is called.</p>


    <div class="center-row">
        <div class="mobile">
            <a href="https://0xdarkvortex.dev/assets/images/2023-01-29-Hiding-In-Plainsight/TppStack_1.png">
                <img class="mobile-image img-fluid" src="https://0xdarkvortex.dev/assets/images/2023-01-29-Hiding-In-Plainsight/TppStack_1.png">
        </a>
    </div>
</div>



    <div class="center-row">
        <div class="mobile">
            <a href="https://0xdarkvortex.dev/assets/images/2023-01-29-Hiding-In-Plainsight/TppStack_0.png">
                <img class="mobile-image img-fluid" src="https://0xdarkvortex.dev/assets/images/2023-01-29-Hiding-In-Plainsight/TppStack_0.png">
        </a>
    </div>
</div>


<p>Now heres the catch. If you modify the top of the stack where the return address lies, add the homing space for the 4 registers and add arguments to it, the whole stack frame will go for a toss and mess up stack unwinding. Thus we have to modify the stack without changing the stack frame itself, but by only changing the values within the stack frame. Each <code class="highlighter-rouge">stack frame</code> starts and ends at the blue line shown in the image above. Our stack frame for <code class="highlighter-rouge">TppWorkpExecuteCallback</code> has enough space within itself to hold 6 arguments. So our next step is to extract the data from our <code class="highlighter-rouge">NTALLOCATEVIRTUALMEMORY_ARGS</code> structure and move it to the respective registers and stack. When we call <code class="highlighter-rouge">TpAllocWork</code>, we pass on the pointer to <code class="highlighter-rouge">NTALLOCATEVIRTUALMEMORY_ARGS</code> structure to the <code class="highlighter-rouge">WorkCallback</code> function, this means our pointer to the structure should be in the <code class="highlighter-rouge">RDX</code> register now. Each value in our structure is of 8 bytes (for x64, for x86 it would be 4 bytes). So, we will extract these QWORD values from the structure and move it to <code class="highlighter-rouge">RCX, RDX, R8, R9</code> and the remaining values on stack after adjusting the homing space. The calling convention for x64 functions in windows as per the <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">msdn documentation</a> would be:</p>

<pre class="hljs" style="display: block; overflow-x: auto; background: rgb(29, 31, 33); color: rgb(197, 200, 198); padding: 0.5em;">__<span class="hljs-function">kernel_entry NTSYSCALLAPI NTSTATUS <span class="hljs-title" style="color: rgb(129, 162, 190);">NtAllocateVirtualMemory</span><span class="hljs-params" style="color: rgb(222, 147, 95);">(
  [in]      HANDLE    ProcessHandle,  <span class="hljs-comment" style="color: rgb(150, 152, 150);">// goes into rcx</span>
  [in, out] PVOID     *BaseAddress,   <span class="hljs-comment" style="color: rgb(150, 152, 150);">// goes into rdx</span>
  [in]      ULONG_PTR ZeroBits,       <span class="hljs-comment" style="color: rgb(150, 152, 150);">// goes into r8</span>
  [in, out] PSIZE_T   RegionSize,     <span class="hljs-comment" style="color: rgb(150, 152, 150);">// goes into r9</span>
  [in]      ULONG     AllocationType, <span class="hljs-comment" style="color: rgb(150, 152, 150);">// goes to stack after adjusting homing space for 4 arguments</span>
  [in]      ULONG     Protect         <span class="hljs-comment" style="color: rgb(150, 152, 150);">// goes to stack below the 5th argument after adjusting homing space for 4 arguments</span>
)</span></span>;
</pre>

<p>Convering this logic to assembly would look like:</p>

<pre class="hljs" style="display: block; overflow-x: auto; background: rgb(29, 31, 33); color: rgb(197, 200, 198); padding: 0.5em;"><span class="hljs-meta" style="color: rgb(222, 147, 95);">section</span> .text

<span class="hljs-meta" style="color: rgb(222, 147, 95);">global</span> WorkCallback
<span class="hljs-symbol" style="color: rgb(181, 189, 104);">
WorkCallback:</span>
    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">mov</span> <span class="hljs-built_in" style="color: rgb(222, 147, 95);">rbx</span>, <span class="hljs-built_in" style="color: rgb(222, 147, 95);">rdx</span>                <span class="hljs-comment" style="color: rgb(150, 152, 150);">; backing up the struct as we are going to stomp rdx</span>
    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">mov</span> <span class="hljs-built_in" style="color: rgb(222, 147, 95);">rax</span>, [<span class="hljs-built_in" style="color: rgb(222, 147, 95);">rbx</span>]              <span class="hljs-comment" style="color: rgb(150, 152, 150);">; NtAllocateVirtualMemory</span>
    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">mov</span> <span class="hljs-built_in" style="color: rgb(222, 147, 95);">rcx</span>, [<span class="hljs-built_in" style="color: rgb(222, 147, 95);">rbx</span> + <span class="hljs-number" style="color: rgb(222, 147, 95);">0x8</span>]        <span class="hljs-comment" style="color: rgb(150, 152, 150);">; HANDLE ProcessHandle</span>
    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">mov</span> <span class="hljs-built_in" style="color: rgb(222, 147, 95);">rdx</span>, [<span class="hljs-built_in" style="color: rgb(222, 147, 95);">rbx</span> + <span class="hljs-number" style="color: rgb(222, 147, 95);">0x10</span>]       <span class="hljs-comment" style="color: rgb(150, 152, 150);">; PVOID *BaseAddress</span>
    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">xor</span> <span class="hljs-built_in" style="color: rgb(222, 147, 95);">r8</span>, <span class="hljs-built_in" style="color: rgb(222, 147, 95);">r8</span>                  <span class="hljs-comment" style="color: rgb(150, 152, 150);">; ULONG_PTR ZeroBits</span>
    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">mov</span> <span class="hljs-built_in" style="color: rgb(222, 147, 95);">r9</span>, [<span class="hljs-built_in" style="color: rgb(222, 147, 95);">rbx</span> + <span class="hljs-number" style="color: rgb(222, 147, 95);">0x18</span>]        <span class="hljs-comment" style="color: rgb(150, 152, 150);">; PSIZE_T RegionSize</span>
    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">mov</span> <span class="hljs-built_in" style="color: rgb(222, 147, 95);">r10</span>, [<span class="hljs-built_in" style="color: rgb(222, 147, 95);">rbx</span> + <span class="hljs-number" style="color: rgb(222, 147, 95);">0x20</span>]       <span class="hljs-comment" style="color: rgb(150, 152, 150);">; ULONG Protect</span>
    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">mov</span> [<span class="hljs-built_in" style="color: rgb(222, 147, 95);">rsp</span>+<span class="hljs-number" style="color: rgb(222, 147, 95);">0x30</span>], <span class="hljs-built_in" style="color: rgb(222, 147, 95);">r10</span>         <span class="hljs-comment" style="color: rgb(150, 152, 150);">; stack pointer for 6th arg</span>
    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">mov</span> <span class="hljs-built_in" style="color: rgb(222, 147, 95);">r10</span>, <span class="hljs-number" style="color: rgb(222, 147, 95);">0x3000</span>             <span class="hljs-comment" style="color: rgb(150, 152, 150);">; ULONG AllocationType</span>
    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">mov</span> [<span class="hljs-built_in" style="color: rgb(222, 147, 95);">rsp</span>+<span class="hljs-number" style="color: rgb(222, 147, 95);">0x28</span>], <span class="hljs-built_in" style="color: rgb(222, 147, 95);">r10</span>         <span class="hljs-comment" style="color: rgb(150, 152, 150);">; stack pointer for 5th arg</span>
    <span class="hljs-keyword" style="color: rgb(178, 148, 187);">jmp</span> <span class="hljs-built_in" style="color: rgb(222, 147, 95);">rax</span>
</pre>

<p>To explain the above code:</p>
<ul>
  <li>We first backup our pointer to the structure residing in the <code class="highlighter-rouge">RDX</code> register into the <code class="highlighter-rouge">RBX</code> register. We are doing this because we are going to stomp the RDX register with the second argument of <code class="highlighter-rouge">NtAllocateVirtualMemory</code> when we call it</li>
  <li>We move the first 8 bytes from the address in <code class="highlighter-rouge">RBX</code> register (<code class="highlighter-rouge">struct NTALLOCATEVIRTUALMEMORY_ARGS</code> i.e <code class="highlighter-rouge">UINT_PTR pNtAllocateVirtualMemory</code>) to rax register where we will jump to later after adjusting the arguments</li>
  <li>We move the second set of 8 bytes (<code class="highlighter-rouge">HANDLE hProcess</code>) from the structure to <code class="highlighter-rouge">RCX</code></li>
  <li>We move the third set of 8 bytes i.e. pointer to a NULL pointer (<code class="highlighter-rouge">PVOID* address</code>) stored in the structure into <code class="highlighter-rouge">RDX</code>. This is where our allocated address will be written by <code class="highlighter-rouge">NtAllocateVirtualMemory</code></li>
  <li>We zero out the <code class="highlighter-rouge">R8</code> register for the <code class="highlighter-rouge">ULONG_PTR ZeroBits</code> argument</li>
  <li>We move the 6th argument i.e the last argument which should go to the bottom of all arguments (<code class="highlighter-rouge">ULONG Protect i.e. PAGE permissions</code>) to r10 and then move it to offset <code class="highlighter-rouge">0x30</code> from top of the stack pointer.
    <ul>
      <li>Top of the stack pointer = RSP = Return address of <code class="highlighter-rouge">TppWorkpExecuteCallback</code> which is 8 bytes</li>
      <li>Homing space size for 4 arguments = 4x8 = 32 bytes</li>
      <li>Space for the 5th argument = 8 bytes</li>
      <li>Thus 32+8 = 40 = 0x28 (this is where the second last 5th argument will go)</li>
      <li>Thus 32+8+8 = 48 = 0x30 (this is where the last 6th argument will go)</li>
    </ul>
  </li>
  <li>We finally move the 5th argument value (<code class="highlighter-rouge">ULONG AllocationType</code>) i.e. <code class="highlighter-rouge">0x3000 - MEM_COMMIT|MEM_RESERVE</code> to the <code class="highlighter-rouge">R10</code> register and then push it to offset <code class="highlighter-rouge">0x28</code> from the RSP</li>
</ul>

<p>Compiling it all together, this is what it looks like before jumping to <code class="highlighter-rouge">NtAllocateVirtualMemory</code>:</p>
<ul>
  <li>The disassembled code shows the asm instructions we wrote. The current instruction pointer is just after adjusting the stack and before jumping to <code class="highlighter-rouge">NtAllocateVirtualMemory</code></li>
  <li>The registers show the arguments for <code class="highlighter-rouge">NtAllocateVirtualMemory</code></li>
  <li>The Dump shows the <code class="highlighter-rouge">NTALLOCATEVIRTUALMEMORY_ARGS</code> structure in memory. Each 8 byte memory block is an object relating to the contents of the strucutre</li>
  <li>The stack shows the adjusted stack for <code class="highlighter-rouge">NtAllocateVirtualMemory</code></li>
</ul>


    <div class="center-row">
        <div class="mobile">
            <a href="https://0xdarkvortex.dev/assets/images/2023-01-29-Hiding-In-Plainsight/finalStack.png">
                <img class="mobile-image img-fluid" src="https://0xdarkvortex.dev/assets/images/2023-01-29-Hiding-In-Plainsight/finalStack.png">
        </a>
    </div>
</div>


<p>And a quick look at the stack after the execute of <code class="highlighter-rouge">NtAllocateVirtualMemory</code> shows a valid callstack which can be unwinded perfectly. You can also see that the syscall for <code class="highlighter-rouge">NtAllocateVirtualMemory</code> returned zero which means the call was successful.</p>


    <div class="center-row">
        <div class="mobile">
            <a href="https://0xdarkvortex.dev/assets/images/2023-01-29-Hiding-In-Plainsight/stacktrace.png">
                <img class="mobile-image img-fluid" src="https://0xdarkvortex.dev/assets/images/2023-01-29-Hiding-In-Plainsight/stacktrace.png">
        </a>
    </div>
</div>


<p>The stack is as clear as crystal again with no signs of anything malevolent. Make note that this is <code class="highlighter-rouge">not</code> stacking spooing, because in our case the stack is being unwinded fully without crashing. There are many more such API calls which can be used for proxying various functions; which I will leave it out to the readers to use their own creativity. The upcoming release of BRc4 will use something similar but with different set of API calls which are fully undocumented and will be under a different payload option called as <code class="highlighter-rouge">stealth++</code>. The full code for this can be found in my <a href="https://github.com/paranoidninja/Proxy-Function-Calls-For-ETwTI">github repository</a>.</p>

                <div class="boxlinks">
                    <p>Tagged with: 
                    <a class="btn btn-rh btn-sm" href="https://0xdarkvortex.dev/tags/red-team/">red-team</a>
                    
                    <a class="btn btn-rh btn-sm" href="https://0xdarkvortex.dev/tags/blogs/">blogs</a>
                    
                    <a class="btn btn-rh btn-sm" href="https://0xdarkvortex.dev/tags/brute-ratel/">brute-ratel</a>
                    </p>
                </div>
    <!-- Close container -->
            </div>
        </div>
        
    <!-- Embeded Tweet JavaScript -->
    

    <!-- Open container -->
    <!-- <div class="container"> 
            <div class="postbox">
                
                <p class="lead text-uppercase">Join the conversation on Twitter!</p>
                <div id="tweet" tweetID="1314213590631510023"></div>
                <script sync src="https://platform.twitter.com/widgets.js"></script>
                <a class="btn btn-rh" href="https://twitter.com/NinjaParanoid/status/1314213590631510023">Reply with Twitter</a>
                 -->
    <!-- Close container -->
            <!-- </div>
    </div> -->
</div>
    
    <!-- End content -->
    
        <!-- Footer -->


    <!-- Custom scripts for this theme -->
    
    
    
    
  


</body></html>