Title:
Signature vs Behaviour – Understanding AV/EDR Detections and Practical Bypasses

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post explains the difference between signature-based detections (hash/byte-pattern/YARA on disk or in memory) and behavior-based detections (runtime actions that trigger alerts, scans, or process termination).  
- It frames what packers/loaders can realistically bypass (static signatures, some AMSI/ETW/hook-based telemetry, entropy heuristics) versus what they generally cannot (malicious runtime behaviors that trigger memory scans or verified detections).  
- The author walks through how packers work (encrypt/obfuscate payload, decrypt in-memory) and why “clean” scan results (e.g., antiScan.me) don’t imply runtime safety.  
- Concrete Defender-focused examples are provided: a fodhelper UAC bypass alert driven by registry-string heuristics, Meterpreter being killed due to reflective DLL injection behavior (stdapi autoload), and Cobalt Strike’s heavy signature/behavior coverage requiring profile, infra, and implant changes.  
- It highlights common evasion levers (sleep/jitter alternatives, memory encryption during idle, syscall usage, source modification) and emphasizes that behavior-based detections often require changing the payload/tooling itself.  
- Useful for red teamers/pentesters building loaders, tuning C2 tradecraft, and defenders wanting to understand why certain behaviors are high-signal and how attackers attempt to reduce them.

Technical Focus:
- Signature detection: hashes, byte patterns, YARA (file + memory scanning)
- Packer/loader design: runtime decryption, in-memory execution
- AMSI/ETW patching and telemetry suppression limits
- API hooking evasion: unhooking, direct/indirect syscalls
- Memory scanning triggers and sleep-based scan evasion (and counters)
- Behavior detections: registry-based heuristics, reflective DLL injection, C2 module/command signatures

Use Cases:
- Build/assess custom packers/loaders and understand what detections they can/can’t evade
- Troubleshoot why “fully undetected” payloads still die at runtime under Defender/EDR
- Reduce Defender alerts for specific techniques (e.g., fodhelper registry patterns, Meterpreter stdapi timing)
- Plan C2 tradecraft changes (staging off, redirectors, malleable profiles, environmental keying, sleep mask customization)
- Inform blue-team detection engineering around high-signal behaviors and verification via memory scans

Keywords:
signature-based detection, behavior-based detection, YARA, memory scanning, Windows Defender, EDR, packer, loader, runtime decryption, AMSI bypass, ETW patching, API hooking, unhooking, direct syscalls, indirect syscalls, entropy detection, SleepKiller, reflective DLL injection, Meterpreter, stdapi, Cobalt Strike, malleable C2 profile, redirector, environmental keying, sleep mask, fodhelper UAC bypass, registry heuristics, LSASS OpenProcess