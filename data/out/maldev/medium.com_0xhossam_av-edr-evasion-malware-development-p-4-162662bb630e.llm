Title:
AV/EDR Evasion | Malware Development P — 4 (IAT Unhooking, Process Memory Hiding & Syscalls)

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post is part 4 of a malware development/AV-EDR evasion series focused on Windows user-mode evasion primitives.  
- It explains the difference between Win32 APIs and Native (NT) APIs and how syscalls sit underneath, framing why EDRs often hook user-mode entry points.  
- The core technical section covers Import Address Table (IAT) hooking detection and “unhooking” by rebuilding IAT entries to point back to the real exported function addresses (including ordinal-based imports), with a referenced PoC and supporting assembly routines for locating image base and resolving exports.  
- It also discusses runtime payload hiding approaches, including temporarily encrypting shellcode and using memory protection tricks (e.g., PAGE_NOACCESS) and PAGE_GUARD + vectored exception handling to evade Defender-style runtime scanning triggers.  
- A module stomping PoC is shown that loads a benign DLL (e.g., amsi.dll) and overwrites its .text section with shellcode, then executes from that region.  
- Finally, it introduces direct vs indirect syscalls as a way to bypass user-mode hooks and links to deeper external resources.  
- Useful for red teamers, pentesters, and malware developers building loaders/implants; also relevant to defenders for understanding common user-mode evasion patterns and telemetry gaps.

Technical Focus:
- Windows PE imports: Import Directory, IAT/ILT thunks, ordinal vs name imports
- IAT hook detection and restoration (unhooking) using GetProcAddress/exports parsing
- PEB/image base discovery and export resolution in x64 assembly
- Runtime payload hiding via memory permissions (PAGE_NOACCESS/RX/RW) and encryption
- PAGE_GUARD + Vectored Exception Handler (VEH) control-flow redirection
- Module stomping (overwriting a loaded DLL .text section) and in-memory execution
- Direct vs indirect syscalls for bypassing user-mode EDR hooks

Use Cases:
- Detect and revert user-mode IAT hooks in a process/module before sensitive actions
- Build shellcode loaders that reduce exposure to runtime memory scanning
- Implement module stomping to execute payloads from “legitimate” module regions
- Prototype syscall-based execution paths to avoid hooked Win32/ntdll exports
- Blue-team validation: create test cases for detecting IAT tampering, PAGE_GUARD abuse, and suspicious VirtualProtect patterns

Keywords:
IAT unhooking, Import Address Table, Import Lookup Table, PE parsing, IMAGE_IMPORT_DESCRIPTOR, GetProcAddress, GetModuleHandleA, VirtualProtect, PAGE_GUARD, AddVectoredExceptionHandler, STATUS_GUARD_PAGE_VIOLATION, CreateProcessInternalW, ntdll.dll, Native API, Win32 API, direct syscalls, indirect syscalls, module stomping, amsi.dll, reflective DLL injection, shellcode, in-memory execution, runtime scanning evasion