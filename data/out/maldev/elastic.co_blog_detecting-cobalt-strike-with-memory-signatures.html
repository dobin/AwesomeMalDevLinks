# https://www.elastic.co/blog/detecting-cobalt-strike-with-memory-signatures

<!DOCTYPE html><html lang="en"><body><div id="MathJax_Message" style="display: none;"></div><div id="__next"><div class="progress-container"><div class="progress-bar" id="myBar"></div></div><div class="skip-links"><a href="https://www.elastic.co/blog/detecting-cobalt-strike-with-memory-signatures#main-content" rel="noreferrer" class="euiSkipLink css-1vo6hom-euiButtonDisplay-s-defaultMinWidth-s-fill-primary-euiSkipLink-euiScreenReaderOnly"><span class="css-1km4ln8-euiButtonDisplayContent"><span class="eui-textTruncate">Skip to main content</span></span></a></div><main id="main-content" role="main"><div class="jsx-3535804128 blog-detail"><section class="jsx-3535804128"><div style="background-image:linear-gradient(rgba(0, 85, 113, 0.5), rgba(0, 85, 113, 0.5)), url(https://static-www.elastic.co/v3/assets/bltefdd0b53724fa2ce/blt3449a8b2e94a5f02/5eea6d715f3aa42c4669df76/blog-banner-security-radar-anomaly-monitor.png);background-repeat:no-repeat;background-position:center;background-size:cover" class="jsx-3535804128 hero-image py-8"><div class="jsx-3535804128 container"><div class="jsx-3535804128 full-bleed-image-wrapper"><div class="jsx-3535804128 full-bleed-image"><span class="jsx-3535804128 blog-date"><time datetime="1615910400000">March 16, 2021</time></span><a class="category-label label-product" href="https://www.elastic.co/blog/category/product">Product</a><div class="title-wrapper"><h1 class="h3 color-variant-white" id="detecting-cobalt-strike-with-memory-signatures">Detecting Cobalt Strike with memory signatures</h1></div><div class="jsx-3535804128 author-name d-flex my-2 paragraph-medium"><span class="jsx-3535804128 mr-1">By</span><div class="jsx-3535804128 d-flex flex-wrap"><a href="https://www.elastic.co/blog/author/joe-desimone">Joe Desimone</a></div></div><p class="jsx-3535804128 share-label mb-1">Share</p></div></div></div></div><div class="layout layout-05"></div><div class="jsx-3535804128 article-post-wrapper blog clearfix paragraph-medium"><div class="jsx-3535804128 container"><div class="jsx-3535804128 row"><div class="jsx-3535804128 col-12 col-lg-9"><div class="jsx-3535804128 disclaimer-wrapper mb-6 p-3"><p>This blog discusses, mentions, or contains links to an Elastic training program that is now retired. For more Elastic resources, please visit the <a href="https://www.elastic.co/getting-started" target="_self">Getting Started page</a>.</p></div><div class="jsx-3535804128 paragraph-medium"><p>At Elastic Security, we approach the challenge of threat detection with various methods. Traditionally, we have focused on machine learning models and behaviors. These two methods are powerful because they can detect never-before-seen malware. Historically, we’ve felt that signatures are too easily evaded, but we also recognize that ease of evasion is only one of many factors to consider. Performance and false positive rates are also critical in measuring a detection technique's effectiveness.</p><p>Signatures, while unable to detect unknown malware, have false positive rates that approach zero and have associated labels that help prioritize alerts. For example, an alert for TrickBot or REvil Ransomware requires more immediate action than a potentially unwanted adware variant. Even if we could hypothetically catch only half of known malware with signatures, that is still a huge win when layered with other protections, considering the other benefits. Realistically we can do even better.</p><p>One roadblock to creating signatures that provide long-term value is the widespread use of packers and throw-away malware loaders. These components rapidly evolve to evade signature detection; however, the final malware payload is eventually decrypted and executed in memory.</p><p>To step around the issue of packers and loaders, we can focus signature detection strategies on in-memory content. This effectively extends the shelf life of the signature from days to months. In this post, we will use Cobalt Strike as an example for leveraging in-memory signatures.&nbsp;</p><h2><strong>Signaturing Cobalt Strike</strong></h2><p><a href="https://www.cobaltstrike.com/">Cobalt Strike</a> is a popular framework for conducting red team operations and adversary simulation. Presumably due to its ease of use, stability, and stealth features, it is also a favorite tool for <a href="https://www.fireeye.com/blog/threat-research/2017/05/cyber-espionage-apt32.html">bad actors</a> with even more <a href="https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/sodinokibi-ransomware-cobalt-strike-pos">nefarious</a> intentions. There have been various techniques for detecting Beacon, Cobalt Strike’s endpoint payload. This includes looking for <a href="https://www.elastic.co/blog/hunting-memory">unbacked threads</a>, and, more recently, built-in <a href="https://labs.f-secure.com/blog/detecting-cobalt-strike-default-modules-via-named-pipe-analysis/">named pipes</a>. However, due to the level of <a href="https://blog.cobaltstrike.com/2019/05/02/cobalt-strike-3-14-post-ex-omakase-shimasu/">configurability</a> in Beacon, there are usually ways to evade public detection strategies. Here we will attempt to use memory signatures as an alternative detection strategy.</p><p>Beacon is typically <a href="https://github.com/stephenfewer/ReflectiveDLLInjection">reflectively loaded</a> into memory and never touches disk in a directly signaturable form. Further, Beacon can be configured with a variety of in-memory obfuscation options to hide its payload. For example, the <a href="https://blog.cobaltstrike.com/2018/09/06/cobalt-strike-3-12-blink-and-youll-miss-it/">obfuscate-and-sleep</a> option attempts to mask portions of the Beacon payload between callbacks to specifically evade signature-based memory scans. We will need to consider this option when developing signatures, but it is still easy to signature Beacon even with these advanced stealth features.</p><h2><strong>Diving in</strong></h2><p>We will start by obtaining a handful of Beacon payloads with the <a href="https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/reference.profile#L254-L255"><strong>sleep_mask</strong></a> option enabled and disabled with the most recent releases (hashes in reference section). Starting with a sample with <strong>sleep_mask</strong> disabled, after detonation we can locate Beacon in memory with Process Hacker by looking for a thread which calls SleepEx from an unbacked region:</p><p><img src="https://images.contentstack.io/v3/assets/bltefdd0b53724fa2ce/blt7b127a57723668a4/603e6e90982f2a0bdaf5a89b/1-process-hacker-blog-detecting-cobalt-strike.png" data-sys-asset-uid="blt7b127a57723668a4" alt="" style="display:block;margin:auto"></p><p>From there, we can save the associated memory region to disk for analysis:</p><p><img src="https://images.contentstack.io/v3/assets/bltefdd0b53724fa2ce/blt8fd59d9d51f487e3/603e6e9ef9638443346d3da1/2-memory-region-blog-detecting-cobalt-strike.png" data-sys-asset-uid="blt8fd59d9d51f487e3" alt="" style="display:block;margin:auto"></p><p>The easiest win would be to pick a few unique strings from this region and use those as our signature. To demonstrate, will will be writing signatures with <a href="https://virustotal.github.io/yara/">yara</a>, an industry standard tool for this purpose:</p><pre class="prettyprint prettyprinted" style=""><span class="pln">rule cobaltstrike_beacon_strings</span><br><span class="pun">{</span><br><span class="pln">meta</span><span class="pun">:</span><br><span class="pln">    author </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Elastic"</span><br><span class="pln">    description </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Identifies strings used in Cobalt Strike Beacon DLL."</span><br><span class="pln">strings</span><span class="pun">:</span><br><span class="pln">    $a </span><span class="pun">=</span><span class="pln"> </span><span class="str">"%02d/%02d/%02d %02d:%02d:%02d"</span><br><span class="pln">    $b </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Started service %s on %s"</span><br><span class="pln">    $c </span><span class="pun">=</span><span class="pln"> </span><span class="str">"%s as %s\\%s: %d"</span><br><span class="pln">condition</span><span class="pun">:</span><br><span class="pln">    </span><span class="lit">2</span><span class="pln"> </span><span class="kwd">of</span><span class="pln"> them</span><br><span class="pun">}</span><br></pre><p>This would give us a good base of coverage, but we can do better by looking at the samples with <strong>sleep_mask</strong>enabled. If we look in memory where the MZ/PE header would normally be found, we now see it is obfuscated:</p><p><img src="https://images.contentstack.io/v3/assets/bltefdd0b53724fa2ce/blt68be7567c87b8f15/603e6eb71322a9094ddecf50/3-obfuscated-header-blog-detecting-cobalt-strike.png" data-sys-asset-uid="blt68be7567c87b8f15" alt="" style="display:block;margin:auto"></p><p>Quickly looking at this, we can see a lot of repeated bytes (0x80 in this case) where we would actually expect null bytes. This can be an indication that Beacon is using a simple one-byte XOR obfuscation. To confirm, we can use <a href="https://gchq.github.io/CyberChef/">CyberChef</a>:</p><p><img src="https://images.contentstack.io/v3/assets/bltefdd0b53724fa2ce/blt51fc44c10e0289c9/603e6ec708636f3d7749a259/4-cyberchef-blog-detecting-cobalt-strike.png" data-sys-asset-uid="blt51fc44c10e0289c9" alt="" style="display:block;margin:auto"></p><p>As you can see, the “This program cannot be run in DOS mode” string appears after decoding, confirming our theory. Because a single byte XOR is one of the oldest tricks in the book, yara actually supports native detection with the <a href="https://yara.readthedocs.io/en/stable/writingrules.html"><strong>xor</strong></a> modifier:</p><pre class="prettyprint prettyprinted" style=""><span class="pln">rule cobaltstrike_beacon_xor_strings</span><br><span class="pun">{</span><br><span class="pln">meta</span><span class="pun">:</span><br><span class="pln">    author </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Elastic"</span><br><span class="pln">    description </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Identifies XOR'd strings used in Cobalt Strike Beacon DLL."</span><br><span class="pln">strings</span><span class="pun">:</span><br><span class="pln">    $a </span><span class="pun">=</span><span class="pln"> </span><span class="str">"%02d/%02d/%02d %02d:%02d:%02d"</span><span class="pln"> xor</span><span class="pun">(</span><span class="lit">0x01</span><span class="pun">-</span><span class="lit">0xff</span><span class="pun">)</span><br><span class="pln">    $b </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Started service %s on %s"</span><span class="pln"> xor</span><span class="pun">(</span><span class="lit">0x01</span><span class="pun">-</span><span class="lit">0xff</span><span class="pun">)</span><br><span class="pln">    $c </span><span class="pun">=</span><span class="pln"> </span><span class="str">"%s as %s\\%s: %d"</span><span class="pln"> xor</span><span class="pun">(</span><span class="lit">0x01</span><span class="pun">-</span><span class="lit">0xff</span><span class="pun">)</span><br><span class="pln">condition</span><span class="pun">:</span><br><span class="pln">    </span><span class="lit">2</span><span class="pln"> </span><span class="kwd">of</span><span class="pln"> them</span><br><span class="pun">}</span><br></pre><p>We can confirm detection for our yara rules thus far by providing a PID while scanning:</p><p><img src="https://images.contentstack.io/v3/assets/bltefdd0b53724fa2ce/blte78d10de1484f20e/603e6ed5f9638443346d3da5/5-confirming-detection-blog-detecting-cobalt-strike.png" data-sys-asset-uid="blte78d10de1484f20e" alt="" style="display:block;margin:auto"></p><p>However, we are not quite done. After testing this signature on a sample with the latest version of Beacon (4.2 as of this writing), the obfuscation routine has been improved. The routine can be located by following the call stack as shown earlier. It now uses a 13-byte XOR key as shown in the following IDA Pro snippet:</p><p><img src="https://images.contentstack.io/v3/assets/bltefdd0b53724fa2ce/blt6ca50e04e513814b/603e6efbacf0d53d70c5accc/6-ida-pro-snippet-blog-detecting-cobalt-strike.png" data-sys-asset-uid="blt6ca50e04e513814b" alt="" style="display:block;margin:auto"><br></p><p>Fortunately, Beacon’s obfuscate-and-sleep option only obfuscates strings and data, leaving the entire code section ripe for signaturing. There is the question of which function in the code section we should develop a signature for, but that is worth its own blog post. For now, we can just create a signature on the deobfuscation routine, which should work well:</p><pre class="prettyprint prettyprinted" style=""><span class="pln">rule cobaltstrike_beacon_4_2_decrypt</span><br><span class="pun">{</span><br><span class="pln">meta</span><span class="pun">:</span><br><span class="pln">    author </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Elastic"</span><br><span class="pln">    description </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Identifies deobfuscation routine used in Cobalt Strike Beacon DLL version 4.2."</span><br><span class="pln">strings</span><span class="pun">:</span><br><span class="pln">    $a_x64 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">4C</span><span class="pln"> </span><span class="lit">8B</span><span class="pln"> </span><span class="lit">53</span><span class="pln"> </span><span class="lit">08</span><span class="pln"> </span><span class="lit">45</span><span class="pln"> </span><span class="lit">8B</span><span class="pln"> </span><span class="lit">0A</span><span class="pln"> </span><span class="lit">45</span><span class="pln"> </span><span class="lit">8B</span><span class="pln"> </span><span class="lit">5A</span><span class="pln"> </span><span class="lit">04</span><span class="pln"> </span><span class="lit">4D</span><span class="pln"> </span><span class="lit">8D</span><span class="pln"> </span><span class="lit">52</span><span class="pln"> </span><span class="lit">08</span><span class="pln"> </span><span class="lit">45</span><span class="pln"> </span><span class="lit">85</span><span class="pln"> C9 </span><span class="lit">75</span><span class="pln"> </span><span class="lit">05</span><span class="pln"> </span><span class="lit">45</span><span class="pln"> </span><span class="lit">85</span><span class="pln"> DB </span><span class="lit">74</span><span class="pln"> </span><span class="lit">33</span><span class="pln"> </span><span class="lit">45</span><span class="pln"> </span><span class="lit">3B</span><span class="pln"> CB </span><span class="lit">73</span><span class="pln"> E6 </span><span class="lit">49</span><span class="pln"> </span><span class="lit">8B</span><span class="pln"> F9 </span><span class="lit">4C</span><span class="pln"> </span><span class="lit">8B</span><span class="pln"> </span><span class="lit">03</span><span class="pun">}</span><br><span class="pln">    $a_x86 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">8B</span><span class="pln"> </span><span class="lit">46</span><span class="pln"> </span><span class="lit">04</span><span class="pln"> </span><span class="lit">8B</span><span class="pln"> </span><span class="lit">08</span><span class="pln"> </span><span class="lit">8B</span><span class="pln"> </span><span class="lit">50</span><span class="pln"> </span><span class="lit">04</span><span class="pln"> </span><span class="lit">83</span><span class="pln"> C0 </span><span class="lit">08</span><span class="pln"> </span><span class="lit">89</span><span class="pln"> </span><span class="lit">55</span><span class="pln"> </span><span class="lit">08</span><span class="pln"> </span><span class="lit">89</span><span class="pln"> </span><span class="lit">45</span><span class="pln"> </span><span class="lit">0C</span><span class="pln"> </span><span class="lit">85</span><span class="pln"> C9 </span><span class="lit">75</span><span class="pln"> </span><span class="lit">04</span><span class="pln"> </span><span class="lit">85</span><span class="pln"> D2 </span><span class="lit">74</span><span class="pln"> </span><span class="lit">23</span><span class="pln"> </span><span class="lit">3B</span><span class="pln"> CA </span><span class="lit">73</span><span class="pln"> E6 </span><span class="lit">8B</span><span class="pln"> </span><span class="lit">06</span><span class="pln"> </span><span class="lit">8D</span><span class="pln"> </span><span class="lit">3C</span><span class="pln"> </span><span class="lit">08</span><span class="pln"> </span><span class="lit">33</span><span class="pln"> D2</span><span class="pun">}</span><br><span class="pln">condition</span><span class="pun">:</span><br><span class="pln">     any </span><span class="kwd">of</span><span class="pln"> them</span><br><span class="pun">}</span><br></pre><p>We can validate that we can detect Beacon even while it is in its stealthy sleep state (both 32- and 64-bit variants):</p><p><img src="https://images.contentstack.io/v3/assets/bltefdd0b53724fa2ce/blt70a33ec8ee2d14c1/603e6eef7d801145b7fb6fd5/7-detection-beacon-blog-detecting-cobalt-strike.png" data-sys-asset-uid="blt70a33ec8ee2d14c1" alt="" style="display:block;margin:auto"></p><p>To build this into a more robust detection, we could regularly scan all processes on the system (or entire enterprise). This could be done with the following powershell one-liner:</p><pre class="prettyprint prettyprinted" style=""><span class="pln">powershell </span><span class="pun">-</span><span class="pln">command </span><span class="str">"Get-Process | ForEach-Object {c:\yara64.exe my_rules.yar $_.ID}"</span><br></pre><h2><strong>Wrapping up</strong></h2><p>Signature-based detection, while often looked down upon, is a valuable detection strategy — especially when we consider in-memory scanning. With only a handful of signatures, we can detect Cobalt Strike regardless of configuration or stealth features enabled with an effective false positive rate of zero.</p><h3>Reference hashes</h3><pre class="prettyprint prettyprinted" style=""><span class="lit">7d2c09a06d731a56bca7af2f5d3badef53624f025d77ababe6a14be28540a17a</span><br><span class="lit">277c2a0a18d7dc04993b6dc7ce873a086ab267391a9acbbc4a140e9c4658372a</span><br><span class="pln">A0788b85266fedd64dab834cb605a31b81fd11a3439dc3a6370bb34e512220e2</span><br><span class="lit">2db56e74f43b1a826beff9b577933135791ee44d8e66fa111b9b2af32948235c</span><br><span class="lit">3d65d80b1eb8626cf327c046db0c20ba4ed1b588b8c2f1286bc09b8f4da204f2</span><br></pre><h2>Learn more about Elastic Security</h2><p>Familiarize yourself (if you haven't already) with the powerful protection, detection, and response capabilities of Elastic Agent. Start your <a href="https://cloud.elastic.co/registration?elektra=en-security-page">free 14-day trial</a>&nbsp;(no credit card required) or <a href="https://www.elastic.co/downloads/">download our products</a>, free, for your on-prem deployment. And take advantage of our&nbsp;<a href="https://www.elastic.co/training/elastic-security-quick-start">Quick Start training</a>&nbsp;to set you up for success.</p></div><div class="layout layout-07"></div></div></div></div></div><div class="layout layout-07"></div></section></div></main><div id="elastic-footer"></div></div><next-route-announcer><p aria-live="assertive" id="__next-route-announcer__" role="alert" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; top: 0px; width: 1px; white-space: nowrap; overflow-wrap: normal;"></p></next-route-announcer></body></html>