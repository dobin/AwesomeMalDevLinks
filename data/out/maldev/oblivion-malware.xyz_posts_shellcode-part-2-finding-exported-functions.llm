Title:
Shellcode – Pt 2: Finding Exported Function

Type:
Blog Post

Short Summary (4–8 sentences max):
- This post explains how shellcode can resolve the address of an exported function from a DLL when the module base address is already known.  
- It walks through parsing the PE structure in memory: IMAGE_DOS_HEADER → e_lfanew → IMAGE_NT_HEADERS → OptionalHeader DataDirectory → IMAGE_EXPORT_DIRECTORY.  
- The core technique uses the export tables (AddressOfNames, AddressOfFunctions, AddressOfNameOrdinals) to map a function name to its ordinal and then to its RVA/function pointer.  
- It provides both an assembly-style routine (“LdrFuncAddr”) and a C implementation that loops over exported names and returns the resolved function address.  
- This is useful for malware developers, red teamers, and exploit/shellcode authors implementing custom API resolution without relying on GetProcAddress.  
- It’s important because export parsing is a foundational primitive for position-independent code and loader-less execution paths.

Technical Focus:
- PE header traversal (DOS header, NT headers, Optional Header)
- IMAGE_EXPORT_DIRECTORY parsing
- Export Address Table / Name Pointer Table / Ordinal Table usage
- RVA-to-VA conversion using module base
- Custom API resolution for shellcode (GetProcAddress replacement)

Use Cases:
- Implementing shellcode API resolution without importing functions
- Building reflective loaders or in-memory PE loaders
- Resolving WinAPI from kernel32/ntdll in constrained execution contexts
- Evasion-oriented payloads that avoid standard loader APIs

Keywords:
PE format, IMAGE_DOS_HEADER, e_lfanew, IMAGE_NT_HEADERS, IMAGE_OPTIONAL_HEADER, DataDirectory, IMAGE_EXPORT_DIRECTORY, AddressOfFunctions, AddressOfNames, AddressOfNameOrdinals, Export Address Table, Name Pointer Table, ordinals, RVA, VA, shellcode, custom GetProcAddress, reflective loading, Windows internals