# https://dennisbabkin.com/blog/?i=AAA03000

<!DOCTYPE html><html lang="en" dir="ltr" class="js no-touch localstorage sessionstorage contenteditable use-opacity-transitions embed-refresh embed-refresh-v2" style="--publisher-color: rgb(0,0,238); --publisher-color-safe: rgb(0,0,238); color-scheme: normal;">
<!--
**************************************************************************
(C) 2003-2026 www.dennisbabkin.com. All Rights Reserved.

Should you have anything to say:
 dennisbabkin.com/webmaster
 twitter.com/dennisbabkin
 facebook.com/dennisbabkin
  dennisbabkin.com/pgp
**************************************************************************
-->
<body class="serif dark-anchor">
<div class="page">
    
    	<div class="tabstwtr">
	</div>

	<div id="tab_twitter_swtwr">
		<a href="https://twitter.com/dennisbabkin" title="Contact On Twitter" target="_blank">
		<img border="0" src="https://dennisbabkin.com/php/images/twtr_logo.png">
		</a>
	</div>
	
	<div id="header_logo" style="background-image: url(https://dennisbabkin.com/php/images/blog_top_logo.png);">
	</div>
	<div id="header_logo_text">
	<h1>Blog Post</h1>
	<h2>Depths of Windows APC</h2>
	</div>
    <main>
	<div id="text_body_blog_tmpl">
	
    <h3 class="blog_h3">Aspects of internals of the Asynchronous Procedure Calls from the kernel mode.</h3>

	
	
	<div id="blog_main">
        <div id="blog_content">
        	<article>
            <div class="blog_main_div"><img src="https://dbimgs.s3-us-west-2.amazonaws.com/dpths-f-wndws-pc-spcts-f-snchrns-prcdr-cll-ntrnls-frm-th-krnl-md.jpg" alt="Depths of Windows APC - Aspects of internals of the Asynchronous Procedure Calls from the kernel mode." draggable="false" class="blog_main_img" style="max-width: 1280px;"></div><div id="text_body_blog">

<blockquote class="qt1 q_wrn">This article contains functions and features that are not documented by the original manufacturer.
							By following advice in this article, you're doing so at your own risk. The methods presented in this article
							may rely on internal implementation and may not work in the future.</blockquote>


<a name="intro"></a>
<h1>Intro<a href="https://dennisbabkin.com/blog/?i=AAA03000#intro" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h1>

<p>After our first blog post on the <a href="https://dennisbabkin.com/blog/?t=windows-apc-deep-dive-into-user-mode-asynchronous-procedure-calls">intricacies of the user-mode APCs</a>,
	we decided to expand this subject with additional in-depth details about the internals of the Asynchronous Procedure Calls (APC) implemented in the Windows OS.
</p>

<p>Let's begin, in no particular order.</p>



<a name="toc"></a>
<h1>Table of Contents<a href="https://dennisbabkin.com/blog/?i=AAA03000#toc" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h1>

<p>The following topics are just loosely connected to each other, so you may want to use the table of contents for easier navigation:</p>

<ul>
	<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#general_info">General APC Internals</a></li>
	<ul>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#attach_thread">Attaching a Thread To Another Process</a></li>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#apc_types">APC Types</a></li>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#kernel_apc_memory">Memory Imperative for Kernel APCs</a></li>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#block_kernel_apc">Interrupts &amp; Blocking Kernel APCs</a></li>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#rundown_routine">RundownRoutine Details</a></li>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#apc_drv_unload">APC &amp; Driver Unloading Nuances</a></li>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#early_inject_kernel32_dll">Case Study - Pitfalls of Early Injection Into Kernel32.dll</a></li>
	</ul>
	<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#user_mode_apc_kernel">User-Mode APCs From The Kernel</a></li>
	<ul>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#implement_user_mode_apc">Implementation of User-mode APCs</a></li>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#special_user_mode_apc">"Special" User-mode APCs</a></li>
	</ul>
	<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#broken_apc_xp">Broken User-Mode APC Implementation in Windows XP</a></li>
	<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#dll_inject_apc">Intricacies of DLL Injection Via User-Mode APC</a></li>
	<ul>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#pslinr_gotcha">PsSetLoadImageNotifyRoutine Gotcha</a></li>
	</ul>
	<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#zqat_vs_qua">ZwQueueApcThread vs QueueUserAPC</a></li>
	<ul>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#act_ctx_bug">Activation Context Handle Bug</a></li>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#bad_msdn_apc_doc">Cagey APC Documentation</a></li>
	</ul>
	<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#apc_demo">User-Mode APC Demo Code</a></li>
	<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#64_bit_apc_in_32_bit_proc">64-bit User-Mode APC In a 32-bit Process</a></li>
	<ul>
		<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#code_get_proc_mods">Code Sample to Get Process Modules</a></li>
	</ul>
	<li><a href="https://dennisbabkin.com/blog/?i=AAA03000#epilogue">Epilogue</a></li>
</ul>



<a name="general_info"></a>
<h1>General APC Internals<a href="https://dennisbabkin.com/blog/?i=AAA03000#general_info" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h1>

<blockquote class="qt1 q_inf">
	For the in-depth understanding of the internals of the kernel APCs refer to the following article: "
	<a href="https://dennisbabkin.com/inside_nt_apc/">Inside NT's Asynchronous Procedure Call</a>".
	We won't be repeating what has been said there. We will add some additional, lesser known APC-related details instead.
</blockquote>

<p>To mention briefly, technically APC is just a few dozen of bytes in the kernel memory, known as the <code class="blg_cq">KAPC</code> struct:</p>

<a name="kapc"></a>
<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode0" style="height: 12em; overflow-y: auto;"><code><span class="c_kw">typedef</span> <span class="c_kw">struct</span> <span class="c_ac">_KAPC</span> {
	<span class="c_ac">UCHAR</span> Type;
	<span class="c_ac">UCHAR</span> SpareByte0;
	<span class="c_ac">UCHAR</span> Size;
	<span class="c_ac">UCHAR</span> SpareByte1;
	<span class="c_ac">ULONG</span> SpareLong0;
	<span class="c_ac">_KTHREAD</span> * Thread;
	<span class="c_ac">_LIST_ENTRY</span> ApcListEntry;
	<span class="c_kw">void</span> (* KernelRoutine)( <span class="c_ac">_KAPC</span> * , <span class="c_kw">void</span> (* * )( <span class="c_kw">void</span> * , <span class="c_kw">void</span> * , <span class="c_kw">void</span> * ), <span class="c_kw">void</span> * * , <span class="c_kw">void</span> * * , <span class="c_kw">void</span> * * );
	<span class="c_kw">void</span> (* RundownRoutine)( <span class="c_ac">_KAPC</span> * );
	<span class="c_kw">void</span> (* NormalRoutine)( <span class="c_kw">void</span> * , <span class="c_kw">void</span> * , <span class="c_kw">void</span> * );
	<span class="c_kw">void</span> * Reserved[0x3];
	<span class="c_kw">void</span> * NormalContext;
	<span class="c_kw">void</span> * SystemArgument1;
	<span class="c_kw">void</span> * SystemArgument2;
	<span class="c_ac">CHAR</span> ApcStateIndex;
	<span class="mrk1"><span class="c_ac">CHAR</span> ApcMode</span>;
	<span class="c_ac">UCHAR</span> Inserted;
}<span class="c_ac">KAPC</span>, *PKAPC;</code></pre></div>

<p>That struct is a part of a double-linked <code class="blg_cq">LIST_ENTRY</code> inside the <code class="blg_cq">KAPC_STATE</code> struct:</p>

<a name="kapc_state"></a>
<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode1" style="height: 12em; overflow-y: auto;"><code><span class="c_kw">typedef</span> <span class="c_kw">struct</span> <span class="c_ac">_KAPC_STATE</span> {
	<span class="mrk1"><span class="c_ac">_LIST_ENTRY</span> ApcListHead</span>[0x2];
	<span class="c_ac">_KPROCESS</span> * Process;
	<span class="c_ac">UCHAR</span> InProgressFlags;
	<span class="c_ac">UCHAR</span> KernelApcInProgress : 01; <span class="c_cmt">// 0x01;</span>
	<span class="c_ac">UCHAR</span> SpecialApcInProgress : 01; <span class="c_cmt">// 0x02;</span>
	<span class="c_ac">UCHAR</span> KernelApcPending;
	<span class="c_ac">UCHAR</span> UserApcPendingAll;
	<span class="c_ac">UCHAR</span> SpecialUserApcPending : 01; <span class="c_cmt">// 0x01;</span>
	<span class="c_ac">UCHAR</span> UserApcPending : 01; <span class="c_cmt">// 0x02;</span>
}<span class="c_ac">KAPC_STATE</span>, *PKAPC_STATE;</code></pre></div>

<p>And <code class="blg_cq">KAPC_STATE</code> itself is a part of the thread object, stored in the <code class="blg_cq">KTHREAD</code> struct in the kernel:</p>

<a name="kthread"></a>
<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode2" style="height: 12em; overflow-y: auto;"><code><span class="c_kw">typedef</span> <span class="c_kw">struct</span> <span class="c_ac">_KTHREAD</span> {
	<span class="c_ac">_DISPATCHER_HEADER</span> Header;
	<span class="c_kw">void</span> * SListFaultAddress;
	<span class="c_ac">ULONGLONG</span> QuantumTarget;
	<span class="c_kw">void</span> * InitialStack;
	<span class="c_kw">void</span> * <span class="c_kw">volatile</span> StackLimit;
	<span class="c_kw">void</span> * StackBase;
	<span class="c_ac">ULONGLONG</span> ThreadLock;
	<span class="c_ac">ULONGLONG</span> <span class="c_kw">volatile</span> CycleTime;
	<span class="c_ac">ULONG</span> CurrentRunTime;
	<span class="c_ac">ULONG</span> ExpectedRunTime;
	<span class="c_kw">void</span> * KernelStack;
	<span class="c_ac">_XSAVE_FORMAT</span> * StateSaveArea;
	<span class="c_ac">_KSCHEDULING_GROUP</span> * <span class="c_kw">volatile</span> SchedulingGroup;
	<span class="c_ac">_KWAIT_STATUS_REGISTER</span> WaitRegister;
	<span class="c_ac">UCHAR</span> <span class="c_kw">volatile</span> Running;
	<span class="c_ac">UCHAR</span> Alerted[0x2];
	<span class="c_ac">ULONG</span> AutoBoostActive : 01; <span class="c_cmt">// 0x00000001;</span>
	<span class="c_ac">ULONG</span> ReadyTransition : 01; <span class="c_cmt">// 0x00000002;</span>
	<span class="c_ac">ULONG</span> WaitNext : 01; <span class="c_cmt">// 0x00000004;</span>
	<span class="c_ac">ULONG</span> SystemAffinityActive : 01; <span class="c_cmt">// 0x00000008;</span>
	<span class="c_ac">ULONG</span> Alertable : 01; <span class="c_cmt">// 0x00000010;</span>
	<span class="c_ac">ULONG</span> UserStackWalkActive : 01; <span class="c_cmt">// 0x00000020;</span>
	<span class="c_ac">ULONG</span> ApcInterruptRequest : 01; <span class="c_cmt">// 0x00000040;</span>
	<span class="c_ac">ULONG</span> QuantumEndMigrate : 01; <span class="c_cmt">// 0x00000080;</span>
	<span class="c_ac">ULONG</span> UmsDirectedSwitchEnable : 01; <span class="c_cmt">// 0x00000100;</span>
	<span class="c_ac">ULONG</span> TimerActive : 01; <span class="c_cmt">// 0x00000200;</span>
	<span class="c_ac">ULONG</span> SystemThread : 01; <span class="c_cmt">// 0x00000400;</span>
	<span class="c_ac">ULONG</span> ProcessDetachActive : 01; <span class="c_cmt">// 0x00000800;</span>
	<span class="c_ac">ULONG</span> CalloutActive : 01; <span class="c_cmt">// 0x00001000;</span>
	<span class="c_ac">ULONG</span> ScbReadyQueue : 01; <span class="c_cmt">// 0x00002000;</span>
	<span class="c_ac">ULONG</span> ApcQueueable : 01; <span class="c_cmt">// 0x00004000;</span>
	<span class="c_ac">ULONG</span> ReservedStackInUse : 01; <span class="c_cmt">// 0x00008000;</span>
	<span class="c_ac">ULONG</span> UmsPerformingSyscall : 01; <span class="c_cmt">// 0x00010000;</span>
	<span class="c_ac">ULONG</span> TimerSuspended : 01; <span class="c_cmt">// 0x00020000;</span>
	<span class="c_ac">ULONG</span> SuspendedWaitMode : 01; <span class="c_cmt">// 0x00040000;</span>
	<span class="c_ac">ULONG</span> SuspendSchedulerApcWait : 01; <span class="c_cmt">// 0x00080000;</span>
	<span class="c_ac">ULONG</span> CetUserShadowStack : 01; <span class="c_cmt">// 0x00100000;</span>
	<span class="c_ac">ULONG</span> BypassProcessFreeze : 01; <span class="c_cmt">// 0x00200000;</span>
	<span class="c_ac">ULONG</span> Reserved : 10; <span class="c_cmt">// 0xffc00000;</span>
	<span class="c_ac">LONG</span> MiscFlags;
	<span class="c_ac">ULONG</span> BamQosLevel : 02; <span class="c_cmt">// 0x00000003;</span>
	<span class="c_ac">ULONG</span> AutoAlignment : 01; <span class="c_cmt">// 0x00000004;</span>
	<span class="c_ac">ULONG</span> DisableBoost : 01; <span class="c_cmt">// 0x00000008;</span>
	<span class="c_ac">ULONG</span> AlertedByThreadId : 01; <span class="c_cmt">// 0x00000010;</span>
	<span class="c_ac">ULONG</span> QuantumDonation : 01; <span class="c_cmt">// 0x00000020;</span>
	<span class="c_ac">ULONG</span> EnableStackSwap : 01; <span class="c_cmt">// 0x00000040;</span>
	<span class="c_ac">ULONG</span> GuiThread : 01; <span class="c_cmt">// 0x00000080;</span>
	<span class="c_ac">ULONG</span> DisableQuantum : 01; <span class="c_cmt">// 0x00000100;</span>
	<span class="c_ac">ULONG</span> ChargeOnlySchedulingGroup : 01; <span class="c_cmt">// 0x00000200;</span>
	<span class="c_ac">ULONG</span> DeferPreemption : 01; <span class="c_cmt">// 0x00000400;</span>
	<span class="c_ac">ULONG</span> QueueDeferPreemption : 01; <span class="c_cmt">// 0x00000800;</span>
	<span class="c_ac">ULONG</span> ForceDeferSchedule : 01; <span class="c_cmt">// 0x00001000;</span>
	<span class="c_ac">ULONG</span> SharedReadyQueueAffinity : 01; <span class="c_cmt">// 0x00002000;</span>
	<span class="c_ac">ULONG</span> FreezeCount : 01; <span class="c_cmt">// 0x00004000;</span>
	<span class="c_ac">ULONG</span> TerminationApcRequest : 01; <span class="c_cmt">// 0x00008000;</span>
	<span class="c_ac">ULONG</span> AutoBoostEntriesExhausted : 01; <span class="c_cmt">// 0x00010000;</span>
	<span class="c_ac">ULONG</span> KernelStackResident : 01; <span class="c_cmt">// 0x00020000;</span>
	<span class="c_ac">ULONG</span> TerminateRequestReason : 02; <span class="c_cmt">// 0x000c0000;</span>
	<span class="c_ac">ULONG</span> ProcessStackCountDecremented : 01; <span class="c_cmt">// 0x00100000;</span>
	<span class="c_ac">ULONG</span> RestrictedGuiThread : 01; <span class="c_cmt">// 0x00200000;</span>
	<span class="c_ac">ULONG</span> VpBackingThread : 01; <span class="c_cmt">// 0x00400000;</span>
	<span class="c_ac">ULONG</span> ThreadFlagsSpare : 01; <span class="c_cmt">// 0x00800000;</span>
	<span class="c_ac">ULONG</span> EtwStackTraceApcInserted : 08; <span class="c_cmt">// 0xff000000;</span>
	<span class="c_ac">LONG</span> <span class="c_kw">volatile</span> ThreadFlags;
	<span class="c_ac">UCHAR</span> <span class="c_kw">volatile</span> Tag;
	<span class="c_ac">UCHAR</span> SystemHeteroCpuPolicy;
	<span class="c_ac">UCHAR</span> UserHeteroCpuPolicy : 07; <span class="c_cmt">// 0x7f;</span>
	<span class="c_ac">UCHAR</span> ExplicitSystemHeteroCpuPolicy : 01; <span class="c_cmt">// 0x80;</span>
	<span class="c_ac">UCHAR</span> RunningNonRetpolineCode : 01; <span class="c_cmt">// 0x01;</span>
	<span class="c_ac">UCHAR</span> SpecCtrlSpare : 07; <span class="c_cmt">// 0xfe;</span>
	<span class="c_ac">UCHAR</span> SpecCtrl;
	<span class="c_ac">ULONG</span> SystemCallNumber;
	<span class="c_ac">ULONG</span> ReadyTime;
	<span class="c_kw">void</span> * FirstArgument;
	<span class="c_ac">_KTRAP_FRAME</span> * TrapFrame;
	<span class="mrk1"><span class="c_ac">_KAPC_STATE</span> ApcState</span>;
	<span class="c_ac">UCHAR</span> ApcStateFill[0x2b];
	<span class="c_ac">CHAR</span> Priority;
	<span class="c_ac">ULONG</span> UserIdealProcessor;
	<span class="c_ac">LONGLONG</span> <span class="c_kw">volatile</span> WaitStatus;
	<span class="c_ac">_KWAIT_BLOCK</span> * WaitBlockList;
	<span class="c_ac">_LIST_ENTRY</span> WaitListEntry;
	<span class="c_ac">_SINGLE_LIST_ENTRY</span> SwapListEntry;
	<span class="c_ac">_DISPATCHER_HEADER</span> * <span class="c_kw">volatile</span> Queue;
	<span class="c_kw">void</span> * Teb;
	<span class="c_ac">ULONGLONG</span> RelativeTimerBias;
	<span class="c_ac">_KTIMER</span> Timer;
	<span class="c_ac">_KWAIT_BLOCK</span> WaitBlock[0x4];
	<span class="c_ac">UCHAR</span> WaitBlockFill4[0x14];
	<span class="c_ac">ULONG</span> ContextSwitches;
	<span class="c_ac">UCHAR</span> WaitBlockFill5[0x44];
	<span class="c_ac">UCHAR</span> <span class="c_kw">volatile</span> State;
	<span class="c_ac">CHAR</span> Spare13;
	<span class="c_ac">UCHAR</span> WaitIrql;
	<span class="c_ac">CHAR</span> WaitMode;
	<span class="c_ac">UCHAR</span> WaitBlockFill6[0x74];
	<span class="c_ac">ULONG</span> WaitTime;
	<span class="c_ac">UCHAR</span> WaitBlockFill7[0xa4];
	<span class="c_ac">SHORT</span> KernelApcDisable;
	<span class="c_ac">SHORT</span> SpecialApcDisable;
	<span class="c_ac">ULONG</span> CombinedApcDisable;
	<span class="c_ac">UCHAR</span> WaitBlockFill8[0x28];
	<span class="c_ac">_KTHREAD_COUNTERS</span> * ThreadCounters;
	<span class="c_ac">UCHAR</span> WaitBlockFill9[0x58];
	<span class="c_ac">_XSTATE_SAVE</span> * XStateSave;
	<span class="c_ac">UCHAR</span> WaitBlockFill10[0x88];
	<span class="c_kw">void</span> * <span class="c_kw">volatile</span> Win32Thread;
	<span class="c_ac">UCHAR</span> WaitBlockFill11[0xb0];
	<span class="c_ac">_UMS_CONTROL_BLOCK</span> * Ucb;
	<span class="c_ac">_KUMS_CONTEXT_HEADER</span> * <span class="c_kw">volatile</span> Uch;
	<span class="c_kw">void</span> * Spare21;
	<span class="c_ac">_LIST_ENTRY</span> QueueListEntry;
	<span class="c_ac">ULONG</span> <span class="c_kw">volatile</span> NextProcessor;
	<span class="c_ac">ULONG</span> NextProcessorNumber : 31; <span class="c_cmt">// 0x7fffffff;</span>
	<span class="c_ac">ULONG</span> SharedReadyQueue : 01; <span class="c_cmt">// 0x80000000;</span>
	<span class="c_ac">LONG</span> QueuePriority;
	<span class="c_ac">_KPROCESS</span> * Process;
	<span class="c_ac">_GROUP_AFFINITY</span> UserAffinity;
	<span class="c_ac">UCHAR</span> UserAffinityFill[0xa];
	<span class="c_ac">CHAR</span> PreviousMode;
	<span class="c_ac">CHAR</span> BasePriority;
	<span class="c_ac">CHAR</span> PriorityDecrement;
	<span class="c_ac">UCHAR</span> ForegroundBoost : 04; <span class="c_cmt">// 0x0f;</span>
	<span class="c_ac">UCHAR</span> UnusualBoost : 04; <span class="c_cmt">// 0xf0;</span>
	<span class="c_ac">UCHAR</span> Preempted;
	<span class="c_ac">UCHAR</span> AdjustReason;
	<span class="c_ac">CHAR</span> AdjustIncrement;
	<span class="c_ac">ULONGLONG</span> AffinityVersion;
	<span class="c_ac">_GROUP_AFFINITY</span> Affinity;
	<span class="c_ac">UCHAR</span> AffinityFill[0xa];
	<span class="c_ac">UCHAR</span> ApcStateIndex;
	<span class="c_ac">UCHAR</span> WaitBlockCount;
	<span class="c_ac">ULONG</span> IdealProcessor;
	<span class="c_ac">ULONGLONG</span> NpxState;
	<span class="c_ac">_KAPC_STATE</span> SavedApcState;
	<span class="c_ac">UCHAR</span> SavedApcStateFill[0x2b];
	<span class="c_ac">UCHAR</span> WaitReason;
	<span class="c_ac">CHAR</span> SuspendCount;
	<span class="c_ac">CHAR</span> Saturation;
	<span class="c_ac">USHORT</span> SListFaultCount;
	<span class="c_ac">_KAPC</span> SchedulerApc;
	<span class="c_ac">UCHAR</span> SchedulerApcFill0[0x1];
	<span class="c_ac">UCHAR</span> ResourceIndex;
	<span class="c_ac">UCHAR</span> SchedulerApcFill1[0x3];
	<span class="c_ac">UCHAR</span> QuantumReset;
	<span class="c_ac">UCHAR</span> SchedulerApcFill2[0x4];
	<span class="c_ac">ULONG</span> KernelTime;
	<span class="c_ac">UCHAR</span> SchedulerApcFill3[0x40];
	<span class="c_ac">_KPRCB</span> * <span class="c_kw">volatile</span> WaitPrcb;
	<span class="c_ac">UCHAR</span> SchedulerApcFill4[0x48];
	<span class="c_kw">void</span> * LegoData;
	<span class="c_ac">UCHAR</span> SchedulerApcFill5[0x53];
	<span class="c_ac">UCHAR</span> CallbackNestingLevel;
	<span class="c_ac">ULONG</span> UserTime;
	<span class="c_ac">_KEVENT</span> SuspendEvent;
	<span class="c_ac">_LIST_ENTRY</span> ThreadListEntry;
	<span class="c_ac">_LIST_ENTRY</span> MutantListHead;
	<span class="c_ac">UCHAR</span> AbEntrySummary;
	<span class="c_ac">UCHAR</span> AbWaitEntryCount;
	<span class="c_ac">UCHAR</span> AbAllocationRegionCount;
	<span class="c_ac">CHAR</span> SystemPriority;
	<span class="c_ac">ULONG</span> SecureThreadCookie;
	<span class="c_ac">_KLOCK_ENTRY</span> LockEntries[0x6];
	<span class="c_ac">_SINGLE_LIST_ENTRY</span> PropagateBoostsEntry;
	<span class="c_ac">_SINGLE_LIST_ENTRY</span> IoSelfBoostsEntry;
	<span class="c_ac">UCHAR</span> PriorityFloorCounts[0x10];
	<span class="c_ac">ULONG</span> PriorityFloorSummary;
	<span class="c_ac">LONG</span> <span class="c_kw">volatile</span> AbCompletedIoBoostCount;
	<span class="c_ac">LONG</span> <span class="c_kw">volatile</span> AbCompletedIoQoSBoostCount;
	<span class="c_ac">SHORT</span> <span class="c_kw">volatile</span> KeReferenceCount;
	<span class="c_ac">UCHAR</span> AbOrphanedEntrySummary;
	<span class="c_ac">UCHAR</span> AbOwnedEntryCount;
	<span class="c_ac">ULONG</span> ForegroundLossTime;
	<span class="c_ac">_LIST_ENTRY</span> GlobalForegroundListEntry;
	<span class="c_ac">_SINGLE_LIST_ENTRY</span> ForegroundDpcStackListEntry;
	<span class="c_ac">ULONGLONG</span> InGlobalForegroundList;
	<span class="c_ac">LONGLONG</span> ReadOperationCount;
	<span class="c_ac">LONGLONG</span> WriteOperationCount;
	<span class="c_ac">LONGLONG</span> OtherOperationCount;
	<span class="c_ac">LONGLONG</span> ReadTransferCount;
	<span class="c_ac">LONGLONG</span> WriteTransferCount;
	<span class="c_ac">LONGLONG</span> OtherTransferCount;
	<span class="c_ac">_KSCB</span> * QueuedScb;
	<span class="c_ac">ULONG</span> <span class="c_kw">volatile</span> ThreadTimerDelay;
	<span class="c_ac">LONG</span> <span class="c_kw">volatile</span> ThreadFlags2;
	<span class="c_ac">ULONG</span> PpmPolicy : 02; <span class="c_cmt">// 0x00000003;</span>
	<span class="c_ac">ULONG</span> ThreadFlags2Reserved : 30; <span class="c_cmt">// 0xfffffffc;</span>
	<span class="c_ac">ULONGLONG</span> TracingPrivate[0x1];
	<span class="c_kw">void</span> * SchedulerAssist;
	<span class="c_kw">void</span> * <span class="c_kw">volatile</span> AbWaitObject;
}<span class="c_ac">KTHREAD</span>, *PKTHREAD;</code></pre></div>


<a name="attach_thread"></a>
<h2>Attaching a Thread To Another Process<a href="https://dennisbabkin.com/blog/?i=AAA03000#attach_thread" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>One thing worthy to note here is that any thread can be temporarily attached to another process through a call to
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-kestackattachprocess" rel="external nofollow" target="_blank"><code class="blg_cq">KeStackAttachProcess</code></a> 
	(and receive <a href="https://dennisbabkin.com/blog/?i=AAA03000#kapc_state"><code class="blg_cq">KAPC_STATE</code></a> object, see its <code class="blg_cq">ApcState</code> parameter),
	or be detached via a call to <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-keunstackdetachprocess" rel="external nofollow" target="_blank"><code class="blg_cq">KeUnstackDetachProcess</code></a>.
	But it's a subtle nuance that can lead to problems, so kernel developers needs to be aware of it.
</p>

<p>Thus, it is important to understand that when we initialize an APC object using undocumented but exported <code class="blg_cq">KeInitializeApc</code> call:</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode3"><code><span class="c_ac">VOID</span> <span class="c_fun">KeInitializeApc</span>(
	<span class="c_ac">IN</span> <span class="c_ac">PRKAPC</span> Apc,									<span class="c_cmt">//pointer to KAPC</span>
	<span class="c_ac">IN</span> <span class="c_ac">PKTHREAD</span> Thread,
	<span class="c_ac">IN</span> <span class="c_ac">KAPC_ENVIRONMENT</span> Environment,
	<span class="c_ac">IN</span> <span class="c_ac">PKKERNEL_ROUTINE</span> KernelRoutine,
	<span class="c_ac">IN</span> <span class="c_ac">PKRUNDOWN_ROUTINE</span> RundownRoutine <span class="c_ac">OPTIONAL</span>,
	<span class="c_ac">IN</span> <span class="c_ac">PKNORMAL_ROUTINE</span> NormalRoutine <span class="c_ac">OPTIONAL</span>,
	<span class="c_ac">IN</span> <span class="c_ac">KPROCESSOR_MODE</span> ApcMode,
	<span class="c_ac">IN</span> <span class="c_ac">PVOID</span> NormalContext
);</code></pre></div>

<p>We provide its <code class="blg_cq">KAPC_ENVIRONMENT</code> parameter, that is enumerated as:</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode4"><code><span class="c_kw">typedef</span> <span class="c_kw">enum</span> <span class="c_ac">_KAPC_ENVIRONMENT</span> {
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment
} KAPC_ENVIRONMENT;</code></pre></div>

<p>This parameter specifies APC <em>environment</em>. Or, in other words, when we insert an APC we tell the system whether it should be activated for the current thread, or
	if it should be activated for the <em>saved</em> state (<a href="https://dennisbabkin.com/blog/?i=AAA03000#kthread"><code class="blg_cq">KTHREAD::SavedApcState</code></a>) before the thread was attached to another process.
	This parameter is later saved in the <a href="https://dennisbabkin.com/blog/?i=AAA03000#kapc"><code class="blg_cq">KAPC::ApcStateIndex</code></a> member.
</p>

<p>To illustrate this concept let's review the code inside <code class="blg_cq">KiInsertQueueApc</code> that has the following logic:</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode5"><code><span class="c_cmt">// KiInsertQueueApc() excerpt:</span>

Thread = Apc-&gt;Thread;
<span class="c_ac">PKAPC_STATE</span> ApcState;

<span class="c_kw">if</span> (Apc-&gt;ApcStateIndex == 0 &amp;&amp; Thread-&gt;ApcStateIndex != 0)
{
	ApcState = &amp;Thread-&gt;SavedApcState;
}
<span class="c_kw">else</span>
{
	Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;
	ApcState = &amp;Thread-&gt;ApcState;
}</code></pre></div>

<p>So basically <a href="https://dennisbabkin.com/blog/?i=AAA03000#kapc"><code class="blg_cq">KAPC::ApcStateIndex</code></a> is a boolean value:</p>
<ul>
	<li><strong>Non-0:</strong> means that APC is inserted into the current thread. Or, in other words, that the APC should be executed in the context of the current process, 
		in which the thread is currently running.</li>
	<li><strong>0:</strong> means that the APC should be executed only in the original process, or the one before the thread was attached to the current process.</li>
</ul>

<p>Then inside the <code class="blg_cq">KeStackAttachProcess</code> function there's the following logic:</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode6"><code><span class="c_cmt">// KeStackAttachProcess() excerpt:</span>

<span class="c_kw">if</span> (Thread-&gt;ApcStateIndex != 0)
{
	<span class="c_fun">KiAttachProcess</span>(Thread, Process, &amp;LockHandle, ApcState);
}
<span class="c_kw">else</span>
{
	<span class="c_fun">KiAttachProcess</span>(Thread, Process, &amp;LockHandle, &amp;Thread-&gt;SavedApcState);
	ApcState-&gt;Process = <span class="c_ac">NULL</span>;
}</code></pre></div>

<p>Which means that when we first attach a thread to another process, i.e. if its <a href="https://dennisbabkin.com/blog/?i=AAA03000#kapc"><code class="blg_cq">KAPC::ApcStateIndex</code></a> is 0, the current <a href="https://dennisbabkin.com/blog/?i=AAA03000#kthread"><code class="blg_cq">KTHREAD::ApcState</code></a> 
	is saved in <a href="https://dennisbabkin.com/blog/?i=AAA03000#kthread"><code class="blg_cq">KTHREAD::SavedApcState</code></a>,
	and the passed <code class="blg_cq">ApcState</code> is not used (apart from setting its <a href="https://dennisbabkin.com/blog/?i=AAA03000#kapc_state"><code class="blg_cq">KAPC_STATE::Process</code></a> to 0 to signal that the state was saved in 
	<a href="https://dennisbabkin.com/blog/?i=AAA03000#kthread"><code class="blg_cq">KTHREAD::SavedApcState</code></a>.)
</p>

<p>But if we have a recursive attachment, or when a thread was already attached to another process when <code class="blg_cq">KeStackAttachProcess</code> was called again, in that case the APC state
	is saved in the <code class="blg_cq">ApcState</code> object that was passed into the function.
</p>

<p>The reason for this logic is to have the original APC state for the thread to be always accessible by the system. This can be used either to insert an APC into the original thread,
	or to detach the thread back to the original process via a call to
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-keunstackdetachprocess" rel="external nofollow" target="_blank"><code class="blg_cq">KeUnstackDetachProcess</code></a>.
</p>





<a name="apc_types"></a>
<h2>APC Types<a href="https://dennisbabkin.com/blog/?i=AAA03000#apc_types" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>APCs come in two basic flavors: kernel- and user-mode APCs.
	Kernel-mode APCs give developers more flexibility in the way they are queued and processed. 
	(We discussed user-mode APCs in <a href="https://dennisbabkin.com/blog/?t=windows-apc-deep-dive-into-user-mode-asynchronous-procedure-calls">this blog post</a> already.)
	Kernel-mode APCs are not accessible directly to the user-mode programmers.
</p>

<p>Internally <a href="https://dennisbabkin.com/blog/?i=AAA03000#kapc_state"><code class="blg_cq">KAPC_STATE::ApcListHead</code></a> contains 2 lists for kernel-mode and user-mode APCs that were queued for the thread, respectively:</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode7"><code><span class="c_kw">typedef</span> <span class="c_kw">enum</span> <span class="c_ac">_MODE</span> {
	KernelMode = 0x0,
	UserMode = 0x1,
	MaximumMode = 0x2
}MODE;</code></pre></div>

<p>The kernel uses those lists to maintain the state of each type of APCs. The <a href="https://dennisbabkin.com/blog/?i=AAA03000#kapc"><code class="blg_cq">KAPC::ApcMode</code></a> serves as an index into <code class="blg_cq">KAPC_STATE::ApcListHead</code> when APC is queued
	or processed by a call to <code class="blg_cq">KeInsertQueueApc</code>:
</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode8"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">NtQueueApcThread</span>(
	<span class="c_ac">IN</span> <span class="c_ac">HANDLE</span> Thread,
	<span class="c_ac">IN</span> <span class="c_ac">PKNORMAL_ROUTINE</span> NormalRoutine,
	<span class="c_ac">IN</span> <span class="c_ac">PVOID</span> NormalContext,
	<span class="c_ac">IN</span> <span class="c_ac">PVOID</span> SystemArgument1,
	<span class="c_ac">IN</span> <span class="c_ac">PVOID</span> SystemArgument2
);</code></pre></div>



<a name="kernel_apc_memory"></a>
<h2>Memory Imperative for Kernel APCs<a href="https://dennisbabkin.com/blog/?i=AAA03000#kernel_apc_memory" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>Many novice kernel developers make a mistake of specifying the wrong type of memory for kernel-mode APCs. This is important to realize to prevent
	all sorts of unexpected <a href="https://en.wikipedia.org/wiki/Blue_screen_of_death" rel="external nofollow" target="_blank">BSOD</a>s.
</p>

<p>The rule of thumb to remember is that <a href="https://dennisbabkin.com/blog/?i=AAA03000#kapc"><code class="blg_cq">KAPC</code></a> struct has to be allocated from the 
	<a href="https://docs.microsoft.com/en-us/windows/win32/memory/memory-pools" rel="external nofollow" target="_blank"><code class="blg_cq">NonPagedPool</code></a> memory <strong>only</strong> (or from a similar 
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_pool_type" rel="external nofollow" target="_blank"><code class="blg_cq">NonPagedPool*</code></a> type.)
	This is also true even if you initialize and insert your APC at the
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/managing-hardware-priorities" rel="external nofollow" target="_blank"><code class="blg_cq">PASSIVE_LEVEL</code></a> IRQL.
</p>

<p>The reason for such restriction comes from the fact that some other APC can be also inserted into the same thread running at the higher <code class="blg_cq">DISPATCH_LEVEL</code> IRQL. During insertion
	into the double-linked APC list, the system will try to access the other <code class="blg_cq">KAPC</code> structs that were already in the list. So if any of them were allocated from the <code class="blg_cq">PagedPool</code>
	you will get an indirect access to a paged memory from the <code class="blg_cq">DISPATCH_LEVEL</code>, which is a guaranteed way for <a href="https://en.wikipedia.org/wiki/Blue_screen_of_death" rel="external nofollow" target="_blank">BSOD</a>.
</p>

<p>The tricky nature of the situation that I described above is that it is very rare and may not come up during the development and testing stage. This will be very
	hard to diagnose in your production code, since BSOD as I explained above, may happen at a later time in an environment that you do not control.
</p>

<a name="block_kernel_apc"></a>
<h2>Interrupts &amp; Blocking Kernel APCs<a href="https://dennisbabkin.com/blog/?i=AAA03000#block_kernel_apc" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>The important thing to remember about kernel-mode APC is that it works as an <em>interrupt</em>, which means that it can happen between (almost) any two CPU instructions in your code.
</p>

<p>Kernel mode development allows us to prevent execution of APCs. This should be resorted to only in some exceptional parts of the code by raising the IRQL to 
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/managing-hardware-priorities" rel="external nofollow" target="_blank"><code class="blg_cq">APC_LEVEL</code></a> or above, or by placing your code between
	calls to <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-keentercriticalregion" rel="external nofollow" target="_blank"><code class="blg_cq">KeEnterCriticalRegion</code></a> and 
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-keleavecriticalregion" rel="external nofollow" target="_blank"><code class="blg_cq">KeLeaveCriticalRegion</code></a>.
	(Note that those functions would not prevent execution of so called <em>special kernel APCs</em>, that can be blocked only by raising the IRQL level.)
</p>

<p>An interesting fact about the restriction that I showed above is that if an APC arrives within the critical region, 
	it won't be lost, and will be processed later inside either of the following functions: 
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-keleaveguardedregion" rel="external nofollow" target="_blank"><code class="blg_cq">KeLeaveGuardedRegion</code></a>, 
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-keleavecriticalregion" rel="external nofollow" target="_blank"><code class="blg_cq">KeLeaveCriticalRegion</code></a>,
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kelowerirql" rel="external nofollow" target="_blank"><code class="blg_cq">KeLowerIrql*</code></a>, or at the end of the critical region.
</p>


<a name="rundown_routine"></a>
<h2>RundownRoutine Details<a href="https://dennisbabkin.com/blog/?i=AAA03000#rundown_routine" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>If I quote <a href="https://dennisbabkin.com/inside_nt_apc/">this blog post</a> again:</p>

<blockquote class="qt0">
	Optionally, either kind of APC may define a valid RundownRoutine. This routine must reside in kernel memory and is only called when the system needs to discard
	the contents of the APC queues, such as when the thread exits. In this case, neither KernelRoutine nor NormalRoutine are executed, just the RundownRoutine. 
	An APC without such a routine will be deleted.
</blockquote>

<p>There are couple of additional points that could be added to it:</p>

<ul>
	<li>The <code class="blg_cq">RundownRoutine</code> callback is only invoked when a thread is exiting while it still has pending APCs queued. (Which is quite possible for user-mode APCs.)
		But it will not be invoked otherwise.
	</li>

	<li>If <code class="blg_cq">RundownRoutine</code> is <code class="blg_cq">NULL</code>, then the kernel simply calls <code class="blg_cq">ExFreeProol(Apc)</code>, which is what was assumed under 
	"<em>APC without such a routine will be deleted</em>" in that blog post. But of course, if the programmer allocated memory with a call to
	<code class="blg_cq">ExAllocatePool(NonPagedPool, sizeof(KAPC))</code> and no additional allocations were involved after that, then we can rely on the system to deallocate it for us.
	But if <code class="blg_cq">KAPC</code> was allocated differently, or if the address of <code class="blg_cq">KAPC</code> does not match the beginning of allocated memory, or due to other reasons, then
	all deallocations must be performed within the <code class="blg_cq">RundownRoutine</code> callback override.
	</li>
</ul>



<a name="apc_drv_unload"></a>
<h2>APC &amp; Driver Unloading Nuances<a href="https://dennisbabkin.com/blog/?i=AAA03000#apc_drv_unload" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>There's one subtle moment when it comes to invoking kernel APC callback routines. For instance, the <code class="blg_cq">KernelRoutine</code> callback must be always provided, 
	and thus the driver itself cannot be
	unloaded from memory while its APC callback may be still running. Otherwise, it's a sure recipe for <a href="https://en.wikipedia.org/wiki/Blue_screen_of_death" rel="external nofollow" target="_blank">BSOD</a>.
</p>

<blockquote class="qt1 q_inf">
	One can easily replicate the BSOD tied to a pending APC for the driver that is being unloaded. Put a breakpoint on some thread and queue an APC to it.
	Force the driver to unload and then resume the thread and invoke an APC with a call to <code class="blg_cq">NtTestAlert</code>. Such will guarantee a BSOD.
</blockquote>

<p>Ideally, the system implementation of APCs should have been the following:</p>

<ul>
	<li>It must have a reference to <code class="blg_cq">DriverObject</code> in <a href="https://dennisbabkin.com/blog/?i=AAA03000#kapc"><code class="blg_cq">KAPC</code></a>, and before insertion of the APC
	the <code class="blg_cq">KeInsertQueueApc</code> function
	should have done <code class="blg_cq"><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obfreferenceobject" rel="external nofollow" target="_blank">ObfReferenceObject</a>(Apc-&gt;DriverObject)</code> 
	(and additionally, if <code class="blg_cq">KeInsertQueueApc</code> fails, also call 
	<code class="blg_cq"><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obdereferenceobject" rel="external nofollow" target="_blank">ObfDereferenceObject</a>(Apc-&gt;DriverObject)</code>
	internally.) With these steps, the driver will not be unloaded while there are queued APCs.
	</li>

	<li>Then before the final invocation of the <code class="blg_cq">KernelRoutine</code>, <code class="blg_cq">NormalRoutine</code>, or <code class="blg_cq">RundownRoutine</code>, the system should've 
		read <code class="blg_cq">DriverObject = Apc-&gt;DriverObject</code> into the local stack, invoked the appropriate APC callback, and then called <code class="blg_cq">ObfDereferenceObject(DriverObject)</code>,
		since the <code class="blg_cq">Apc</code> itself will not be valid after the callback returns.
	</li>

	<li>Additionally, it would be also very helpful if <code class="blg_cq">RundownRoutine</code> was invoked unconditionally, and not how it's currently done now.</li>
</ul>

<p>With the changes that I proposed above, the coding of the kernel-mode APC callback routines would be much more simple. 
	But unfortunately the invocation of those callbacks was not coded correctly. ðŸ˜’</p>

<blockquote class="qt1 q_inf">
	Incidentally, such functionality has been realized for the <code class="blg_cq">WorkItem</code> objects. See
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-ioinitializeworkitem" rel="external nofollow" target="_blank"><code class="blg_cq">IoInitializeWorkItem</code></a> function.
	We pass into it a pointer to the <code class="blg_cq">DriverObject</code> or device object, which will hold our driver in memory and won't let it unload while <code class="blg_cq">WorkItem</code> is still active.
	Or, in other words, when we add a <code class="blg_cq">WorkItem</code>, the system calls <code class="blg_cq">ObfReferenceObject</code> for us, and then when our final callback is invoked, 
	the system then calls <code class="blg_cq">ObfDereferenceObject</code>. Which is the correct way to implement it.
</blockquote>

<p>So what's the workaround for setting up the kernel APC callbacks correctly?</p>

<p>Obviously we can call <code class="blg_cq">ObfReferenceObject</code> from the driver itself during initialization. But how do we call <code class="blg_cq">ObfDereferenceObject</code> at the end of the lifetime of our object
	from within it? If we do it, and the execution returns back from the <code class="blg_cq">ObfDereferenceObject</code> function, we will create a situation in which the driver code that we're 
	running is already unloaded. This is a good way to cause a <a href="https://en.wikipedia.org/wiki/Blue_screen_of_death" rel="external nofollow" target="_blank">BSOD</a>s.
</p>

<p>My solution to this problem is to use the assembly language and to invoke <code class="blg_cq">ObfDereferenceObject</code> function using the <code class="blg_cq">JMP</code> instruction 
	instead of a conventional <code class="blg_cq">CALL</code> instruction, like most compilers do. By using the <code class="blg_cq">JMP</code> instruction, we're guaranteeing that the execution will not return back to the
	code that is being unloaded. Unfortunately though such solution is not currently available through C or C++ languages.
</p>

<blockquote class="qt1 q_inf">
	Check <a href="https://dennisbabkin.com/blog/?i=AAA03000#jmp_unload">this assembly code</a> for an example of implementation of this technique, 
	or check <a href="https://github.com/rbmm/INJECT/blob/master/DRV/" rel="external nofollow" target="_blank">my GitHub</a> for the full sample.
</blockquote>




<a name="early_inject_kernel32_dll"></a>
<h2>Case Study - Pitfalls of Early Injection Into Kernel32.dll<a href="https://dennisbabkin.com/blog/?i=AAA03000#early_inject_kernel32_dll" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<blockquote class="qt1 q_inf">
	This is the actual case that I helped to resolve while freelancing for one antivirus company (that should remain nameless.)
</blockquote>

<p>Let's say, that an antivirus company wanted to inject their own DLL into all running processes. Additionally, they wanted to run code in their DLL very early, even before
	other loaded DLLs had a chance to receive <a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dllmain" rel="external nofollow" target="_blank"><code class="blg_cq">DLL_PROCESS_ATTACH</code></a> notification.
</p>

<p>This worked well for them, except when one competing product was also installed on the system, everything crashed.</p>
<p>
	They later discovered that the other AV was inserting an APC into loading of <code class="blg_cq">kernel32.dll</code> that made their injected DLL to load earlier,
	and they couldn't figure out why that was causing the crash.
</p>

<p>The answer to that conundrum was to understand the early DLL loading process that <a href="https://dennisbabkin.com/blog/?i=AAA03000#pslinr_gotcha">I describe here</a>.
	When the custom DLL of our AV company was injected and loaded before <code class="blg_cq">kernel32.dll</code>, that DLL <strong>should've not</strong> had any dependencies on any other
	DLL except the native <code class="blg_cq">ntdll.dll</code> (directly, or indirectly via dependencies in other modules.)
	But that was not the case, and that is what was causing the crash.
</p>

<p>If a driver, like I <a href="https://dennisbabkin.com/blog/?i=AAA03000#pslinr_gotcha">show here</a>, invokes a user-mode APC callback, that in turn was invoking <code class="blg_cq">LoadLibrary</code> on some custom DLL,
	and if such callback was invoked before <code class="blg_cq">kernel32.dll</code> had a chance to load itself, then a call to  <code class="blg_cq">LoadLibrary</code> will attempt to import <code class="blg_cq">ntdll.dll</code>,
	while the imports were not set up yet. So the first imported call to any function in <code class="blg_cq">ntdll.dll</code> from within <code class="blg_cq">kernel32.dll</code> will crash the process.
</p>

<p>As a workaround for AV company, they needed to write their injector in a different way. APC was not the best solution because of the limitations that I described above,
	and because of the fact that their DLL was supposed to be loaded into every module in the system. 
</p>

<blockquote class="qt1 q_wrn">
	If we are using APC callback, we must be ready that our callback can be invoked at <strong>any moment</strong> after we queued it.
	But if we call <code class="blg_cq">LoadLibrary[Ex]</code> type function from our callback, that in itself is imported from <code class="blg_cq">kernel32.dll</code>, we're breaking that rule because that library may not be
	yet initialized in our process.
</blockquote>

<p>In that case, a 
	<a href="https://dennisbabkin.com/blog/?t=how-to-implement-getprocaddress-in-shellcode">specially crafted shellcode</a> could be a better approach, that will load the DLL using
	native functions, such as <code class="blg_cq">ntdll!LdrLoadDll</code>:
</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode9"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">LdrLoadDll</span>( 
	<span class="c_ac">IN</span> <span class="c_ac">PCWSTR</span> SearchPaths,
	<span class="c_ac">IN</span> <span class="c_ac">PULONG</span> pFlags,
	<span class="c_ac">IN</span> <span class="c_ac">PCUNICODE_STRING</span> DllName,
	<span class="c_ac">OUT</span> <span class="c_ac">HMODULE</span>* pDllBase
);</code></pre></div>

<p>Additionally, such custom DLL itself must only have static imports from <code class="blg_cq">ntdll.dll</code>, or alternatively use 
	<a href="https://docs.microsoft.com/en-us/cpp/build/reference/specifying-dlls-to-delay-load?view=msvc-160" rel="external nofollow" target="_blank">delay-loaded</a> imports from <code class="blg_cq">kernel32.dll</code>.
	Such DLL cannot use any of the <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features?view=msvc-160" rel="external nofollow" target="_blank">C Run-Time Libraries</a> (CRT) 
	and many of the <a href="http://www.cplusplus.com/doc/" rel="external nofollow" target="_blank">C++ constructs</a> either,
	as they (even if linked statically) will bring implicit imports to <code class="blg_cq">kernel32.dll</code> and other libraries.
</p>




<a name="user_mode_apc_kernel"></a>
<h1>User-Mode APCs From The Kernel<a href="https://dennisbabkin.com/blog/?i=AAA03000#user_mode_apc_kernel" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h1>

<p>For the user-mode APC the situation is different in the following ways:</p>
<ul>
	<li>It can't execute between any two CPU instructions, or in other words, it is not delivered via a CPU <em>interrupt</em>.</li>
	<li>It has to run in <code class="blg_cq">ring-3</code> code, or with the user-mode context.</li>
	<li>It runs only after execution of specific <a href="https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls" rel="external nofollow" target="_blank"><em>waitable</em> Windows functions</a> 
		when thread is in an <em>alertable</em> state.</li>
</ul>

<p>To accomplish this, the kernel and the native-subsystem are coded in such a way that user-mode APCs are executed when the CPU leaves the system call.
	Many Windows functions (or WinAPIs) require a call to the kernel, which is delivered via the <code class="blg_cq">sysenter</code> CPU instruction.
	Upon its execution, the CPU first enters the part of the Windows kernel that is responsible for routing system calls, known as the <em>System Service Dispatcher</em>.
	Then the system call itself is processed depending on the <em>system function index</em> supplied in the <code class="blg_cq">EAX</code> register.
	And only after that, but before leaving the kernel space, the <em>System Service Dispatcher</em> checks for the presence of the user-mode APCs and 
	adjusts the <code class="blg_cq">KTRAP_FRAME</code> on the kernel stack to handle user-mode APC later.
</p>

<p>The checks for the presence of the user-mode APCs are done in the <code class="blg_cq">nt!KiDeliverApc</code> function in the kernel. In a nutshell, after processing kernel-mode APCs for the thread, 
	it checks if <a href="https://dennisbabkin.com/blog/?i=AAA03000#kthread"><code class="blg_cq">KTHREAD::PreviousMode</code></a> == <code class="blg_cq">UserMode</code>, and that <code class="blg_cq">KTHREAD.SpecialApcDisable</code> is not set, and if so it then
	checks that <code class="blg_cq">KTHREAD.ApcState.UserApcPending</code> is not zero, signifying the presence of the user-mode APC. Then it calls <code class="blg_cq">nt!KiInitializeUserApc</code> that
	modifies the user mode context for the return from the system call to process the user-mode APC.
</p>

<p>For that, <code class="blg_cq">nt!KiInitializeUserApc</code> remembers the original <code class="blg_cq">ring-3</code> context where the system call was supposed to return before adjusting <code class="blg_cq">KTRAP_FRAME</code> to 
	return execution into the special <code class="blg_cq">ntdll!KiUserApcDispatcher</code> function in the native subsystem. After that <code class="blg_cq">nt!KiInitializeUserApc</code> returns.
</p>

<p>And only later, upon execution of the <code class="blg_cq">sysexit</code> CPU instruction, due to the modified <code class="blg_cq">KTRAP_FRAME</code> context, CPU returns into the <code class="blg_cq">ntdll!KiUserApcDispatcher</code> function in <code class="blg_cq">ring-3</code>. 
	That function in turn processes a single user-mode APC and then calls <code class="blg_cq">ntdll!NtContinue(context, TRUE)</code> that returns execution back to the kernel.
	And the cycle that I described above continues until there's no more user-mode APCs left in the queue for the thread.
</p>


<a name="implement_user_mode_apc"></a>
<h2>Implementation of User-mode APCs<a href="https://dennisbabkin.com/blog/?i=AAA03000#implement_user_mode_apc" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>There are some specific aspects of user-mode APCs that I need to point out:</p>
<ul>
	<li>Even though CPU can enter kernel-mode at any moment between any two instructions following an <em>interrupt</em>, a user-mode APC callback does not get invoked at that time. 
		User-mode APCs can be invoked only after execution of special Windows API calls, as I <a href="https://dennisbabkin.com/blog/?i=AAA03000#user_mode_apc_kernel">described here</a>.
	</li>
	<li>Hypothetically any Windows API that requires <code class="blg_cq">sysenter</code> can be used to process user-mode APCs upon return, 
		provided that <em>some</em> kernel code sets <code class="blg_cq">KTHREAD.ApcState.UserApcPending</code> for the thread, and a user-mode APC is queued prior to the call.
	</li>
	<li>Setting the <code class="blg_cq">KTHREAD.ApcState.UserApcPending</code> is what MSDN calls <code class="blg_cq">alertable</code> state for a thread. Which is a somewhat confusing terminology.</li>
	<li><a name="alertable_wait_api"></a>
		Which APIs can set that <code class="blg_cq">KTHREAD.ApcState.UserApcPending</code> flag? Obviously the following documented functions can do it: 
		<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepex" rel="external nofollow" target="_blank">SleepEx</a>, 
		<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait" rel="external nofollow" target="_blank">SignalObjectAndWait</a>, 
		<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex" rel="external nofollow" target="_blank">MsgWaitForMultipleObjectsEx</a>, 
		<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex" rel="external nofollow" target="_blank">WaitForMultipleObjectsEx</a>, or 
		<a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex" rel="external nofollow" target="_blank">WaitForSingleObjectEx</a>.
		But there are also these undocumented functions that can do it too:

		<ul>
		<li><strong><code class="blg_cq">ntdll!NtTestAlert</code></strong>, that has no input parameters. It seems like its only function is to prepare all queued user-mode APCs.
			Internally it calls <code class="blg_cq">nt!KiInitializeUserApc</code> itself, that I <a href="https://dennisbabkin.com/blog/?i=AAA03000#user_mode_apc_kernel">described here</a>:

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode10"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">NtTestAlert</span>();</code></pre></div>
		</li>
		<li><strong><code class="blg_cq">ntdll!NtContinue</code></strong>, that returns execution back to the kernel for continued processing (like I <a href="https://dennisbabkin.com/blog/?i=AAA03000#user_mode_apc_kernel">described here</a>)
			and then passes the execution to provided user-mode <code class="blg_cq">ThreadContext</code>, while optionally setting <code class="blg_cq">KTHREAD.ApcState.UserApcPending</code> if <code class="blg_cq">RaiseAlert</code> is set:

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode11"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">NtContinue</span>(
	<span class="c_ac">IN</span> <span class="c_ac">PCONTEXT</span> ThreadContext,
	<span class="c_ac">IN</span> <span class="c_ac">BOOLEAN</span> RaiseAlert
);</code></pre></div>
		</li>
	</ul></li>
</ul>


<a name="special_user_mode_apc"></a>
<h2>"Special" User-mode APCs<a href="https://dennisbabkin.com/blog/?i=AAA03000#special_user_mode_apc" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>There's also a new member in the <a href="https://dennisbabkin.com/blog/?i=AAA03000#kapc_state"><code class="blg_cq">KAPC_STATE</code></a> struct, called <code class="blg_cq">SpecialUserApcPending</code>. There's not much known about it, except
	some bits and pieces from the true "Windows internals spelunkers":
</p>

<blockquote class="qt0">
	It's been a while since APCs got messed around with. RS5 now adds "Special User APCs" (KTHREAD-&gt;SpecialUserApcPending) which can be queued with
	NtQueueApcThreadEx passing in 1 as the reserve handle. These are delivered with Mode == KernelMode to force a thread signal. Big change.
</blockquote>



<a name="broken_apc_xp"></a>
<h1>Broken User-Mode APC Implementation in Windows XP<a href="https://dennisbabkin.com/blog/?i=AAA03000#broken_apc_xp" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h1>

<blockquote class="qt1 q_wrn">
	This information applies only to legacy implementation on Windows XP and earlier systems.
</blockquote>

<p>If we follow the documentation for the <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc" rel="external nofollow" target="_blank">QueueUserAPC</a> function, 
	we can see the following section about APCs:
</p>

<blockquote class="qt0">
	If an application queues an APC before the thread begins running, the thread begins by calling the APC function ...
</blockquote>

<p>Prior to Windows Vista, when a thread began running (from the kernel this happened after a call to <code class="blg_cq">KiStartUserThread</code> and then to <code class="blg_cq">PspUserThreadStartup</code>)
	the kernel would queue a user-mode APC with a callback set to <code class="blg_cq">ntdll!LdrInitializeThunk</code>. But this meant that in user-mode, the thread would begin running from 
	the special post-<em>System-Service-Dispatcher</em> function <code class="blg_cq">ntdll!KiUserApcDispatcher</code> (as I <a href="https://dennisbabkin.com/blog/?i=AAA03000#user_mode_apc_kernel">described here</a>) and 
	not from the intended <code class="blg_cq">ntdll!LdrInitializeThunk</code>.
</p>

<p>The problem in this case was that if we ourselves added our APC into that thread, it could've begun running before <code class="blg_cq">ntdll!LdrInitializeThunk</code>, 
	and thus we would receive a thread context that was not yet initialized.
	That could lead to some intermittent crashes and nasty timing bugs.
</p>

<p>The solution back then was to call <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext" rel="external nofollow" target="_blank"><code class="blg_cq">GetThreadContext</code></a>
	that would guarantee that the thread context was initialized before returning. And only after that it was safe to queue an APC:
</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++ (Outdated code. Do not use!)</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode12" style="height: 16em; overflow-y: auto;"><code><span class="c_cmt">//WARNING: Deprecated code - do not use!</span>
<span class="c_ac">HANDLE</span> hThread = <span class="c_fun">CreateThread</span>(<span class="c_ac">NULL</span>, 0, ThreadProc, 0, <span class="c_ac">CREATE_SUSPENDED</span>, <span class="c_ac">NULL</span>);
<span class="c_kw">if</span> (hThread)
{
	<span class="c_ac">CONTEXT</span> ctx;
	<span class="c_fun">GetThreadContext</span>(hThread, &amp;ctx);		<span class="c_cmt">//XP bug workaround</span>

	<span class="c_cmt">//Now it's safe to queue APC</span>
	<span class="c_fun">QueueUserAPC</span>(Papcfunc, hThread, 0);

	<span class="c_cmt">//Because thread is originally suspended, this will ensure that our APC callback </span>
	<span class="c_cmt">//in 'Papcfunc' is executed before 'ThreadProc'</span>
	<span class="c_fun">ResumeThread</span>(hThread);

	<span class="c_fun">CloseHandle</span>(hThread);
}</code></pre></div>

<blockquote class="qt1 q_inf">
	The reason <code class="blg_cq">GetThreadContext</code> was able to solve that timing bug is because of the way thread context is retrieved. It is done by queuing a special kernel-mode APC
	into the target thread with a callback function collecting its context, and then by setting an event which is waited by the callee thread, that called <code class="blg_cq">GetThreadContext</code>,
	that reads the context when the internal event is set.
</blockquote>


<a name="dll_inject_apc"></a>
<h1>Intricacies of DLL Injection Via User-Mode APC<a href="https://dennisbabkin.com/blog/?i=AAA03000#dll_inject_apc" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h1>

<p>There is a technique to perform DLL injection into a process that we start ourselves. It works as such:</p>
<ul>
	<li>Create a process that is originally suspended 
		(<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw" rel="external nofollow" target="_blank"><code class="blg_cq">CreateProcess</code></a> with 
		<a href="https://docs.microsoft.com/en-us/windows/win32/procthread/process-creation-flags" rel="external nofollow" target="_blank"><code class="blg_cq">CREATE_SUSPENDED</code></a> flag.) We only need it for its initial thread.</li>
	<li>Add an APC into that thread (<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc" rel="external nofollow" target="_blank"><code class="blg_cq">QueueUserAPC</code></a>) with a 
		callback set to <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw" rel="external nofollow" target="_blank"><code class="blg_cq">LoadLibrary</code></a> function and resume it
		(<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread" rel="external nofollow" target="_blank"><code class="blg_cq">ResumeThread</code></a>).
	</li>
	<li>Our APC callback, or a call to <code class="blg_cq">LoadLibrary</code> is guaranteed to be called in the target process before its entry point code.</li>
</ul>

<p>But when will our APC callback be called? This should technically happen before the entry point code in the process has a chance to run, 
	at the exit from the <code class="blg_cq">ntdll!LdrInitializeThunk</code> function call (when the code inside it invokes <code class="blg_cq">NtTestAlert</code>.) So we're guaranteed that our APC callback will not
	be called later than that. But can it be called earlier?
</p>

<p>What if one of the DLLs that are loaded into the process at its creation calls one of the <a href="https://dennisbabkin.com/blog/?i=AAA03000#alertable_wait_api">alertable wait functions</a> in its
	<a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dllmain" rel="external nofollow" target="_blank"><code class="blg_cq">DLL_PROCESS_ATTACH</code></a> handler?
	This is highly unlikely for the Windows system DLLs, but is still possible for a custom DLL that is also loaded into the process.
	The bottom line is that such scenario will lead to our APC callback being called earlier.
</p>

<p>But really, who cares if we call <code class="blg_cq">LoadLibrary</code> and inject our DLL earlier? In most cases this won't matter than much.</p>


<a name="pslinr_gotcha"></a>
<h2>PsSetLoadImageNotifyRoutine Gotcha<a href="https://dennisbabkin.com/blog/?i=AAA03000#pslinr_gotcha" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>There's one intricate situation that can be very critical for when DLL is loaded. Say, a driver may use 
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetloadimagenotifyroutine" rel="external nofollow" target="_blank"><code class="blg_cq">PsSetLoadImageNotifyRoutine</code></a> function
	to intercept loading of some DLLs. To do that it queues its own APC early into the DLL loading process.
	A driver then usually sets the <code class="blg_cq">KAPC_STATE::UserApcPending</code> flag (implicitly) with a call to 
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kedelayexecutionthread" rel="external nofollow" target="_blank"><code class="blg_cq">KeDelayExecutionThread</code></a>, or 
	using the undocumented function <code class="blg_cq">KeTestAlertThread</code>, and thus forcing the user-mode code (in the APC callback) to run before the code in the DLL that is being loaded
	has any chance to run itself.
</p>

<p>This can be illustrated in the following pseudo-code:</p>

<blockquote class="qt1 q_inf">
	The full version of the code below can be <a href="https://github.com/rbmm/INJECT/blob/master/DRV/LoadImage.cpp" rel="external nofollow" target="_blank">found at my GitHub</a>.
</blockquote>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode13" style="height: 32em; overflow-y: auto;"><code><span class="c_ppr">#ifndef</span> _WIN64
<span class="c_ppr">#error</span> Showing <span class="c_kw">this</span> <span class="c_kw">for</span> 64-bit builds only!
<span class="c_ppr">#endif</span>

<span class="c_ac">LONG</span> gFlags;
<span class="c_ac">PDRIVER_OBJECT</span> g_DriverObject;

<span class="c_kw">enum</span>{
	flImageNotifySet,
};

<span class="c_kw">extern</span> <span class="c_dq">"C"</span> <span class="c_ac">NTSTATUS</span> <span class="c_ac">NTAPI</span> <span class="c_fun">DriverEntry</span>(<span class="c_ac">PDRIVER_OBJECT</span> DriverObject, <span class="c_ac">PUNICODE_STRING</span> RegistryPath)
{
	g_DriverObject = DriverObject;

	DriverObject-&gt;DriverUnload = DriverUnload;

	<span class="c_ac">NTSTATUS</span> status = <span class="c_fun">PsSetLoadImageNotifyRoutine</span>(OnLoadImage);

	<span class="c_kw">if</span> (0 &lt;= status)
	{
		<span class="c_fun">_bittestandset</span>(&amp;gFlags, flImageNotifySet);
	}

	<span class="c_kw">return</span> status;
}

<span class="c_kw">void</span> <span class="c_ac">NTAPI</span> <span class="c_fun">DriverUnload</span>(<span class="c_ac">PDRIVER_OBJECT</span> DriverObject)
{	
	<span class="c_fun">FreeLoadImageData</span>();
}

<span class="c_kw">void</span> <span class="c_fun">FreeLoadImageData</span>()
{
	<span class="c_kw">if</span> (<span class="c_fun">_bittestandreset</span>(&amp;gFlags, flImageNotifySet)) <span class="c_fun">PsRemoveLoadImageNotifyRoutine</span>(OnLoadImage);
}

<span class="c_ac">VOID</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">OnLoadImage</span>(
						  <span class="c_ac">IN</span> <span class="c_ac">PUNICODE_STRING</span> FullImageName,
						  <span class="c_ac">IN</span> <span class="c_ac">HANDLE</span> ProcessId, <span class="c_cmt">// Process where image is mapped</span>
						  <span class="c_ac">IN</span> <span class="c_ac">PIMAGE_INFO</span> ImageInfo
						  )
{
	<span class="c_ac">STATIC_UNICODE_STRING</span>(kernel32, <span class="c_dq">"\\kernel32.dll"</span>);

	<span class="c_kw">if</span> (
		!ImageInfo-&gt;SystemModeImage &amp;&amp; 
		ProcessId == <span class="c_fun">PsGetCurrentProcessId</span>() &amp;&amp; 	<span class="c_cmt">// section can be "remotely" mapped from another process</span>
		<span class="c_fun">SuffixUnicodeString</span>(FullImageName, &amp;kernel32) &amp;&amp; 
		<span class="c_fun">IsByLdrLoadDll</span>(&amp;kernel32)
		)
	{
		<span class="c_fun">BeginInject</span>(&amp;<span class="c_ac">NATIVE_DLL</span>::di);
	}
}

<span class="c_ac">VOID</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">RundownRoutine</span>(<span class="c_ac">PKAPC</span> );
<span class="c_ac">VOID</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">KernelRoutine</span>(<span class="c_ac">PKAPC</span> , <span class="c_ac">PKNORMAL_ROUTINE</span> *, <span class="c_ac">PVOID</span> * , <span class="c_ac">PVOID</span> * ,<span class="c_ac">PVOID</span> * );
<span class="c_ac">VOID</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">NormalRoutine</span>(<span class="c_ac">PVOID</span> , <span class="c_ac">PVOID</span> ,<span class="c_ac">PVOID</span> );

<span class="c_kw">void</span> <span class="c_fun">BeginInject</span>(<span class="c_ac">DLL_INFORMATION</span>* pdi)
{
	<span class="c_ac">PVOID</span> Section;

	<span class="c_kw">if</span> (0 &lt;= pdi-&gt;<span class="c_fun">GetSection</span>(&amp;Section))
	{
		<span class="c_kw">if</span> (<span class="c_ac">PKAPC</span> Apc = <span class="c_fun">ExAllocatePool</span>(NonPagedPool, <span class="c_kw">sizeof</span>(<span class="c_ac">KAPC</span>)))
		{
			<span class="c_fun">KeInitializeApc</span>(Apc, <span class="c_fun">KeGetCurrentThread</span>(), OriginalApcEnvironment, 
				KernelRoutine, RundownRoutine, NormalRoutine, KernelMode, Apc);

			<span class="c_fun">ObfReferenceObject</span>(g_DriverObject);
			<span class="c_fun">ObfReferenceObject</span>(Section);

			<span class="c_kw">if</span> (!<span class="c_fun">KeInsertQueueApc</span>(Apc, Section, pdi, <span class="c_ac">IO_NO_INCREMENT</span>))
			{
				<span class="c_fun">ObfDereferenceObject</span>(Section);

				<span class="c_fun">RundownRoutine</span>(Apc);
			}
		}
	}
}

<span class="c_kw">extern</span> <span class="c_dq">"C"</span> <span class="c_ac">NTSYSAPI</span> <span class="c_ac">BOOLEAN</span> <span class="c_ac">NTAPI</span> <span class="c_fun">KeTestAlertThread</span>(<span class="c_ac">IN</span> <span class="c_ac">KPROCESSOR_MODE</span> 	AlertMode);

<span class="c_ac">VOID</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">_NormalRoutine</span> (
							  <span class="c_ac">PKAPC</span> Apc,
							  <span class="c_ac">PVOID</span> Section,
							  <span class="c_ac">DLL_INFORMATION</span>* pdi
							  )
{
	<span class="c_ac">PVOID</span> BaseAddress;
	<span class="c_ac">NTSTATUS</span> status = pdi-&gt;<span class="c_fun">MapSection</span>(BaseAddress);

	<span class="c_fun">ObfDereferenceObject</span>(Section);

	<span class="c_kw">if</span> (0 &lt;= status)
	{
		<span class="c_kw">union</span> {
			<span class="c_ac">PVOID</span> pvNormalRoutine;
			<span class="c_ac">PKNORMAL_ROUTINE</span> NormalRoutine;
		};

		<span class="c_ac">PVOID</span> NormalContext = BaseAddress;
		pvNormalRoutine = (<span class="c_ac">PBYTE</span>)BaseAddress + pdi-&gt;rva_1;

		<span class="c_kw">if</span> (pdi == &amp;<span class="c_ac">WOW_DLL</span>::di) <span class="c_fun">PsWrapApcWow64Thread</span>(&amp;NormalContext, &amp;pvNormalRoutine);

		<span class="c_fun">KeInitializeApc</span>(Apc, <span class="c_fun">KeGetCurrentThread</span>(), OriginalApcEnvironment, 
			KernelRoutine, RundownRoutine, NormalRoutine, UserMode, NormalContext);

		<span class="c_fun">ObfReferenceObject</span>(g_DriverObject);

		<span class="c_kw">if</span> (<span class="c_fun">KeInsertQueueApc</span>(Apc, <span class="c_fun">NtCurrentProcess</span>(), BaseAddress, <span class="c_ac">IO_NO_INCREMENT</span>))
		{
			<span class="c_cmt">//Force user-mode APC callback</span>
			<span class="c_fun">KeTestAlertThread</span>(UserMode);

			<span class="c_kw">return</span>;
		}

		<span class="c_fun">ObfDereferenceObject</span>(g_DriverObject);

		<span class="c_fun">MmUnmapViewOfSection</span>(<span class="c_fun">IoGetCurrentProcess</span>(), BaseAddress);
	}

	<span class="c_fun">_RundownRoutine</span>(Apc);
}

<span class="c_ac">VOID</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">_KernelRoutine</span>(
							 <span class="c_ac">PKAPC</span> Apc, 
							 <span class="c_ac">PKNORMAL_ROUTINE</span> * <span class="c_cmt">/*NormalRoutine*/</span>, 
							 <span class="c_ac">PVOID</span> * <span class="c_cmt">/*NormalContext*/</span>, 
							 <span class="c_ac">PVOID</span> * <span class="c_cmt">/*SystemArgument1*/</span>, 
							 <span class="c_ac">PVOID</span> * <span class="c_cmt">/*SystemArgument2*/</span>
							 )
{
	<span class="c_kw">if</span> (Apc-&gt;ApcMode == KernelMode)
	{
		<span class="c_cmt">//Kernel-mode APC</span>
		<span class="c_fun">ObfReferenceObject</span>(g_DriverObject);		<span class="c_cmt">//NormalRoutine will be called</span>

		<span class="c_kw">return</span>;
	}

	<span class="c_cmt">//User-mode APC -&gt; free Apc object</span>
	<span class="c_fun">_RundownRoutine</span>(Apc);
}

<span class="c_ac">VOID</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">_RundownRoutine</span>(<span class="c_ac">PKAPC</span> Apc)
{
	<span class="c_fun">ExFreePool</span>(Apc);
}</code></pre></div>

<p>With special supplementary assembly language implementation:</p>

<blockquote class="qt1 q_inf">
	Note that I'm writing these functions in assembly to be able to use the <code class="blg_cq">JMP</code> instruction to safely dereference <code class="blg_cq">KAPC</code> objects.
	Read <a href="https://dennisbabkin.com/blog/?i=AAA03000#apc_drv_unload">more details here</a>.
</blockquote>

<a name="jmp_unload"></a>
<div class="blog_code rndcrntr"><span class="blog_code_ttl">x86-64</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_msm" id="idCode14" style="height: 32em; overflow-y: auto;"><code><span class="asm_oc">extern</span> g_DriverObject:QWORD
<span class="asm_oc">extern</span> __imp_ObfDereferenceObject:QWORD

<span class="asm_oc">extern</span> ?_RundownRoutine@NT@@YAXPEAU_KAPC@1@@Z : <span class="asm_oc">PROC</span>
<span class="asm_oc">extern</span> ?_NormalRoutine@NT@@YAXPEAU_KAPC@1@PEAXPEAUDLL_INFORMATION@1@@Z : <span class="asm_oc">PROC</span>
<span class="asm_oc">extern</span> ?_KernelRoutine@NT@@YAXPEAU_KAPC@1@PEAP6AXPEAX11@ZPEAPEAX33@Z : <span class="asm_oc">PROC</span>

_TEXT <span class="asm_oc">segment</span>

<span class="asm_cmt">; VOID CALLBACK RundownRoutine(PKAPC );</span>
?RundownRoutine@NT@@YAXPEAU_KAPC@1@@Z <span class="asm_oc">proc</span>
	<span class="asm_ig">sub</span>    <span class="asm_rg">rsp</span>,40
	<span class="asm_cmt">;      void __cdecl NT::_RundownRoutine(struct NT::_KAPC *)</span>
	<span class="asm_igc">call</span>   ?_RundownRoutine@NT@@YAXPEAU_KAPC@1@@Z
	<span class="asm_ig">add</span>    <span class="asm_rg">rsp</span>,40
	<span class="asm_ig">mov</span>    <span class="asm_rg">rcx</span>,g_DriverObject
	<span class="asm_igc">jmp</span>    __imp_ObfDereferenceObject
?RundownRoutine@NT@@YAXPEAU_KAPC@1@@Z <span class="asm_oc">endp</span>

<span class="asm_cmt">; VOID CALLBACK KernelRoutine(PKAPC , PKNORMAL_ROUTINE *, PVOID * , PVOID * ,PVOID * );</span>
?KernelRoutine@NT@@YAXPEAU_KAPC@1@PEAP6AXPEAX11@ZPEAPEAX33@Z <span class="asm_oc">proc</span>
	<span class="asm_ig">mov</span>    <span class="asm_rg">rax</span>,[<span class="asm_rg">rsp</span> + 40]
	<span class="asm_ig">mov</span>    [<span class="asm_rg">rsp</span> + 24],<span class="asm_rg">rax</span>
	<span class="asm_ig">mov</span>    <span class="asm_rg">rax</span>,[<span class="asm_rg">rsp</span>]
	<span class="asm_ig">mov</span>    [<span class="asm_rg">rsp</span> + 32],<span class="asm_rg">rax</span>
	<span class="asm_ig">push</span>   <span class="asm_rg">rax</span>
	<span class="asm_cmt">;      void __cdecl NT::_KernelRoutine(struct NT::_KAPC *,void (__cdecl **)(void *,void *,void *),void **,void **,void **)</span>
	<span class="asm_igc">call</span>   ?_KernelRoutine@NT@@YAXPEAU_KAPC@1@PEAP6AXPEAX11@ZPEAPEAX33@Z
	<span class="asm_ig">pop</span>    <span class="asm_rg">rax</span>
	<span class="asm_ig">mov</span>    <span class="asm_rg">rax</span>,[<span class="asm_rg">rsp</span> + 32]
	<span class="asm_ig">mov</span>    [<span class="asm_rg">rsp</span>],<span class="asm_rg">rax</span>
	<span class="asm_ig">mov</span>    <span class="asm_rg">rcx</span>,g_DriverObject
	<span class="asm_igc">jmp</span>    __imp_ObfDereferenceObject
?KernelRoutine@NT@@YAXPEAU_KAPC@1@PEAP6AXPEAX11@ZPEAPEAX33@Z <span class="asm_oc">endp</span>

<span class="asm_cmt">; VOID CALLBACK NormalRoutine(PVOID , PVOID ,PVOID );</span>
?NormalRoutine@NT@@YAXPEAX00@Z <span class="asm_oc">proc</span>
	<span class="asm_ig">sub</span>    <span class="asm_rg">rsp</span>,40
	<span class="asm_cmt">;      void __cdecl NT::_NormalRoutine(struct NT::_KAPC *,void *,struct NT::DLL_INFORMATION *)</span>
	<span class="asm_igc">call</span>   ?_NormalRoutine@NT@@YAXPEAU_KAPC@1@PEAXPEAUDLL_INFORMATION@1@@Z
	<span class="asm_ig">add</span>    <span class="asm_rg">rsp</span>,40
	<span class="asm_ig">mov</span>    <span class="asm_rg">rcx</span>,g_DriverObject
	<span class="asm_igc">jmp</span>    __imp_ObfDereferenceObject
?NormalRoutine@NT@@YAXPEAX00@Z <span class="asm_oc">endp</span>

_TEXT <span class="asm_oc">ends</span>
<span class="asm_oc">end</span></code></pre></div>

<blockquote class="qt1 q_inf">
	The "<em>crazy</em>" externs that you see above are 
	<a href="https://docs.microsoft.com/en-us/cpp/build/reference/decorated-names?view=msvc-160" rel="external nofollow" target="_blank">mangled C++ function names</a>. You can obtain them using the 
	<a href="https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-160" rel="external nofollow" target="_blank"><code class="blg_cq">__FUNCDNAME__</code></a> preprocessor command during the compilation of the source 
	code by placing it as such:

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode15"><code><span class="c_kw">int</span> <span class="c_fun">SomeFunction</span>(<span class="c_ac">WCHAR</span>* pstr, <span class="c_kw">int</span> value)
{
	<span class="c_fun">__pragma</span>(<span class="c_fun">message</span>(<span class="c_dq">"extern "</span> <span class="c_ac">__FUNCDNAME__</span> <span class="c_dq">" : PROC ; "</span>  <span class="c_ac">__FUNCSIG__</span>))
}</code></pre></div>

	<p>When that code compiles, the <em>Output</em> window in Visual Studio will contain the required C++ <em>mangled</em> function name:</p>
<blockquote class="qt0">
extern ?SomeFunction@@YAHPEA_WH@Z : PROC ; int __cdecl SomeFunction(wchar_t *,int)
</blockquote>
</blockquote>

<p>It is important to understand that <code class="blg_cq">PsSetLoadImageNotifyRoutine</code> callback is executed inside a call to the
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwmapviewofsection" rel="external nofollow" target="_blank"><code class="blg_cq">ZwMapViewOfSection</code></a> function that maps DLL into memory.
	This callback happens before that function finishes settings up DLL, which means that DLL is mapped but it is not yet initialized.
	For instance, its imported functions are not yet processed. So in other words, that DLL cannot be used yet!
</p>

<blockquote class="qt1 q_ctn">
	As a consequence of the statement above, one rule of thumb that must be followed if you decide to load your own module into all other modules using 
	the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetloadimagenotifyroutine" rel="external nofollow" target="_blank"><code class="blg_cq">PsSetLoadImageNotifyRoutine</code></a> function:
	you <strong>cannot import</strong> any other DLLs into your module except for <code class="blg_cq">ntdll.dll</code>. That DLL, and <strong>no other</strong>, is guaranteed to be mapped into any 
	user-mode process.
</blockquote>



<a name="zqat_vs_qua"></a>
<h1>ZwQueueApcThread vs QueueUserAPC<a href="https://dennisbabkin.com/blog/?i=AAA03000#zqat_vs_qua" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h1>

<p>Let me ask, which function would you use?</p>
<p>
<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc" rel="external nofollow" target="_blank"><code class="blg_cq">QueueUserAPC</code></a>
	is obviously documented (more or less), and thus should be safer to use, and <code class="blg_cq">ZwQueueApcThread</code> or <code class="blg_cq">NtQueueApcThread</code> are not.
</p>

<blockquote class="qt1 q_inf">
	For the user-mode code there's <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines" rel="external nofollow" target="_blank">no difference</a>
	between <code class="blg_cq">ZwQueueApcThread</code> and <code class="blg_cq">NtQueueApcThread</code> functions. It's just the matter of what prefix you like.
</blockquote>

<p>Before continuing, let's check how native <code class="blg_cq">ZwQueueApcThread</code> function is declared:</p>

<a name="zqat"></a>
<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode16"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">ZwQueueApcThread</span>(
	<span class="c_ac">HANDLE</span> hThread,
	<span class="c_ac">PKNORMAL_ROUTINE</span> ApcRoutine,
	<span class="c_ac">PVOID</span> ApcContext,
	<span class="c_ac">PVOID</span> Argument1,
	<span class="c_ac">PVOID</span> Argument2
);</code></pre></div>

<p>As you can see, instead of a single custom parameter, or <code class="blg_cq">dwData</code> in <code class="blg_cq">QueueUserAPC</code>, we have a chance to pass 3 custom parameters with a native function.
	OK. That simplifies things a little bit for a native function, but still as long as we can pass a pointer we can pass as many parameters as we want.
	So no big deal for <code class="blg_cq">QueueUserAPC</code>, right?
</p>

<p>Well, as we shall see below, the difference actually lies with an <em>activation context</em>
	used by <code class="blg_cq">QueueUserAPC</code>. And not only the difference, but actually a bug.</p>


<a name="act_ctx_bug"></a>
<h2>Activation Context Handle Bug<a href="https://dennisbabkin.com/blog/?i=AAA03000#act_ctx_bug" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>The way user-mode APCs deal with the <a href="https://docs.microsoft.com/en-us/windows/win32/sbscs/activation-contexts" rel="external nofollow" target="_blank">activation context</a>
	is not mentioned in the <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc" rel="external nofollow" target="_blank">documentation</a> for the <code class="blg_cq">QueueUserAPC</code>
	function at all. Instead it is only briefly touched
	<a href="https://docs.microsoft.com/en-us/windows/win32/sbscs/using-threads--asynchronous-procedures--and-window-messages" rel="external nofollow" target="_blank">here</a>:
</p>

<blockquote class="qt0">
	Asynchronous procedure calls, completion port callbacks, and any other callbacks on other threads automatically get the activation context of the source.
</blockquote>

<p>You can see what this means from the implementation of <code class="blg_cq">QueueUserAPC</code>. It roughly goes as such on my Windows 10:</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++ pseudo-code</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode17" style="height: 32em; overflow-y: auto;"><code><span class="c_kw">typedef</span> <span class="c_kw">struct</span> <span class="c_ac">_ACTIVATION_CONTEXT_BASIC_INFORMATION</span> {
	<span class="c_ac">HANDLE</span>  hActCtx;
	<span class="c_ac">DWORD</span>   dwFlags;
} <span class="c_ac">ACTIVATION_CONTEXT_BASIC_INFORMATION</span>, *<span class="c_ac">PACTIVATION_CONTEXT_BASIC_INFORMATION</span>;

<span class="c_ac">DWORD</span> <span class="c_fun">QueueUserAPC</span>(<span class="c_ac">PAPCFUNC</span> pfnAPC, <span class="c_ac">HANDLE</span> hThread, <span class="c_ac">ULONG_PTR</span> dwData)
{
	<span class="c_ac">ACTIVATION_CONTEXT_BASIC_INFORMATION</span> ContextInfo = {};

	<span class="c_ac">NTSTATUS</span> status = <span class="c_fun">RtlQueryInformationActivationContext</span>(
						1,		<span class="c_cmt">//RTL_QUERY_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT,</span>
						<span class="c_ac">NULL</span>,
						<span class="c_ac">NULL</span>,
						1,		<span class="c_cmt">//ActivationContextBasicInformation,</span>
						&amp;ContextInfo,
						<span class="c_kw">sizeof</span>(ContextInfo),
						<span class="c_ac">NULL</span>);
	<span class="c_kw">if</span>(<span class="c_ac">FAILED</span>(status))
	{
		<span class="c_fun">BaseSetLastNTError</span>(status);
		<span class="c_kw">return</span> <span class="c_ac">FALSE</span>;
	}

	status = <span class="c_fun">ZwQueueApcThread</span>(hThread, RtlDispatchAPC, pfnAPC, dwData, 
				!(ContextInfo.dwFlags &amp; 1) ? ContextInfo.hActCtx : <span class="c_ac">INVALID_HANDLE_VALUE</span>);
	<span class="c_kw">if</span>(<span class="c_ac">FAILED</span>(status))
	{
		<span class="c_fun">BaseSetLastNTError</span>(status);
		<span class="c_kw">return</span> <span class="c_ac">FALSE</span>;
	}

	<span class="c_kw">return</span> <span class="c_ac">TRUE</span>;
}

<span class="c_kw">typedef</span> <span class="c_kw">struct</span> <span class="c_ac">_RTL_ACTIVATION_CONTEXT_STACK_FRAME</span>
{
	<span class="c_ac">PRTL_ACTIVATION_CONTEXT_STACK_FRAME</span> Previous;
	<span class="c_ac">_ACTIVATION_CONTEXT</span> * ActivationContext;
	<span class="c_ac">ULONG</span> Flags;
} <span class="c_ac">RTL_ACTIVATION_CONTEXT_STACK_FRAME</span>, *<span class="c_ac">PRTL_ACTIVATION_CONTEXT_STACK_FRAME</span>;

<span class="c_kw">typedef</span> <span class="c_kw">struct</span> <span class="c_ac">_RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_EXTENDED</span>
{
	<span class="c_ac">SIZE_T</span> Size;
	<span class="c_ac">ULONG</span> Format;
	<span class="c_ac">RTL_ACTIVATION_CONTEXT_STACK_FRAME</span> Frame;
	<span class="c_ac">PVOID</span> Extra1;
	<span class="c_ac">PVOID</span> Extra2;
	<span class="c_ac">PVOID</span> Extra3;
	<span class="c_ac">PVOID</span> Extra4;
} <span class="c_ac">RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_EXTENDED</span>,
 *<span class="c_ac">PRTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_EXTENDED</span>;

<span class="c_kw">void</span> <span class="c_fun">RtlDispatchAPC</span>(<span class="c_ac">PAPCFUNC</span> pfnAPC, <span class="c_ac">ULONG_PTR</span> dwData, <span class="c_ac">HANDLE</span> hActCtx)
{
	<span class="c_ac">RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_EXTENDED</span> ActEx = {};
	ActEx.Size = <span class="c_kw">sizeof</span>(ActEx);
	ActEx.Format = 1;

	<span class="c_kw">if</span>(hActCtx != <span class="c_ac">INVALID_HANDLE_VALUE</span>)
	{
		<span class="c_fun">RtlActivateActivationContextUnsafeFast</span>(&amp;ActEx, hActCtx);

		<span class="c_fun">pfnAPC</span>(dwData);

		<span class="c_fun">RtlDeactivateActivationContextUnsafeFast</span>(&amp;ActEx);
		<span class="c_fun">RtlReleaseActivationContext</span>(hActCtx);
	}
	<span class="c_kw">else</span>
		<span class="c_fun">pfnAPC</span>(dwData);
}</code></pre></div>

<p>As you can see, they take the current activation context (with added reference to it) and then call <code class="blg_cq">ZwQueueApcThread</code> to queue the APC with a callback function pointing to
	<code class="blg_cq">ntdll!RtlDispatchAPC</code>. In it they pass the original callback function, specified by the user, and also user-provided parameter for the call to <code class="blg_cq">QueueUserAPC</code>,
	and finally the handle to the activation context.
</p>

<blockquote class="qt1 q_inf">
	This is, by the way, where all 3 parameters are used up in <code class="blg_cq">QueueUserAPC</code>. So the user has only 1 parameter left out of available 3.
</blockquote>

<p>Inside the APC callback, the <code class="blg_cq">ntdll!RtlDispatchAPC</code> implementation activates the context, invokes user-provided callback with a parameter, and then
	deactivates and releases it.
</p>

<p>What is important to note, and where the bug lies, is that activation context "handle" is not really a handle. It is just a pointer to some internal data structure.
	It is easier to understand it if we reverse engineer the code in the <code class="blg_cq">RtlReleaseActivationContext</code> function:
</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">x86-64</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_msm" id="idCode18"><code>	<span class="asm_cmt">; RtlReleaseActivationContext function</span>
	<span class="asm_cmt">; rcx = activation context handle</span>

	<span class="asm_ig">test</span>    <span class="asm_rg">rcx</span>, <span class="asm_rg">rcx</span>
	<span class="asm_igc">jnz</span>     @@1
	<span class="asm_igc">retn</span>
@@1:
	<span class="asm_ig">mov</span>     [<span class="asm_rg">rsp</span>+0x8], <span class="asm_rg">rbx</span>
	<span class="asm_ig">push</span>    <span class="asm_rg">rdi</span>
	<span class="asm_ig">sub</span>     <span class="asm_rg">rsp</span>, 20h
	<span class="asm_ig">lea</span>     <span class="asm_rg">rax</span>, [<span class="asm_rg">rcx</span>-1]
	<span class="asm_ig">mov</span>     <span class="asm_rg">rbx</span>, <span class="asm_rg">rcx</span>
	<span class="asm_ig">or</span>      <span class="asm_rg">rax</span>, 7
	<span class="asm_ig">cmp</span>     <span class="asm_rg">rax</span>, 0FFFFFFFFFFFFFFFFh
	<span class="asm_igc">jz</span>      @@exit
	<span class="asm_ig">mov</span>     <span class="asm_rg">eax</span>, [<span class="asm_rg">rcx</span>]			<span class="asm_cmt">; <span class="mrk1">potential crash</span></span>
	<span class="asm_ig">mov</span>     <span class="asm_rg">ecx</span>, 1
	<span class="asm_ig">sub</span>     <span class="asm_rg">eax</span>, <span class="asm_rg">ecx</span>
	<span class="asm_ig">cmp</span>     <span class="asm_rg">eax</span>, 7FFFFFFDh
	<span class="asm_igc">ja</span>      @@exit
	<span class="asm_ig">mov</span>     <span class="asm_rg">eax</span>, [<span class="asm_rg">rbx</span>]
	<span class="asm_ig">lea</span>     <span class="asm_rg">edi</span>, [<span class="asm_rg">rax</span>-1]
	<span class="asm_ig">lock</span> <span class="asm_ig">cmpxchg</span> [<span class="asm_rg">rbx</span>], <span class="asm_rg">edi</span>		<span class="asm_cmt">; <span class="mrk1">potential overwrite of memory</span></span>
	<span class="asm_cmt">; ....</span></code></pre></div>

<p>As you can see <code class="blg_cq">RtlReleaseActivationContext</code> expects only one input parameter, that is the activation context handle, which is passed in the <code class="blg_cq">rcx</code> register.
	But follow it later in the assembly code. As you can see, this function does a quick check if it is 0 and if so exits. It then does another rudimentary check
	for the handle bits not to be all <code class="blg_cq">1</code>'s, except for lower 3 bits, and if so it also exits.
</p>

<p>But this leaves a vast majority of non-zero activation context "handle" values to be allowed to pass through to the <code class="blg_cq">mov eax, [rcx]</code> instruction, that merely
	treats it as an address in memory. Further more, the <code class="blg_cq">lock cmpxchg [rbx], edi</code> instruction may begin writing into that address later.
</p>

<blockquote class="qt1 q_wrn">
	A true <code class="blg_cq">handle</code> is an index into a dictionary or a map of objects in a <em>handle table</em> in kernel memory. It should not be used as a mere pointer, especially if such 
	handle can be passed between processes!
</blockquote>

<p>Such handling of the activation context "handle" does not pose a problem when used in the same process. But what if we use <code class="blg_cq">QueueUserAPC</code> to queue an APC
	in another process? Then their use of the "handle"/pointer will only mean:
</p>

<div class="blg_idv i_algn_c"><a href="https://dbimgs.s3-us-west-2.amazonaws.com/dpths-f-wndws-pc-spcts-f-snchrns-prcdr-cll-ntrnls-frm-th-krnl-md-sub01.png" target="_blank" class="fImg" rel="gallery"><img src="https://dbimgs.s3-us-west-2.amazonaws.com/dpths-f-wndws-pc-spcts-f-snchrns-prcdr-cll-ntrnls-frm-th-krnl-md-sub01.png" draggable="false" alt="Application crash"></a></div>

<p>But such crash will not be the worst thing. Consider if the activation context "handle" points to a valid memory in the target process.
	What would happen then? The <code class="blg_cq">RtlReleaseActivationContext</code>, as example, will overwrite some writable memory in that process, which would not only lead to
	undefined behavior (UB) but will also be very difficult to diagnose and debug afterwards.
</p>

<p>So why didn't this bug cause a lot of ruckus? Activation context is not a new concept after all.</p>

<p>The reason is that usually an activation context for a process is not present. So a call to <code class="blg_cq">RtlQueryInformationActivationContext</code> with <code class="blg_cq">ActivationContextBasicInformation</code>, 
	or to its documented equivalent
	<a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcurrentactctx" rel="external nofollow" target="_blank"><code class="blg_cq">GetCurrentActCtx</code></a>, will return <code class="blg_cq">NULL</code> as the 
	activation context "handle". And <code class="blg_cq">NULL</code>s are handled gracefully by the Microsoft's callback function.
</p>
<p>
	The issue happens though when a module has an activation context.
	For instance, in the <code class="blg_cq">DllMain</code> if the module itself has manifest with the <code class="blg_cq">ISOLATIONAWARE_MANIFEST_RESOURCE_ID</code> identifier.
	But this is quite rare and thus, my guess, this issue went unattended.
</p>


<a name="bad_msdn_apc_doc"></a>
<h2>Cagey APC Documentation<a href="https://dennisbabkin.com/blog/?i=AAA03000#bad_msdn_apc_doc" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>Let's check MSDN documentation concerning the activation context "handle" bug that I <a href="https://dennisbabkin.com/blog/?i=AAA03000#act_ctx_bug">explained here</a>:</p>

<blockquote class="qt0">
	Note  Queuing APCs to threads outside the caller's process is not recommended for a number of reasons. ...
</blockquote>

<p>ðŸ˜Š Really? That is because you have an implementation bug in it. So why not just write, that the activation context "handle" cannot be used in another process?
	Or better still, that it may lead to crashes, undefined behavior and corrupted memory.
</p>

<p>But ideally, there should be a separate parameter for the <code class="blg_cq">QueueUserAPC</code> function, or maybe a new function <code class="blg_cq">QueueUserAPCEx</code>, that should tell it whether or not to use
	the activation context at all. And, they should technically also modify the current implementation of <code class="blg_cq">QueueUserAPC</code>, and internally pass <code class="blg_cq">NULL</code> for the 
	activation context into the APC callback function if the <code class="blg_cq">hThread</code> input handle points to a thread in a different process.
</p>


<p>Then this:</p>

<blockquote class="qt0">
	... Similarly, if a 64-bit process queues an APC to a 32-bit process or vice versa, addresses will be incorrect and the application will crash.
</blockquote>

<p>Again, they are not telling the whole truth.</p>

<p>You cannot queue a 32-bit APC callback into a 64-bit process. But you can queue a 64-bit APC callback into a 32-bit process. For that, instead of <code class="blg_cq">ZwQueueApcThread</code> 
	one needs to use another lesser known and undocumented native function <code class="blg_cq">RtlQueueApcWow64Thread</code>, that queues a 64-bit APC callback in a 32-bit 
	<a href="https://docs.microsoft.com/en-us/windows/win32/winprog64/wow64-implementation-details" rel="external nofollow" target="_blank">WOW64</a> process:</p>

<a name="rqaw64t"></a>
<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode19"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">RtlQueueApcWow64Thread</span> (
	<span class="c_ac">HANDLE</span> hThread,
	<span class="c_ac">PKNORMAL_ROUTINE</span> ApcRoutine,
	<span class="c_ac">PVOID</span> ApcContext,
	<span class="c_ac">PVOID</span> Argument1,
	<span class="c_ac">PVOID</span> Argument2
);</code></pre></div>

<p>Alternatively, from the kernel-mode instead of calling <code class="blg_cq">KeInsertQueueApc</code> one needs to call <code class="blg_cq">PsWrapApcWow64Thread</code>:</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode20"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">PsWrapApcWow64Thread</span> (
    _Inout_ <span class="c_ac">PVOID</span> *ApcContext,
	_Inout_ <span class="c_ac">PVOID</span> *ApcRoutine
);</code></pre></div>

<p>But why would someone need to queue a 64-bit APC into a 32-bit process? We'll <a href="https://dennisbabkin.com/blog/?i=AAA03000#64_bit_apc_in_32_bit_proc">review it later</a>.</p>


<a name="apc_demo"></a>
<h1>User-Mode APC Demo Code<a href="https://dennisbabkin.com/blog/?i=AAA03000#apc_demo" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h1>

<p>To illustrate the concepts and pitfalls of the user-mode APCs that I explained above, we wrote a small sample code:</p>

<blockquote class="qt1 q_inf">
	Make sure to check comments in the code below for more details.
</blockquote>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode21" style="height: 32em; overflow-y: auto;"><code><span class="c_kw">int</span> <span class="c_fun">main</span>()
{
	<span class="c_cmt">//Create activation context</span>
	<span class="c_ac">HANDLE</span> hActCtx = <span class="c_ac">INVALID_HANDLE_VALUE</span>;
	<span class="c_ac">ACTCTX</span> ActCtx = { <span class="c_kw">sizeof</span>(ActCtx), <span class="c_ac">ACTCTX_FLAG_HMODULE_VALID</span> | <span class="c_ac">ACTCTX_FLAG_RESOURCE_NAME_VALID</span> };

	<span class="c_kw">if</span> (ActCtx.hModule = <span class="c_fun">LoadLibraryW</span>(<span class="c_dq">L"IMAGEHLP"</span>))
	{
		ActCtx.lpResourceName = <span class="c_ac">CREATEPROCESS_MANIFEST_RESOURCE_ID</span>;

		hActCtx = <span class="c_fun">CreateActCtxW</span>(&amp;ActCtx);

		<span class="c_fun">FreeLibrary</span>(ActCtx.hModule);
	}

	<span class="c_kw">if</span> (hActCtx != <span class="c_ac">INVALID_HANDLE_VALUE</span>)
	{
		<span class="c_cmt">//Check that we don't have an activation context yet</span>
		<span class="c_fun">QueryCtx</span>();

		<span class="c_cmt">//Set our activation context for this process</span>
		<span class="c_ac">ULONG_PTR</span> dwCookie;
		<span class="c_kw">if</span> (<span class="c_fun">ActivateActCtx</span>(hActCtx, &amp;dwCookie))
		{
			<span class="c_cmt">//Check that we have an activation context now</span>
			<span class="c_fun">QueryCtx</span>();

			<span class="c_cmt">//Queue APC in this process on this thread</span>
			<span class="c_fun">QueueUserAPC</span>(OnApc, <span class="c_fun">GetCurrentThread</span>(), 0);

			<span class="c_cmt">//Make APC callback execute now</span>
			<span class="c_fun">ZwTestAlert</span>();			<span class="c_cmt">//same as: SleepEx(0, TRUE);</span>

			<span class="c_cmt">//Queue APC in a remote process (using native API)</span>
			<span class="c_cmt">//It will succeed</span>
			<span class="c_fun">TestAPC_InRemoteProcess</span>(<span class="c_kw">true</span>);

			<span class="c_cmt">//Queue APC in a remote process (using Win32 API)</span>
			<span class="c_cmt">//It will crash the remote process!</span>
			<span class="c_fun">TestAPC_InRemoteProcess</span>(<span class="c_kw">false</span>);

			<span class="c_fun">DeactivateActCtx</span>(0, dwCookie);
		}

		<span class="c_fun">ReleaseActCtx</span>(hActCtx);
	}

	<span class="c_kw">return</span> 0;
}

<span class="c_kw">void</span> <span class="c_fun">TestAPC_InRemoteProcess</span>(<span class="c_kw">bool</span> bUseNativeApi)
{
	<span class="c_cmt">//Invoke a user-mode APC callback in a remote process</span>

	<span class="c_cmt">//Get path to cmd.exe</span>
	<span class="c_ac">WCHAR</span> appname[<span class="c_ac">MAX_PATH</span>];
	<span class="c_kw">if</span> (<span class="c_fun">GetEnvironmentVariableW</span>(<span class="c_dq">L"comspec"</span>, appname, <span class="c_fun">_countof</span>(appname)))
	{
		<span class="c_ac">PROCESS_INFORMATION</span> pi;
		<span class="c_ac">STARTUPINFO</span> si = { <span class="c_kw">sizeof</span>(si) };

		<span class="c_cmt">//Run cmd.exe suspended</span>
		<span class="c_kw">if</span> (<span class="c_fun">CreateProcessW</span>(appname, 0, 0, 0, 0, <span class="c_ac">CREATE_SUSPENDED</span>, 0, 0, &amp;si, &amp;pi))
		{
			<span class="c_cmt">//Invoke APC in cmd.exe, using either a native or documented Win32 function</span>
			<span class="c_cmt">//We don't care about the callback function itself, for as long as it can</span>
			<span class="c_cmt">//handle our input parameters. Thus I will use LPVOID TlsGetValue(DWORD)</span>
			bUseNativeApi
				? <span class="c_fun">ZwQueueApcThread</span>(pi.hThread, (<span class="c_ac">PKNORMAL_ROUTINE</span>)TlsGetValue, 0, 0, 0)
				: <span class="c_fun">QueueUserAPC</span>((<span class="c_ac">PAPCFUNC</span>)TlsGetValue, pi.hThread, 0);

			<span class="c_cmt">//Resume thread to let APC execute</span>
			<span class="c_fun">ResumeThread</span>(pi.hThread);

			<span class="c_fun">CloseHandle</span>(pi.hThread);
			<span class="c_fun">CloseHandle</span>(pi.hProcess);
		}
	}
}

<span class="c_kw">void</span> <span class="c_fun">QueryCtx</span>()
{
	<span class="c_cmt">//Query activation context in this process and output it into (debugger) console</span>
	<span class="c_ac">SIZE_T</span> cb = 0;
	<span class="c_ac">ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION</span> acrli;
	<span class="c_kw">union</span> {
		<span class="c_ac">PVOID</span> buf;
		<span class="c_ac">PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION</span> pacadi;
	};
	buf = 0;
	<span class="c_ac">ACTIVATION_CONTEXT_QUERY_INDEX</span> QueryIndex = { 1, 0 };

__again:
	<span class="c_kw">switch</span> (<span class="c_fun">QueryActCtxW</span>(<span class="c_ac">QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX</span>, 0, &amp;QueryIndex,
		AssemblyDetailedInformationInActivationContext, buf, cb, &amp;cb) ? <span class="c_ac">NOERROR</span> : <span class="c_fun">GetLastError</span>())
	{
	<span class="c_kw">case</span> <span class="c_ac">ERROR_INSUFFICIENT_BUFFER</span>:
		buf = <span class="c_fun">alloca</span>(cb);
		<span class="c_kw">goto</span> __again;
		<span class="c_kw">break</span>;
	<span class="c_kw">case</span> <span class="c_ac">NOERROR</span>:
		<span class="c_kw">if</span> (buf)
		{
			<span class="c_fun">DbgPrint</span>(<span class="c_dq">"==========\nPID=%u: %S\n%S\n"</span>, 
				<span class="c_fun">GetCurrentProcessId</span>(), 
				pacadi-&gt;lpAssemblyManifestPath, 
				pacadi-&gt;lpAssemblyEncodedAssemblyIdentity);
		}
		<span class="c_kw">break</span>;
	}

	<span class="c_kw">if</span> (<span class="c_fun">QueryActCtxW</span>(<span class="c_ac">QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX</span>, 0, 0, 
		RunlevelInformationInActivationContext, &amp;acrli, <span class="c_kw">sizeof</span>(acrli), &amp;cb))
	{
		<span class="c_fun">DbgPrint</span>(<span class="c_dq">"PID=%u: RunLevel = %x\n"</span>, <span class="c_fun">GetCurrentProcessId</span>(), acrli.RunLevel);
	}
}

<span class="c_ac">VOID</span> <span class="c_ac">NTAPI</span> <span class="c_fun">OnApc</span>(
	_In_ <span class="c_ac">ULONG_PTR</span> <span class="c_cmt">/*Parameter*/</span>
)
{
	<span class="c_cmt">//User-mode APC callback</span>
	<span class="c_fun">QueryCtx</span>();
}</code></pre></div>

<p>To compile this code sample in Visual Studio without <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk" rel="external nofollow" target="_blank">WDK</a>, 
	you will need the following declarations:</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode22" style="height: 16em; overflow-y: auto;"><code><span class="c_ppr">#pragma</span> <span class="c_fun">comment</span>(lib, <span class="c_dq">"ntdll.lib"</span>)		<span class="c_cmt">//For native function calls</span>

<span class="c_kw">typedef</span>
<span class="c_ac">VOID</span>
<span class="c_ac">KNORMAL_ROUTINE</span>(
	__in_opt <span class="c_ac">PVOID</span> NormalContext,
	__in_opt <span class="c_ac">PVOID</span> SystemArgument1,
	__in_opt <span class="c_ac">PVOID</span> SystemArgument2
);
<span class="c_kw">typedef</span> <span class="c_ac">KNORMAL_ROUTINE</span>* <span class="c_ac">PKNORMAL_ROUTINE</span>;

<span class="c_kw">extern</span> <span class="c_dq">"C"</span> {
	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">ZwQueueApcThread</span>(<span class="c_ac">HANDLE</span> hThread,
		<span class="c_ac">PKNORMAL_ROUTINE</span> ApcRoutine, 
		<span class="c_ac">PVOID</span> ApcContext, 
		<span class="c_ac">PVOID</span> Argument1, 
		<span class="c_ac">PVOID</span> Argument2);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">ZwTestAlert</span>();

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">ULONG</span> <span class="c_ac">CALLBACK</span>
		<span class="c_fun">DbgPrint</span>(
			_In_z_ _Printf_format_string_ <span class="c_ac">PCSTR</span> Format,
			...
		);
}</code></pre></div>



<a name="64_bit_apc_in_32_bit_proc"></a>
<h1>64-bit User-Mode APC In a 32-bit Process<a href="https://dennisbabkin.com/blog/?i=AAA03000#64_bit_apc_in_32_bit_proc" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h1>

<p>One reason to queue a 64-bit user-mode APC into a 32-bit process would be to inject a DLL into it. But that is not the only use-case.</p>

<p>Say, what if you need to know a list of modules that were loaded into a process?</p>

<p>One way to do it for your own process is to call undocumented <code class="blg_cq">LdrQueryProcessModuleInformation</code> function. It will write the full list in provided memory buffer:</p>

<a name="lqpmi"></a>
<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode23"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">LdrQueryProcessModuleInformation</span> 
(
	<span class="c_ac">PRTL_PROCESS_MODULES</span> psmi,
	<span class="c_ac">ULONG</span> BufferSize,
	<span class="c_ac">PULONG</span> RealSize
);</code></pre></div>

<p>But how do you call it for modules in a remote process, that may also be of a different bitness?</p>

<p>Let me give you the steps:</p>

<ol>
	<li>We need to create a section (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwcreatesection" rel="external nofollow" target="_blank"><code class="blg_cq">NtCreateSection</code></a>) 
		that we will use to collect and pass the information about the modules in the target process (in the Win32 parlance, it is called a 
		<a href="https://docs.microsoft.com/en-us/windows/win32/memory/file-mapping" rel="external nofollow" target="_blank"><code class="blg_cq">file mapping object</code></a>.)</li>
	<li>Map that section into the target process (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwmapviewofsection" rel="external nofollow" target="_blank"><code class="blg_cq">ZwMapViewOfSection</code></a>)
		for writing.
	</li>
	<li>Create suspended thread in the target process with the address of its entry point set to <code class="blg_cq">RtlExitUserThread</code>.
		We don't really need the thread function itself, and thus we will shunt it to exit as soon as possible.
		<blockquote class="qt1 q_inf">
			It is important in this case to use the native function <code class="blg_cq">RtlCreateUserThread</code> to start the thread instead of the documented 
			<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread" rel="external nofollow" target="_blank"><code class="blg_cq">CreateRemoteThread</code></a>.
			Such is needed to ensure that we can control the bitness of the entry point of the thread.
			<code class="blg_cq">CreateRemoteThread</code> would not allow it since the <em>actual</em> entry point that it uses is <code class="blg_cq">kernel32!BaseThreadInitThunk</code> and not the 
			function that we provide into it in its <code class="blg_cq">lpStartAddress</code> parameter.
		</blockquote>
		<p>To define which context the thread will start in: 64-bit or 32-bit, the system will use the bitness of the module that the entry point of the thread is located in.
			(Or if there's no module, like in a plain <em>shellcode</em>, the thread will receive a 32-bit context by default.)
		</p>
		<blockquote class="qt1 q_inf">
			Note that it is possible to run a 64-bit thread in a 32-bit (so called 
			<a href="https://docs.microsoft.com/en-us/windows/win32/winprog64/wow64-implementation-details" rel="external nofollow" target="_blank">WOW64</a>) process in a 64-bit OS.
			There is also a 64-bit version of the <code class="blg_cq">ntdll.dll</code> module that is mapped into every 32-bit WOW64 process.
		</blockquote>
	</li>
	<li>Insert a user-mode APC into our suspended thread. The bitness of the callback will depend on the bitness of the target process:
		<ul>
			<li><strong>64-bit</strong> Process: We only need <code class="blg_cq">ZwQueueApcThread</code> function to queue 64-bit APC callback natively. Quite straightforward here.</li>
			<li><strong>32-bit</strong> Process: First use <code class="blg_cq">ZwQueueApcThread</code> to queue a 64-bit callback to retrieve all mapped 64-bit modules. (As I said above, any 32-bit WOW64 
			process will have at least one 64-bit module loaded into it.) And then use <code class="blg_cq">RtlQueueApcWow64Thread</code> to queue a 32-bit APC callback.</li>
		</ul>
		<p>We will use the <code class="blg_cq">LdrQueryProcessModuleInformation</code> function as a callback for the APC of the appropriate bitness. Very conveniently for us it has <a href="https://dennisbabkin.com/blog/?i=AAA03000#lqpmi">3 input
			parameters</a> that match custom arguments for the <a href="https://dennisbabkin.com/blog/?i=AAA03000#zqat"><code class="blg_cq">ZwQueueApcThread</code></a> and <a href="https://dennisbabkin.com/blog/?i=AAA03000#rqaw64t"><code class="blg_cq">RtlQueueApcWow64Thread</code></a> functions. 
			This is also another reason why we chose those native functions versus the documented 
			<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc" rel="external nofollow" target="_blank"><code class="blg_cq">QueueUserAPC</code></a>.
		</p>
	</li>
	<li>Resume thread, that will run our queued APC in the target process. Since we set its callback to <code class="blg_cq">LdrQueryProcessModuleInformation</code>, that function
		will fill in the memory in our mapped section with the needed information about the modules in the target process.
	</li>
	<li>The thread itself will run <code class="blg_cq">RtlExitUserThread</code> function that will terminate it. (Unlike <code class="blg_cq">Create[Remote]Thread</code> that will pass control to an internal
		wrapper function upon the thread return.)
	</li>
	<li>In our own process we simply wait for the remote thread to finish running.</li>
	<li>Then we can unmap the section from the target process, and map it into our own process and read the modules information that we collected.</li>
	<li>Destroy the section and do other cleanup.</li>
</ol>

<p>Having run the algorithm above on an older (32-bit) Microsoft Word process, we can get its list of loaded modules:</p>

<div class="blg_idv i_algn_c"><a href="https://dbimgs.s3-us-west-2.amazonaws.com/dpths-f-wndws-pc-spcts-f-snchrns-prcdr-cll-ntrnls-frm-th-krnl-md-sub02.png" target="_blank" class="fImg" rel="gallery"><img src="https://dbimgs.s3-us-west-2.amazonaws.com/dpths-f-wndws-pc-spcts-f-snchrns-prcdr-cll-ntrnls-frm-th-krnl-md-sub02.png" draggable="false" alt="Console App"></a></div>



<a name="code_get_proc_mods"></a>
<h2>Code Sample to Get Process Modules<a href="https://dennisbabkin.com/blog/?i=AAA03000#code_get_proc_mods" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h2>

<p>To better illustrate the concepts <a href="https://dennisbabkin.com/blog/?i=AAA03000#64_bit_apc_in_32_bit_proc">outlined here</a> let me give you the following code sample that will retrieve modules 
	that are mapped into an arbitrary process:</p>

<blockquote class="qt1 q_inf">
	Note: Below is an unoptimized code intended for better readability for the reader.
	We're formatting it with <code class="blg_cq">goto</code> statements only to prevent the need for horizontal scrolling.
	Please refer to comments for additional details.
</blockquote>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode24" style="height: 32em; overflow-y: auto;"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">ListModulesForProc</span>(<span class="c_ac">DWORD</span> dwPID)
{
	<span class="c_cmt">//'dwPID' = process ID of the process to retrieve modules for</span>
	<span class="c_ac">NTSTATUS</span> status = <span class="c_ac">S_FALSE</span>;

	<span class="c_ac">HANDLE</span> hProcess = <span class="c_ac">NULL</span>;
	<span class="c_ac">LARGE_INTEGER</span> liSectionSize = {};
	<span class="c_ac">SIZE_T</span> ViewSize = 0;
	<span class="c_ac">NTDLL_FN_PTRS</span> nfp = {};
	<span class="c_ac">ULONG_PTR</span> wow = 0;

<span class="c_ppr">#ifndef</span> _WIN64
<span class="c_ppr">#error</span> Must be compiled as x64 only!
<span class="c_ppr">#endif</span>

	hProcess = <span class="c_fun">OpenProcess</span>(<span class="c_ac">PROCESS_VM_OPERATION</span> | <span class="c_ac">PROCESS_CREATE_THREAD</span> | <span class="c_ac">PROCESS_QUERY_INFORMATION</span>, <span class="c_ac">FALSE</span>, dwPID);
	<span class="c_kw">if</span> (!hProcess)
	{
		status = <span class="c_fun">GetLastError</span>();
		<span class="c_kw">goto</span> cleanup;
	}

	<span class="c_cmt">//Collect 64-bit modules</span>
	nfp.pRtlExitUserThread.pstrName = <span class="c_dq">"RtlExitUserThread"</span>;
	nfp.pRtlExitUserThread.pfn = (<span class="c_ac">FARPROC</span>)RtlExitUserThread;
	nfp.pLdrQueryProcessModuleInformation.pstrName = <span class="c_dq">"LdrQueryProcessModuleInformation"</span>;
	nfp.pLdrQueryProcessModuleInformation.pfn = (<span class="c_ac">FARPROC</span>)LdrQueryProcessModuleInformation;

	status = <span class="c_fun">CollectModules</span>(hProcess, <span class="c_ac">TRUE</span>, &amp;nfp);
	<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
		<span class="c_kw">goto</span> cleanup;

	<span class="c_cmt">//Get process bitness</span>
	status = <span class="c_fun">NtQueryInformationProcess</span>(hProcess, ProcessWow64Information, &amp;wow, <span class="c_kw">sizeof</span>(wow), <span class="c_ac">NULL</span>);
	<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
		<span class="c_kw">goto</span> cleanup;

	<span class="c_kw">if</span> (wow)
	{
		<span class="c_cmt">//Collect 32-bit modules</span>
		status = <span class="c_fun">ResolveNtDllFuncs32bit</span>(&amp;nfp);
		<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
			<span class="c_kw">goto</span> cleanup;

		status = <span class="c_fun">CollectModules</span>(hProcess, <span class="c_ac">FALSE</span>, &amp;nfp);
		<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
			<span class="c_kw">goto</span> cleanup;
	}
	<span class="c_kw">else</span>
		status = <span class="c_ac">STATUS_SUCCESS</span>;

cleanup:
	<span class="c_cmt">//Clean-up process</span>

	<span class="c_kw">if</span>(hProcess)
		<span class="c_fun">CloseHandle</span>(hProcess);

	<span class="c_fun">assert</span>(<span class="c_ac">SUCCEEDED</span>(status));
	<span class="c_kw">return</span> status;
}</code></pre></div>

<p>The actual work of injecting an APC into a target process is done in the following function:</p>

<a name="collect_modules"></a>
<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode25" style="height: 32em; overflow-y: auto;"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">CollectModules</span>(<span class="c_ac">HANDLE</span> hProcess, <span class="c_ac">BOOL</span> b64bit, <span class="c_ac">NTDLL_FN_PTRS</span>* pfnPtrs)
{
	<span class="c_cmt">//INFO: It is not the most efficient way of calling this function twice with</span>
	<span class="c_cmt">//      repeated creation of the section and then mapping it into a process.</span>
	<span class="c_cmt">//      Ideally, you'd create it once and then close and re-create it ONLY if its</span>
	<span class="c_cmt">//      original size is too small to fit all the modules.</span>
	<span class="c_cmt">//</span>
	<span class="c_cmt">//      But, I will leave this code as-is for brevity, as such optimization</span>
	<span class="c_cmt">//      has nothing to do with the APC concepts that we discuss in this blog post.</span>

	<span class="c_ac">NTSTATUS</span> status;

	<span class="c_ac">HANDLE</span> hThread = <span class="c_ac">NULL</span>;
	<span class="c_ac">BYTE</span>* pThisBaseAddr = <span class="c_ac">NULL</span>;
	<span class="c_ac">SIZE_T</span> ViewSize = 0;
	<span class="c_ac">ULONG</span> uiRealSize = 0;
	<span class="c_ac">PRTL_PROCESS_MODULES</span> pRPMs = <span class="c_ac">NULL</span>;
	PRTL_PROCESS_MODULES32 pRPMs32 = <span class="c_ac">NULL</span>;
	<span class="c_ac">HANDLE</span> hSection = <span class="c_ac">NULL</span>;
	<span class="c_ac">LARGE_INTEGER</span> liSectionSize = {};
	<span class="c_ac">PVOID</span> pBaseAddr = <span class="c_ac">NULL</span>;
	<span class="c_ac">ULONG</span> szBufferSz = 0;
	<span class="c_kw">bool</span> bExportSuppression = <span class="c_kw">false</span>;
	<span class="c_kw">bool</span> bDone = <span class="c_kw">false</span>;

	<span class="c_kw">typedef</span> <span class="c_ac">NTSTATUS</span>(<span class="c_ac">CALLBACK</span> <span class="c_ac">PFN_PTR</span>)(<span class="c_ac">HANDLE</span> hThread,
		<span class="c_ac">PKNORMAL_ROUTINE</span> ApcRoutine,
		<span class="c_ac">PVOID</span> ApcContext,
		<span class="c_ac">PVOID</span> Argument1,
		<span class="c_ac">PVOID</span> Argument2);
	<span class="c_ac">PFN_PTR</span>* pQueueAPC;

	<span class="c_fun">assert</span>(pfnPtrs);
	<span class="c_fun">assert</span>(pfnPtrs-&gt;pLdrQueryProcessModuleInformation.pfn);
	<span class="c_fun">assert</span>(pfnPtrs-&gt;pRtlExitUserThread.pfn);

	<span class="c_cmt">//Assume 8 memory pages as the original section size</span>
	<span class="c_ac">SYSTEM_INFO</span> si = {};
	<span class="c_fun">GetSystemInfo</span>(&amp;si);
	szBufferSz = si.dwPageSize * 8;
	<span class="c_fun">assert</span>(szBufferSz);

	<span class="c_cmt">//See if export suppression is enabled in Control Flow Guard (CFG) for the target process</span>
	<span class="c_cmt">//INFO: If so, we need to enable our thread's EP function and APC callback for CFG, </span>
	<span class="c_cmt">//      since calling them otherwise will crash the target process as a security measure!</span>
	status = <span class="c_fun">IsExportSuppressionEnabled</span>(hProcess, &amp;bExportSuppression);
	<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
		<span class="c_kw">goto</span> cleanup;

	<span class="c_kw">if</span> (bExportSuppression)
	{
		<span class="c_cmt">//Enable our function pointers for CFG in the process</span>
		status = <span class="c_fun">SetValidExport</span>(hProcess, pfnPtrs-&gt;pRtlExitUserThread.pfn);
		<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
			<span class="c_kw">goto</span> cleanup;

		status = <span class="c_fun">SetValidExport</span>(hProcess, pfnPtrs-&gt;pLdrQueryProcessModuleInformation.pfn);
		<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
			<span class="c_kw">goto</span> cleanup;
	}

	<span class="c_kw">while</span> (!bDone)
	{
		bDone = <span class="c_kw">true</span>;

		liSectionSize.QuadPart = szBufferSz;

		<span class="c_cmt">//Create section</span>
		<span class="c_fun">assert</span>(!hSection);
		status = <span class="c_fun">NtCreateSection</span>(&amp;hSection, <span class="c_ac">SECTION_ALL_ACCESS</span>, <span class="c_ac">NULL</span>, &amp;liSectionSize, <span class="c_ac">PAGE_READWRITE</span>, <span class="c_ac">SEC_COMMIT</span>, 0);
		<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
			<span class="c_kw">goto</span> cleanup;

		<span class="c_fun">assert</span>(!pBaseAddr);
		pBaseAddr = <span class="c_ac">NULL</span>;
		ViewSize = 0;

		<span class="c_cmt">//Map section into target process for writing</span>
		status = <span class="c_fun">ZwMapViewOfSection</span>(hSection, hProcess, &amp;pBaseAddr, 0, 0, <span class="c_ac">NULL</span>, &amp;ViewSize, ViewShare, 0, <span class="c_ac">PAGE_READWRITE</span>);
		<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
			<span class="c_kw">goto</span> cleanup;

		<span class="c_cmt">//Create remote thread in the target process (and shunt it to RtlExitUserThread)</span>
		<span class="c_cmt">//Ensure that the thread is created suspended!</span>
		<span class="c_fun">assert</span>(!hThread);
		status = <span class="c_fun">RtlCreateUserThread</span>(hProcess, <span class="c_ac">NULL</span>, <span class="c_ac">TRUE</span>, 0, 0, 0, pfnPtrs-&gt;pRtlExitUserThread.pfn, <span class="c_ac">NULL</span>, &amp;hThread, <span class="c_ac">NULL</span>);
		<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
			<span class="c_kw">goto</span> cleanup;

		<span class="c_cmt">//(Optional call)</span>
		<span class="c_cmt">//INFO: Notifications about creation and termination of this thread will not be passed to an attached debugger.</span>
		<span class="c_cmt">//      And, exceptions in such thread will not be passed to a debugger either.</span>
		<span class="c_fun">NtSetInformationThread</span>(hThread, ThreadHideFromDebugger, 0, 0);

		<span class="c_cmt">//Pick which APC function to use (depending on the bitness)</span>
		pQueueAPC = b64bit ? ZwQueueApcThread : RtlQueueApcWow64Thread;

		<span class="c_cmt">//We'll reserve last ULONG in our buffer for LdrQueryProcessModuleInformation to return its RequiredSize</span>
		status = <span class="c_fun">pQueueAPC</span>(hThread, 
			(<span class="c_ac">PKNORMAL_ROUTINE</span>)pfnPtrs-&gt;pLdrQueryProcessModuleInformation.pfn, 
			pBaseAddr, 
			(<span class="c_ac">PVOID</span>)(szBufferSz - <span class="c_kw">sizeof</span>(<span class="c_ac">ULONG</span>)),
			(<span class="c_ac">BYTE</span>*)pBaseAddr + szBufferSz - <span class="c_kw">sizeof</span>(<span class="c_ac">ULONG</span>));

		<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
			<span class="c_kw">goto</span> cleanup;

		<span class="c_cmt">//Let our APC callback and the thread itself run</span>
		<span class="c_kw">if</span> (<span class="c_fun">ResumeThread</span>(hThread) != 1)
		{
			status = <span class="c_fun">GetLastError</span>();
			<span class="c_kw">goto</span> cleanup;
		}

		<span class="c_cmt">//Wait for the thread to finish</span>
		<span class="c_kw">if</span> (<span class="c_fun">WaitForSingleObject</span>(hThread, <span class="c_ac">INFINITE</span>) != WAIT_OBJECT_0)
		{
			status = <span class="c_fun">GetLastError</span>();
			<span class="c_kw">goto</span> cleanup;
		}

		<span class="c_cmt">//Unmap the section from the target process</span>
		status = <span class="c_fun">ZwUnmapViewOfSection</span>(hProcess, pBaseAddr);
		<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
			<span class="c_kw">goto</span> cleanup;

		pBaseAddr = <span class="c_ac">NULL</span>;

		<span class="c_fun">assert</span>(!pThisBaseAddr);
		pThisBaseAddr = <span class="c_ac">NULL</span>;
		ViewSize = 0;

		<span class="c_cmt">//Map the same section into our own process so that we can read it</span>
		status = <span class="c_fun">ZwMapViewOfSection</span>(hSection, <span class="c_fun">GetCurrentProcess</span>(), 
					(<span class="c_ac">PVOID</span>*)&amp;pThisBaseAddr, 0, 0, <span class="c_ac">NULL</span>, &amp;ViewSize, ViewShare, 0, <span class="c_ac">PAGE_READONLY</span>);
		<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
			<span class="c_kw">goto</span> cleanup;

		<span class="c_fun">assert</span>(ViewSize &lt;= szBufferSz);

		<span class="c_cmt">//Check if the size of the section that we assumed earlier was enough to fill in all modules</span>
		uiRealSize = *(<span class="c_ac">ULONG</span>*)(pThisBaseAddr + szBufferSz - <span class="c_kw">sizeof</span>(<span class="c_ac">ULONG</span>));
		<span class="c_kw">if</span> (uiRealSize &lt;= szBufferSz)
		{
			<span class="c_cmt">//Unfortunately we cannot check the return value from the LdrQueryProcessModuleInformation() call. Here's why:</span>
			<span class="c_cmt">//The LdrQueryProcessModuleInformation() function is called from an APC callback, and by the time</span>
			<span class="c_cmt">//our remote thread gets to calling RtlExitUserThread() its context will be restored by a call to ntdll!NtContinue()</span>

			<span class="c_kw">if</span> (b64bit)
			{
				<span class="c_cmt">//64-bit modules</span>
				pRPMs = (<span class="c_ac">PRTL_PROCESS_MODULES</span>)pThisBaseAddr;
				<span class="c_ac">ULONG</span> nNumberOfModules = pRPMs-&gt;NumberOfModules;

				<span class="c_cmt">//Check that we have at least one module loaded, otherwise it's an error</span>
				<span class="c_kw">if</span> (!nNumberOfModules)
				{
					status = <span class="c_ac">STATUS_PROCEDURE_NOT_FOUND</span>;
					<span class="c_kw">goto</span> cleanup;
				}

				<span class="c_cmt">//Output results to the console</span>
				<span class="c_fun">wprintf</span>(<span class="c_dq">L"64-bit Modules (%u):\n"</span>, nNumberOfModules);

				<span class="c_ac">RTL_PROCESS_MODULE_INFORMATION</span>* pPMI = pRPMs-&gt;Modules;

				<span class="c_kw">do</span>
				{
					<span class="c_fun">printf</span>(<span class="c_dq">"%p sz=%08X flg=%08X Ord=%02X %s\n"</span>
						,
						pPMI-&gt;ImageBase,
						pPMI-&gt;ImageSize,
						pPMI-&gt;Flags,
						pPMI-&gt;InitOrderIndex,
						pPMI-&gt;FullPathName
					);
				}
				<span class="c_kw">while</span> (pPMI++, --nNumberOfModules);
			}
			<span class="c_kw">else</span>
			{
				<span class="c_cmt">//32-bit modules</span>
				pRPMs32 = (PRTL_PROCESS_MODULES32)pThisBaseAddr;
				<span class="c_ac">ULONG</span> nNumberOfModules = pRPMs32-&gt;NumberOfModules;

				<span class="c_cmt">//Check that we have at least one module loaded, otherwise it's an error</span>
				<span class="c_kw">if</span> (!nNumberOfModules)
				{
					status = <span class="c_ac">STATUS_PROCEDURE_NOT_FOUND</span>;
					<span class="c_kw">goto</span> cleanup;
				}

				<span class="c_cmt">//Output results to the console</span>
				<span class="c_fun">wprintf</span>(<span class="c_dq">L"32-bit Modules (%u):\n"</span>, nNumberOfModules);

				<span class="c_ac">RTL_PROCESS_MODULE_INFORMATION</span>* pPMI32 = pRPMs32-&gt;Modules;

				<span class="c_kw">do</span>
				{
					<span class="c_fun">printf</span>(<span class="c_dq">"%08X sz=%08X flg=%08X Ord=%02X %s\n"</span>
						,
						pPMI32-&gt;ImageBase,
						pPMI32-&gt;ImageSize,
						pPMI32-&gt;Flags,
						pPMI32-&gt;InitOrderIndex,
						pPMI32-&gt;FullPathName
					);
				}
				<span class="c_kw">while</span> (pPMI32++, --nNumberOfModules);
			}

			status = <span class="c_ac">STATUS_SUCCESS</span>;
		}
		<span class="c_kw">else</span>
		{
			<span class="c_cmt">//Need more memory - allocate it on a page boundary</span>
			<span class="c_kw">if</span> (uiRealSize % si.dwPageSize)
			{
				szBufferSz = uiRealSize / si.dwPageSize;
				szBufferSz++;
				szBufferSz *= si.dwPageSize;
			}
			<span class="c_kw">else</span>
				szBufferSz = uiRealSize;

			<span class="c_cmt">//Retry</span>
			bDone = <span class="c_kw">false</span>;
		}

cleanup:
		<span class="c_cmt">//Clean-up</span>

		<span class="c_kw">if</span> (pBaseAddr)
		{
			<span class="c_fun">ZwUnmapViewOfSection</span>(<span class="c_fun">GetCurrentProcess</span>(), pBaseAddr);
			pBaseAddr = <span class="c_ac">NULL</span>;
		}

		<span class="c_kw">if</span> (pThisBaseAddr)
		{
			<span class="c_fun">ZwUnmapViewOfSection</span>(<span class="c_fun">GetCurrentProcess</span>(), pThisBaseAddr);
			pThisBaseAddr = <span class="c_ac">NULL</span>;
		}

		<span class="c_kw">if</span> (hSection)
		{
			<span class="c_fun">ZwClose</span>(hSection);
			hSection = <span class="c_ac">NULL</span>;
		}

		<span class="c_kw">if</span> (hThread)
		{
			<span class="c_fun">ZwClose</span>(hThread);
			hThread = <span class="c_ac">NULL</span>;
		}
	}

	<span class="c_kw">return</span> status;
}</code></pre></div>

<blockquote class="qt1 q_inf">
	You might have noticed that the function above calls 
	<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntsetinformationthread" rel="external nofollow" target="_blank"><code class="blg_cq">NtSetInformationThread</code></a> 
	with the <code class="blg_cq">ThreadHideFromDebugger</code> flag. This is an optional call that may be used by a debugger process to ensure that its own thread that was 
	injected into the target process does not cause notifications, such as thread creation, termination, etc. Usually these notifications are passed
	to a debugger that is attached to a debuggee process. By using <code class="blg_cq">ThreadHideFromDebugger</code> a debugger can prevent that. 
	
	<p>Additionally, by specifying <code class="blg_cq">ThreadHideFromDebugger</code> for the thread all exceptions in it will not be passed to an attached debugger either.
	</p>
</blockquote>

<p>Other important functions resolve the 32-bit export pointers for the mapped <code class="blg_cq">ntdll!LdrQueryProcessModuleInformation</code> and <code class="blg_cq">ntdll!RtlExitUserThread</code> native functions
	that we will need to inject our APC callback into a 32-bit WOW64 process:</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode26" style="height: 32em; overflow-y: auto;"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">ResolveNtDllFuncs32bit</span>(<span class="c_ac">NTDLL_FN_PTRS</span>* pfnPtrs)
{
	<span class="c_ac">NTSTATUS</span> status;

	<span class="c_ac">HANDLE</span> hSection;
	<span class="c_ac">SECTION_IMAGE_INFORMATION</span> sii;
	<span class="c_ac">PVOID</span> pBaseAddr = <span class="c_ac">NULL</span>;
	<span class="c_ac">SIZE_T</span> ViewSize = 0;

	<span class="c_cmt">//We'll need the special 32-bit image section for ntdll.dll</span>
	<span class="c_kw">static</span> <span class="c_kw">const</span> <span class="c_ac">WCHAR</span> oa_ntdll_str[] = <span class="c_dq">L"\\KnownDlls32\\ntdll.dll"</span>;
	<span class="c_kw">static</span> <span class="c_kw">const</span> <span class="c_ac">UNICODE_STRING</span> oa_ntdll_ustr = { <span class="c_kw">sizeof</span>(oa_ntdll_str) - <span class="c_kw">sizeof</span>((oa_ntdll_str)[0]), <span class="c_kw">sizeof</span>(oa_ntdll_str), <span class="c_kw">const_cast</span>&lt;<span class="c_ac">PWSTR</span>&gt;(oa_ntdll_str) };
	<span class="c_kw">static</span> <span class="c_ac">OBJECT_ATTRIBUTES</span> oa_ntdll = { <span class="c_kw">sizeof</span>(oa_ntdll), 0, <span class="c_kw">const_cast</span>&lt;<span class="c_ac">PUNICODE_STRING</span>&gt;(&amp;oa_ntdll_ustr), <span class="c_ac">OBJ_CASE_INSENSITIVE</span> };

	pfnPtrs-&gt;pLdrQueryProcessModuleInformation.pfn = <span class="c_ac">NULL</span>;
	pfnPtrs-&gt;pRtlExitUserThread.pfn = <span class="c_ac">NULL</span>;

	status = <span class="c_fun">ZwOpenSection</span>(&amp;hSection, <span class="c_ac">SECTION_QUERY</span> | <span class="c_ac">SECTION_MAP_READ</span>, &amp;oa_ntdll);
	<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
		<span class="c_kw">goto</span> cleanup;

	status = <span class="c_fun">ZwQuerySection</span>(hSection, SectionImageInformation, &amp;sii, <span class="c_kw">sizeof</span>(sii), 0);
	<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
		<span class="c_kw">goto</span> cleanup;

	status = <span class="c_fun">ZwMapViewOfSection</span>(hSection, <span class="c_fun">GetCurrentProcess</span>(), &amp;pBaseAddr, 0, 0, 0, &amp;ViewSize, ViewUnmap, 0, <span class="c_ac">PAGE_READONLY</span>);
	<span class="c_kw">if</span> (<span class="c_ac">FAILED</span>(status))
		<span class="c_kw">goto</span> cleanup;

	__try
	{
		<span class="c_cmt">//We will have to parse PE structure manually</span>
		<span class="c_cmt">//(Remember, the image section here is of a different bitness than our own process!)</span>
		<span class="c_kw">if</span> (PIMAGE_NT_HEADERS32 pinth = (PIMAGE_NT_HEADERS32)<span class="c_fun">RtlImageNtHeader</span>(pBaseAddr))
		{
			<span class="c_cmt">//We'll do a really quick-and-dirty parsing here ...</span>
			status = <span class="c_fun">ResolveModuleExports</span>((<span class="c_ac">PBYTE</span>)sii.TransferAddress - pinth-&gt;OptionalHeader.AddressOfEntryPoint, 
				pBaseAddr, (<span class="c_ac">EXPORT_ENTRY</span> *)pfnPtrs, 2);
		}
		<span class="c_kw">else</span>
			status = <span class="c_ac">STATUS_BAD_FILE_TYPE</span>;
	}
	<span class="c_kw">__except</span> (<span class="c_ac">EXCEPTION_EXECUTE_HANDLER</span>)
	{
		<span class="c_cmt">//Catch exceptions in case the section is not a valid PE file</span>
		status = <span class="c_ac">STATUS_BAD_DATA</span>;
	}

cleanup:
	<span class="c_cmt">//Clean-up</span>

	<span class="c_kw">if</span> (pBaseAddr)
		<span class="c_fun">ZwUnmapViewOfSection</span>(<span class="c_fun">GetCurrentProcess</span>(), pBaseAddr);

	<span class="c_kw">if</span>(hSection)
		<span class="c_fun">ZwClose</span>(hSection);

	<span class="c_kw">return</span> status;
}

<span class="c_ac">NTSTATUS</span> <span class="c_fun">ResolveModuleExports</span>(<span class="c_ac">PVOID</span> ImageBase, <span class="c_ac">PVOID</span> pBaseAddr, <span class="c_ac">EXPORT_ENTRY</span>* pfnExports, <span class="c_kw">int</span> nCntExports)
{
	<span class="c_cmt">//Resolve exported functions by their names provided in 'pfnExports', using the image section mapped in memory</span>
	<span class="c_ac">NTSTATUS</span> status;

	<span class="c_ac">ULONG</span> exportSize, exportRVA;
	<span class="c_ac">ULONG</span> NumberOfFunctions;
	<span class="c_ac">ULONG</span> NumberOfNames;
	<span class="c_ac">ULONG</span> OrdinalBase;
	<span class="c_ac">PULONG</span> AddressOfFunctions;
	<span class="c_ac">PULONG</span> AddressOfNames;
	<span class="c_ac">PWORD</span> AddressOfNameOrdinals;

	<span class="c_ac">PIMAGE_EXPORT_DIRECTORY</span> pied = (<span class="c_ac">PIMAGE_EXPORT_DIRECTORY</span>)
		<span class="c_fun">RtlImageDirectoryEntryToData</span>(pBaseAddr, <span class="c_ac">TRUE</span>, <span class="c_ac">IMAGE_DIRECTORY_ENTRY_EXPORT</span>, &amp;exportSize);
	<span class="c_kw">if</span> (!pied)
	{
		status = <span class="c_ac">STATUS_INVALID_IMAGE_FORMAT</span>;
		<span class="c_kw">goto</span> cleanup;
	}

	exportRVA = <span class="c_fun">RtlPointerToOffset</span>(pBaseAddr, pied);
	NumberOfFunctions = pied-&gt;NumberOfFunctions;
	<span class="c_kw">if</span> (!NumberOfFunctions)
	{
		status = <span class="c_ac">STATUS_SOURCE_ELEMENT_EMPTY</span>;
		<span class="c_kw">goto</span> cleanup;
	}

	NumberOfNames = pied-&gt;NumberOfNames;
	OrdinalBase = pied-&gt;Base;

	AddressOfFunctions = (<span class="c_ac">PULONG</span>)<span class="c_fun">RtlOffsetToPointer</span>(pBaseAddr, pied-&gt;AddressOfFunctions);
	AddressOfNames = (<span class="c_ac">PULONG</span>)<span class="c_fun">RtlOffsetToPointer</span>(pBaseAddr, pied-&gt;AddressOfNames);
	AddressOfNameOrdinals = (<span class="c_ac">PWORD</span>)<span class="c_fun">RtlOffsetToPointer</span>(pBaseAddr, pied-&gt;AddressOfNameOrdinals);

	status = <span class="c_ac">STATUS_SUCCESS</span>;

	<span class="c_kw">for</span> (<span class="c_ac">EXPORT_ENTRY</span>* pEnd = pfnExports + nCntExports; pfnExports &lt; pEnd; pfnExports++)
	{
		<span class="c_ac">ULONG</span> i;
		<span class="c_ac">PCSTR</span> Name = pfnExports-&gt;pstrName;

		<span class="c_fun">assert</span>(*Name != <span class="c_sq">'#'</span>);	<span class="c_cmt">//Can't process ordinals</span>

		<span class="c_cmt">//Match each export by name</span>
		i = <span class="c_fun">GetNameOrdinal</span>(pBaseAddr, AddressOfNames, NumberOfNames, Name);
		<span class="c_kw">if</span> (i == <span class="c_ac">UINT_MAX</span>)
		{
			status = <span class="c_ac">STATUS_OBJECT_NAME_NOT_FOUND</span>;
			<span class="c_kw">break</span>;
		}

		<span class="c_kw">if</span> (i &lt; NumberOfNames)
			i = AddressOfNameOrdinals[i];

		<span class="c_kw">if</span> (i &gt;= NumberOfFunctions)
		{
			status = <span class="c_ac">STATUS_FOUND_OUT_OF_SCOPE</span>;
			<span class="c_kw">break</span>;
		}

		<span class="c_ac">DWORD</span> Rva = AddressOfFunctions[i];

		<span class="c_kw">if</span> ((<span class="c_ac">ULONG_PTR</span>)Rva - (<span class="c_ac">ULONG_PTR</span>)exportRVA &gt;= exportSize)
		{
			(<span class="c_ac">FARPROC</span>&amp;)pfnExports-&gt;pfn = (<span class="c_ac">FARPROC</span>)<span class="c_fun">RtlOffsetToPointer</span>(ImageBase, Rva);
		}
		<span class="c_kw">else</span>
		{
			<span class="c_cmt">//For brevity, we won't handle forwarded function exports ...</span>
			<span class="c_cmt">//(This has nothing to do with the subject of this blog post.)</span>
			status = <span class="c_ac">STATUS_ILLEGAL_FUNCTION</span>;
			<span class="c_kw">break</span>;
		}
	}

cleanup:
	<span class="c_cmt">//Clean-up process</span>

	<span class="c_kw">return</span> status;
}

<span class="c_ac">ULONG</span> <span class="c_fun">GetNameOrdinal</span>(<span class="c_ac">PVOID</span> pBaseAddr, <span class="c_ac">PDWORD</span> AddressOfNames, <span class="c_ac">DWORD</span> NumberOfNames, <span class="c_ac">PCSTR</span> Name)
{
	<span class="c_cmt">//Resolve ordinal index by a function name</span>
	<span class="c_cmt">//RETURN:</span>
	<span class="c_cmt">//		Such index, or</span>
	<span class="c_cmt">//		UINT_MAX if error</span>
	<span class="c_kw">if</span> (NumberOfNames)
	{
		<span class="c_ac">DWORD</span> a = 0;

		<span class="c_kw">do</span>
		{
			<span class="c_kw">int</span> u = (a + NumberOfNames) &gt;&gt; 1;
			<span class="c_ac">PCSTR</span> pNm = <span class="c_fun">RtlOffsetToPointer</span>(pBaseAddr, AddressOfNames[u]);
			<span class="c_kw">int</span> i = <span class="c_fun">strcmp</span>(pNm, Name);

			<span class="c_kw">if</span> (!i)
			{
				<span class="c_kw">return</span> u;
			}

			0 &gt; i ? a = u + 1 : NumberOfNames = u;

		} <span class="c_kw">while</span> (a &lt; NumberOfNames);
	}

	<span class="c_cmt">//Name was not found</span>
	<span class="c_kw">return</span> <span class="c_ac">UINT_MAX</span>;
}</code></pre></div>

<blockquote class="qt1 q_inf">
	<p>We also need to account for something else that may interfere with our method above. This has technically nothing to do with the subject of APCs,
		so I will touch on it very briefly.
	</p>

	<p>I'm talking about <a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard" rel="external nofollow" target="_blank">Control Flow Guard</a>, or CFG.
		If it is enabled for the target process, and it has one of its features for the 
		<em><a href="https://docs.microsoft.com/en-us/windows/win32/secbp/pe-metadata#export-suppression" rel="external nofollow" target="_blank">Export Suppression</a></em> on, this will prevent
		our APC code injection from going through. And namely, if our APC callback and the remote thread entry point are not in the 
		<a href="https://en.wikipedia.org/wiki/Control-flow_integrity" rel="external nofollow" target="_blank"><em>CFG bitmap</em></a>,
		the target process will be forced by CFG to crash. Which is a good security measure, but not very good for our purpose.
	</p>

	<p>For our use-case though, we need to bypass CFG. Luckily for us, this is quite easy to do.
		All we need is to call the 
		<a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets" rel="external nofollow" target="_blank"><code class="blg_cq">SetProcessValidCallTargets</code></a> function 
		on the needed export functions to disbale it. This is what the following code accomplishes for us.
	</p>
</blockquote>

<p>The first function below (<code class="blg_cq">IsExportSuppressionEnabled</code>) determines if CFG with the <em>Export Suppression</em> is enabled. 
	And the second function (<code class="blg_cq">SetValidExport</code>) disables <em>Export Suppression</em> for our exports in the target process:</p>

<blockquote class="qt1 q_inf">
	For completeness it would be also prudent to enable those exports back when our main function exits. It is trivial to do and thus we won't dwell on it here.
</blockquote>
<blockquote class="qt1 q_wrn">
	Note that the following function poses a race condition in a sense that some other thread, or even a process may enable CFG on our exports after we disable them.
</blockquote>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode27" style="height: 32em; overflow-y: auto;"><code><span class="c_ac">NTSTATUS</span> <span class="c_fun">IsExportSuppressionEnabled</span>(<span class="c_ac">HANDLE</span> hProcess, <span class="c_kw">bool</span>* enabled)
{
	<span class="c_cmt">//Checks if CFG with export suppression is enabled for 'hProcess' and returns it in 'enabled'</span>
	<span class="c_cmt">//The 'hProcess' handle must be opened with the PROCESS_QUERY_INFORMATION permission flag</span>
	<span class="c_kw">struct</span> <span class="c_ac">PROCESS_MITIGATION</span> {
		<span class="c_ac">PROCESS_MITIGATION_POLICY</span> Policy;
		<span class="c_ac">ULONG</span> Flags;
	};

	<span class="c_kw">bool</span> bEnabled = <span class="c_kw">false</span>;

	<span class="c_ac">PROCESS_MITIGATION</span> m = { ProcessControlFlowGuardPolicy };
	<span class="c_ac">NTSTATUS</span> status = <span class="c_fun">NtQueryInformationProcess</span>(hProcess, ProcessMitigationPolicy, &amp;m, <span class="c_kw">sizeof</span>(m), 0);
	<span class="c_kw">if</span> (<span class="c_ac">SUCCEEDED</span>(status))
	{
		<span class="c_ac">PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY</span>* pCFG = (<span class="c_ac">PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY</span>*)&amp;m.Flags;

		bEnabled = pCFG-&gt;EnableControlFlowGuard &amp;&amp;
			pCFG-&gt;EnableExportSuppression;
	}

	<span class="c_kw">if</span>(enabled)
		*enabled = bEnabled;

	<span class="c_kw">return</span> status;
}

<span class="c_ppr">#pragma</span> <span class="c_fun">comment</span>(lib, <span class="c_dq">"mincore.lib"</span>) 
<span class="c_ac">NTSTATUS</span> <span class="c_fun">SetValidExport</span>(<span class="c_ac">HANDLE</span> hProcess, <span class="c_ac">LPCVOID</span> pv)
{
	<span class="c_cmt">//Disables CFG export-suppression on 'pv' function in 'hProcess'</span>
	<span class="c_ac">MEMORY_BASIC_INFORMATION</span> mbi;
	<span class="c_ac">NTSTATUS</span> status = <span class="c_fun">NtQueryVirtualMemory</span>(hProcess, (<span class="c_kw">void</span>*)pv, MemoryBasicInformation, &amp;mbi, <span class="c_kw">sizeof</span>(mbi), 0);
	<span class="c_kw">if</span> (<span class="c_ac">SUCCEEDED</span>(status))
	{
		<span class="c_kw">if</span> (mbi.State != <span class="c_ac">MEM_COMMIT</span> || mbi.Type != <span class="c_ac">MEM_IMAGE</span>)
		{
			<span class="c_kw">return</span> <span class="c_ac">STATUS_INVALID_ADDRESS</span>;
		}

		<span class="c_ac">CFG_CALL_TARGET_INFO</span> OffsetInformation = {
			(<span class="c_ac">ULONG_PTR</span>)pv - (<span class="c_ac">ULONG_PTR</span>)mbi.BaseAddress,
			<span class="c_ac">CFG_CALL_TARGET_CONVERT_EXPORT_SUPPRESSED_TO_VALID</span> | <span class="c_ac">CFG_CALL_TARGET_VALID</span>
		};

		<span class="c_kw">return</span> <span class="c_fun">SetProcessValidCallTargets</span>(hProcess, mbi.BaseAddress, mbi.RegionSize, 1, &amp;OffsetInformation) &amp;&amp;
			(OffsetInformation.Flags &amp; <span class="c_ac">CFG_CALL_TARGET_PROCESSED</span>) ? <span class="c_ac">STATUS_SUCCESS</span> : <span class="c_ac">STATUS_STRICT_CFG_VIOLATION</span>;
	}

	<span class="c_kw">return</span> status;
}</code></pre></div>

<p>And finally, to compile the code above in Visual Studio you would ideally need the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk" rel="external nofollow" target="_blank">WDK</a> 
	installed. Optionally, you can use the following declarations to compile it without the WDK:
</p>

<div class="blog_code rndcrntr"><span class="blog_code_ttl">C++ - Native API/Struct Declarations</span><span class="blog_code_ttcp"><a href="https://dennisbabkin.com/blog/?i=AAA03000#" title="Click to copy code">[Copy]</a></span><pre class="blog_pre code_cpp" id="idCode28" style="height: 32em; overflow-y: auto;"><code><span class="c_ppr">#include</span> &lt;iostream&gt;
<span class="c_ppr">#include</span> Windows.h&gt;
<span class="c_ppr">#include</span> &lt;assert.h&gt;

<span class="c_ppr">#pragma</span> <span class="c_fun">comment</span>(lib, <span class="c_dq">"ntdll.lib"</span>)		<span class="c_cmt">//For native API calls</span>

<span class="c_kw">struct</span> <span class="c_ac">EXPORT_ENTRY</span> {
	<span class="c_ac">FARPROC</span> pfn;
	<span class="c_ac">PCSTR</span> pstrName;
};
<span class="c_kw">struct</span> <span class="c_ac">NTDLL_FN_PTRS</span> {
	<span class="c_ac">EXPORT_ENTRY</span> pLdrQueryProcessModuleInformation;
	<span class="c_ac">EXPORT_ENTRY</span> pRtlExitUserThread;
};

<span class="c_kw">typedef</span>
<span class="c_ac">VOID</span>
<span class="c_ac">KNORMAL_ROUTINE</span>(
	__in_opt <span class="c_ac">PVOID</span> NormalContext,
	__in_opt <span class="c_ac">PVOID</span> SystemArgument1,
	__in_opt <span class="c_ac">PVOID</span> SystemArgument2
);
<span class="c_kw">typedef</span> <span class="c_ac">KNORMAL_ROUTINE</span>* <span class="c_ac">PKNORMAL_ROUTINE</span>;

<span class="c_kw">typedef</span> <span class="c_kw">struct</span> <span class="c_ac">_UNICODE_STRING</span> {
	<span class="c_ac">USHORT</span> Length;
	<span class="c_ac">USHORT</span> MaximumLength;
	<span class="c_fun">_Field_size_bytes_part_opt_</span>(MaximumLength, Length) <span class="c_ac">PWCH</span>   Buffer;
} <span class="c_ac">UNICODE_STRING</span>;
<span class="c_kw">typedef</span> <span class="c_ac">UNICODE_STRING</span>* <span class="c_ac">PUNICODE_STRING</span>;
<span class="c_kw">typedef</span> <span class="c_kw">const</span> <span class="c_ac">UNICODE_STRING</span>* <span class="c_ac">PCUNICODE_STRING</span>;

<span class="c_kw">typedef</span> <span class="c_kw">struct</span> <span class="c_ac">_OBJECT_ATTRIBUTES</span> {
	<span class="c_ac">ULONG</span> Length;
	<span class="c_ac">HANDLE</span> RootDirectory;
	<span class="c_ac">PUNICODE_STRING</span> ObjectName;
	<span class="c_ac">ULONG</span> Attributes;
	<span class="c_ac">PVOID</span> SecurityDescriptor;        <span class="c_cmt">// Points to type SECURITY_DESCRIPTOR</span>
	<span class="c_ac">PVOID</span> SecurityQualityOfService;  <span class="c_cmt">// Points to type SECURITY_QUALITY_OF_SERVICE</span>
} <span class="c_ac">OBJECT_ATTRIBUTES</span>;
<span class="c_kw">typedef</span> <span class="c_ac">OBJECT_ATTRIBUTES</span>* <span class="c_ac">POBJECT_ATTRIBUTES</span>;
<span class="c_kw">typedef</span> <span class="c_ac">CONST</span> <span class="c_ac">OBJECT_ATTRIBUTES</span>* <span class="c_ac">PCOBJECT_ATTRIBUTES</span>;

<span class="c_kw">typedef</span> <span class="c_kw">enum</span> <span class="c_ac">_SECTION_INHERIT</span> {
	ViewShare = 1,
	ViewUnmap = 2
} <span class="c_ac">SECTION_INHERIT</span>;

<span class="c_kw">typedef</span> <span class="c_kw">struct</span> <span class="c_ac">_CLIENT_ID</span> {
	<span class="c_ac">HANDLE</span> UniqueProcess;
	<span class="c_ac">HANDLE</span> UniqueThread;
} <span class="c_ac">CLIENT_ID</span>;
<span class="c_kw">typedef</span> <span class="c_ac">CLIENT_ID</span>* <span class="c_ac">PCLIENT_ID</span>;

<span class="c_kw">typedef</span> <span class="c_kw">struct</span> <span class="c_ac">RTL_PROCESS_MODULE_INFORMATION</span> {
	<span class="c_ac">HANDLE</span> Section;                 <span class="c_cmt">// Not filled in</span>
	<span class="c_ac">PVOID</span> MappedBase;
	<span class="c_ac">PVOID</span> ImageBase;
	<span class="c_ac">ULONG</span> ImageSize;
	<span class="c_ac">ULONG</span> Flags;
	<span class="c_ac">USHORT</span> LoadOrderIndex;
	<span class="c_ac">USHORT</span> InitOrderIndex;
	<span class="c_ac">USHORT</span> LoadCount;
	<span class="c_ac">USHORT</span> OffsetToFileName;
	<span class="c_ac">CHAR</span>  FullPathName[256];
} *<span class="c_ac">PRTL_PROCESS_MODULE_INFORMATION</span>;

<span class="c_kw">typedef</span> <span class="c_kw">struct</span> <span class="c_ac">RTL_PROCESS_MODULES</span> {
	<span class="c_ac">ULONG</span> NumberOfModules;
	<span class="c_ac">RTL_PROCESS_MODULE_INFORMATION</span> Modules[1];
} *<span class="c_ac">PRTL_PROCESS_MODULES</span>;

<span class="c_kw">typedef</span> <span class="c_kw">int</span> HANDLE32;
<span class="c_kw">typedef</span> <span class="c_kw">int</span> PVOID32;

<span class="c_ppr">#pragma</span> <span class="c_fun">pack</span>(push)
<span class="c_ppr">#pragma</span> <span class="c_fun">pack</span>(4)
<span class="c_kw">typedef</span> <span class="c_kw">struct</span> RTL_PROCESS_MODULE_INFORMATION32 {
	HANDLE32 Section;                 <span class="c_cmt">// Not filled in</span>
	PVOID32 MappedBase;
	PVOID32 ImageBase;
	<span class="c_ac">ULONG</span> ImageSize;
	<span class="c_ac">ULONG</span> Flags;
	<span class="c_ac">USHORT</span> LoadOrderIndex;
	<span class="c_ac">USHORT</span> InitOrderIndex;
	<span class="c_ac">USHORT</span> LoadCount;
	<span class="c_ac">USHORT</span> OffsetToFileName;
	<span class="c_ac">CHAR</span>  FullPathName[256];
} *PRTL_PROCESS_MODULE_INFORMATION32;

<span class="c_kw">typedef</span> <span class="c_kw">struct</span> RTL_PROCESS_MODULES32 {
	<span class="c_ac">ULONG</span> NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION32 Modules[1];
} *PRTL_PROCESS_MODULES32;
<span class="c_ppr">#pragma</span> <span class="c_fun">pack</span>(pop)


<span class="c_kw">typedef</span> <span class="c_kw">enum</span> <span class="c_ac">_PROCESSINFOCLASS</span> {
	ProcessBasicInformation = 0,
	ProcessQuotaLimits = 1,
	ProcessIoCounters = 2,
	ProcessVmCounters = 3,
	ProcessTimes = 4,
	ProcessBasePriority = 5,
	ProcessRaisePriority = 6,
	ProcessDebugPort = 7,
	ProcessExceptionPort = 8,
	ProcessAccessToken = 9,
	ProcessLdtInformation = 10,
	ProcessLdtSize = 11,
	ProcessDefaultHardErrorMode = 12,
	ProcessIoPortHandlers = 13,   <span class="c_cmt">// Note: this is kernel mode only</span>
	ProcessPooledUsageAndLimits = 14,
	ProcessWorkingSetWatch = 15,
	ProcessUserModeIOPL = 16,
	ProcessEnableAlignmentFaultFixup = 17,
	ProcessPriorityClass = 18,
	ProcessWx86Information = 19,
	ProcessHandleCount = 20,
	ProcessAffinityMask = 21,
	ProcessPriorityBoost = 22,
	ProcessDeviceMap = 23,
	ProcessSessionInformation = 24,
	ProcessForegroundInformation = 25,
	ProcessWow64Information = 26,
	ProcessImageFileName = 27,
	ProcessLUIDDeviceMapsEnabled = 28,
	ProcessBreakOnTermination = 29,
	ProcessDebugObjectHandle = 30,
	ProcessDebugFlags = 31,
	ProcessHandleTracing = 32,
	ProcessIoPriority = 33,
	ProcessExecuteFlags = 34,
	ProcessTlsInformation = 35,
	ProcessCookie = 36,
	ProcessImageInformation = 37,
	ProcessCycleTime = 38,
	ProcessPagePriority = 39,
	ProcessInstrumentationCallback = 40,
	ProcessThreadStackAllocation = 41,
	ProcessWorkingSetWatchEx = 42,
	ProcessImageFileNameWin32 = 43,
	ProcessImageFileMapping = 44,
	ProcessAffinityUpdateMode = 45,
	ProcessMemoryAllocationMode = 46,
	ProcessGroupInformation = 47,
	ProcessTokenVirtualizationEnabled = 48,
	ProcessOwnerInformation = 49,
	ProcessWindowInformation = 50,
	ProcessHandleInformation = 51,
	ProcessMitigationPolicy = 52,
	ProcessDynamicFunctionTableInformation = 53,
	ProcessHandleCheckingMode = 54,
	ProcessKeepAliveCount = 55,
	ProcessRevokeFileHandles = 56,
	ProcessWorkingSetControl = 57,
	ProcessHandleTable = 58,
	ProcessCheckStackExtentsMode = 59,
	ProcessCommandLineInformation = 60,
	ProcessProtectionInformation = 61,
	ProcessMemoryExhaustion = 62,
	ProcessFaultInformation = 63,
	ProcessTelemetryIdInformation = 64,
	ProcessCommitReleaseInformation = 65,
	ProcessReserved1Information = 66,
	ProcessReserved2Information = 67,
	ProcessSubsystemProcess = 68,
	ProcessInPrivate = 70,
	ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
	ProcessSubsystemInformation = 75,
	ProcessWin32kSyscallFilterInformation = 79,
	ProcessEnergyTrackingState = 82,
	MaxProcessInfoClass                             <span class="c_cmt">// MaxProcessInfoClass should always be the last enum</span>
} <span class="c_ac">PROCESSINFOCLASS</span>;

<span class="c_ppr">#define</span> <span class="c_ac">OBJ_CASE_INSENSITIVE</span>                0x00000040L

<span class="c_ppr">#define</span> <span class="c_ac">STATUS_SUCCESS</span>                   ((<span class="c_ac">NTSTATUS</span>)0x00000000L)
<span class="c_ppr">#define</span> <span class="c_ac">STATUS_BAD_DATA</span>                  ((<span class="c_ac">NTSTATUS</span>)0xC000090BL)
<span class="c_ppr">#define</span> <span class="c_ac">STATUS_BAD_FILE_TYPE</span>             ((<span class="c_ac">NTSTATUS</span>)0xC0000903L)
<span class="c_ppr">#define</span> <span class="c_ac">STATUS_INVALID_IMAGE_FORMAT</span>      ((<span class="c_ac">NTSTATUS</span>)0xC000007BL)
<span class="c_ppr">#define</span> <span class="c_ac">STATUS_SOURCE_ELEMENT_EMPTY</span>      ((<span class="c_ac">NTSTATUS</span>)0xC0000283L)
<span class="c_ppr">#define</span> <span class="c_ac">STATUS_FOUND_OUT_OF_SCOPE</span>        ((<span class="c_ac">NTSTATUS</span>)0xC000022EL)
<span class="c_ppr">#define</span> <span class="c_ac">STATUS_ILLEGAL_FUNCTION</span>          ((<span class="c_ac">NTSTATUS</span>)0xC00000AFL)
<span class="c_ppr">#define</span> <span class="c_ac">STATUS_OBJECT_NAME_NOT_FOUND</span>     ((<span class="c_ac">NTSTATUS</span>)0xC0000034L)
<span class="c_ppr">#define</span> <span class="c_ac">STATUS_PROCEDURE_NOT_FOUND</span>       ((<span class="c_ac">NTSTATUS</span>)0xC000007AL)
<span class="c_ppr">#define</span> <span class="c_ac">STATUS_INVALID_ADDRESS</span>           ((<span class="c_ac">NTSTATUS</span>)0xC0000141L)
<span class="c_ppr">#define</span> <span class="c_ac">STATUS_STRICT_CFG_VIOLATION</span>      ((<span class="c_ac">NTSTATUS</span>)0xC0000606L)

<span class="c_ppr">#define</span> <span class="c_fun">RtlPointerToOffset</span>(<span class="c_ac">B</span>,<span class="c_ac">P</span>)  ((<span class="c_ac">ULONG</span>)( ((<span class="c_ac">PCHAR</span>)(<span class="c_ac">P</span>)) - ((<span class="c_ac">PCHAR</span>)(<span class="c_ac">B</span>)) ))
<span class="c_ppr">#define</span> <span class="c_fun">RtlOffsetToPointer</span>(<span class="c_ac">B</span>,<span class="c_ac">O</span>)  ((<span class="c_ac">PCHAR</span>)( ((<span class="c_ac">PCHAR</span>)(<span class="c_ac">B</span>)) + ((<span class="c_ac">ULONG_PTR</span>)(<span class="c_ac">O</span>)) ))


<span class="c_kw">struct</span> <span class="c_ac">SECTION_IMAGE_INFORMATION</span>
{
	<span class="c_ac">PVOID</span> TransferAddress;
	<span class="c_ac">ULONG</span> ZeroBits;
	<span class="c_ac">SIZE_T</span> MaximumStackSize;
	<span class="c_ac">SIZE_T</span> CommittedStackSize;
	<span class="c_ac">ULONG</span> SubSystemType;
	<span class="c_kw">union</span>
	{
		<span class="c_kw">struct</span>
		{
			<span class="c_ac">USHORT</span> SubSystemMinorVersion;
			<span class="c_ac">USHORT</span> SubSystemMajorVersion;
		};
		<span class="c_ac">ULONG</span> SubSystemVersion;
	};
	<span class="c_ac">ULONG</span> GpValue;
	<span class="c_ac">USHORT</span> ImageCharacteristics;
	<span class="c_ac">USHORT</span> DllCharacteristics;
	<span class="c_ac">USHORT</span> Machine;
	<span class="c_ac">BOOLEAN</span> ImageContainsCode;
	<span class="c_kw">union</span>
	{
		<span class="c_ac">UCHAR</span> ImageFlags;
		<span class="c_kw">struct</span>
		{
			<span class="c_ac">UCHAR</span> ComPlusNativeReady : 1;
			<span class="c_ac">UCHAR</span> ComPlusILOnly : 1;
			<span class="c_ac">UCHAR</span> ImageDynamicallyRelocated : 1;
			<span class="c_ac">UCHAR</span> ImageMappedFlat : 1;
			<span class="c_ac">UCHAR</span> BaseBelow4gb : 1;
			<span class="c_ac">UCHAR</span> Reserved : 3;
		};
	};
	<span class="c_ac">ULONG</span> LoaderFlags;
	<span class="c_ac">ULONG</span> ImageFileSize;
	<span class="c_ac">ULONG</span> CheckSum;
};

<span class="c_kw">enum</span> <span class="c_ac">SECTION_INFORMATION_CLASS</span>
{
	SectionBasicInformation,
	SectionImageInformation
};

<span class="c_kw">typedef</span> <span class="c_kw">enum</span> <span class="c_ac">_THREADINFOCLASS</span> {
	ThreadBasicInformation = 0,
	ThreadTimes = 1,
	ThreadPriority = 2,
	ThreadBasePriority = 3,
	ThreadAffinityMask = 4,
	ThreadImpersonationToken = 5,
	ThreadDescriptorTableEntry = 6,
	ThreadEnableAlignmentFaultFixup = 7,
	ThreadEventPair_Reusable = 8,
	ThreadQuerySetWin32StartAddress = 9,
	ThreadZeroTlsCell = 10,
	ThreadPerformanceCount = 11,
	ThreadAmILastThread = 12,
	ThreadIdealProcessor = 13,
	ThreadPriorityBoost = 14,
	ThreadSetTlsArrayAddress = 15,   <span class="c_cmt">// Obsolete</span>
	ThreadIsIoPending = 16,
	ThreadHideFromDebugger = 17,
	ThreadBreakOnTermination = 18,
	ThreadSwitchLegacyState = 19,
	ThreadIsTerminated = 20,
	ThreadLastSystemCall = 21,
	ThreadIoPriority = 22,
	ThreadCycleTime = 23,
	ThreadPagePriority = 24,
	ThreadActualBasePriority = 25,
	ThreadTebInformation = 26,
	ThreadCSwitchMon = 27,   <span class="c_cmt">// Obsolete</span>
	ThreadCSwitchPmu = 28,
	ThreadWow64Context = 29,
	ThreadGroupInformation = 30,
	ThreadUmsInformation = 31,   <span class="c_cmt">// UMS</span>
	ThreadCounterProfiling = 32,
	ThreadIdealProcessorEx = 33,
	ThreadCpuAccountingInformation = 34,
	ThreadSuspendCount = 35,
	ThreadActualGroupAffinity = 41,
	ThreadDynamicCodePolicyInfo = 42,
	ThreadSubsystemInformation = 45,

	MaxThreadInfoClass = 51,
} <span class="c_ac">THREADINFOCLASS</span>;

<span class="c_kw">typedef</span> <span class="c_kw">enum</span> <span class="c_ac">_MEMORY_INFORMATION_CLASS</span> {
	MemoryBasicInformation
} <span class="c_ac">MEMORY_INFORMATION_CLASS</span>;


<span class="c_cmt">//Imported native functions from ntdll</span>
<span class="c_kw">extern</span> <span class="c_dq">"C"</span> {
	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">ZwQueueApcThread</span>
	(
		<span class="c_ac">HANDLE</span> hThread,
		<span class="c_ac">PKNORMAL_ROUTINE</span> ApcRoutine, 
		<span class="c_ac">PVOID</span> ApcContext, 
		<span class="c_ac">PVOID</span> Argument1, 
		<span class="c_ac">PVOID</span> Argument2
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">NtCreateSection</span>
	(
		_Out_ <span class="c_ac">PHANDLE</span> SectionHandle,
		_In_ <span class="c_ac">ACCESS_MASK</span> DesiredAccess,
		_In_opt_ <span class="c_ac">POBJECT_ATTRIBUTES</span> ObjectAttributes,
		_In_opt_ <span class="c_ac">PLARGE_INTEGER</span> MaximumSize,
		_In_ <span class="c_ac">ULONG</span> SectionPageProtection,
		_In_ <span class="c_ac">ULONG</span> AllocationAttributes,
		_In_opt_ <span class="c_ac">HANDLE</span> FileHandle
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">ZwClose</span>
	(
		_In_ <span class="c_ac">HANDLE</span> Handle
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">ZwMapViewOfSection</span>
	(
		_In_ <span class="c_ac">HANDLE</span> SectionHandle,
		_In_ <span class="c_ac">HANDLE</span> ProcessHandle,
		<span class="c_fun">_Outptr_result_bytebuffer_</span>(*ViewSize) <span class="c_ac">PVOID</span>* BaseAddress,
		_In_ <span class="c_ac">ULONG_PTR</span> ZeroBits,
		_In_ <span class="c_ac">SIZE_T</span> CommitSize,
		_Inout_opt_ <span class="c_ac">PLARGE_INTEGER</span> SectionOffset,
		_Inout_ <span class="c_ac">PSIZE_T</span> ViewSize,
		_In_ <span class="c_ac">SECTION_INHERIT</span> InheritDisposition,
		_In_ <span class="c_ac">ULONG</span> AllocationType,
		_In_ <span class="c_ac">ULONG</span> Win32Protect
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">ZwUnmapViewOfSection</span>
	(
		_In_ <span class="c_ac">HANDLE</span> ProcessHandle,
		_In_opt_ <span class="c_ac">PVOID</span> BaseAddress
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">RtlCreateUserThread</span>
	(
		<span class="c_ac">IN</span> <span class="c_ac">HANDLE</span> hProcess,
		<span class="c_ac">PVOID</span>   SecurityDescriptor,
		<span class="c_ac">BOOLEAN</span> CreateSuspended,
		<span class="c_ac">ULONG</span>	ZeroBits,
		<span class="c_ac">SIZE_T</span>	StackReserve,
		<span class="c_ac">SIZE_T</span>	StackCommit,
		<span class="c_ac">PVOID</span>	EntryPoint,
		<span class="c_kw">const</span> <span class="c_kw">void</span>* Argument,
		<span class="c_ac">PHANDLE</span>	phThread,
		<span class="c_ac">PCLIENT_ID</span> pCid
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">RtlExitUserThread</span>
	(
		<span class="c_ac">DWORD</span> dwExitCode
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">RtlQueueApcWow64Thread</span>
	(
		<span class="c_ac">HANDLE</span> hThread, 
		<span class="c_ac">PKNORMAL_ROUTINE</span> ApcRoutine, 
		<span class="c_ac">PVOID</span> ApcContext, 
		<span class="c_ac">PVOID</span> Argument1, 
		<span class="c_ac">PVOID</span> Argument2
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">LdrQueryProcessModuleInformation</span>
	(
		<span class="c_ac">PRTL_PROCESS_MODULES</span> psmi,
		<span class="c_ac">ULONG</span> BufferSize,
		<span class="c_ac">PULONG</span> RealSize
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">NtQueryInformationProcess</span>
	(
		<span class="c_ac">IN</span> <span class="c_ac">HANDLE</span> ProcessHandle,
		<span class="c_ac">IN</span>  <span class="c_ac">PROCESSINFOCLASS</span> ProcessInformationClass,
		<span class="c_ac">OUT</span> <span class="c_ac">PVOID</span> ProcessInformation,
		<span class="c_ac">IN</span> <span class="c_ac">ULONG</span> ProcessInformationLength,
		<span class="c_ac">OUT</span> <span class="c_ac">PULONG</span> ReturnLength <span class="c_ac">OPTIONAL</span>
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">ZwOpenSection</span>
	(
		_Out_ <span class="c_ac">PHANDLE</span> SectionHandle,
		_In_ <span class="c_ac">ACCESS_MASK</span> DesiredAccess,
		_In_ <span class="c_ac">POBJECT_ATTRIBUTES</span> ObjectAttributes
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">ZwQuerySection</span>
	(
		<span class="c_ac">IN</span> <span class="c_ac">HANDLE</span> SectionHandle,
		<span class="c_ac">IN</span> <span class="c_ac">ULONG</span> SectionInformationClass,
		<span class="c_ac">OUT</span> <span class="c_ac">PVOID</span> SectionInformation,
		<span class="c_ac">IN</span> <span class="c_ac">ULONG</span> SectionInformationLength,
		<span class="c_ac">OUT</span> <span class="c_ac">PSIZE_T</span> ResultLength <span class="c_ac">OPTIONAL</span>
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">PIMAGE_NT_HEADERS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">RtlImageNtHeader</span>
	(
		<span class="c_ac">PVOID</span> Base
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">PVOID</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">RtlImageDirectoryEntryToData</span>
	(
		<span class="c_ac">PVOID</span> Base,
		<span class="c_ac">BOOLEAN</span> MappedAsImage,
		<span class="c_ac">USHORT</span> DirectoryEntry,
		<span class="c_ac">PULONG</span> Size
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">NtSetInformationThread</span>(
		_In_ <span class="c_ac">HANDLE</span> ThreadHandle,
		_In_ <span class="c_ac">THREADINFOCLASS</span> ThreadInformationClass,
		<span class="c_fun">_When_</span>((ThreadInformationClass != ThreadManageWritesToExecutableMemory),
			<span class="c_fun">_In_reads_bytes_</span>(ThreadInformationLength))
		<span class="c_fun">_When_</span>((ThreadInformationClass == ThreadManageWritesToExecutableMemory),
			<span class="c_fun">_Inout_updates_</span>(ThreadInformationLength))
		<span class="c_ac">PVOID</span> ThreadInformation,
		_In_ <span class="c_ac">ULONG</span> ThreadInformationLength
	);

	<span class="c_kw">__declspec</span>(dllimport) <span class="c_ac">NTSTATUS</span> <span class="c_ac">CALLBACK</span> <span class="c_fun">NtQueryVirtualMemory</span>(
		_In_ <span class="c_ac">HANDLE</span> ProcessHandle,
		_In_opt_ <span class="c_ac">PVOID</span> BaseAddress,
		_In_ <span class="c_ac">MEMORY_INFORMATION_CLASS</span> MemoryInformationClass,
		<span class="c_fun">_Out_writes_bytes_</span>(MemoryInformationLength) <span class="c_ac">PVOID</span> MemoryInformation,
		_In_ <span class="c_ac">SIZE_T</span> MemoryInformationLength,
		_Out_opt_ <span class="c_ac">PSIZE_T</span> ReturnLength
	);
}</code></pre></div>


<a name="epilogue"></a>
<h1>Epilogue<a href="https://dennisbabkin.com/blog/?i=AAA03000#epilogue" style="display: inline-flex; vertical-align: middle; padding: 0 0.5em 0 0.6em; margin: 0;  border: 0; width: 16px; height: 16px; visibility: hidden;"><img src="https://dennisbabkin.com/php/images/lnk_pic.svg" title="Link to this title" style="margin: 0; padding: 0; width: 16px; height: 16x;" width="16" height="16"></a></h1>

<p>As you can tell by the size of this blog post <em>Asynchronous Procedure Calls</em> is a tricky subject in Windows.
	The best way to understand it is to code it yourself and to test it in practice.
	And if you run into an interesting situation dealing with APCs yourself, feel free to leave a comment below.
</p>

<p>Or, if you want to contact me (<a href="https://dennisbabkin.com/blog/author/?a=rbmm" title="Click here to view author's info">Rbmm</a>) or <a href="https://dennisbabkin.com/blog/author/?a=dab" title="Click here to view author's info">Dennis A. Babkin</a> directly, feel free to do that.</p>


</div>

        	</article>
			
            <div id="blog_footer">
            <h1>Social Media</h1>
            <ul class="lifb">		<li>
		<a href="https://twitter.com/dennisbabkin" target="_blank"><img border="0" alt="Twitter link" src="https://dennisbabkin.com/php/images/twtr_sm_logo.png" title="Follow on Twitter" id="imgsocmed"></a>
		<a href="https://twitter.com/dennisbabkin" title="Follow on Twitter" target="_blank">Follow to get latest blog posts</a>
		</li>		<li>
		<a href="https://facebook.com/dennisbabkin" target="_blank"><img border="0" alt="Facebook link" src="https://dennisbabkin.com/php/images/fb_sm_logo.png" title="Follow on Facebook" id="imgsocmed"></a>
		<a href="https://facebook.com/dennisbabkin" title="Follow on Facebook" target="_blank">Check to see latest blog posts</a>
		</li></ul>
            
            <h1>Contact</h1>
                
            Should you have anything to say privately, <a href="https://dennisbabkin.com/contact?mes=Blog+post%3A+Depths+of+Windows+APC+-+Aspects+of+internals+of+the+Asynchronous+Procedure+Calls+from+the+kernel+mode." target="_blank" title="Click here to contact the author(s) privately">click here</a>.
            </div>	
        </div>
        <div id="blog_sidebar"><h3 class="blog_h3_rltd">Related Articles</h3><div class="blog_related"><ul><li><a href="https://dennisbabkin.com/blog/?t=coding-windows-driver-dll-injection-into-all-running-processes-in-visual-studio">Coding Windows Kernel Driver - InjectAll</a><div class="blog_rltd_sttl">Making the Visual Studio solution for DLL injection into all running processes.</div><div class="blog_rltd_dt">May 29, 2021</div></li><li><a href="https://dennisbabkin.com/blog/?t=how-to-step-into-syscall-with-debugger-using-kernel-binary-patch">Reverse Engineering - Stepping Into a System Call</a><div class="blog_rltd_sttl">How to step into a SYSCALL with a debugger using kernel binary patch.</div><div class="blog_rltd_dt">August 25, 2023</div></li><li><a href="https://dennisbabkin.com/blog/?t=critical_section_vs_kernel_objects_in_windows">Critical Section vs Kernel Objects</a><div class="blog_rltd_sttl">Spinning in user-mode versus entering kernel - the cost of a SYSCALL in Windows.</div><div class="blog_rltd_dt">August 19, 2023</div></li><li><a href="https://dennisbabkin.com/blog/?t=how-to-make-critical-process-that-can-crash-windows-if-it-is-closed">Native Functions To The Rescue - Part 1</a><div class="blog_rltd_sttl">How to make a critical process that can crash Windows if it is closed.</div><div class="blog_rltd_dt">August 22, 2023</div></li><li><a href="https://dennisbabkin.com/blog/?t=how-to-perform-title-bar-window-shake-programmatically-in-windows">Shaky Windows All The Way</a><div class="blog_rltd_sttl">How to perform "title bar window shake" programmatically in Windows.</div><div class="blog_rltd_dt">August 21, 2023</div></li><li><a href="https://dennisbabkin.com/blog/?t=how-to-tell-the-real-version-of-windows-your-app-is-running-on">Things You Thought You Knew - Getting Windows Version</a><div class="blog_rltd_sttl">How to tell the "real" version of Windows your app is running on?</div><div class="blog_rltd_dt">October 20, 2022</div></li><li><a href="https://dennisbabkin.com/blog/?t=when-developers-give-up-deletesecuritypackage-function">When Developers Give Up - DeleteSecurityPackage Function</a><div class="blog_rltd_sttl">Why it pays off to look into some Win32 functions with a disassembler.</div><div class="blog_rltd_dt">October 13, 2021</div></li><li><a href="https://dennisbabkin.com/blog/?t=windows-apc-deep-dive-into-user-mode-asynchronous-procedure-calls">Intricacies of Windows APC</a><div class="blog_rltd_sttl">Deep dive into user-mode Asynchronous Procedure Calls in Windows.</div><div class="blog_rltd_dt">November 11, 2020</div></li><li><a href="https://dennisbabkin.com/blog/?t=reverse-engineer-virtual-functions-vs-cpp-compiler-vtable-purecall-cfg">Reverse Engineering Virtual Functions Compiled With Visual Studio C++ Compiler - Part 1</a><div class="blog_rltd_sttl">Understanding virtual function tables, vtable, __purecall, novtable, Control Flow Guard.</div><div class="blog_rltd_dt">January 10, 2025</div></li><li><a href="https://dennisbabkin.com/blog/?t=sequence-of-calls-to-credential-provider-in-windows">Windows Authentication - Credential Providers - Part 2</a><div class="blog_rltd_sttl">Sequence of calls to a credential provider in Windows.</div><div class="blog_rltd_dt">October 4, 2023</div></li><li><a href="https://dennisbabkin.com/blog/?t=primer-on-writing-credential-provider-in-windows">Windows Authentication - Credential Providers - Part 1</a><div class="blog_rltd_sttl">A primer on writing a credential provider in Windows.</div><div class="blog_rltd_dt">September 20, 2023</div></li><li><a href="https://dennisbabkin.com/blog/?t=how-to-put-thread-into-kernel-wait-and-to-wake-it-by-thread-id">Things You Find While Reverse Engineering - AlertByThreadId</a><div class="blog_rltd_sttl">How to put a thread into a kernel wait state and how to wake it up by a thread ID.</div><div class="blog_rltd_dt">August 18, 2023</div></li></ul></div></div>
    </div>
    


<div id="disqus_thread"><div id="dsq-app7643" name="dsq-app7643" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" allow="autoplay 'src' https://www.youtube.com https://youtube.com https://m.youtube.com https://youtu.be https://www.youtube-nocookie.com" width="100%" src="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#version=670b3f7229f9c5e11382076cc0d25eb5" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 1197px !important;" horizontalscrolling="no" verticalscrolling="no" data-original-tag="iframe"><!--[if IE 8]><html lang="en" dir="ltr" class="ie8"><![endif]--><!--[if IE 9]><html lang="en" dir="ltr" class="ie9"><![endif]--><!--[if gt IE 9]><!--><!--<![endif]-->
    <title>Disqus Comments</title>

    
    
    

    
    
    

<link rel="stylesheet" href="https://c.disquscdn.com/next/embed/styles/lounge.0cac168e69be819cc3e3a9bc73b7d30a.css"><base target="_parent">

    

    
    <div id="error" class="alert--error">
        <p>We were unable to load Disqus. If you are a moderator please see our <a href="https://docs.disqus.com/help/83/"> troubleshooting guide</a>. </p>
    </div>

    
    

    


    <div id="fixed-content"></div>

    
        
    



    
        
            


        
        
        
    


<div id="sr-announcements" class="visually-hidden" aria-live="polite" role="status"></div><div id="a11y-helper-comma" class="visually-hidden" aria-hidden="true" aria-label=","></div><div id="layout" data-tracking-area="layout"><div id="thread__container"><div><div id="thread__wrapper"><div id="placement-top" data-tracking-area="discovery-north"></div><div id="onboard" data-tracking-area="onboard"></div><div id="comment-policy" class="comment-policy-refresh comment-policy-refresh--v2 publisher-anchor-color "><div class="content"><h2 class="comment-policy-refresh__heading">dennisbabkin.com Comment Policy</h2><p class="comment-policy-refresh__text"></p><p class="comment-policy-refresh__prompt">Please read our <a href="https://dennisbabkin.com/blog/policy/" target="_blank" rel="noopener noreferrer" class=" comment-policy-refresh__link">Comment Policy</a> before commenting.</p><p></p></div><button class="btn comment-policy-refresh__button publisher-background-color" data-action="accept-comment-policy">Got it</button></div><div id="reactions__container"></div><div id="ratings__container"></div><div id="global-alert"></div><div id="tos__container"></div><section id="conversation" data-role="main" data-tracking-area="main"><div id="posts"><div id="form" class="textarea-outer-wrapper--top-level"><form class="reply form-refresh form-refresh-v2"><div class="postbox"><div role="alert"></div><div class="ratings-wrapper" data-role="ratings-container"></div><div class="compose-wrapper"><div class="avatar"><span class="user user--refresh"><img data-role="user-avatar" src="https://c.disquscdn.com/uploads/forums/619/627/avatar92.jpg?1592184394" alt="Avatar" class="image-refresh"></span></div><div class="textarea-outer-wrapper textarea-outer-wrapper--refresh"><div class="textarea-wrapper textarea-wrapper--embedv2" data-role="textarea" dir="auto"><div class="_container_ylcfx_1"><div class="_editor-container_ylcfx_37"><div class="_placeholder_s9avi_1">Join the discussionâ€¦</div><div role="textbox" aria-multiline="true" class="_editor_ylcfx_13" spellcheck="true" data-slate-editor="true" data-slate-node="value" contenteditable="true" zindex="-1" style="position: relative; white-space: pre-wrap; overflow-wrap: break-word;"><div data-slate-node="element"><span data-slate-node="text"><span data-slate-leaf="true"><span data-slate-zero-width="n" data-slate-length="0">ï»¿<br></span></span></span></div></div><button class="_placeholder-submit-button_ylcfx_55" aria-hidden="true" type="button">Comment</button></div></div></div></div></div><div data-role="login-form"><div><div><div role="login-form-alert"></div><section class="auth-section logged-out__display"><div class="connect"><h6 class="connect__heading">Log in with</h6><ul data-role="login-menu" class="services login-buttons"><li class="auth-disqus"><button type="button" data-action="auth:disqus" title="Disqus" class="connect__button" aria-label="Login with Disqus"><i class="icon-disqus"></i></button></li><li class="auth-facebook"><button type="button" data-action="auth:facebook" title="Facebook" class="connect__button" aria-label="Login with Facebook"><i class="icon-facebook-circle"></i></button></li><li class="auth-twitter"><button type="button" data-action="auth:twitter" title="X (Twitter)" class="connect__button" aria-label="Login with X (Twitter)"><i class="icon-twitter-x"></i></button></li><li class="auth-google"><button type="button" data-action="auth:google" title="Google" class="connect__button" aria-label="Login with Google"><i class="icon-google-plus-circle"></i></button></li><li class="auth-microsoft"><button type="button" data-action="auth:microsoft" title="Microsoft" class="connect__button" aria-label="Login with Microsoft"></button></li><li class="auth-apple"><button type="button" data-action="auth:apple" title="Apple" class="connect__button" aria-label="Login with Apple"></button></li></ul></div><div class="guest guest--refresh"><div class="sign-up-wrapper-refresh"><h6 class="guest-form-title guest-form-title--refresh"><span class="register-text"> or sign up with Disqus </span><span class="guest-text"> or pick a name </span></h6> <button type="button" class="help-tooltip__wrapper help-icon" name="guest_tooltip" tabindex="0"><div id="rules" class="help-tooltip__container" data-role="guest-form-tooltip"><div class="tooltip show help-tooltip"><h3 class="help-tooltip__heading">Disqus is a discussion network</h3><ul class="help-tooltip__list"><li><span>Don't be a jerk or do anything illegal. Everything is easier that way.</span></li></ul><p class="clearfix"><a href="https://docs.disqus.com/kb/terms-and-policies/" class="btn btn-small help-tooltip__button" rel="noopener noreferrer" target="_blank">Read full terms and conditions</a></p></div></div></button></div><p class="input-wrapper"><input dir="auto" type="text" placeholder="Name" name="display_name" id="view34_display_name" maxlength="30" class="input--text" aria-label="name" required=""></p><div class="guest-details " data-role="guest-details"><p class="input-wrapper"><input dir="auto" type="email" placeholder="Email" name="email" id="view34_email" class="input--text" aria-label="email" required=""></p><p class="input-wrapper"><input dir="auto" disabled="" type="text" class="register-text input--text" placeholder="Password" name="password" aria-label="password" id="view34_password" required=""></p><p class="privacy-info acceptance-wrapper"></p><div>This comment platform is hosted by Disqus, Inc. I authorize Disqus and its affiliates to:</div><div><ul class="privacy-info-list"><li>Use, sell, and share my information to enable me to use its comment services and for marketing purposes, including cross-context behavioral advertising, as described in our <a href="https://help.disqus.com/customer/portal/articles/466260-terms-of-service" target="_blank" rel="noopener noreferrer">Terms of Service</a> and <a href="https://disqus.com/privacy-policy" target="_blank" rel="noopener noreferrer">Privacy Policy</a>, including supplementing that information with other data about me, such as my browsing and location data.</li><li>Contact me or enable others to contact me by email with offers for goods or services</li><li>Process any sensitive personal information that I submit in a comment. See our <a href="https://disqus.com/privacy-policy" target="_blank" rel="noopener noreferrer">Privacy Policy</a> for more information</li></ul></div><label class="input-wrapper spacing-top-small"><input type="checkbox" name="ageDeclaration" id="view34_ageDeclaration" required=""><span class="spacing-left-small">Acknowledge I am 18 or older</span></label><p></p><div class="guest-checkbox"><label><input type="checkbox" name="author-guest"> I'd rather post as a guest</label></div><div class="g-recaptcha" data-role="grecaptcha-container"></div><div class="proceed" data-role="submit-btn-container"><div><button type="submit" class="proceed__button btn submit" aria-label="Post"><span class="icon-proceed"></span><div class="spinner"></div></button><button type="submit" class="proceed__button btn next" aria-label="Next"><span class="icon-proceed"></span><div class="spinner"></div></button></div></div></div></div></section></div></div></div></div></form></div><div id="email-signup"></div><div id="secondary-navigation"><div data-tracking-area="secondary-nav" class="nav-secondary-refresh"><ul class="nav-secondary-refresh__list"><li class="nav-secondary-refresh__list-item"><div id="favorite-button"><div class="thread-likes"><div><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="favorite" title="Favorite this discussion" class="favorite-button-toggle favorite-button-toggle--v2 " aria-label="Favorite this discussion"><span class="label label-default"><span class="favorite-icon favorite-icon--refresh-v2 icon-heart-empty"></span></span><span class="label label-favorited"><span class="favorite-icon favorite-icon--refresh-v2 icon-heart"></span></span> <span class="label label-count-refresh label-count-refresh--v2">1</span></a><ul class="dropdown-menu dropdown-menu--coachmark pull-right"><li><div><h2 class="coachmark__heading">Discussion Favorited!</h2><p class="coachmark__description">Favoriting means this is a discussion worth sharing. It gets shared to your followers' Disqus feeds, and gives the creator kudos!</p></div> <a href="https://disqus.com/home/?utm_source=disqus_embed&amp;utm_content=recommend_btn" class="btn btn-primary coachmark__button" target="_blank" rel="noopener noreferrer">Find More Discussions</a></li></ul></div></div></div><div id="thread-share-bar" class="share-bar-refresh"><div class="thread-share-wrapper"><div class="round-delimiter"></div><span data-role="thread-share" class="thread-share-bar-buttons-refresh" data-toggleable="true"><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" class="share-button-toggle share-button-toggle--v2" data-toggle="thread-share-bar-buttons-refresh" aria-label="Share" aria-haspopup="true" aria-expanded="false" id="share-dropdown-toggle">Share</a><ul class="share-dropdown-refresh" role="menu" aria-labelledby="share-dropdown-toggle"><li class="share-dropdown-refresh__item" role="none"><button class="share-icons-wrapper share-icons-wrapper--twitter" data-action="share:twitter" role="menuitem" tabindex="-1" aria-label="Tweet this discussion"><span class="icon-twitter-x" aria-hidden="true"></span><span class="visually-hidden">Tweet this discussion</span></button></li><li class="share-dropdown-refresh__item" role="none"><button class="share-icons-wrapper share-icons-wrapper--facebook" data-action="share:facebook" role="menuitem" tabindex="-1" aria-label="Share this discussion on Facebook"><span class="icon-facebook" aria-hidden="true"></span><span class="visually-hidden">Share this discussion on Facebook</span></button></li><li class="share-dropdown-refresh__item" role="none"><button class="share-icons-wrapper share-icons-wrapper--email" data-action="share:email" role="menuitem" tabindex="-1" aria-label="Share this discussion via email"><span class="icon-mail" aria-hidden="true"></span><span class="visually-hidden">Share this discussion via email</span></button></li><li class="share-dropdown-refresh__item" role="none"><button class="share-icons-wrapper share-icons-wrapper--link" data-action="copy-link" role="menuitem" tabindex="-1" aria-label="Copy link to discussion"><span class="icon-link" aria-hidden="true"></span><span class="visually-hidden">Copy link to discussion</span></button></li></ul></span></div></div></li><li data-role="post-sort"><ul class="sort-menu-refresh"><li class="sort-menu-refresh__item selected"><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="sort" data-sort="popular">Best</a></li><li class="sort-menu-refresh__item "><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="sort" data-sort="desc">Newest</a></li><li class="sort-menu-refresh__item "><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="sort" data-sort="asc">Oldest</a></li></ul></li></ul></div></div><div id="no-posts" style="display: none;"></div><div id="highlighted-post" data-tracking-area="highlighted" class="highlighted-post" style="display: none;"></div><button class="alert alert--realtime alert--realtime--refresh alert--realtime--refresh-v2" data-role="realtime-notification" style="display: none;"></button><ul id="post-list" class="post-list"><li class="post" id="post-5280005995"><div role="alert"></div><div role="article" data-role="post-content" class="post-content seen" tabindex="0" aria-labelledby="post-author-description-5280005995 a11y-helper-comma post-message-5280005995"><div class="indicator"></div><span class="pinned-icon"></span><ul class="post-menu dropdown post-menu--refresh" data-role="menu" data-view-id="post-menu" data-post-id="5280005995" data-toggleable="true"><li class="post-menu-item collapse"><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="collapse" title="Collapse" name="Collapse"><span>âˆ’</span></a></li><li class="post-menu-item expand"><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="collapse" title="Expand" name="Collapse"><span>+</span></a></li><li class=" post-menu-item"><div class="dropdown post-menu-flag"><a class="dropdown-toggle" href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="flag" data-role="flag" role="button" aria-label="Flag as inappropriate" title="Flag as inappropriate"><i aria-hidden="true" class="icon icon-flag"></i></a></div></li></ul><div class="avatar"><div class="user user--refresh"><img src="https://c.disquscdn.com/uploads/forums/619/627/avatar92.jpg?1592184394" class="user image-refresh" alt="Avatar"></div></div><div class="post-body"><div class="post-body-inner"><div class="post-message-container" data-role="message-container"><div class="publisher-anchor-color" data-role="message-content"><div id="post-message-5280005995" class="post-message " data-role="message" dir="auto"><div><p>This is one of the best write-ups I've read on APCs.  Great job.</p><p>I'm having an issue maybe you can help shed some light on.  If I inject from the kernel into a process and force the APC using KeTestAlertThread, the injected library loads but then quickly unloads from the process.  DLLMain is never called however all of its dependencies are loaded (but consequently also unloaded).  If I don't use KeTestAlertThread then the library loads properly but at a later point that makes the injection useless.  I see your note about not being able to import other modules but it seems that only applies if you queue the UserMode APC directly from the ImageLoad callback vice queuing a KernelMode APC and then a UserMode APC.  Doing the former leads to STATUS_INTERNAL_ERROR.  And I would expect that if there was a module import issue that the process would crash with an error such as STATUS_INTERNAL_ERROR.</p></div></div><span class="post-media"><ul data-role="post-media-list"></ul></span></div></div><a class="see-more hidden" title="see more" data-action="see-more">see more</a></div></div><div class="moderate-form blacklist-form" data-role="blacklist-form"></div><div class="moderate-form flag-form" data-role="flagging-form"></div><div class="badges-form" data-role="badges-form"></div><div class="reply-form-container" data-role="reply-form"></div></div><div class="children"><ul data-role="children"><li class="post" id="post-5280416784"><div role="alert"></div><div role="article" data-role="post-content" class="post-content seen" tabindex="0" aria-labelledby="post-author-description-5280416784 a11y-helper-comma post-parent-5280416784 a11y-helper-comma post-message-5280416784"><div class="indicator"></div><span class="pinned-icon"></span><ul class="post-menu dropdown post-menu--refresh" data-role="menu" data-view-id="post-menu" data-post-id="5280416784" data-toggleable="true"><li class="post-menu-item collapse"><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="collapse" title="Collapse" name="Collapse"><span>âˆ’</span></a></li><li class="post-menu-item expand"><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="collapse" title="Expand" name="Collapse"><span>+</span></a></li><li class=" post-menu-item"><div class="dropdown post-menu-flag"><a class="dropdown-toggle" href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="flag" data-role="flag" role="button" aria-label="Flag as inappropriate" title="Flag as inappropriate"><i aria-hidden="true" class="icon icon-flag"></i></a></div></li></ul><div class="avatar hovercard"><button class="user user--refresh" aria-haspopup="dialog" aria-expanded="false" data-action="show-hovercard" aria-label="Avatar for rbmm, profile card button"><img data-role="user-avatar" data-user="365133028" src="https://c.disquscdn.com/uploads/forums/619/627/avatar92.jpg?1592184394" alt="Avatar for rbmm" class="image-refresh"></button></div><div class="post-body"><div class="post-body-inner"><div class="post-message-container" data-role="message-container"><div class="publisher-anchor-color" data-role="message-content"><div id="post-message-5280416784" class="post-message " data-role="message" dir="auto"><div><p>your problem is not related to APC. but exactly to my note "<i>you cannot import any other DLLs into your module except for ntdll.dll</i>". you're wrongly interpreting your observed results.</p><p></p><blockquote>If I don't use KeTestAlertThread then the library loads properly <b>but at a later point</b> that makes the injection useless.</blockquote><p></p><p>The error lies in this - <b>at a later point</b>. if your dll is loaded later - all is good, but when you force it to load early, it will fail. this is not about apc. your issue is the timing when dll is loaded. what matters is this:</p><p>- what dlls are loaded into the process at the time<br>- the state they are in (whether they are initialized or not) like i described in the blog post above.</p><p></p><blockquote>however all of its dependencies are loaded</blockquote><p></p><p>here is your error. i dont know when, and after which event you try to load your dll, but I can guess you're doing it from <i>PsSetLoadImageNotifyRoutine</i> callback, when some system dll is loaded. to say why exactly dll fails to load - i need more info. this task is simple to research with a debugger. here's an <a href="https://github.com/rbmm/INJECT" rel="nofollow noopener" target="_blank" title="https://github.com/rbmm/INJECT"> example</a> of a working code for you.</p></div></div><span class="post-media"><ul data-role="post-media-list"></ul></span></div></div><a class="see-more hidden" title="see more" data-action="see-more">see more</a></div></div><div class="moderate-form blacklist-form" data-role="blacklist-form"></div><div class="moderate-form flag-form" data-role="flagging-form"></div><div class="badges-form" data-role="badges-form"></div><div class="reply-form-container" data-role="reply-form"></div></div><div class="children"><ul data-role="children"><li class="post" id="post-5281519561"><div role="alert"></div><div role="article" data-role="post-content" class="post-content seen" tabindex="0" aria-labelledby="post-author-description-5281519561 a11y-helper-comma post-parent-5281519561 a11y-helper-comma post-message-5281519561"><div class="indicator"></div><span class="pinned-icon"></span><ul class="post-menu dropdown post-menu--refresh" data-role="menu" data-view-id="post-menu" data-post-id="5281519561" data-toggleable="true"><li class="post-menu-item collapse"><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="collapse" title="Collapse" name="Collapse"><span>âˆ’</span></a></li><li class="post-menu-item expand"><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="collapse" title="Expand" name="Collapse"><span>+</span></a></li><li class=" post-menu-item"><div class="dropdown post-menu-flag"><a class="dropdown-toggle" href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="flag" data-role="flag" role="button" aria-label="Flag as inappropriate" title="Flag as inappropriate"><i aria-hidden="true" class="icon icon-flag"></i></a></div></li></ul><div class="avatar"><div class="user user--refresh"><img src="https://c.disquscdn.com/uploads/forums/619/627/avatar92.jpg?1592184394" class="user image-refresh" alt="Avatar"></div></div><div class="post-body"><div class="post-body-inner"><div class="post-message-container" data-role="message-container"><div class="publisher-anchor-color" data-role="message-content"><div id="post-message-5281519561" class="post-message " data-role="message" dir="auto"><div><p>You are right.  I was keying off the wrong library to start the injection process.  And apparently the STATUS_INTERNAL_ERROR result from LdrLoadDll was being swallowed instead of causing the program to crash.</p><p>I got it working to meet my needs but it'd be nice to find a way (hooking LdrLoadDll maybe?) to inject after kernel32.dll and load properly without any of the restrictions that come along with APC injection.</p></div></div><span class="post-media"><ul data-role="post-media-list"></ul></span></div></div><a class="see-more hidden" title="see more" data-action="see-more">see more</a></div></div><div class="moderate-form blacklist-form" data-role="blacklist-form"></div><div class="moderate-form flag-form" data-role="flagging-form"></div><div class="badges-form" data-role="badges-form"></div><div class="reply-form-container" data-role="reply-form"></div></div><div class="children"><ul data-role="children"><li class="post" id="post-5282387280"><div role="alert"></div><div role="article" data-role="post-content" class="post-content seen" tabindex="0" aria-labelledby="post-author-description-5282387280 a11y-helper-comma post-parent-5282387280 a11y-helper-comma post-message-5282387280"><div class="indicator"></div><span class="pinned-icon"></span><ul class="post-menu dropdown post-menu--refresh" data-role="menu" data-view-id="post-menu" data-post-id="5282387280" data-toggleable="true"><li class="post-menu-item collapse"><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="collapse" title="Collapse" name="Collapse"><span>âˆ’</span></a></li><li class="post-menu-item expand"><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="collapse" title="Expand" name="Collapse"><span>+</span></a></li><li class=" post-menu-item"><div class="dropdown post-menu-flag"><a class="dropdown-toggle" href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="flag" data-role="flag" role="button" aria-label="Flag as inappropriate" title="Flag as inappropriate"><i aria-hidden="true" class="icon icon-flag"></i></a></div></li></ul><div class="avatar hovercard"><button class="user user--refresh" aria-haspopup="dialog" aria-expanded="false" data-action="show-hovercard" aria-label="Avatar for rbmm, profile card button"><img data-role="user-avatar" data-user="365133028" src="https://c.disquscdn.com/uploads/forums/619/627/avatar92.jpg?1592184394" alt="Avatar for rbmm" class="image-refresh"></button></div><div class="post-body"><div class="post-body-inner"><div class="post-message-container" data-role="message-container"><div class="publisher-anchor-color" data-role="message-content"><div id="post-message-5282387280" class="post-message " data-role="message" dir="auto"><div><p>it possible inject on kernel32.dll section map event. simply dll must have import only from ntdll.dll. for another dll we can use delay import. however all depend from - how task is set</p></div></div><span class="post-media"><ul data-role="post-media-list"></ul></span></div></div><a class="see-more hidden" title="see more" data-action="see-more">see more</a></div></div><div class="moderate-form blacklist-form" data-role="blacklist-form"></div><div class="moderate-form flag-form" data-role="flagging-form"></div><div class="badges-form" data-role="badges-form"></div><div class="reply-form-container" data-role="reply-form"></div></div><div class="children"><ul data-role="children"></ul><div class="show-children-wrapper hidden"><a class="show-children" id="post-5282387280-show-children" data-action="show-children" href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#">Show more replies</a></div></div></li></ul><div class="show-children-wrapper hidden"><a class="show-children" id="post-5281519561-show-children" data-action="show-children" href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#">Show more replies</a></div></div></li></ul><div class="show-children-wrapper hidden"><a class="show-children" id="post-5280416784-show-children" data-action="show-children" href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#">Show more replies</a></div></div></li></ul><div class="show-children-wrapper hidden"><a class="show-children" id="post-5280005995-show-children" data-action="show-children" href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#">Show more replies</a></div></div></li></ul><div class="load-more-refresh load-more-refresh--v2" data-role="more" style="display: none;"><a href="https://disqus.com/embed/comments/?base=default&amp;f=dennisbabkin-com&amp;t_i=AAA03000&amp;t_u=https%3A%2F%2Fdennisbabkin.com%2Fblog%2F%3Ft%3Ddepths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode&amp;t_d=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;t_t=Depths%20of%20Windows%20APC%20-%20Aspects%20of%20internals%20of%20the%20Asynchronous%20Procedure%20Calls%20from%20the%20kernel%20mode.&amp;s_o=default#" data-action="more-posts" class="btn load-more-refresh__button">Load more comments</a></div></div></section><div id="placement-bottom" data-tracking-area="discovery-south"></div></div></div></div><div id="embed_v2-root"></div></div><div id=":r2:" data-floating-ui-portal=""><div class="_overlay_1i4qh_1" tabindex="-1" id=":r0:" role="listbox" style="position: fixed; left: 0px; top: 0px; transform: translate(62px, 141px); width: 1842px;"></div></div></div></div>


</div>
	
    </main>
    
</div>

<div id="fancybox-tmp"></div><div id="fancybox-loading"><div></div></div><div id="fancybox-overlay"></div><div id="fancybox-wrap"><div id="fancybox-outer"><div class="fancybox-bg" id="fancybox-bg-n"></div><div class="fancybox-bg" id="fancybox-bg-ne"></div><div class="fancybox-bg" id="fancybox-bg-e"></div><div class="fancybox-bg" id="fancybox-bg-se"></div><div class="fancybox-bg" id="fancybox-bg-s"></div><div class="fancybox-bg" id="fancybox-bg-sw"></div><div class="fancybox-bg" id="fancybox-bg-w"></div><div class="fancybox-bg" id="fancybox-bg-nw"></div><div id="fancybox-content"></div><a id="fancybox-close"></a><div id="fancybox-title"></div><a id="fancybox-left"><span class="fancy-ico" id="fancybox-left-ico"></span></a><a id="fancybox-right"><span class="fancy-ico" id="fancybox-right-ico"></span></a></div></div><div style="display: none;" data-original-tag="iframe"></div></body></html>