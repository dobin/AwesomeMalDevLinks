# https://www.trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-memory-regions

![Revisit consent button](https://cdn-cookieyes.com/assets/images/revisit.svg)

We value your privacy

We use cookies to enhance your browsing experience, serve personalised ads or content, and analyse our traffic. By clicking "Accept All", you consent to our use of cookies.

CustomiseReject AllAccept All

Customise Consent Preferences![Close](https://cdn-cookieyes.com/assets/images/close.svg)

We use cookies to help you navigate efficiently and perform certain functions. You will find detailed information about all cookies under each consent category below.

The cookies that are categorised as "Necessary" are stored on your browser as they are essential for enabling the basic functionalities of the site. ... Show more

NecessaryAlways Active

Necessary cookies are required to enable the basic features of this site, such as providing secure log-in or adjusting your consent preferences. These cookies do not store any personally identifiable data.

- Cookie

\_\_cf\_bm

- Duration

1 hour

- Description

This cookie, set by Cloudflare, is used to support Cloudflare Bot Management.


- Cookie

\_\_hssrc

- Duration

session

- Description

This cookie is set by Hubspot whenever it changes the session cookie. The \_\_hssrc cookie set to 1 indicates that the user has restarted the browser, and if the cookie does not exist, it is assumed to be a new session.


- Cookie

\_\_hssc

- Duration

1 hour

- Description

HubSpot sets this cookie to keep track of sessions and to determine if HubSpot should increment the session number and timestamps in the \_\_hstc cookie.


- Cookie

\_cfuvid

- Duration

session

- Description

Calendly sets this cookie to track users across sessions to optimize user experience by maintaining session consistency and providing personalized services


Functional

Functional cookies help perform certain functionalities like sharing the content of the website on social media platforms, collecting feedback, and other third-party features.

- Cookie

lidc

- Duration

1 day

- Description

LinkedIn sets the lidc cookie to facilitate data center selection.


- Cookie

li\_gc

- Duration

6 months

- Description

Linkedin set this cookie for storing visitor's consent regarding using cookies for non-essential purposes.


Analytics

Analytical cookies are used to understand how visitors interact with the website. These cookies help provide information on metrics such as the number of visitors, bounce rate, traffic source, etc.

- Cookie

\_gcl\_au

- Duration

3 months

- Description

Google Tag Manager sets the cookie to experiment advertisement efficiency of websites using their services.


- Cookie

\_ga\_\*

- Duration

1 year 1 month 4 days

- Description

Google Analytics sets this cookie to store and count page views.


- Cookie

\_ga

- Duration

1 year 1 month 4 days

- Description

Google Analytics sets this cookie to calculate visitor, session and campaign data and track site usage for the site's analytics report. The cookie stores information anonymously and assigns a randomly generated number to recognise unique visitors.


- Cookie

\_\_hstc

- Duration

6 months

- Description

Hubspot set this main cookie for tracking visitors. It contains the domain, initial timestamp (first visit), last timestamp (last visit), current timestamp (this visit), and session number (increments for each subsequent session).


- Cookie

hubspotutk

- Duration

6 months

- Description

HubSpot sets this cookie to keep track of the visitors to the website. This cookie is passed to HubSpot on form submission and used when deduplicating contacts.


Performance

Performance cookies are used to understand and analyse the key performance indexes of the website which helps in delivering a better user experience for the visitors.

- Cookie

session\_id

- Duration

1 year

- Description

This cookie is used to get or set the session id for the current session.


Advertisement

Advertisement cookies are used to provide visitors with customised advertisements based on the pages you visited previously and to analyse the effectiveness of the ad campaigns.

- Cookie

sa-user-id

- Duration

1 year

- Description

StackAdapt sets this cookie as a third party advertising cookie to record information about a user's website activity, such as the pages visited and the locations viewed, to enable us to provide users with interest-based content and personalised advertisements on external websites.


- Cookie

sa-user-id-v2

- Duration

1 year

- Description

StackAdapt sets this cookie as a third party advertising cookie to record information about a user's website activity, such as the pages visited and the locations viewed, to enable us to provide users with interest-based content and personalised advertisements on external websites.


- Cookie

bcookie

- Duration

1 year

- Description

LinkedIn sets this cookie from LinkedIn share buttons and ad tags to recognize browser IDs.


- Cookie

IDE

- Duration

1 year 24 days

- Description

Google DoubleClick IDE cookies store information about how the user uses the website to present them with relevant ads according to the user profile.


- Cookie

test\_cookie

- Duration

15 minutes

- Description

doubleclick.net sets this cookie to determine if the user's browser supports cookies.


Uncategorised

Other uncategorised cookies are those that are being analysed and have not been classified into a category as yet.

- Cookie

sa-user-id-v3

- Duration

1 year

- Description

Description is currently not available.


- Cookie

calltrk\_nearest\_tld

- Duration

1 year 1 month 4 days

- Description

Description is currently not available.


- Cookie

calltrk\_referrer

- Duration

6 months

- Description

This is a functionality cookie set by the CallRail. This cookie is used to store the referring URL. It helps to accurately attribute the visitor source when displaying a tracking phone number.


- Cookie

calltrk\_landing

- Duration

6 months

- Description

This is a functionality cookie set by the CallRail. This cookie is used to store the landing page URL. It helps to accurately attribute the visitor source when displaying a tracking phone number.


- Cookie

frontend\_lang

- Duration

1 year

- Description

No description available.


- Cookie

libsyn-paywall-s

- Duration

1 day

- Description

Description is currently not available.


Reject AllSave My PreferencesAccept All

Powered by [![Cookieyes logo](https://cdn-cookieyes.com/assets/images/poweredbtcky.svg)](https://www.cookieyes.com/product/cookie-consent/?ref=cypbcyb&utm_source=cookie-banner&utm_medium=powered-by-cookieyes)

- [Blog](https://trustedsec.com/blog)
- [Windows Processes, Nefarious Anomalies, and You: Memory Regions](https://trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-memory-regions)

November 01, 2022

# Windows Processes, Nefarious Anomalies, and You: Memory Regions

Written by
Brandon McGrath


![](https://trusted-sec.transforms.svdcdn.com/production/images/Blog-Covers/WindowProcesses_Part1_WebHero.jpg?w=320&h=320&q=90&auto=format&fit=crop&dm=1767067278&s=4cc8db5321525c4fc883859f5e3270f6)

Share

- [Share URL](https://www.trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-memory-regions "Share URL")
- [Share via Email](mailto:?subject=Check%20out%20this%20article%20from%20TrustedSec%21&body=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Memory%20Regions%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions "Share via Email")
- [Share on Facebook](http://www.facebook.com/sharer.php?u=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions "Share on Facebook")
- [Share on X](http://twitter.com/share?text=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Memory%20Regions%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions "Share on X")
- [Share on LinkedIn](https://www.linkedin.com/shareArticle?url=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions&mini=true "Share on LinkedIn")

Share

- [Share URL](https://www.trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-memory-regions "Share URL")
- [Share via Email](mailto:?subject=Check%20out%20this%20article%20from%20TrustedSec%21&body=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Memory%20Regions%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions "Share via Email")
- [Share on Facebook](http://www.facebook.com/sharer.php?u=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions "Share on Facebook")
- [Share on X](http://twitter.com/share?text=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Memory%20Regions%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions "Share on X")
- [Share on LinkedIn](https://www.linkedin.com/shareArticle?url=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions&mini=true "Share on LinkedIn")

While operating on a red team, the likelihood of an Endpoint Detection and Response (EDR) being present on a host is becoming increasingly higher than it was a few years ago. When an implant is being initiated on a host, whether it’s on-disk or loaded into memory, then there is a lot to consider. In this post, we will focus on one very specific component of EDR: memory scanners.

A memory scanner is quite self-explanatory. It scans the memory of a process and attempts to identify non-standard attributes within a memory region in effort to determine if the process requires additional analysis and/or containment.

The community has done a great job of implementing memory scanners to identify malicious activity, and they have been adopted by red teamers as a means to QA their own implants:

- [pe-sieve](https://github.com/hasherezade/pe-sieve) by [Hasherezade](https://twitter.com/hasherezade)
- [Moneta](https://github.com/forrest-orr/moneta) by [Forrest Orr](https://twitter.com/_forrestorr)
- [Hunt-Sleeping-Beacons](https://github.com/thefLink/Hunt-Sleeping-Beacons) by [thefLinkk](https://twitter.com/thefLinkk)

For extra points, organizations _could_ implement these into their own detection strategy – however, these types of tools look for very specific anomalies within a process, and because of that, may generate false positives.

In terms of EDR vendors, smaller components of these scanners will likely be in their toolkit, but they must undergo a lot of effort to ensure that false positives don’t make it into production, let alone customer environments. However, they are used for a slightly different purpose within an EDR—typically, when one of the memory scanner indicators is hit, it will trigger further analysis of the process. That could be known-malware signatures, log analysis for that particular process, and so on. An EDR is extremely unlikely to create an alert on an endpoint because RWX was allocated in a process. As we go into this series, we will show the sheer number of false positives that memory scanners can create when scanning everything. However, it _may_ cause the EDR to take a further look into that process (as a naive example).

In this blog, we will look at what a memory scanner is looking at and why, and then we will identify some low-hanging fruit from a Command & Control (C2) implant.

## 1.  Process Structure

In its simplest form, a process is an executing program. Under the hood, Windows is an object-oriented system. This means that each component of Windows will essentially boil down to sort of object. As for a process, the Windows Kernel knows this as the [EPROCESS structure](https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/ps/eprocess/index.htm). However, going up a level, this structure is simplified to the [Process Environment Block](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb) (PEB).

```css
typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;
```

From this structure, we can get information such as the process name, current directory, loaded Dynamic-Link Libraries (DLLs), and so on. This is the structure we will be working with a lot.

To simplify this quite a bit, we will focus on three components of a process:

1. Memory regions
2. Threads
3. Loaded DLLs

To learn more about the PEB, " [Anatomy of the Process Environment Block (PEB) (Windows Internals)](https://ntopcode.wordpress.com/2018/02/26/anatomy-of-the-process-environment-block-peb-windows-internals/)" is recommended reading.

## 2.  A Bit of Context

For a bit of context, the sample used for this demonstration is going to be an unreleased/proof-of-concept C2 for the [Maelstrom](https://pre.empt.dev/posts/maelstrom-an-introduction/) series, as it contains embedded indicators of compromise, which is perfect for this demonstration.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath1.png)Figure 1 Maelstrom Implant Existing

This reaches out to a local IP address, requests a Reflective DLL, and then executes it within memory. We will be searching for that final step.

One final note: The framework being used in this article to assess the process will not be released, but we will do our best to supply source code to achieve each component of this blog. The tool in question is known as Fennec and will be addressed as such throughout.

## 3.  Enumerating Memory Regions

Using explorer.exe as an example, let’s use [Process Hacker](https://processhacker.sourceforge.io/) to look at the memory regions. This is done by finding a process, double-clicking and going to the Memory tab.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath2.png)Figure 2 Process Explorer Memory Regions

The way to achieve this programmatically is the [VirtualQueryEx](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualqueryex) call.

```css
SIZE_T VirtualQueryEx(
  [in]           HANDLE                    hProcess,
  [in, optional] LPCVOID                   lpAddress,
  [out]          PMEMORY_BASIC_INFORMATION lpBuffer,
  [in]           SIZE_T                    dwLength
);
```

This takes in a few arguments:

- Handle to the process
- A base address to query
- A pointer to a structure
- The size of the previous parameter

The most important part in this call is what we are expecting to get out of it: [MEMORY\_BASIC\_INFORMATION](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information).

```cpp
 typedef struct _MEMORY_BASIC_INFORMATION {
  PVOID  BaseAddress;
  PVOID  AllocationBase;
  DWORD  AllocationProtect;
  WORD   PartitionId;
  SIZE_T RegionSize;
  DWORD  State;
  DWORD  Protect;
  DWORD  Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
```

This structure will essentially create most of the regions found in the screenshot of Process Hacker, and this will give us 99% of the information required to analyze a processes memory!

As the scanner we will be producing has an extra member, and to allow for expansion later, a new structure is defined.

```java
typedef struct REGION_
{
      LPVOID BaseAddress = nullptr;
      LPVOID AllocationBase = nullptr;
      WORD PartitionId = 0;
      DWORD Size = 0;
      DWORD ActiveProtect     = 0;
      DWORD InitialProtect = 0;
      DWORD State = 0;
      DWORD Type = 0;
      std::string Use = "";
} Region;
```

In this case, the Use will hold the DLL associated with the region, _IF_ it exists.

One final thing before we work through all the regions—let’s make a quick note on each of the structure members we actually need:

- **Base Address:** The base address of the memory region
- **Allocation Base:** The base address of a range of pages which are created by [VirtualAlloc](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)
- **Region Size:** The size of the region beginning at the base address of all pages
- **State:** Whether it’s committed, freed, or reserved
- **Active Protection:** The access protection of the region as of access
- **Initial Protection:** The protection it was originally allocated as
- **Type:** Whether it’s private, image, or mapped memory (more on this later)
- **Use:** The reason that the region exists

Each of the structures defined will be put into a [vector](https://en.cppreference.com/w/cpp/container/vector) (array of objects). Here is the function to query each region, incrementing by the current region's size. Then, we build out the region structure and add it to the vector.

```ruby
std::vector<FENNEC::Processes::Region> FENNEC::Processes::GetAllRegions(HANDLE hProcess)
{
    std::vector<FENNEC::Processes::Region> Regions;
    MEMORY_BASIC_INFORMATION mbi = { 0 };
    LPVOID offset = 0;

    while (VirtualQueryEx(hProcess, offset, &mbi, sizeof(mbi)))
    {
        if (mbi.RegionSize > 0)
        {
            offset = (LPVOID)((DWORD_PTR)mbi.BaseAddress + mbi.RegionSize);
            FENNEC::Processes::Region Region;
            Region.BaseAddress = mbi.BaseAddress;
            Region.AllocationBase = mbi.AllocationBase;
            Region.PartitionId = mbi.PartitionId;
            Region.Size = mbi.RegionSize;
            Region.ActiveProtect = mbi.Protect;
            Region.InitialProtect = mbi.AllocationProtect;
            Region.State = mbi.State;
            Region.Type = mbi.Type;
            Region.Use = FENNEC::Processes::GetRegionUse(hProcess, Region);

            Regions.push_back(Region);
        }
    }
    return Regions;
}
```

As for the `GetRegionUse`, this is simply a wrapper around the following function.

```ruby
std::string FENNEC::Processes::GetModulePath(HANDLE hProcess, HMODULE hModule)
{
    CHAR Path[MAX_PATH];
    if (K32GetModuleFileNameExA(hProcess, hModule, Path, sizeof(Path) / sizeof(CHAR)))
    {
        return std::string(Path);
    }
    else
    {
        return "";
    }
}
```

[GetModuleFileNameExA](https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getmodulefilenameexa) takes in a handle to a process and a module (base address), then attempts to retrieve its name. If this succeeds, then the region has a 'use'. This means that the memory region is attributed to something. We can demonstrate that.

In the following screenshot, we can see the memory regions of WINWORD.EXE, and there are two things to note.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath3.png)Figure 3 WINWORD.EXE Memory Use

First of all, the Use column is filled with various DLLs. Secondly, the memory type is `Image: Commit (MEM_IMAGE).`

When a DLL is loaded into a process, its memory region will be a mapped image (`MEM_IMAGE`), and the base address will be that of the DLL—that is where the `Use` comes from, and that is what we are replicating above.

As an example, one of the structures would appear as follows.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath4.png)Figure 4 Example of a Region Structure

With that, the enumeration section is done for now. Up next, parsing it for badness.

## 4.  Identifying Malicious Attributes in Memory Regions

There are many ways to filter through memory regions to mark them as malicious. In this blog, we will look at two low-hanging fruits— RWX and MZ headers in private memory Regions—to ensure that this blog does not go on too long.

### 4.1.      PAGE\_EXECUTE\_READWRITE

Out of all the techniques mentioned in this blog, this is the easiest to identify. And like the rest of the techniques, if the memory scanner detects any of these techniques, it does not necessarily mean they are malicious—it is just a potential indicator for further enumeration.

Below is the code to check for RWX.

```ruby
void Scanner::HuntRWX(std::vector<FENNEC::Processes::Region> Regions, FENNEC::Comms::Common Common)
{
	for (FENNEC::Processes::Region& Region : Regions)
	{
		if (Region.ActiveProtect == PAGE_EXECUTE_READWRITE)
		{
			nlohmann::json Json;
			Json["method"] = "RWX";

			Json["base_address"] = FENNEC::Strings::LPVOID2StringA(Region.BaseAddress);
			Json["use"] = Region.Use;
			Json["allocation_base"] = FENNEC::Strings::LPVOID2StringA(Region.AllocationBase);
			Json["partition_id"] = std::to_string(Region.PartitionId);
			Json["region_size"] = std::to_string(Region.Size);
			Json["region_protection_active"] = FENNEC::Strings::ProtectToString(Region.ActiveProtect);
			Json["region_allocation_initial"] = FENNEC::Strings::ProtectToString(Region.InitialProtect);
			Json["region_state"] = FENNEC::Strings::AllocateToString(Region.State);
			Json["region_type"] = FENNEC::Strings::TypeToString(Region.Type);

			std::string Log = FENNEC::Comms::ConvertCommonLogStructureToJson(Common, Json);
			FENNEC::Logger::Good("RWX Identified: %s\n", Log.c_str());
			FENNEC::Logger::WriteLogToFile(LOG_TYPE, Log);
		}
	}
}
```

Essentially, we check if the `ActiveProtect`member of the structure is `PAGE_EXECUTE_READWRITE`—simple.

Then we run the scanner.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath5.png)Figure 5 Log for RWX Scan

Beautifying the JSON, here is the full log.

```swift
{
  "data": {
    "allocation_base": "0x00000000001E0000",
    "base_address": "0x00000000001E0000",
    "method": "RWX",
    "partition_id": "0",
    "region_allocation_initial": "PAGE_EXECUTE_READWRITE",
    "region_protection_active": "PAGE_EXECUTE_READWRITE",
    "region_size": "73728",
    "region_state": "MEM_COMMIT",
    "region_type": "MEM_PRIVATE",
    "use": ""
  },
  "event_category": "Memory Scanner",
  "event_time": "Tue Sep 6 10:07:34 2022",
  "guid": "e861eb49-08ab-427f-95d7-e8116475c1e8",
  "image_name": "maelstrom.unsafe.x64.exe",
  "image_path": "\\Device\\HarddiskVolume11\\maelstrom\\agent\\stage0\\bin\\maelstrom.unsafe.x64.exe",
  "parent_procecess": 12652,
  "process_id": 15372
}
```

This log structure is common amongst all techniques within the scanner, and it provides a lot of context that could aid in further analysis. For example, in this case, it was allocated as RWX and was not changed at all. However, if this was allocated as RW and made a switch to RX, then this could also be malware, as this is the process to which 99% of implants subscribe.

In the case of an EDR, checking for protection changes from RW to RX whilst on a memory scan isn’t performed too often. Adjusting the scanner to scan all processes, it produces 498 entries on the host.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath6.png)Figure 6 498 RWX Entries Found

Taking this one step further by checking this information out inside of ELK, we find there are quite a lot of processes that use RWX.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath7.png)Figure 7 Image to RWX Log Entry

To clarify, the left column is the process name, and the right is the amount of log entries in which that process has RWX allocated.

### 4.2.      MZ Headers in Private Memory Regions

This method is far less common, and a bit more complicated to understand. When a DLL is loaded, it gets marked as `MEM_IMAGE`, one of the types from [MEMORY\_BASIC\_INFORMATION](https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-memory_basic_information).

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath8.png)Figure 8 MEMORY\_BASIC\_INFORMATION Types

We can see this by opening up Process Hacker, finding a process, and navigating to the `Memory` section.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath9.png)Figure 9 MEM\_IMAGE Memory Regions

In this list, there will also be regions marked as mapped, which equates to the `MEM_MAPPED` type.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath10.png)Figure 10 MEM\_MAPPED Memory Regions

Looking at all the `MEM_PRIVATE` allocations, they tend to be regions used within the process/DLL for whatever they may need.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath11.png)Figure 11 MEM\_PRIVATE Memory Regions

As an example, let’s allocate a big chunk of memory.

```cpp
LPVOID pAddress = VirtualAlloc(nullptr, 409600, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	memset(pAddress, 'a', 409600);
```

Opening up the memory regions, we can see our allocation is `Private Memory`.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath12.png)Figure 12 VirtualAlloc Creating Private Memory

And then again with `malloc` (and a VirtualQuery so we can find where it is).

```cpp
	LPVOID pAddress = (LPVOID)malloc(409600);
	memset(pAddress, 'a', 409600);

	MEMORY_BASIC_INFORMATION mbi = { 0 };
	VirtualQuery(pAddress, &mbi, sizeof mbi);
```

Here's the result.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath13.png)Figure 13 Malloc Creating Private Memory

As we can see in both cases, the memory is allocated as private, meaning that when ever memory is allocated within a process to do something with a buffer, a region like this will be created.

Therefore, if a DLL is found within this region, it’s extremely suspicious. If a genuine process needs a legitimate DLL, it will just load it appropriately—it will either load it at runtime as a dependency, or it will dynamically load it with something like [LoadLibraryA](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya).

Now that we understand why seeing a DLL in private memory is a bit weird, let’s look at how we identify this.

We begin by identifying all the memory regions as we did earlier and putting their structures into a vector. Now it’s time to parse.

The first thing we can do is disregard `MEM_IMAGE` and `MEM_MAPPED`. As this is more of a proof-of-concept, we don’t need to care about them. With that said, EDRs will respond differently to these types, and this kind of logic is extremely unlikely to occur. But we will do it for now.

```python
if (Region.Type == MEM_MAPPED || Region.Type == MEM_IMAGE)
{
    continue;
}
```

Next, we define a few things that will be used.

```cpp
BOOL bMzFound = FALSE;
BOOL bIsDLLBacked = FALSE;
std::vector<unsigned char> bytes = { 0x4d, 0x5a };
PCHAR lpBuffer = static_cast<PCHAR>(malloc(Region.Size));
```

Note the bytes vector. 0x4d and 0x5a are the hex values of MZ. We then allocate space into which we can read the entire region.

Using [ReadProcessMemory](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory), we then read the region.

```objectivec
BOOL bRead = ReadProcessMemory(hProcess, (LPVOID)Region.BaseAddress, lpBuffer, Region.Size, NULL);

if (bRead == FALSE)
{
      free(lpBuffer);
      continue;
}
```

In this example, we then get the first two bytes of the region and put them into a vector.

```cpp
std::vector<unsigned char> vectorBuffer(lpBuffer, lpBuffer + 2);
```

By simply adding three 0s (000) to the start of the malicious region, this logic would be avoided.

With that, we compare the newly created 2-byte vector to the `MZ` vector.

```cpp
BOOL FENNEC::Strings::CompareVectors(std::vector<unsigned char> a, std::vector<unsigned char> b)
{
	if (std::equal(a.begin(), a.end(), b.begin()))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
```

At this point, it could potentially be finished. But there is a bit more checking to do first, just to make sure.

If this returns a 'true' response, the scanner will validate if that region belongs to any DLL in the process. Not strictly required, but worthwhile. To achieve this, there are two methods.

First, we get every DLL in the process and compare base addresses.

```ruby
	std::vector<FENNEC::Processes::Module> modules = FENNEC::Processes::GetModules(hProcess);
	for (FENNEC::Processes::Module& Module : modules)
	{
		if (Region.AllocationBase == Module.BaseAddress)
		{
			bIsDLLBacked = TRUE;
			break;
		}
	}
```

Or we can do this manually by parsing the [PPEB\_LDR\_DATA](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data) structure.

```rust
BOOL FENNEC::PEBLOCK::IsBaseAddressWithDll(LPVOID BaseAddress)
{
	PPEB_LDR_DATA Ldr = FENNEC::PEBLOCK::Peb->Ldr;
	LIST_ENTRY* ModuleList = NULL;
	BOOL bDllIsBacked = FALSE;

	ModuleList = &Ldr->InMemoryOrderModuleList;
	LIST_ENTRY* pStartListEntry = ModuleList->Flink;
	for (LIST_ENTRY* pListEntry = pStartListEntry; pListEntry != ModuleList; pListEntry = pListEntry->Flink)
	{
		LDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));
		std::wstring wsName(pEntry->BaseDllName.Buffer);
		std::wstring wsPath(pEntry->FullDllName.Buffer);

		std::string modName = FENNEC::Strings::StringW2StringA(wsName);
		std::string modPath = FENNEC::Strings::StringW2StringA(wsPath);

		if (BaseAddress == pEntry->DllBase)
		{
			bDllIsBacked = TRUE;
			break;
		}

	}
	return bDllIsBacked;
}
```

Either way, this will return a 'false' response, as the memory region is not the base address of a DLL.

Targeting the implant process, it identifies one region.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath14.png)Figure 14 MZ Header Found in MEM\_PRIVATE

Here is the full log.

```swift
{
  "data": {
    "allocation_base": "0x00000000001E0000",
    "base_address": "0x00000000001E0000",
    "method": "Memory Allocation without DLL Backing",
    "partition_id": "0",
    "region_allocation_initial": "PAGE_EXECUTE_READWRITE",
    "region_protection_active": "PAGE_EXECUTE_READWRITE",
    "region_size": "73728",
    "region_state": "MEM_COMMIT",
    "region_type": "MEM_PRIVATE",
    "use": ""
  },
  "event_category": "Memory Scanner",
  "event_time": "Tue Sep  6 11:57:57 2022",
  "guid": "59cd7a5a-53aa-4ca8-91b4-d76e8feecab1",
  "image_name": "maelstrom.unsafe.x64.exe",
  "image_path": "\\Device\\HarddiskVolume11\\maelstrom\\agent\\stage0\\bin\\maelstrom.unsafe.x64.exe",",
  "parent_procecess": 12652,
  "process_id": 15372
}
```

As with RWX, this detection strategy is reporting a region. So, the structure above is exactly the same. However, this time the `method` has changed in the JSON.

```json
"method": "Memory Allocation without DLL Backing"
```

If we run this scanner across every process on the host, only one region is hit.

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath15.png)Figure 15 Single MZ Header in MEM\_PRIVATE Found

We can verify this by opening Process Hacker and finding the region (`0x00000000001E0000`).

![](https://www.trustedsec.com/wp-content/uploads/2022/10/Mcgrath16.png)Figure 16 MEM\_PRIVATE with MZ Header

Comparing this to the RWX check, this is far more accurate and a much bigger indicator.

## 5.  Conclusion

As far as this goes, tools such as [pe-sieve](https://github.com/hasherezade/pe-sieve) are a lot better at detecting malicious activity with greater detail and are recommended tools if implant development is required. As for EDRs, some of the utility _MAY_ be too performance intensive and aren’t likely to be used—however, attributes of this will be used and are often used as a basis to trigger further queries, rules, or scripts.

Share

- [Share URL](https://www.trustedsec.com/blog/windows-processes-nefarious-anomalies-and-you-memory-regions "Share URL")
- [Share via Email](mailto:?subject=Check%20out%20this%20article%20from%20TrustedSec%21&body=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Memory%20Regions%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions "Share via Email")
- [Share on Facebook](http://www.facebook.com/sharer.php?u=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions "Share on Facebook")
- [Share on X](http://twitter.com/share?text=Windows%20Processes%2C%20Nefarious%20Anomalies%2C%20and%20You%3A%20Memory%20Regions%3A%20https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions "Share on X")
- [Share on LinkedIn](https://www.linkedin.com/shareArticle?url=https%3A%2F%2Ftrustedsec.com%2Fblog%2Fwindows-processes-nefarious-anomalies-and-you-memory-regions&mini=true "Share on LinkedIn")

CloseShow Transcript