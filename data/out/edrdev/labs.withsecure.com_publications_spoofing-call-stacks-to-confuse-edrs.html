# https://labs.withsecure.com/publications/spoofing-call-stacks-to-confuse-edrs

<!DOCTYPE html><html lang="en">
	<body class="page basicpage" data-aos-easing="ease-out-back" data-aos-duration="800" data-aos-delay="0">
		
		



		<!-- Google Tag Manager for withsecure (noscript) -->

<!-- End Google Tag Manager withsecure (noscript) -->

<svg version="1.1" xmlns="http://www.w3.org/2000/svg" style="height: 0; display: block">
	<filter id="f-blue-clouds" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 0.196  0.000  0.000  0.000 0.060
      0.274  0.000  0.000  0.000 0.060
      0.705  0.000  0.000  0.000 0.060
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
	<filter id="f-arctic-mountain" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 0.623  0.000  0.000  0.000  0.000
      0.466  0.000  0.000  0.000  0.000
      0.878  0.000  0.000  0.000  0.000
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
	<filter id="f-sunset" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 1.000  0.000  0.000  0.000  0.000
      0.439  0.000  0.000  0.000  0.000
      0.439  0.000  0.000  0.000  0.000
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
	<filter id="f-grain-fields" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 1.000  0.000  0.000  0.000  0.000
      0.725  0.000  0.000  0.000  0.000
      0.313  0.000  0.000  0.000  0.000
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
	<filter id="f-deep-forest" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 0.549  0.000  0.000  0.000  0.000
      0.705  0.000  0.000  0.000  0.000
      0.298  0.000  0.000  0.000  0.000
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
	<filter id="f-northern-lights" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 0.364  0.000  0.000  0.000  0.000
      0.788  0.000  0.000  0.000  0.000
      0.623  0.000  0.000  0.000  0.000
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
	<filter id="f-blue-clouds-light" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 0.776  0.000  0.000  0.000 0.000
      0.809  0.000  0.000  0.000 0.000
      1.000  0.000  0.000  0.000 0.000
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
	<filter id="f-arctic-mountain-light" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 0.847  0.000  0.000  0.000  0.000
      0.788  0.000  0.000  0.000  0.000
      0.945  0.000  0.000  0.000  0.000
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
	<filter id="f-sunset-light" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 1.000  0.000  0.000  0.000  0.000
      0.847  0.000  0.000  0.000  0.000
      0.847  0.000  0.000  0.000  0.000
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
	<filter id="f-grain-fields-light" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 1.000  0.000  0.000  0.000  0.000
      0.945  0.000  0.000  0.000  0.000
      0.824  0.000  0.000  0.000  0.000
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
	<filter id="f-deep-forest-light" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 0.859  0.000  0.000  0.000  0.000
      0.922  0.000  0.000  0.000  0.000
      0.761  0.000  0.000  0.000  0.000
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
	<filter id="f-northern-lights-light" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
		<feColorMatrix type="matrix" values=" 0.784  0.000  0.000  0.000  0.000
      0.953  0.000  0.000  0.000  0.000
      0.890  0.000  0.000  0.000  0.000
      0.000  0.000  0.000  1.000  0.000"></feColorMatrix>
	</filter>
</svg>



	
		
			<div class="header-ref-black"><div class="cq-dd-paragraph"><div class="businessheader businessHeader parbase section-two">

</div>
</div>
</div>
		
		
			<div class="header-ref-white"><div class="cq-dd-paragraph"><div class="businessheader_copy businessHeader parbase header-white-background">

</div>
</div>
</div>
		
	
	




<div class="container">
	<div class="root responsivegrid">


<div class="aem-Grid aem-Grid--12 aem-Grid--default--12 ">
    
    <div class="businessHeader parbase aem-GridColumn aem-GridColumn--default--12">

</div>
<div class="responsivegrid aem-GridColumn aem-GridColumn--default--12">


<div class="aem-Grid aem-Grid--12 aem-Grid--default--12 ">
    
    <div class="responsivegrid aem-GridColumn aem-GridColumn--default--12">


<div class="aem-Grid aem-Grid--12 aem-Grid--default--12 ">
    
    <div class="responsivegrid main-content aem-GridColumn aem-GridColumn--default--12">


<div class="aem-Grid aem-Grid--12 aem-Grid--default--12 ">
    
    <div class="hero b2b wsbg bc theme-bc aem-GridColumn aem-GridColumn--default--12">
	
	
	
	
	
	
	
	
	
	<div id="hero-1584103665" class="hero b2b wsbg-spot width-full    " role="banner" aria-label="Hero banner: Spoofing Call Stacks To Confuse EDRs">
		<div class="container hero-container">
			<div data-aos-delay="800">
				
				
				<h1 class="title">
					Spoofing Call Stacks To Confuse EDRs
				</h1>
				<p>By William Burgess on 30 June, 2022</p>

				
				
				<div class="btn-wrapper">
					
					
				</div>
			</div>
		</div>
		
		
		
		
	<canvas data-engine="three.js r156" width="1280" height="51" style="display: block; width: 1280px; height: 51.5254px;"></canvas></div>
	

    
</div>
<div class="customContainer parbase aem-GridColumn aem-GridColumn--default--12">






	<div id="container-639790597" class="wsbg-spot container-639790597  image-div">
		
		<div class="custom-container container">
			


<div class="aem-Grid aem-Grid--12 aem-Grid--default--12 aem-Grid--xs--12 authorWidgetParentContainer stickyParent0">
    
    <div class="customContainer parbase aem-GridColumn--default--none aem-GridColumn--offset--xs--0 aem-GridColumn aem-GridColumn--xs--none aem-GridColumn--xs--10 aem-GridColumn--offset--default--0 aem-GridColumn--default--4 authorWidgetContainer0">






	<div id="container-495033642" class="wsbg-spot container-495033642 image-div authorWidget0">
		
		<div class="custom-container container">
			


<div class="aem-Grid aem-Grid--4 aem-Grid--default--4 ">
    
    <div class="responsivegrid aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--4">


<div class="aem-Grid aem-Grid--4 aem-Grid--default--4 aw-smooth">
    
    <div class="authorWidget parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--4 sticky">



<div class="author-widget-wrapper is-sticky">
	
		
		
		<div class="author-widget-section author-widget-navi p-t-0 p-l-0">
			
			
				<div>



<div class="progressbar-content published" id="progressbar-1842030614">
	<div class="progressbar-line " id="progressbar"></div>
	<div class="jump-container container" id="jump-container" style="width: 100%;">
		<div class="jt-tabs-wrapper" style="width: 100%;">
			<div class="jt-left">
				
			</div>
			
			
		</div>
		<div class="jt-menu-toggle invisible" aria-label="Menu" aria-controls="jt-tabs"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 35" width="32" height="35" preserveAspectRatio="xMidYMid meet" style="width: 100%; height: 100%; transform: translate3d(0px, 0px, 0px); content-visibility: visible;"><defs><clipPath id="__lottie_element_19"><rect width="32" height="35" x="0" y="0"></rect></clipPath><clipPath id="__lottie_element_21"><path d="M0,0 L32,0 L32,35 L0,35z"></path></clipPath><clipPath id="__lottie_element_34"><path d="M0,0 L32,0 L32,35 L0,35z"></path></clipPath></defs><g clip-path="url(#__lottie_element_19)"><g clip-path="url(#__lottie_element_34)" transform="matrix(1,0,0,1,0,0)" opacity="1" style="display: block;"><g transform="matrix(1.0321400165557861,0,0,2.4737699031829834,8.321077346801758,15.179876327514648)" opacity="1" style="display: block;"><g opacity="1" transform="matrix(1,0,0,1,-0.03099999949336052,4.5)"><path fill="rgb(0,20,35)" fill-opacity="1" d=" M8.031000137329102,-0.9375 C8.031000137329102,-0.9375 8.031000137329102,0.9375 8.031000137329102,0.9375 C8.031000137329102,0.9375 -8.031000137329102,0.9375 -8.031000137329102,0.9375 C-8.031000137329102,0.9375 -8.031000137329102,-0.9375 -8.031000137329102,-0.9375 C-8.031000137329102,-0.9375 8.031000137329102,-0.9375 8.031000137329102,-0.9375z"></path></g></g><g transform="matrix(-2.490910053253174,0,0,1.932629942893982,14.862268447875977,34.642765045166016)" opacity="1" style="display: block;"><g opacity="1" transform="matrix(1,0,0,1,-3,-4.218999862670898)"><path fill="rgb(0,20,35)" fill-opacity="1" d=" M0.9375,-4.343999862670898 C0.9375,-4.343999862670898 0.9375,4.343999862670898 0.9375,4.343999862670898 C0.9375,4.343999862670898 -0.9375,4.343999862670898 -0.9375,4.343999862670898 C-0.9375,4.343999862670898 -0.9375,-4.343999862670898 -0.9375,-4.343999862670898 C-0.9375,-4.343999862670898 0.9375,-4.343999862670898 0.9375,-4.343999862670898z"></path></g></g><g transform="matrix(0.6116999983787537,0,0,2.466670036315918,27.044418334960938,15.213583946228027)" opacity="1" style="display: block;"><g opacity="1" transform="matrix(1,0,0,1,-0.03099999949336052,4.5)"><path fill="rgb(0,20,35)" fill-opacity="1" d=" M8.031000137329102,-0.9375 C8.031000137329102,-0.9375 8.031000137329102,0.9375 8.031000137329102,0.9375 C8.031000137329102,0.9375 -8.031000137329102,0.9375 -8.031000137329102,0.9375 C-8.031000137329102,0.9375 -8.031000137329102,-0.9375 -8.031000137329102,-0.9375 C-8.031000137329102,-0.9375 8.031000137329102,-0.9375 8.031000137329102,-0.9375z"></path></g></g></g><g clip-path="url(#__lottie_element_21)" transform="matrix(-1,0,0,-1,32,35)" opacity="1" style="display: block;"><g transform="matrix(1.0321400165557861,0,0,2.4737699031829834,8.321077346801758,15.179876327514648)" opacity="1" style="display: block;"><g opacity="1" transform="matrix(1,0,0,1,-0.03099999949336052,4.5)"><path fill="rgb(0,20,35)" fill-opacity="1" d=" M8.031000137329102,-0.9375 C8.031000137329102,-0.9375 8.031000137329102,0.9375 8.031000137329102,0.9375 C8.031000137329102,0.9375 -8.031000137329102,0.9375 -8.031000137329102,0.9375 C-8.031000137329102,0.9375 -8.031000137329102,-0.9375 -8.031000137329102,-0.9375 C-8.031000137329102,-0.9375 8.031000137329102,-0.9375 8.031000137329102,-0.9375z"></path></g></g><g transform="matrix(-2.490910053253174,0,0,1.932629942893982,14.862268447875977,34.642765045166016)" opacity="1" style="display: block;"><g opacity="1" transform="matrix(1,0,0,1,-3,-4.218999862670898)"><path fill="rgb(0,20,35)" fill-opacity="1" d=" M0.9375,-4.343999862670898 C0.9375,-4.343999862670898 0.9375,4.343999862670898 0.9375,4.343999862670898 C0.9375,4.343999862670898 -0.9375,4.343999862670898 -0.9375,4.343999862670898 C-0.9375,4.343999862670898 -0.9375,-4.343999862670898 -0.9375,-4.343999862670898 C-0.9375,-4.343999862670898 0.9375,-4.343999862670898 0.9375,-4.343999862670898z"></path></g></g><g transform="matrix(0.6116999983787537,0,0,2.466670036315918,27.044418334960938,15.213583946228027)" opacity="1" style="display: block;"><g opacity="1" transform="matrix(1,0,0,1,-0.03099999949336052,4.5)"><path fill="rgb(0,20,35)" fill-opacity="1" d=" M8.031000137329102,-0.9375 C8.031000137329102,-0.9375 8.031000137329102,0.9375 8.031000137329102,0.9375 C8.031000137329102,0.9375 -8.031000137329102,0.9375 -8.031000137329102,0.9375 C-8.031000137329102,0.9375 -8.031000137329102,-0.9375 -8.031000137329102,-0.9375 C-8.031000137329102,-0.9375 8.031000137329102,-0.9375 8.031000137329102,-0.9375z"></path></g></g></g></g></svg></div>
	</div>
</div>

    

</div>
			
		</div>
	
	
	<div class="author-widget-section author-widget-details">
		
		
		<h5 class="author-name m-t-0 m-b-2">William Burgess</h5>
		<div class="author-details"><p>30 June,&nbsp; 2022</p>
</div>
	</div>
	<div class="author-widget-section author-widget-share">
		
		
	</div>
</div>

    

</div>

    
</div>
</div>

    
</div>

		</div>
	</div>

</div>
<div class="customContainer parbase aem-GridColumn--xs--newline aem-GridColumn--default--none aem-GridColumn--offset--xs--0 aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0 aem-GridColumn--xs--12">






	<div id="container-1552547863" class="wsbg-spot container-1552547863  image-div">
		
		<div class="custom-container container">
			


<div class="aem-Grid aem-Grid--8 aem-Grid--default--8 ">
    
    <div class="responsivegrid aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0 aw-smooth">


<div class="aem-Grid aem-Grid--8 aem-Grid--default--8 ">
    
    <div class="businessHeader parbase aem-GridColumn aem-GridColumn--default--8">

</div>
<div class="title parbase aem-GridColumn aem-GridColumn--default--8">
	<h3 class="cmp-title__text grey-text">
		Call stacks are an understated yet often important source of telemetry for EDR products. They can provide vital context to an event and be an extremely powerful tool in determining false positives from true positives (especially for credential theft events such as handle access to lsass).
	</h3>

    
</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>&nbsp;An example of this is that attackers will typically reside in-memory via injected code. This unbacked, or floating memory, will show up in call stacks when making API calls and appear highly anomalous.<br>
<br>
There has been some public research on spoofing call stacks (most notably&nbsp;<a href="https://github.com/mgeeky/ThreadStackSpoofer">https://github.com/mgeeky/ThreadStackSpoofer</a>&nbsp;and&nbsp;<a href="https://github.com/Cracked5pider/Ekko">https://github.com/Cracked5pider/Ekko</a>), however these seem largely focused on obscuring the call stack for sleeping threads from AV/EDR detection (i.e. for the&nbsp;<a href="https://www.cobaltstrike.com/blog/sleep-mask-update-in-cobalt-strike-4-5/">Cobalt Strike sleep mask</a>). &nbsp;<br>
<br>
This contrasts with actively tricking an EDR (or ETW provider) to record a fake call stack from a kernel driver for a specific TTP, say opening a handle to lsass in preparation for dumping credentials. This blog post will demonstrate a PoC technique that will enable NtOpenProcess to be called&nbsp;with an arbitrary call stack (i.e. a genuine call stack spoofer).</p>


	
    


</div>

    
</div>
</div>
<div class="responsivegrid aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">


<div class="aem-Grid aem-Grid--8 aem-Grid--default--8 ">
    
    <div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="anchor aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0"><div class="cmp-anchor cmp-anchor--offset" id="part1"></div>

    


</div>
<div class="title parbase aem-GridColumn aem-GridColumn--default--8">
	<h3 class="cmp-title__text grey-text">
		Technical Walkthrough
	</h3>

    
</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>The Windows kernel provides a number of callbacks for AV/EDR drivers to subscribe to in order to receive notifications about system events. For example, this includes process creation/deletion events (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutineex">PsSetCreateProcessNotifyRoutineEx</a>), thread creation/deletion events (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreatethreadnotifyroutine">PsSetCreateThreadNotifyRoutine</a>), and object access (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nc-wdm-pob_pre_operation_callback">ObRegisterCallbacks</a>) etc.<br>
</p>
<p><br>
Many of these callbacks run in the&nbsp;<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/changing-contexts">context</a>&nbsp;of the thread that triggered the action. Hence, when a kernel driver’s process notify routine is called, it is running in the context of the process that triggered the callback (e.g. via calling CreateProcess) and interprets user mode virtual addresses in the context of that user process. Furthermore, the callback will run inline; the operating system is waiting on the callback to return before it can complete the target action of say creating a process or new thread.<br>
<br>
This is demonstrated in the contrived kernel call stack below (obtained from windbg via kernel debugging). This shows a breakpoint set on a custom ObRegisterCallback routine (in this case a process handle operation) which was triggered via Outflank’s&nbsp;<a href="https://github.com/outflanknl/Dumpert">dumpert</a>&nbsp;tool:</p>


	
    


</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="customContainer parbase padding-t-0 padding-b-0 aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">






	<div id="container-4257528494" class="wsbg-spot container-4257528494  image-div">
		
		<div class="custom-container container">
			


<div class="aem-Grid aem-Grid--8 aem-Grid--default--8 ">
    
    <div class="codeBlock parbase aem-GridColumn aem-GridColumn--default--8">
<div>
	<pre><code class="dark hljs language-typescript"><span class="hljs-number dark">1</span>: kd&gt; k
<span class="hljs-number dark">00</span> ffff9387<span class="hljs-string dark">`368011f0 fffff806`</span>2e0a78cc exampleAVDriver!<span class="hljs-title class_ dark">ObjectCallback</span>+<span class="hljs-number dark">0x50</span>
<span class="hljs-number dark">01</span> ffff9387<span class="hljs-string dark">`36801b70 fffff806`</span>2e0a7a3a nt!<span class="hljs-title class_ dark">ObpCallPreOperationCallbacks</span>+<span class="hljs-number dark">0x10c</span>
<span class="hljs-number dark">02</span> ffff9387<span class="hljs-string dark">`36801bf0 fffff806`</span>2e015e13 nt!<span class="hljs-title class_ dark">ObpPreInterceptHandleCreate</span>+<span class="hljs-number dark">0xaa</span>
<span class="hljs-number dark">03</span> ffff9387<span class="hljs-string dark">`36801c60 fffff806`</span>2e086ca9 nt!<span class="hljs-title class_ dark">ObpCreateHandle</span>+<span class="hljs-number dark">0xce3</span>
<span class="hljs-number dark">04</span> ffff9387<span class="hljs-string dark">`36801e70 fffff806`</span>2e09a60f nt!<span class="hljs-title class_ dark">ObOpenObjectByPointer</span>+<span class="hljs-number dark">0x1b9</span>
<span class="hljs-number dark">05</span> ffff9387<span class="hljs-string dark">`368020f0 fffff806`</span>2e0f27b3 nt!<span class="hljs-title class_ dark">PsOpenProcess</span>+<span class="hljs-number dark">0x3af</span>
<span class="hljs-number dark">06</span> ffff9387<span class="hljs-string dark">`36802480 fffff806`</span>2de272b5 nt!<span class="hljs-title class_ dark">NtOpenProcess</span>+<span class="hljs-number dark">0x23</span>
<span class="hljs-number dark">07</span> ffff9387<span class="hljs-string dark">`368024c0 00007ff7`</span>ef821d42 nt!<span class="hljs-title class_ dark">KiSystemServiceCopyEnd</span>+<span class="hljs-number dark">0x25</span>
<span class="hljs-number dark">08</span> 0000000f<span class="hljs-string dark">`f4aff1e8 00007ff7`</span>ef8219b2 <span class="hljs-title class_ dark">Outflank</span>_Dumpert+<span class="hljs-number dark">0x1d42</span>
<span class="hljs-number dark">09</span> 0000000f<span class="hljs-string dark">`f4aff1f0 00007ff7`</span>ef821fb0 <span class="hljs-title class_ dark">Outflank</span>_Dumpert+<span class="hljs-number dark">0x19b2</span>
0a 0000000f<span class="hljs-string dark">`f4aff890 00007ffd`</span>6c317034 <span class="hljs-title class_ dark">Outflank</span>_Dumpert+<span class="hljs-number dark">0x1fb0</span>
0b 0000000f<span class="hljs-string dark">`f4aff8d0 00007ffd`</span>6d862651 <span class="hljs-title class_ dark">KERNEL32</span>!<span class="hljs-title class_ dark">BaseThreadInitThunk</span>+<span class="hljs-number dark">0x14</span>
0c 0000000f<span class="hljs-string dark">`f4aff900 00000000`</span><span class="hljs-number dark">00000000</span> ntdll!<span class="hljs-title class_ dark">RtlUserThreadStart</span>+<span class="hljs-number dark">0x21</span></code></pre>
</div>
</div>

    
</div>

		</div>
	</div>

</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>From this callback, an AV/EDR driver can inspect the object access request and take direct action, such as stripping permission bits from the requested handle if required.&nbsp; Similarly, from a process or thread callback perspective, an AV/EDR can inspect the new process/thread and take preventative action such as blocking it from executing based on some kind of detection logic/heuristic (does the thread point to sketchy memory? etc.).<br>
<br>
Additionally, to support the argument of just how useful call stack collection can be, the example above clearly demonstrates the use of direct system calls as there is no ntdll listed in the call stack prior to nt!KiSystemServiceCopyEnd.<br>
<br>
As a word of caution, the ObjectCallback is&nbsp;<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nc-wdm-pob_pre_operation_callback">not actually guaranteed to run in the context of the thread that triggered the action</a>; it runs in what is called an&nbsp;<a href="https://www.osr.com/blog/2014/09/08/arbitrary-thread-context-article-video/">arbitrary thread context</a>&nbsp;(hence the current context may not be the actual process which triggered the callback). However, it appears you can reliably assume this is the case the majority of the time.</p>
<p>What should be clear from the example above is that one action an AV/EDR can perform inline from a kernel callback is the act of walking the call stack. In fact, this is exactly what SysMon does for process access events (<a href="https://rootdse.org/posts/understanding-sysmon-events/">Event id 10: Process access</a>).</p>
<p>In the screenshot below we can see a Process access event generated by SysMon, which shows svchost obtaining a handle to lsass:</p>


	
    


</div>
<div class="image aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0"><div data-cmp-is="image" data-cmp-widths="480,768,992,1280,1920" data-cmp-src="/adobe/dynamicmedia/deliver/dm-aid--8a131c9e-aced-4776-9530-ca766ff25779/sysmon-generic-lsass-access.png?width={width}&amp;quality=82&amp;preferwebp=true" data-asset-id="8a131c9e-aced-4776-9530-ca766ff25779" data-cmp-filereference="/content/dam/labs/images/sysmon_generic_lsass_access.png" id="image-1cde601b61" data-cmp-hook-image="imageV3" class="cmp-image" itemscope="" itemtype="http://schema.org/ImageObject">
    
        <img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--8a131c9e-aced-4776-9530-ca766ff25779/sysmon-generic-lsass-access.png?quality=82&amp;preferwebp=true" loading="lazy" class="cmp-image__image" itemprop="contentUrl" width="1024" height="595" alt="">
    
    
    
</div>

    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p><span class="small">Figure 1: An example SysMon event for process access where lsass is the target image.</span></p>


	
    


</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>We can see the event contains a ‘CallTrace’ field; this shows the user mode call stack and essentially reveals the chain of events within the process that led to the handle request (albeit without full symbol resolution). This particular event was generated minutes after installing SysMon and occurred at a regular frequency afterwards. Given the call stack does not contain any anomalous memory regions it should be clear this is demonstrably a false positive.<br>
</p>
<p>If we load up the SysMon driver (SysmonDrv.sys) into IDA we can determine how exactly SysMon collects the call stack. The key function to look for is&nbsp;<a href="https://doxygen.reactos.org/d8/d2f/unwind_8c.html#a703c006cc016ffffe4d2982c373711d4">RtlWalkFrameChain</a>&nbsp;and cross reference from there. SysMonDrv registers a callback (ObjectHandleCallback below) for process handle operations and on each invocation will call RtlWalkFrameChain to collect the user mode call stack (via the StackWalkWrapper function):</p>


	
    


</div>
<div class="image aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0"><div data-cmp-is="image" data-cmp-widths="480,768,992,1280,1920" data-cmp-src="/adobe/dynamicmedia/deliver/dm-aid--1510fbeb-5890-4759-a451-aebdece007d2/object-callback-sysmondrv--resizedimagewzewnjgsota3xq.png?width={width}&amp;quality=82&amp;preferwebp=true" data-asset-id="1510fbeb-5890-4759-a451-aebdece007d2" data-cmp-filereference="/content/dam/labs/images/object_callback_sysmondrv__ResizedImageWzEwNjgsOTA3XQ.png" id="image-7c216a04cd" data-cmp-hook-image="imageV3" class="cmp-image" itemscope="" itemtype="http://schema.org/ImageObject">
    
        <img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--1510fbeb-5890-4759-a451-aebdece007d2/object-callback-sysmondrv--resizedimagewzewnjgsota3xq.png?quality=82&amp;preferwebp=true" loading="lazy" class="cmp-image__image" itemprop="contentUrl" width="1024" height="870" alt="">
    
    
    
</div>

    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p><span class="small">Figure 2: The decompilation generated by IDA for SysMonDrv's object call back.</span></p>


	
    


</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>Note that SysMon uses a flag of 1 (‘mov r8d, 1’) in the call to RtlWalkFrameChain to indicate it wants to collect a user mode call stack only.<br>
</p>
<p>RtlWalkFrameChain is exported by ntoskrnl and (at a very high level) works as follows:</p>
<ul><li>Calls&nbsp;<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-rtlcapturecontext">RtlCaptureContext</a>&nbsp;to capture a ContextRecord /&nbsp;<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context">CONTEXT</a>&nbsp;structure of the current thread</li><li>Calls RtlpxVirtualUnwind which will take the CONTEXT structure and start unwinding the stack (based on the current state of execution recorded in the CONTEXT structure e.g. via Rip/Rsp etc.)</li></ul>
<p>An example of the implementation of RtlVirtualUnwind can be found here:&nbsp;<a href="https://github.com/hzqst/unicorn_pe/blob/master/unicorn_pe/except.cpp#L773">https://github.com/hzqst/unicorn_pe/blob/master/unicorn_pe/except.cpp#L773</a>&nbsp;and here:&nbsp;<a href="https://doxygen.reactos.org/d8/d2f/unwind_8c.html#a03c91b6c437066272ebc2c2fff051a4c">https://doxygen.reactos.org/d8/d2f/unwind_8c.html#a03c91b6c437066272ebc2c2fff051a4c</a>.</p>
<p>Furthermore, ETW can also be configured to collect a stack trace (see:&nbsp;<a href="https://github.com/microsoft/krabsetw/pull/191">https://github.com/microsoft/krabsetw/pull/191</a>). This again can be very useful for determining anomalous activity for a number of providers (For example, when applied to the Microsoft TI feed or looking for unbacked wininet calls). As a note, ETW collects the call stack in a slightly different way to the typical inline kernel callback approach demonstrated above. It queues an APC to the target thread first and then calls RtlWalkFrameChain. This is probably due to the fact that some ETW providers execute in an arbitrary thread context.<br>
<br>
A quick look at the implementation of RtlVirtualUnwind reveals the (rather complicated looking) parsing of X64 unwind codes. Therefore, in order to understand how the call stack is walked via RtlVirtualUnwind, it is first necessary to understand a little bit about how code generation/execution works on X64. A full overview is beyond the scope of this blog post, but this excellent CodeMachine blog post contains everything that is needed to fully understand the techniques used in this blog post:&nbsp;<a href="https://codemachine.com/articles/x64_deep_dive.html">https://codemachine.com/articles/x64_deep_dive.html</a>.<br>
<br>
As a brief recap, the CPU has no concept of a function, rather it is a higher level language abstraction. In x86, functions are implemented at the CPU level via using the frame pointer register (Ebp), which can be used as a reference to access local variables and arguments passed via the stack. Through following this chain of Ebp pointers (or function frames) it is possible to find the next stack frame up and hence walk the x86 stack.<br>
<br>
In X64, things are more complicated as Rbp is no longer used as a frame pointer and so, alas, the method used above will not work. The key difference to understand is that X64 executables contain a new section called “.pdata”. This section is essentially a database containing every function in the executable and instructions (known as&nbsp;<a href="https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170">UNWIND_CODE</a>s) as to how to “unwind” a given function in the event of an exception. “Unwind” here essentially means to reverse any operation it performed in its function prologue which modified the stack in some way (e.g. made space for local variables, pushed any non-volatile registers to the stack etc.). On X64, once a function has finished its prologue (and hence stack modifications), it does not modify the stack pointer until its epilogue reverses them, hence Rsp is static throughout the function body.<br>
<br>
Some typical UNWIND_CODEs are:</p>
<ul><li>ALLOC_SMALL/LARGE (allocates a small/large amount of memory for local args e.g. sub rsp, 80h)</li><li>PUSH_NONVOL (pushes a non-volatile register to the stack e.g. push rdi)</li></ul>
<p>In windbg, the '.fnent' command will parse this information for a specified function and display its unwind info, as demonstrated for kernelbase!OpenProcess below:</p>


	
    


</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="codeBlock parbase aem-GridColumn aem-GridColumn--default--8">
<div>
	<pre><code class="dark hljs language-makefile"><span class="hljs-section dark">0:000&gt; .fnent kernelbase!OpenProcess</span>
Debugger function entry 000001e2`92241720 for:
(00007ff8`7a3bc0f0) KERNELBASE!OpenProcess | (00007ff8`7a3bc170) KERNELBASE!SetWaitableTimer
Exact matches:
BeginAddress = 00000000`0002c0f0
EndAddress = 00000000`0002c160
UnwindInfoAddress = 00000000`00266838

Unwind info at 00007ff8`7a5f6838, 6 bytes
version 1, flags 0, prolog 7, codes 1
<span class="hljs-section dark">00: offs 7, unwind op 2, op info c UWOP_ALLOC_SMALL.</span></code></pre>
</div>
</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>This shows that OpenProcess only has one unwind code, which is that it allocates a small area of memory on the stack. The total size of ‘UWOP_ALLOC_SMALL’ is calculated by multiplying the op info value by 8 and adding 8 (0xc * 8 + 8 =0x68). This can be confirmed by disassembling the first few bytes of kernelbase!OpenProcess (sub rsp, 68h):</p>


	
    


</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="codeBlock parbase aem-GridColumn aem-GridColumn--default--8">
<div>
	<pre><code class="dark hljs language-makefile"><span class="hljs-section dark">0:000&gt; uf kernelbase!OpenProcess</span>
<span class="hljs-section dark">KERNELBASE!OpenProcess:</span>
00007ff8`7a3bc0f0 4c8bdc mov r11,rsp
00007ff8`7a3bc0f3 4883ec68 sub rsp,68h</code></pre>
</div>
</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>A documented list of all the available UNWIND_CODES (and how to parse them) can be found here:&nbsp;<a href="https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170">https://docs.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-170</a><br>
<br>
In order to walk the stack, windbg will calculate the total stack size for each function found by adding up the size of:</p>
<ul><li>any local variables</li><li>any stack based parameters</li><li>the return address (8 bytes)</li><li>homing space</li><li>stack space taken up by non-volatile registers</li></ul>
<p>If we take a call to OpenProcess as an example:</p>


	
    


</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="customContainer parbase padding-t-0 padding-b-0 aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">






	<div id="container-4220528227" class="wsbg-spot container-4220528227  image-div">
		
		<div class="custom-container container">
			


<div class="aem-Grid aem-Grid--8 aem-Grid--default--8 ">
    
    <div class="codeBlock parbase aem-GridColumn aem-GridColumn--default--8">
<div>
	<pre><code class="dark hljs language-r"><span class="hljs-number dark">0</span><span class="hljs-operator dark">:</span><span class="hljs-number dark">000</span><span class="hljs-operator dark">&gt;</span> knf
<span class="hljs-comment dark"># Memory Child-SP RetAddr Call Site</span>
<span class="hljs-number dark">00</span> <span class="hljs-number dark">000000</span>df`<span class="hljs-number dark">7</span>d8fef88 <span class="hljs-number dark">00007</span>ffd`b1bdc13e ntdll!NtOpenProcess
01 8 000000df`7d8fef90 <span class="hljs-number dark">00007</span>ff7`f10c087d KERNELBASE!OpenProcess+0x4e
02 70 000000df`7d8ff000 <span class="hljs-number dark">00007</span>ff7`f10c24b9 VulcanRaven!main+0x5d [C:\Users\wb\source\repos\VulcanRaven\VulcanRaven\VulcanRaven.cpp @ 641]
03 9e0 000000df`7d8ff9e0 <span class="hljs-number dark">00007</span>ff7`f10c239e VulcanRaven!invoke_main+0x39 [d:\a01\_work\43\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl @ 79]
04 50 000000df`7d8ffa30 <span class="hljs-number dark">00007</span>ff7`f10c225e VulcanRaven!__scrt_common_main_seh+0x12e [d:\a01\_work\43\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl @ 288]
05 70 000000df`7d8ffaa0 <span class="hljs-number dark">00007</span>ff7`f10c254e VulcanRaven!__scrt_common_main+0xe [d:\a01\_work\43\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl @ 331]
06 30 000000df`7d8ffad0 <span class="hljs-number dark">00007</span>ffd`b2237034 VulcanRaven!mainCRTStartup+0xe [d:\a01\_work\43\s\src\vctools\crt\vcstartup\src\startup\exe_main.cpp @ 17]
07 30 000000df`7d8ffb00 <span class="hljs-number dark">00007</span>ffd`b3e82651 KERNEL32!BaseThreadInitThunk+0x14
08 30 000000df`7d8ffb30 <span class="hljs-number dark">00000000</span>`<span class="hljs-number dark">00000000</span> ntdll<span class="hljs-operator dark">!</span>RtlUserThreadStart<span class="hljs-operator dark">+</span><span class="hljs-number dark">0x21</span></code></pre>
</div>
</div>

    
</div>

		</div>
	</div>

</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>The top entry, ntdll!NtOpenProcess (#00), is the current stack frame. The Child-SP value of 000000df`7d8fef88 is the value of Rsp after NtOpenProcess has finished its function prologue (i.e. the value of the stack pointer after any stack modifications NtOpenProcess needs to make have been performed). &nbsp;The value of 8 in the ‘Memory’ column in the row below the current frame is the total stack size used by NtOpenProcess. Therefore, in order to calculate the Child-SP of the next frame, we can add the total stack size of the current frame (8) to the current Child-SP:</p>


	
    


</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="codeBlock parbase aem-GridColumn aem-GridColumn--default--8">
<div>
	<pre><code class="dark hljs language-typescript"><span class="hljs-number dark">0</span>:<span class="hljs-number dark">000</span>&gt; ? 000000df<span class="hljs-string dark">`7d8fef88 + 8
Evaluate expression: 959884291984 = 000000df`</span>7d8fef90</code></pre>
</div>
</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>Note that NtOpenProcess has no unwind op codes (it doesn't modify the stack) so the next Child-SP is simply found by skipping the return address pushed by the previous caller (KERNELBASE!OpenProcess). This is why its total stack size is listed as 8 bytes (e.g. the return address only).<br>
<br>
This new Child-SP (000000df`7d8fef90) is the value of Rsp after KERNELBASE!OpenProcess has finished its function prologue. When KERNELBASE!OpenProcess calls ntdll!NtOpenProcess it will push its ret address on to the stack; therefore this return address will be the&nbsp;next value on the stack immediately after where its Child-SP points, as shown by Child-SP 01 in Figure 3.<br>
<br>
This process can be repeated again for the next frame. Kernelbase!OpenProcess has a Child-SP of 000000df`7d8fef90 and its total stack utilisation is 0x70 bytes. Once again if we add them together we can get the next Child-SP for VulcanRaven!main:</p>


	
    


</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="codeBlock parbase aem-GridColumn aem-GridColumn--default--8">
<div>
	<pre><code class="dark hljs language-typescript"><span class="hljs-number dark">0</span>:<span class="hljs-number dark">000</span>&gt; ? 000000df<span class="hljs-string dark">`7d8fef90 + 70
Evaluate expression: 959884292096 = 000000df`</span>7d8ff000</code></pre>
</div>
</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>This process is repeated until the debugger has completely walked the stack. Therefore, at a high level the stack walking process looks like this:</p>


	
    


</div>
<div class="image aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0"><div data-cmp-is="image" data-cmp-widths="480,768,992,1280,1920" data-cmp-src="/adobe/dynamicmedia/deliver/dm-aid--c1d5a3c5-3137-477d-8def-bc9ae7dac4f1/call-stack-walking-example--resizedimagewzgwmcw0ntzd.png?width={width}&amp;quality=82&amp;preferwebp=true" data-asset-id="c1d5a3c5-3137-477d-8def-bc9ae7dac4f1" data-cmp-filereference="/content/dam/labs/images/call_stack_walking_example__ResizedImageWzgwMCw0NTZd.png" id="image-976f578cf8" data-cmp-hook-image="imageV3" class="cmp-image" itemscope="" itemtype="http://schema.org/ImageObject">
    
        <img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--c1d5a3c5-3137-477d-8def-bc9ae7dac4f1/call-stack-walking-example--resizedimagewzgwmcw0ntzd.png?quality=82&amp;preferwebp=true" loading="lazy" class="cmp-image__image" itemprop="contentUrl" width="800" height="456" alt="">
    
    
    
</div>

    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p><span class="small">Figure 3: A diagram showing the stack walking process for X64.</span></p>


	
    


</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>The key take away relevant to this blog post is that by knowing the total stack size of a function, it is possible (without symbols) to follow this chain of child stack pointers and walk a call stack. This process will be mimicked in reverse when it comes to spoofing call stacks.<br>
<br>
Having discussed the usefulness of call stack telemetry and given a brief overview of how unwinding call stacks works on x64, we can now pivot to the question this blog post addresses: is it possible to spoof a call stack so that when this collection takes place inline (say from within a kernel driver callback routine) a fake call stack is recorded?</p>


	
    


</div>

    
</div>
</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="responsivegrid aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">


<div class="aem-Grid aem-Grid--8 aem-Grid--default--8 ">
    
    <div class="anchor aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0"><div class="cmp-anchor cmp-anchor--offset" id="part2"></div>

    


</div>
<div class="title parbase aem-GridColumn aem-GridColumn--default--8">
	<h3 class="cmp-title__text grey-text">
		Approach
	</h3>

    
</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>The PoC in this blog post takes the following approach:</p>
<p>1. Identify a target call stack to spoof. For this SysMon was used and an arbitrary entry for event type 10 that opened a handle to lsass was chosen e.g. the example below:</p>


	
    


</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="codeBlock parbase aem-GridColumn aem-GridColumn--default--8">
<div>
	<pre><code class="dark hljs language-makefile"><span class="hljs-section dark">CallTrace:</span>
<span class="hljs-section dark">C:\Windows\SYSTEM32\ntdll.dll + 9d204 (ntdll!NtOpenProcess)</span>
<span class="hljs-section dark">C:\Windows\System32\KERNELBASE.dll + 32ea6 (KERNELBASE!OpenProcess)</span>
<span class="hljs-section dark">C:\Windows\System32\lsm.dll + e959</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + 79633</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + 13711</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + dd77b</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + 5d2ac</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + 5a408</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + 3a266</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + 39bb8</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + 48a0f</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + 47e18</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + 47401</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + 46e6e</span>
<span class="hljs-section dark">C:\Windows\System32\RPCRT4.dll + 4b542</span>
<span class="hljs-section dark">C:\Windows\SYSTEM32\ntdll.dll + 20330</span>
<span class="hljs-section dark">C:\Windows\SYSTEM32\ntdll.dll + 52f26</span>
<span class="hljs-section dark">C:\Windows\System32\KERNEL32.DLL + 17034</span>
<span class="hljs-section dark">C:\Windows\SYSTEM32\ntdll.dll + 52651</span></code></pre>
</div>
</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>2.&nbsp;For each return address in the target call stack above, parse its unwind codes and calculate the total stack space required so we can locate the next childSP frame.</p>
<p>3.&nbsp;Create a suspended thread and modify the CONTEXT structure so that the stack/rsp fits the&nbsp;<b>exact</b>&nbsp;outline of the target call stack to spoof (without any of the actual data being there). Hence we are initialising the thread’s state to “fit the profile” of another thread by pushing fake return addresses and subtracting correct child-SP offsets (e.g. stack unwinding in reverse). Care needs to be taken when handling certain unwind codes (UWOP_SET_FPREG) as this will reset rsp == rbp.</p>
<p>4.&nbsp;Modify the CONTEXT structure so that Rip points to our target function (ntdll!NtOpenProcess in this case) and set the appropriate arguments required by the&nbsp;<a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 calling convention</a>&nbsp;(e.g. via setting Rcx/Rdx/R8/R9).</p>
<p>5. Resume the thread and handle the inevitable error once the sys call returns (as it is returning up a fake call stack) via a vectored exception handler. From this exception handler, we can re-direct the thread to RtlExitUserThread (via re-setting Rip)&nbsp; and let it gracefully exit.</p>


	
    


</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>For 5), this approach is an obvious limitation; a better approach would be to use VEH exception handling with either hardware or software breakpoints in a similar manner to this patchless AMSI bypass:&nbsp;<a href="https://gist.github.com/CCob/fe3b63d80890fafeca982f76c8a3efdf">https://gist.github.com/CCob/fe3b63d80890fafeca982f76c8a3efdf</a>.<br>
<br>
With this approach, we could place a breakpoint on the ret immediately after the NtOpenProcess sys call (00007ff8`7ca6d204 below) has returned:</p>


	
    


</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="codeBlock parbase aem-GridColumn aem-GridColumn--default--8">
<div>
	<pre><code class="dark hljs language-typescript"><span class="hljs-number dark">0</span>:<span class="hljs-number dark">000</span>&gt; uf ntdll!<span class="hljs-title class_ dark">NtOpenProcess</span>
ntdll!<span class="hljs-title class_ dark">NtOpenProcess</span>:
00007ff8<span class="hljs-string dark">`7ca6d1f0 4c8bd1 mov r10,rcx
00007ff8`</span>7ca6d1f3 b826000000 mov eax,26h
00007ff8<span class="hljs-string dark">`7ca6d1f8 f604250803fe7f01 test byte ptr [SharedUserData+0x308 (00000000`</span>7ffe0308)],<span class="hljs-number dark">1</span>
00007ff8<span class="hljs-string dark">`7ca6d200 7503 jne ntdll!NtOpenProcess+0x15 (00007ff8`</span>7ca6d205) <span class="hljs-title class_ dark">Branch</span>
ntdll!<span class="hljs-title class_ dark">NtOpenProcess</span>+<span class="hljs-number dark">0x12</span>:
00007ff8<span class="hljs-string dark">`7ca6d202 0f05 syscall
00007ff8`</span>7ca6d204 c3 ret</code></pre>
</div>
</div>
<div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>Once a breakpoint exception is generated (and before the thread returns and crashes) we could handle the error in the same way as discussed previously. Additionally, recovering the state of the fake thread and being able to re-use it would be an improvement and stop the need to repeatedly create “sacrificial threads”.<br>
<br>
Furthermore, this approach could also potentially be applied to the sleeping obfuscation problem; a fake thread with a legitimate call stack could be initialised to call ntdll!NtDelayExecution (or WaitForSingleObject etc.) and VEH exceptions used to re-direct flow to a main beacon function on return of the sleep duration.</p>


	
    


</div>

    
</div>
</div>
<div class="responsivegrid aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">


<div class="aem-Grid aem-Grid--8 aem-Grid--default--8 ">
    
    <div class="space aem-GridColumn aem-GridColumn--default--8">
	<div class="cmp-space  "></div>


    

</div>
<div class="anchor aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0"><div class="cmp-anchor cmp-anchor--offset" id="part3"></div>

    


</div>
<div class="title parbase aem-GridColumn aem-GridColumn--default--8">
	<h3 class="cmp-title__text grey-text">
		PoC || GTFO
	</h3>

    
</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>The PoC code can be found here:&nbsp;<a href="https://github.com/countercept/CallStackSpoofer">https://github.com/countercept/CallStackSpoofer</a><br>
<br>
The PoC comes with three example call stacks (wmi/rpc/svchost) to mimic, all of which were taken arbitrarily from SysMon logs via observing process handle access to lsass. These call stack profiles can be selected via the '–wmi', '--rpc', and '–svchost' flags, as demonstrated below:</p>


	
    


</div>
<div class="image aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0"><div data-cmp-is="image" data-cmp-widths="480,768,992,1280,1920" data-cmp-src="/adobe/dynamicmedia/deliver/dm-aid--89414471-f36d-4079-ac09-c2a7771027e4/vulcan-raven-example.png?width={width}&amp;quality=82&amp;preferwebp=true" data-asset-id="89414471-f36d-4079-ac09-c2a7771027e4" data-cmp-filereference="/content/dam/labs/images/vulcan_raven_example.png" id="image-19d0773457" data-cmp-hook-image="imageV3" class="cmp-image" itemscope="" itemtype="http://schema.org/ImageObject">
    
        <img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--89414471-f36d-4079-ac09-c2a7771027e4/vulcan-raven-example.png?quality=82&amp;preferwebp=true" loading="lazy" class="cmp-image__image" itemprop="contentUrl" width="1024" height="1028" alt="">
    
    
    
</div>

    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p><span class="small">Figure 4: A screenshot showing VulcanRaven grabbing a handle to lsass and spoofing the call stack to look like RPC activity.</span></p>


	
    


</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>The screenshot above demonstrates a fake call stack being recorded by SysMon (contrast this to the expected use of OpenProcess which would have a call stack of: VulcanRaven.exe -&gt; kernelbase!OpenProcess -&gt; ntdll!NtOpenProcess). Just to stress, the examples in this PoC were chosen to mimic events found via SysMon but the call stack does not have to make sense and can be anything, as demonstrated below:</p>


	
    


</div>
<div class="image aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0"><div data-cmp-is="image" data-cmp-widths="480,768,992,1280,1920" data-cmp-src="/adobe/dynamicmedia/deliver/dm-aid--dbb0da97-ac3b-4877-a6dc-acf5f03813f7/nonsense-call-stack-example.png?width={width}&amp;quality=82&amp;preferwebp=true" data-asset-id="dbb0da97-ac3b-4877-a6dc-acf5f03813f7" data-cmp-filereference="/content/dam/labs/images/nonsense_call_stack_example.png" id="image-128330f144" data-cmp-hook-image="imageV3" class="cmp-image" itemscope="" itemtype="http://schema.org/ImageObject">
    
        <img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--dbb0da97-ac3b-4877-a6dc-acf5f03813f7/nonsense-call-stack-example.png?quality=82&amp;preferwebp=true" loading="lazy" class="cmp-image__image" itemprop="contentUrl" width="1024" height="791" alt="">
    
    
    
</div>

    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p><span class="small">Figure 5: A screenshot from WinDbg showing a completely nonsensical call stack being spoofed when calling NtOpenProcess.</span></p>


	
    


</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>The most obvious example of why this technique would be of interest to an attacker is that most remote access trojans (beacon etc.) still tend to operate off floating / unbacked memory. Thus, when an attacker injects mimikatz directly into memory, the call stack for the subsequent handle access from this injected code will look highly anomalous.<br>
<br>
As an example, a SysMon event is shown below for unbacked memory calling OpenProcess:</p>


	
    


</div>
<div class="image aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0"><div data-cmp-is="image" data-cmp-widths="480,768,992,1280,1920" data-cmp-src="/adobe/dynamicmedia/deliver/dm-aid--8745809b-c509-4b54-a820-e864b0a074dc/sysmon-unbacked-lsass-access.png?width={width}&amp;quality=82&amp;preferwebp=true" data-asset-id="8745809b-c509-4b54-a820-e864b0a074dc" data-cmp-filereference="/content/dam/labs/images/sysmon_unbacked_lsass_access.png" id="image-82e0f8cfff" data-cmp-hook-image="imageV3" class="cmp-image" itemscope="" itemtype="http://schema.org/ImageObject">
    
        <img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--8745809b-c509-4b54-a820-e864b0a074dc/sysmon-unbacked-lsass-access.png?quality=82&amp;preferwebp=true" loading="lazy" class="cmp-image__image" itemprop="contentUrl" width="975" height="414" alt="">
    
    
    
</div>

    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p><span class="small">Figure 6: A SysMon event showing handle access to lsass originating from unbacked memory.</span></p>


	
    


</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>This was generated via using a modified version of Stephen Fewer’s ReflectiveDLLInjection&nbsp;<a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a>&nbsp;codebase.<br>
<br>
In this example, a reflective DLL has been injected into cmd.exe and subsequently obtained a handle to lsass with PROCESS_ALL_ACCESS access. As the call originated from unbacked memory, SysMon records the last entry in the call stack as “UNKNOWN” (e.g. the last return address in the stack walk belonged to floating/unbacked code and not a legitimately loaded module) and hence is obviously suspicious.<br>
<br>
However, if we modify the VulcanRaven PoC above to run as a reflective DLL, we generate the following event:</p>


	
    


</div>
<div class="image aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0"><div data-cmp-is="image" data-cmp-widths="480,768,992,1280,1920" data-cmp-src="/adobe/dynamicmedia/deliver/dm-aid--9bc36065-61de-4176-b009-32985a420f89/3-sysmon-spoofed-unbacked-lsass-access.png?width={width}&amp;quality=82&amp;preferwebp=true" data-asset-id="9bc36065-61de-4176-b009-32985a420f89" data-cmp-filereference="/content/dam/labs/images/3_sysmon_spoofed_unbacked_lsass_access.png" id="image-233b40010b" data-cmp-hook-image="imageV3" class="cmp-image" itemscope="" itemtype="http://schema.org/ImageObject">
    
        <img src="https://labs.withsecure.com/adobe/dynamicmedia/deliver/dm-aid--9bc36065-61de-4176-b009-32985a420f89/3-sysmon-spoofed-unbacked-lsass-access.png?quality=82&amp;preferwebp=true" loading="lazy" class="cmp-image__image" itemprop="contentUrl" width="1024" height="898" alt="">
    
    
    
</div>

    

</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p><span class="small">Figure 7: A screenshot showing Vulcan Raven modified to run as reflective DLL. Even though it is running from unbacked memory, the call stack for handle access to lsass is still spoofed to look legimate</span></p>


	
    


</div>
<div class="businessRichtext parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--default--8 aem-GridColumn--offset--default--0">
	<p>The call stack (“CallTrace”) is spoofed to an arbitrary value pulled from SysMon as expected; it is impossible to tell from this call stack that the call to NtOpenProcess/OpenProcess actually originated from code running from unbacked memory, and the thread on the surface looks genuine (although the cmd.exe is contrived and obviously suspicious). Also note the different GrantedAccess to Figure 1, which in this case is PROCESS_ALL_ACCESS/0x1FFFFF.<br>
<br>
It is clear though that an attacker could profile their chosen call stack to blend in with their chosen injected process (wmi, procexp, svchost etc. all regularly grab handles to lsass).</p>


	
    


</div>

    
</div>
</div>

    
</div>

		</div>
	</div>

</div>

    
</div>

		</div>
	</div>

</div>

    
</div>
</div>

    
</div>
</div>

    
</div>
</div>

    
</div>
</div>

</div>






		
	
	
    





	
	
		
    









	
		
    







	
		
    




	
		
    









	
		
    



	
		
    




	
		
    



	
		
    



	
		
    





	
		
    




	

	
	
	


	


		

	

</body></html>