Title:
Gotta Catch ‘Em all! Catching Your Favorite C2 In Memory Using Stack & Thread Telemetry

Type:
Blog Post

Short Summary (4–8 sentences max):
- The post describes detecting in-memory C2 agents by continuously tracing thread call stacks and thread metadata to spot artifacts of stack spoofing/sleep obfuscation.  
- It introduces a custom “stack tracer” that monitors newly spawned processes, resolves symbols/modules for each stack frame (RIP/EIP + return addresses), and compares this against the thread start address.  
- Two primary anomaly classes are highlighted: abruptly truncated stacks (missing typical unwind frames like `RtlThreadStart`/`BaseThreadInitThunk`) and thread start addresses that do not appear anywhere in the observed stack trace.  
- The author demonstrates these indicators against multiple real-world offensive frameworks, showing how “out-of-the-box” evasion can produce inconsistent or invalid frames, non-module-backed addresses, and misleading start-address reporting depending on API/symbol resolution.  
- It also covers “too perfect” stack replacement (e.g., CallStackMasker) and how mismatches between the reported start address and stack frames remain detectable.  
- Finally, it analyzes Havoc Demon’s NtTib/TEB swapping approach and proposes detecting it by monitoring thread `StackBase` fluctuations over time.  
- Useful for detection engineers/blue teams building telemetry-based detections, and for red teams to understand what their stack spoofing implementations leak.

Technical Focus:
- Windows thread call stack walking and symbol/module resolution
- Stack spoofing / call stack masking artifacts and invariants
- Thread start address sources (`NtQueryInformationThread` vs `NtQuerySystemInformation`)
- TEB/NtTib manipulation and sleep obfuscation
- Detection via stack truncation, invalid return addresses, and non-image-backed frames
- Monitoring thread stack boundaries (`StackBase`) for anomalies

Use Cases:
- Build EDR/DFIR detections for in-memory C2 beacons using stack/thread telemetry
- Hunt for suspicious threads with non-module-backed start addresses or frames
- Validate whether stack spoofing implementations are internally consistent
- Detect TEB/NtTib swap-based sleep obfuscation by tracking `StackBase` changes
- Compare tooling output differences (Process Explorer vs Process Hacker vs custom tracers)

Keywords:
Windows, call stack, stack walking, stack spoofing, call stack masking, sleep obfuscation, thread telemetry, TEB, NtTib, StackBase, RtlThreadStart, BaseThreadInitThunk, RtlUserThreadStart, NtQueryInformationThread, ThreadQuerySetWin32StartAddress, NtQuerySystemInformation, SYSTEM_PROCESS_INFORMATION, Process Hacker, Process Explorer, WININET, HttpSendRequestA, Havoc Demon, Cobalt Strike, CallStackMasker, in-memory C2 detection