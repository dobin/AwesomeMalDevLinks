# https://n4r1b.com/posts/2020/02/dissecting-the-windows-defender-driver-wdfilter-part-2/

<!DOCTYPE html><html lang="en" data-theme="light"><body><div class="container"><div class="content"><main class="post"><div class="post-info"><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><path d="M12 6v6l4 2"></path></svg>19 minutes</p></div><article><h1 class="post-title"><a href="https://n4r1b.com/posts/2020/02/dissecting-the-windows-defender-driver-wdfilter-part-2/">Dissecting the Windows Defender Driver - WdFilter (Part 2)</a></h1><div class="post-excerpt">In this series of posts I'll be explaining how the Windows Defender main Driver works, in this second post we will look into Image loading and Thread creation notifications among other things</div><div class="post-content"><p>Welcome back to Dissecting the Windows Defender Driver, in the previous part we saw how <strong>WdFilter</strong> gets initialized and how it handles the process creation throughout a process-creation callback. We also saw the <strong>ProcessCtx</strong> structure which will be used all over the driver to keep track of the different process running on the system. And now for this part, we will focus on the following things:</p><ul><li>Image loading callback</li><li>Thread creation callback</li><li>Sending Sync/Async notifications</li></ul><blockquote><p><strong>Disclaimer:</strong> The callbacks I‚Äôll explain in this post rely mainly on <code>ProcessCtx.ProcessRules</code> and as much as I‚Äôve tried with different type of process (Even malware) I haven‚Äôt been able to determine to what type of process corresponds each rule (Maybe it has to do with the Windows Defender configuration)</p><p>I deeply apologize for not having this info, hopefully once I get further into the driver I will discover more about the different rules. Just for demonstration purpose, I‚Äôve forced the code to follow different paths.</p></blockquote><p>And after that disclaimer, let‚Äôs get into it!</p><h3 id="mpcreatethreadnotifyroutineex-mpcreatethreadnotifyroutine">MpCreateThreadNotifyRoutineEx - MpCreateThreadNotifyRoutine</h3><p>The first two callbacks we will look are <code>MpCreateThreadNotifyRoutine</code> and <code>MpCreateThreadNotifyRoutineEx</code>, both of them are notified whenever a new thread is created or a thread is deleted. There‚Äôs two different callbacks because the first one is registered using <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreatethreadnotifyroutine" target="_blank">PsSetCreateThreadNotifyRoutine</a> while the second one is registered using <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreatethreadnotifyroutineex" target="_blank">PsSetCreateThreadNotifyRoutineEx</a>, this function is available starting from Windows 10, and a pointer to it is saved in <strong>MpData</strong>, of course if the pointer is <code>NULL</code> this second callback won‚Äôt be registered.</p><blockquote><p>As explained on the remark section from <code>PsSetCreateThreadNotifyRoutineEx</code> documentation this two functions differ in the context in which the callback is executed quoting MS documentation: <em>‚ÄúWith PsSetCreateThreadNotifyRoutine, the callback is executed on the creator thread. With PsSetCreateThreadNotifyRoutineEx, the callback is executed on the newly created thread.‚Äù</em></p></blockquote><h4 id="mpcreatethreadnotifyroutine">MpCreateThreadNotifyRoutine</h4><p>The code of the callbacks differ more than what you may expect, so we will study both. Starting with <code>MpCreateThreadNotifyRoutine</code> ‚Äì Keep in mind this callback is executed in the context of the creator thread ‚Äì this callback will check the following three things in order to execute:</p><ul><li>Create parameter is set to <code>TRUE</code></li><li>ProcessId is different than <code>0x4</code> (System)</li><li>Curren thread is not a system thread ‚Äì <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-psissystemthread" target="_blank">!PsIsSystemThread</a></li></ul><p>In case this three conditions are met, the code will proceed to set a flag that indicates if the current process is the same as the one from the parameter ProcessId.</p><blockquote><p>A process could be creating a thread in another process, and since this callback executes in the context of the creator thread the current process would be the creator while the parameter ProcessId would be the one where the thread is going to execute.</p></blockquote><p>If they are the same then the current process <code>ProcessCtx.ProcessRules</code> will be tested against rule <strong>NotifyNewThreadSameProcess</strong> (<code>0x10000000</code>) and a flag will be set accordingly. In case the current process is not the same then the <code>ProcessRules</code> will be tested against rule <strong>NotifyNewThreadDifferentProcess</strong> (<code>0x400000</code>) and other flag will be set accordingly. If none of these flags is set then the callback will return ‚Äì The following pseudocode shows this behavior in case my explanation is not clear enough</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">BOOLEAN SameProcess <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>;
BOOLEAN NotifyNewThreadSameProcFlag <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
BOOLEAN NotifyNewThreadDiffProcFlag <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;

<span style="color:#ff79c6">if</span> ( Create <span style="color:#ff79c6">&amp;&amp;</span> ProcessId <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">4</span> <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>PsIsSystemThread(KeGetCurrentThread()) ) {

    SameProcess <span style="color:#ff79c6">=</span> ProcessId <span style="color:#ff79c6">==</span> PsGetCurrentProcessId();
    <span style="color:#6272a4">// Retrieve the ProcessCtx by the ProcessId
</span><span style="color:#6272a4"></span>    MpGetProcessContextById(PsGetCurrentProcessId(), <span style="color:#ff79c6">&amp;</span>CurrentProcessCtx);

    <span style="color:#ff79c6">if</span> ( SameProcess <span style="color:#ff79c6">&amp;&amp;</span> CurrentProcessCtx<span style="color:#ff79c6">-&gt;</span>ProcessRules <span style="color:#ff79c6">&amp;</span> NotifyNewThreadSameProcess ) 
        NotifyNewThreadSameProcFlag <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>;
    <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>SameProcess <span style="color:#ff79c6">&amp;&amp;</span> CurrentProcessCtx<span style="color:#ff79c6">-&gt;</span>ProcessRules <span style="color:#ff79c6">&amp;</span> NotifyNewThreadDifferentProcess )
        NotifyNewThreadDiffProcFlag <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>;

    <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>NotifyNewThreadSameProcFlag <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">!</span>NotifyNewThreadDiffProcFlag )
        <span style="color:#ff79c6">goto</span> Cleanup;
}</code></pre></div><p>In case one of the flags is set the code will proceed to obtain the structure I called <code>AuxPidCreationTime</code> ‚Äì We saw in part 1, but as a remainder it contains de PID and the CreationTime of the process ‚Äì after it has this structure for both process (Is obtained two times even if is the same process) the code will proceed to call <code>MpGetPriorityInfo</code>, this function will mainly call <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltretrieveiopriorityinfo" target="_blank">FltRetrieveIoPriorityInfo</a> to get the <code>IO_PRIORITY_INFO</code> of the current thread and use this data to fill a structure I coined <code>MP_IO_PRIORITY</code>:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_IO_PRIORITY
{
    IO_PRIORITY_HINT IoPriority
    ULONG ThreadPriority  
    ULONG PagePriority    
} MP_IO_PRIORITY, <span style="color:#ff79c6">*</span>PMP_IO_PRIORITY;</code></pre></div><p>Different messages will be send to <strong>MsMpEng</strong> depending on the flag that was set. In the case of <strong>NotifyNewThreadDifferentProcess</strong>, <code>MpSendSyncMonitorNotification</code> will be called with <em>OperationType</em> equal to <strong>NewThreadDifferentProcess</strong> (<code>0x3</code>) and the <em>Data</em> will be the <code>AuxPidCreationTime</code> from the process that will execute the thread.</p><p><img src="https://n4r1b.com/images/wdFilter/part2/NewThreadDifferentProcess.png" alt="alt image" title="Notify new thread different process" class="medium-zoom-image"></p><p>In the case the thread is being created in the same process, before calling <code>MpSendSyncMonitorNotification</code> the data that to send will be initialized, function <code>MpCreatePsThreadSyncMonitorData</code> is in charge of doing this. This function will basically fill the following structure:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _ThreadNotifySyncMessage
{
  AuxTidCreationTime CreatedThread;
  AuxTidCreationTime CurrentThread;
  AuxPidCreationTime Process;
  INT64 Unk;
  PVOID ThreadStartAddress;
} ThreadNotifySyncMessage, <span style="color:#ff79c6">*</span>PThreadNotifySyncMessage;</code></pre></div><p>to get the value of the <strong>ThreadStartAddress</strong> it will open obtain a handle to the thread (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-pslookupthreadbythreadid" target="_blank">PsLookupThreadByThreadId</a>) and then using this handle it will call <a href="https://docs.microsoft.com/en-us/previous-versions/windows/hardware/drivers/mt629133(v%3Dvs.85)" target="_blank">ZwQueryInformationThread</a> with class <strong>ThreadQuerySetWin32StartAddress</strong>. Once <code>ThreadNotifySyncMessage</code> is filled, function <code>MpSendSyncMonitorNotification</code> will be called with this structure as the <em>Data</em> and <em>OperationType</em> equal to <strong>NewThreadSameProcess</strong> (<code>0x6</code>)</p><p><img src="https://n4r1b.com/images/wdFilter/part2/NewThreadSameProcess.png" alt="alt image" title="Notify new thread same process" class="medium-zoom-image"></p><p>Lastly if <strong>NotifyNewThreadDifferentProcess</strong> is set the callback will execute one last step. This step will consist on sending an async notification with the following data</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _ThreadNotifyMessage
{
  AuxPidCreationTime CurrentProcess;
  INT CurrentThreadId;
  AuxPidCreationTime CreatedThreadProcess;
  AuxTidCreationTime CreatedThread;
  WCHAR <span style="color:#ff79c6">*</span>ImageFileName;
} ThreadNotifyMessage, <span style="color:#ff79c6">*</span>PThreadNotifyMessage;</code></pre></div><p>Fields are pretty self-explanatory, in the case of the ImageFileName it will be retrieved from the <strong>ProcessCtx</strong> ‚Äì In this case the <strong>ProcessCtx</strong> corresponds to the one from the thread creator process, which may not be the same as the one where the thread is going to run</p><p><img src="https://n4r1b.com/images/wdFilter/part2/NewThreadAsyncMessage.png" alt="alt image" title="Async notification new thread" class="medium-zoom-image"></p><h4 id="mpcreatethreadnotifyroutineex">MpCreateThreadNotifyRoutineEx</h4><p>This routine is much simple than the previous one, in this case the function executes on the new thread, this basically means that the current process will always match the one indicated by the parameter ProcessId. First, in order to actually send the notification a lot of conditions must be met:</p><ul><li><code>MpProcessTable-&gt;CreateThreadNotifyLock</code> set to a value different than 0 (I know, lock is not the best name for this field, is locked when is zero üòÜ)</li><li>Create param set to <code>TRUE</code></li><li>Current process other than <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/mm64bitphysicaladdress" target="_blank">PsInitialSystemProcess</a></li><li>Flag <strong>ThreadNotifyRoutineExSet</strong> (<code>0x400</code>) set in <code>ProcessCtx.ProcessFlags</code></li><li>Rule <strong>NotifyProcessCmdLine</strong> (<code>0x20000000</code>) set in <code>ProcessCtx.ProcessRules</code></li></ul><p>As before, the following pseudocode explains this a bit better:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">if</span> ( _InterlockedCompareExchange(<span style="color:#ff79c6">&amp;</span>MpProcessTable<span style="color:#ff79c6">-&gt;</span>CreateThreadNotifyLock, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>) 
    <span style="color:#ff79c6">&amp;&amp;</span> IoGetCurrentProcess() <span style="color:#ff79c6">!=</span> PsInitialSystemProcess <span style="color:#ff79c6">&amp;&amp;</span> Create ) {

    <span style="color:#6272a4">// Retrieve the ProcessCtx using the Process Object, in the end it will use
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// the CreationTime (PsGetProcessCreateTimeQuadPart) and the ProcessId (PsGetProcessId)   
</span><span style="color:#6272a4"></span>    MpGetProcessContextByObject(IoGetCurrentProcess(), <span style="color:#ff79c6">&amp;</span>ProcessCtx)

    <span style="color:#6272a4">// Same as ((ProcessCtx-&gt;ProcessFlags &gt;&gt; 10) &amp; 1  &amp;&amp; (ProcessCtx-&gt;ProcessRules &gt;&gt; 0x1D) &amp; 1)
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> ((ProcessCtx<span style="color:#ff79c6">-&gt;</span>ProcessFlags <span style="color:#ff79c6">&amp;</span> ThreadNotifyRoutineExSet) 
        <span style="color:#ff79c6">&amp;&amp;</span> (ProcessCtx<span style="color:#ff79c6">-&gt;</span>ProcessRules <span style="color:#ff79c6">&amp;</span> NotifyProcessCmdLine)) {
      .....
    }
}</code></pre></div><p>A couple of clarifications here, the flag <strong>ThreadNotifyRoutineExSet</strong> is set in every ProcessCtx if the pointer to <code>PsSetCreateThreadNotifyRoutineEx</code> is not NULL in the <code>MP_DATA</code>:</p><p><img src="https://n4r1b.com/images/wdFilter/part2/ThreadNotifyExFlag.png" alt="alt image" title="Set ThreadNotifyRoutineFlag" class="medium-zoom-image"></p><p>in the case of the rule <strong>NotifyProcessCmdLine</strong>, comes from <strong>MsMpEng</strong> when setting the process info ‚Äì Again, I haven‚Äôt managed to trigger this rule with any process, so I don‚Äôt really know to what kind of process does this rule apply, I apologize for this ‚Äì So in the end of the process creation if this rule is set then the <code>MpProcessTable-&gt;CreateThreadNotifyLock</code> value will be incremented:</p><p><img src="https://n4r1b.com/images/wdFilter/part2/ThreadNotifyLock.png" alt="alt image" title="Set CreateThreadNotifyLock" class="medium-zoom-image"></p><p>Getting back into the actual function, if all the conditions are met, then first thing is to decrement <code>CreateThreadNotifyLock</code> and remove the <strong>ThreadNotifyRoutineExSet</strong> from the ProcessCtx, once this is done, a handle to the Process Object will be obtained (<code>ObOpenObjectByPointer</code> with ObjectType as <em>PsProcessType</em>) this handle will be used in order to retrieve the Process CommandLine, inside <code>MpGetProcessCommandLineByHandle</code>, this function pretty much uses <code>ZwQueryInformationProcess</code> with ProcessInformationClass set to <em>ProcessCommandLineInformation</em>. This command line is going to be compared against the one inside <code>ProcessCtx-&gt;ProcessCmdLine</code>, in case they don‚Äôt match then the function will get the <code>MP_IO_PRIORITY</code>, the <code>AuxPidCreationTime</code> and it will call <code>MpSendSyncMonitorNotification</code> with both Command Lines as the <em>Data</em>.</p><p><img src="https://n4r1b.com/images/wdFilter/part2/TamperedCommandLine.png" alt="alt image" title="Tampered command line" class="medium-zoom-image"></p><blockquote><p>As seen on the image, if someone modifies the command line from the <code>PEB</code> this callback would notify <strong>MsMpEng</strong> of the tampered command line (Of course if the rules and flags for that ProcessCtx are set)</p></blockquote><h3 id="mploadimagenotifyroutine">MpLoadImageNotifyRoutine</h3><p><code>MpLoadImageNotifyRoutine</code> is the callback routine that gets triggered whenever an image is loaded or mapped into memory. In order to register this callback the driver uses the function <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetloadimagenotifyroutine" target="_blank">PsSetLoadImageNotifyRoutine</a>.</p><p>Getting into the actual callback code, first thing is to check if the image to be load is going to be mapped into user space or kernel space, checking the bit <code>Properties.SystemModeImage</code> inside the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-_image_info" target="_blank"><code>IMAGE_INFO</code></a>. In case it is a kernel-mode component the information of the image will be added to a <code>DRIVER_INFO</code> structure and then chained into the Loaded drivers list entry ‚Äì Similar to the process creation adding boot process to the boot process list ‚Äì this is done inside <code>MpAddDriverInfo</code>.</p><p>After this check, the <strong>ProcessCtx</strong> will be obtained and <code>ProcessCtx-&gt;ProcessRules</code> will be checked to see if <strong>NotifyWow64cpuLoad</strong> (<code>0x800</code>) is set. In case the rule is set, the function will proceed to compare the <em>FullImageName</em> byte by byte against the string <em>\Windows\System32\Wow64cpu.dll</em>. If they match the <code>ProcessCtx-&gt;ProcessFlags</code> will be OR‚Äôed with <strong>ImageWow64cpuLoaded</strong> (<code>0x200</code>) and the <em>ImageBase</em> will be written to <code>ProcessCtx-&gt;Wow64CpuImageBase</code> ‚Äì If you remember first part of the series this field was named as <em>ImageBase</em>, I‚Äôve double-checked and this field is only set here in the whole code, that‚Äôs why I renamed it.</p><p><img src="https://n4r1b.com/images/wdFilter/part2/ProcessCtxWow64Cpu.png" alt="alt image" title="Process Context with Wow64cpu imagebase" class="medium-zoom-image"></p><p>From here on the main functionality of the routine starts ‚Äì Just to make it clear, this point of the code is reached even if the <em>ImageName</em> don‚Äôt match or the <strong>NotifyWow64cpuLoad</strong> is not set ‚Äì this piece of code will first check if the <code>IMAGE_INFO</code> has the <em>ExtendedInfoPresent</em> bit set, if <em>ExtendedInfoPresent</em> is set then <code>IMAGE_INFO</code> is contained inside <code>IMAGE_INFO_EX</code> which keeps a pointer to the <em>FileObject</em>, this pointer will be used to retrieve a <strong>StreamContext</strong> (<code>MpGetStreamContextFromFileObject</code>) ‚Äì Basically a structure defined by the minifilter that‚Äôs associated to a Stream objects, we‚Äôll discuss this much more when we get to how the filtering works ‚Äì with the <strong>StreamCtx</strong> and the <strong>ProcessCtx</strong> the following checks are done:</p><ul><li>If <code>StreamCtx-&gt;StreamCtxRules</code> has <strong>NotifyImageLoadRule</strong> (<code>0x8000</code>) active, then <strong>NotifyImageLoadPerStreamFlag</strong> is set.</li><li>If <code>ProcessCtx-&gt;ProcessRules</code> has <strong>NotifyImageLoadRule</strong> (<code>0x8000000</code>) active, then <strong>NotifyImageLoadPerProcessFlag</strong> is set.</li><li>If <code>ProcessCtx-&gt;ProcessRules</code> has <code>0x200</code> active (Haven‚Äôt figured out this value yet), in case is not set then <strong>AsyncNotificationFlag</strong> is activated.</li></ul><p>If <strong>AsyncNotificationFlag</strong> is set the function will create an <code>AsyncMessageData</code> structure where the union <em>TypeOfMessage</em> will take the structure <code>ImageLoadAndProcessNotify</code>, we already saw this structure in the previous post, the main difference is that <code>AsyncMessageData-&gt;TypeOfOperation</code> will be set to <strong>LoadImage</strong> (<code>0x3</code>). Lastly the notification will be send by calling MpAsyncSendNotification.</p><p><img src="https://n4r1b.com/images/wdFilter/part2/AsyncLoadImage.png" alt="alt image" title="Async load image notify" class="medium-zoom-image"></p><p>For the other two cases, the notification will be send synchronously, and the sent data will be the same for both cases. Only thing that differ will be the <em>OperationType</em> and the <em>Rule</em> ‚Äì We‚Äôll discuss this params shortly when we look into how synchronous messages are sent.</p><ul><li><strong>NotifyImageLoadPerProcessFlag</strong> -&gt; <em>OperationType</em> = <strong>NewImageLoadPerProcess</strong> (<code>0x5</code>) and <em>Rule</em> = <code>ProcessCtx-&gt;ProcessRules</code></li><li><strong>NotifyImageLoadPerStreamFlag</strong> -&gt; <em>OperationType</em> = <strong>NewImageLoadPerStream</strong> (<code>0x1</code>) and <em>Rule</em> = <code>StreamCtx-&gt;StreamCtxRules</code></li></ul><p>Finally function <code>MpSendSyncMonitorNotification</code> is called with the parameter <em>Data</em> as a UNICODE_STRING with the normalized name <em>FullImageName</em> of the loaded image.</p><p><img src="https://n4r1b.com/images/wdFilter/part2/SyncLoadImage.png" alt="alt image" title="Sync load image notify" class="medium-zoom-image"></p><p>One edge case where the code flow is a bit different is when <strong>ImageWow64cpuLoaded</strong> is set on the <code>ProcessCtx-&gt;ProcessFlags</code>. If this happens, then an <code>AsyncMessageData</code> structure of size 0x30 is allocated and the <em>TypeOfMessage</em> will contain the following structure:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _Wow64CpuLoadMessage
{
  INT ProcessId;
  INT ThreadId;
  PVOID Wow64CpuImageBase;
} Wow64CpuLoadMessage, <span style="color:#ff79c6">*</span>PWow64CpuLoadMessage;</code></pre></div><p>finally with <code>AsyncMessageData</code> populated the routine will call <code>FltSendMessage</code> ‚Äì Fun fact, the <code>AsyncMessageData-&gt;SizeOfData</code> is set to <code>0x70</code> when actually the size of the structure is <code>0x30</code>, even parameter <em>SenderBufferLength</em> of <code>FltSendMessage</code> is set to <code>0x30</code>, this could lead to some potential error if <code>AsyncMessageData-&gt;SizeOfData</code> is used by <strong>MsMpEng</strong>.</p><p><img src="https://n4r1b.com/images/wdFilter/part2/Wow64CpuLoadMessage.png" alt="alt image" title="Wow64Cpu load async notification" class="medium-zoom-image"></p><blockquote><p>So to explain a bit the flow, once <strong>Wow64cpu.dll</strong> is loaded this callback will set <strong>ImageWow64cpuLoaded</strong> in the <code>ProcessCtx-&gt;ProcessFlags</code> and will continue the execution through the main path. Next time this process loads an image, since <strong>ImageWow64cpuLoaded</strong> was previously set, the code will follow this path before taking the main path.</p></blockquote><h3 id="synchronous-notifications">Synchronous notifications</h3><div class="highlight-wrapper"><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">NTSTATUS <span style="color:#50fa7b">MpSendSyncMonitorNotification</span>(
    MP_SYNC_NOTIFICATION OperationType, 
    PAuxPidCreationTime ProcessIdAndCreationTime, 
    PVOID Data, 
    PMP_IO_PRIORITY MpIoPriority,
    PULONG Rule
);

<span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">enum</span> _MP_SYNC_NOTIFICATION_OPERATION 
{
  NewImageLoadPerStream <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1</span>,
  RegistryEventSync <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x2</span>,
  NewThreadDifferentProcess <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x3</span>,
  NewImageLoadPerProcess <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x5</span>,
  NewThreadSameProcess <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x6</span>,
  NewThreadProcessCmdLine <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x7</span>,
} MP_SYNC_NOTIFICATION_OPERATION;</code></pre></div></div><p><code>MpSendSyncMonitorNotification</code> is the one in charge of sending the synchronous messages through out the <strong>MicrosoftMalwareProtectionPort</strong>, in order for this function to execute the flag <strong>SyncMonitorNotificationFlag</strong> from the <code>MP_DATA</code> must be set. After this check has been done, the code will check if the <em>OperationType</em> is within the range of the <code>MP_SYNC_NOTIFICATION</code> enum, also it will check that none of the other parameters is <code>NULL</code>.</p><p>If every check is fulfilled, the code will proceed to obtain the size of the parameter <em>Data</em> ‚Äì As we saw during the post, the data provided in this parameter differs on each type of operation ‚Äì to do this the code uses the function <code>MpConstructSyncMonitorVariableData</code>.</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">ULONG MpConstructSyncMonitorVariableData(
  INT OperationType, 
  PVOID Data, 
  PVOID <span style="color:#ff79c6">*</span>__shifted(SyncMessageData,<span style="color:#bd93f9">0x30</span>) DataToSend, 
  ULONG SizeOfData
)</code></pre></div><p>this function can be used in two ways:</p><ul><li>To obtain the size of the data to send (<em>DataToSend</em> == <code>NULL</code>)</li><li>To fill te buffer that‚Äôs going to be send using the data from the parameter <em>Data</em></li></ul><p>In the first case the pseudocode would look something like this:</p><div class="highlight-wrapper"><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>DataToSend) {
  <span style="color:#ff79c6">switch</span> (OperationType) {
    <span style="color:#ff79c6">case</span> <span style="color:#8be9fd;font-style:italic">NewImageLoadPerStream</span>:
    <span style="color:#ff79c6">case</span> <span style="color:#8be9fd;font-style:italic">NewImageLoadPerProcess</span>:
    <span style="color:#ff79c6">case</span> <span style="color:#8be9fd;font-style:italic">NewThreadAndCmdLine</span>:
      <span style="color:#ff79c6">return</span> (UNICODE_STRING <span style="color:#ff79c6">*</span>) Data<span style="color:#ff79c6">-&gt;</span>Length <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0xA</span>;
    <span style="color:#ff79c6">case</span> <span style="color:#8be9fd;font-style:italic">RegistryEventSync</span>:
      <span style="color:#ff79c6">return</span> (RegistryNotifySyncMessage) Data<span style="color:#ff79c6">-&gt;</span>RegDataLength;
    <span style="color:#ff79c6">case</span> <span style="color:#8be9fd;font-style:italic">NewThreadDifferentProcess</span>:
      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">sizeof</span>(AuxPidCreationTime);
    <span style="color:#ff79c6">case</span> <span style="color:#8be9fd;font-style:italic">NewThreadSameProcess</span>:
      <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">sizeof</span>(ThreadNotifySyncMessage);
  }
}</code></pre></div></div><p>getting back to the main function, after calling <code>MpConstructSyncMonitorVariableData</code> for the first time the code will obtain the size of the data to send, this size will be added to the size of the message header (<code>0x30</code>) and with the whole size a pool will be allocated and filled accordingly. The message header has the following definition</p><div class="highlight-wrapper"><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _SyncMessageData
{
  SHORT Magic;      <span style="color:#6272a4">// Set to 0x5D 
</span><span style="color:#6272a4"></span>  SHORT SizeHeader; <span style="color:#6272a4">// Sizeof 0x30 
</span><span style="color:#6272a4"></span>  ULONG TotalSize;
  MP_IO_PRIORITY MpIoPriority;
  INT TypeOfOperation;
  AuxPidCreationTime CurrentProcess;
  INT SizeOfData;
  <span style="color:#ff79c6">union</span> SyncVariableData {
    WCHAR <span style="color:#ff79c6">*</span> NewThreadAndCmdLine;
    WCHAR <span style="color:#ff79c6">*</span> NewImageLoadPerStream;
    WCHAR <span style="color:#ff79c6">*</span> NewImageLoadPerProcess;
    RegistryNotifySyncMessage RegistryEventSync;
    AuxPidCreationTime NewThreadDifferentProcess;
    ThreadNotifySyncMessage NewThreadSameProcess;
  };
} SyncMessageData, <span style="color:#ff79c6">*</span>PSyncMessageData;</code></pre></div></div><p>lastly before sending the message the variable data has to be copied into the <code>SyncMessageData</code> structure, to do this <code>MpConstructSyncMonitorVariableData</code> is called again but this time the parameter <em>DataToSend</em> is pointing to the structure <code>SyncMessageData</code> shifted by <code>0x30</code> (Pointing to the variable data), in this case the function will just copy the data from the buffer <em>Data</em> to the buffer <em>DataToSend</em> ‚Äì In case the buffer <em>Data</em> is a <code>UNICODE_STRING</code> the <code>UNICODE_STRING.Buffer</code> will be copied using <code>memcpy_s</code>.</p><p>At this point everything is ready to send the data to <strong>MsMpEng</strong>, just one more check needs to be done, inside <code>MpAcquireSendingSyncMonitorNotification</code> which will basically check that <code>MpData-&gt;SendSyncNotificationFlag</code> is active and after this the function will wait on <code>MpData-&gt;SendingSyncSemaphore</code> using <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcancellablewaitforsingleobject" target="_blank">FltCancellableWaitForSingleObject</a> ‚Äì The timeout used for this wait comes from the variable <code>MpData-&gt;SyncMonitorNotificationTimeout</code> ‚Äì in case the wait returns anything other than <code>STATUS_SUCCESS</code> the main function won‚Äôt send any message and will increment and set accordingly the following two variables:</p><ul><li>MpData-&gt;ErrorSyncNotificationsCount[OperationType]</li><li>MpData-&gt;ErrorSyncNotificationsStatus[OperationType]</li></ul><p>In case the wait succeeds, <code>FltSendMessage</code> will be called and based on the returned status different variables will be filled. First variable is a structure that keeps a counter of the notifications and the total timestamp of them (For each <em>OperationType</em>). The structure array can be found in the variable <code>MpData-&gt;SyncNotifications[OperationType]</code> and the definition of it looks like this:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_SYNC_NOTIFICATIONS
{
  INT64 Timestamp;
  INT NotificationsCount;
} MP_SYNC_NOTIFICATIONS, <span style="color:#ff79c6">*</span>PMP_SYNC_NOTIFICATIONS;</code></pre></div><p>In case <code>FltSendMessage</code> returns an error the following variables will be updated:</p><ul><li>MpData-&gt;ErrorSyncNotificationsCount[OperationType]</li><li>MpData-&gt;ErrorSyncNotificationsStatus[OperationType]</li><li>MpData-&gt;SyncNotificationsIoTimeoutCount[OperationType] -&gt; Incremented just in case the returned status from <code>FltSendMessage</code> is <code>STATUS_TIMEOUT</code></li></ul><p>if <code>FltSendMessage</code> returned <code>STATUS_SUCCESS</code> then the function will proceed to check the reply buffer. This buffer should contain the same <em>OperationType</em> in offset <code>0x8</code> if this is the case then it will proceed to reset the <code>ProcessCtx-&gt;ProcessRules</code> or <code>StreamCtx-&gt;StreamCtxRule</code> that triggered this specific notification ‚Äì It uses the parameter <em>Rule</em> ‚Äì This can be seen in the following image:</p><p><img src="https://n4r1b.com/images/wdFilter/part2/ResetRuleSwitch.png" alt="alt image" title="Switch to reset rule" class="medium-zoom-image"></p><blockquote><p>There are two more variables in this last step <code>MpData-&gt;SyncNotificationRecvCount[OperationType]</code> and <code>MpData-&gt;SyncNotificationsRecvErrorCount[OperationType]</code>. The latter is incremend in case the ReplyBuffer check doesn‚Äôt match, the former in the other case.</p></blockquote><h3 id="asynchronous-notifications">Asynchronous Notifications</h3><p>In this section I will explain how does the driver handles sending the asynchronous notifications, there are two functions in charge of doing this. <code>MpAsyncSendNotification</code> which is in charge of adding the message to the async messages queue and <code>MpAsyncpWorkerThread</code> which is a worker thread checking the async messages queue and sending the messages if there are any.</p><h4 id="mpasyncpworkerthread">MpAsyncpWorkerThread</h4><p>In the first part of the series we already mention this worker thread. We saw that it is initialized, along with the async structure, inside <code>MpAsyncInitialize</code>. This function uses <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-pscreatesystemthread" target="_blank">PsCreateSystemThread</a> to create the worker thread, setting up <code>MpAsyncpWorkerThread</code> as the <em>StartRoutine</em> ‚Äì No <em>StartContext</em> is passed into this new thread.</p><p>This thread will work mainly with the structure <code>MP_ASYNC</code>, this structure has the following definition (However much I tried to cross-reference this structure, I couldn‚Äôt manage to get more fields for now. That‚Äôs the main reason why I‚Äôm missing many fields):</p><div class="highlight-wrapper" style="max-height: 350px; overflow: hidden;"><div class="highlight" style="margin: 0px auto;"><pre style="color: rgb(248, 248, 242); background-color: rgb(40, 42, 54); tab-size: 4; margin-top: 0px; margin-bottom: 0px;"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_ASYNC
{
  SHORT Magic;      <span style="color:#6272a4">// Set to 0xDA07
</span><span style="color:#6272a4"></span>  SHORT StructSize; <span style="color:#6272a4">// Sizeof 0x180
</span><span style="color:#6272a4"></span>  LIST_ENTRY HighPriorityNotificationsList;
  LIST_ENTRY NotificationsList;
  PETHREAD WorkerThread;
  KEVENT AsyncNotificationEvent;
  KSEMAPHORE AsyncSemaphore;
  FAST_MUTEX AsyncFastMutex;
  INT NotificationsCount;
  INT64 field_A8;
  INT64 field_B0;
  INT64 field_B8;
  PAGED_LOOKASIDE_LIST NotificationsLookaside;
  INT64 TotalSizeNotificationsSent;
  INT64 TotalSizeRemainingNotifications;
  INT FailedNotifications;
  INT64 field_158;
  INT64 field_160;
  INT64 field_168;
  INT64 field_170;
  INT64 field_178;
} MP_ASYNC, <span style="color:#ff79c6">*</span>PMP_ASYNC;</code></pre></div><div class="highlight-link"><a href="https://n4r1b.com/posts/2020/02/dissecting-the-windows-defender-driver-wdfilter-part-2/">Show More</a></div></div><p>Once the worker thread starts executing it will enter an infinite loop waiting for two synchronization objects, <code>MpAsync-&gt;AsyncSemaphore</code> and <code>MpAsync-&gt;AsyncNotificationEvent</code>. In order to do this it uses <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kewaitformultipleobjects" target="_blank">KeWaitForMultipleObjects</a></p><p><img src="https://n4r1b.com/images/wdFilter/part2/KeWaitForMultipleObjects.png" alt="alt image" title="KeWaitForMultipleObjects" class="medium-zoom-image"></p><blockquote><p>I want to stop in this call and how is used for a second because I think is pretty cool, as we can see <em>WaitType</em> is set to <strong>WaitAny</strong> which means it will wait until any of the objects attains a signaled state. Also using <strong>WaitAny</strong> means that if the function returns <code>STATUS_SUCCESS</code>, it will actually return the zero-based index of the object as the <code>NTSTATUS</code>. Taking this into account, since the Event is set as the first element of the Objects array whenever the Event is signaled the returned value will be <code>STATUS_WAIT_0</code>, which corresponds to <code>0x0</code>. Which, again as seen in the image, would make the condition of the for-loop <code>FALSE</code> which would make the loop stop and the thread would terminate by calling <code>PsTerminateSystemThread</code>.</p></blockquote><p>In the case the semaphore is the signaled object, the thread will proceed to obtain the data that must be sent to <strong>MsMpEng</strong>. To do this, first the value <code>MpConfig.AsyncStarvationLimit</code> will be compared against the global variable <code>AsyncStarvationLimit</code> ‚Äì If they are the same the global <code>AsyncStarvationLimit</code> will be set to <code>0x0</code> ‚Äì In case they don‚Äôt match, data will be searched on the <code>MpAsync-&gt;HighPriorityNotificationsList</code>, if any entry is found in the <code>LIST_ENTRY</code> then <code>AsyncStarvationLimit</code> will be incremented by one. If no entries are found then <code>MpAsync-&gt;NotificationsList</code> will be checked and if an entry is found <code>AsyncStarvationLimit</code> is clear. In case the starvation limit is reached the list entries will be checked in reverse order, first the normal priority then the higher. The following pseudo-horrible-code shows this:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">if</span> (MpConfig.AsyncStarvationLimit <span style="color:#ff79c6">==</span> _InterlockedCompareExchange(
                                        <span style="color:#ff79c6">&amp;</span>AsyncStarvationLimit,
                                        <span style="color:#bd93f9">0</span>,
                                        MpConfig.AsyncStarvationLimit)) {
  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">&amp;</span>MpAsync<span style="color:#ff79c6">-&gt;</span>NotificationsList <span style="color:#ff79c6">!=</span> MpAsync<span style="color:#ff79c6">-&gt;</span>NotificationsList.Flink)
    <span style="color:#ff79c6">goto</span> SendMessage;

  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">&amp;</span>MpAsync<span style="color:#ff79c6">-&gt;</span>HighPriorityNotificationsList <span style="color:#ff79c6">!=</span> MpAsync<span style="color:#ff79c6">-&gt;</span>HighPriorityNotificationsList.Flink) {
<span style="color:#8be9fd;font-style:italic">IncrementLimit</span>:
    _InterlockedAdd(<span style="color:#ff79c6">&amp;</span>AsyncStarvationLimit, <span style="color:#bd93f9">1</span>);
    <span style="color:#ff79c6">goto</span> SendMessage
  }
}

<span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">&amp;</span>MpAsync<span style="color:#ff79c6">-&gt;</span>HighPriorityNotificationsList <span style="color:#ff79c6">!=</span> MpAsync<span style="color:#ff79c6">-&gt;</span>HighPriorityNotificationsList.Flink)
  <span style="color:#ff79c6">goto</span> IncrementLimit

<span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">&amp;</span>MpAsync<span style="color:#ff79c6">-&gt;</span>NotificationsList <span style="color:#ff79c6">!=</span> MpAsync<span style="color:#ff79c6">-&gt;</span>NotificationsList.Flink) {
  _InterlockedCompareExchange(<span style="color:#ff79c6">&amp;</span>AsyncStarvationLimit, <span style="color:#bd93f9">0</span>, AsyncStarvationLimit); <span style="color:#6272a4">// Atomic set to 0
</span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">goto</span> SendMessage;
}</code></pre></div><blockquote><p>As you can see, messages from <code>MpAsync-&gt;HighPriorityNotificationsList</code> have a higher priority because this <code>LIST_ENTRY</code> will be checked first unless the starvation limit is reached</p></blockquote><p>The next part is pretty straightforward, if an entry is found in any of the two list entries then the following steps will take part:</p><ul><li>Decrement <code>MpAsync-&gt;NotificationsCount</code></li><li>Subtract the data size from <code>MpAsync-&gt;TotalSizeRemainingNotifications</code></li><li>Set the <em>Magic</em> and <em>Size</em> of <code>MP_ASYNC_NOTIFICATION</code> (We will see this structure shortly) to <code>0xBABAFAFA</code></li><li>Push or free, in case the max depth has been reached, the <code>MP_ASYNC_NOTIFICATION</code> entry to the lookaside <code>MpAsync-&gt;AsyncNotificationsLookaside</code></li><li>Send the actual message using <code>FltSendMessage</code></li><li>In case of error increment <code>MpAsync-&gt;FailedNotifications</code></li><li>Add the data size to <code>MpAsync-&gt;TotalSizeNotificationsSent</code></li></ul><p><img src="https://n4r1b.com/images/wdFilter/part2/AsyncFltSendMessage.png" alt="alt image" title="Async notification FltSendMessage" class="medium-zoom-image"></p><p>And after that the thread would iterate again over the for-loop waiting for any of the two objects to be signaled.</p><blockquote><p>Just to complete the full circle on this worker thread, function <code>MpAsyncpShutdownWorkerThreads</code> is the one that calls <code>KeSetEvent</code> with <code>MpAsync-&gt;AsyncNotificationEvent</code> as the event to signal, which as we saw before would end the loop and terminate the thread. This function is called from within <code>MpAsyncShutdown</code> which is in charge of cleaning all related to async notifications.</p></blockquote><h4 id="mpasyncsendnotification">MpAsyncSendNotification</h4><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">NTSTATUS <span style="color:#50fa7b">MpAsyncSendNotification</span>(
  PVOID <span style="color:#ff79c6">*</span>__shifted(AsyncMessageData,<span style="color:#bd93f9">8</span>) AsyncMessageBuffer,
  ULONG SizeOfBuffer, 
  INT PriorityFlag, 
  PProcessCtx ProcessCtx
);</code></pre></div><p>We‚Äôve already seen a couple of cases where the code will create a <strong>AsyncMessageData</strong> structure and populate it with the data that‚Äôs going to be send afterwards to <strong>MsMpEng</strong>. We just saw how this data is sent, now we are going to see how this data is added to the previously seen list entries.</p><p>The function in charge of this is <code>MpAsyncSendNotification</code>, which will first do a sanity check on <em>AsyncMessageBuffer</em> and <em>SizeOfBuffer</em>. If checks are fulfilled function will test if the <code>SenderBuffer-&gt;TypeOfOperation</code> is less than <code>0xA</code>, if it‚Äôs the case, the value <code>MpData-&gt;AsyncNotificationCount</code> will be incremented and assigned to <code>SenderBuffer-&gt;NotificationNumber</code> ‚Äì The Possible values of <em>TypeOfOperation</em> are the following:</p><div class="highlight-wrapper"><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">enum</span> _MP_ASYNC_NOTIFICATION_OPERATION
{
  CreateProcess <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0</span>, 
  RegistryEvent <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1</span>,
  SendFile <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x2</span>,
  LoadImage <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x3</span>,
  OpenProcess <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x4</span>,
  RawVolumeWrite <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x5</span>, <span style="color:#6272a4">// High-Priority
</span><span style="color:#6272a4"></span>  CreateThread <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x6</span>,
  DocOpen <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x7</span>,
  PostMount <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x8</span>, <span style="color:#6272a4">// High-Priority
</span><span style="color:#6272a4"></span>  OpenDesktop <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x9</span>,
  PanicMode <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xB</span>,
  CheckJournal <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xC</span>, <span style="color:#6272a4">// High-Priority
</span><span style="color:#6272a4"></span>  TrustedOrUntrustedProcess <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xD</span>, <span style="color:#6272a4">// High-Priority
</span><span style="color:#6272a4"></span>  LogPrint <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xE</span>,
  Wow64cpuLoad <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xF</span>,
  OpenWithoutRead <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x10</span>,
  FolderGuardEvents <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x11</span>,
  DlpOnFileObjectClose <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x13</span>,
} MP_ASYNC_NOTIFICATION_OPERATION;</code></pre></div></div><p>next step is to increment the <code>ProcessCtx-&gt;NotificationsSent</code> ‚Äì If there is a <em>ProcessCtx</em> ‚Äì once this is done an entry from <code>MpAsync-&gt;AsyncNotificationsLookaside</code> will be popped or allocated and the following structure will be initialized in that buffer:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_ASYNC_NOTIFICATION
{
  SHORT Magic;        <span style="color:#6272a4">// Set to 0xDA08
</span><span style="color:#6272a4"></span>  SHORT StructSize;   <span style="color:#6272a4">// Sizeof 0x18 - Header Size
</span><span style="color:#6272a4"></span>  LIST_ENTRY AsyncNotificationsList;
  PVOID <span style="color:#ff79c6">*</span><span style="color:#50fa7b">__shifted</span>(AsyncMessageData,<span style="color:#bd93f9">8</span>) pMessageBuffer;
  INT MessageBufferSize;
} MP_ASYNC_NOTIFICATION, <span style="color:#ff79c6">*</span>PMP_ASYNC_NOTIFICATION;</code></pre></div><p>Once this structure is initialized there‚Äôs tow possible paths, first path in case <code>MpAsync-&gt;NotificationsCount</code> is less than <code>MpConfig.MaxAsyncNotificationCount</code>. In this case, the initialized structure will be inserted at the end of <code>MpAsync-&gt;HighPriorityNotificationsList</code> or <code>MpAsync-&gt;NotificationsList</code> based on the <em>PriorityFlag</em> ‚Äì If is set then is chained to the former, in the other case to the latter ‚Äì then <code>MpAsync-&gt;NotificationsCount</code> is incremented, <em>MessageBufferSize</em> is added to <code>MpAsync-&gt;TotalSizeRemainingNotifications</code> and lastly the semaphore is signaled ‚Äì <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kereleasesemaphore" target="_blank">KeReleaseSemaphore</a></p><p><img src="https://n4r1b.com/images/wdFilter/part2/AsyncNotificationBeforeSignal.png" alt="alt image" title="Async notification list entries before signal" class="medium-zoom-image"></p><p>The second path is taken when <code>MpAsync-&gt;NotificationsCount</code> is greater or equal to <code>MpConfig.MaxAsyncNotificationCount</code>, if this happens then the first entry of <code>MpAsync-&gt;HighPriorityNotificationsList</code> or <code>MpAsync-&gt;NotificationsList</code> (Again based on the <em>PriorityFlag</em>) will be unchained from the <code>LIST_ENTRY</code> and the newly created entry will be inserted at the end of it. Before finishing, as we saw in the worker thread, the function will increment <code>MpAsync-&gt;AsyncMessagesFailed</code> and push/free the unchained entry to/from the lookaside list (After setting the first bytes to <code>0xBABAFAFA</code>)</p><blockquote><p>This is basically to make sure there will be enough resources to allocate a pool from the lookaside list in case a new notification must be created, also this makes sure the newer notifications are the ones kept on the <code>LIST_ENTRY</code> in case the worker thread is not getting enough execution time to free the notifications list</p></blockquote><h3 id="conclusion">Conclusion</h3><p>And that‚Äôs all for this part folks! Sorry again for the long post but I‚Äôm trying to explain and clarify as much as possible ‚Äì And even with theses long posts I‚Äôm leaving some stuff out ‚Äì This part was a bit messy, not being able to know which process or options trigger some paths makes things a bit harder. Anyway, I hope you guys liked and still want to keep reading the series! This is just the tip of the iceberg!! On the next post we‚Äôll look into the registered callback for objects (<em>PsProcessType</em> and <em>ExDesktopObjectType</em>) and also we will look into how drivers information is saved and how their verification is done.</p><p>If there‚Äôs any mistake or something not clear, please don‚Äôt hesitate to reach out to me on twitter <a href="https://twitter.com/n4r1B" target="_blank">@n4r1b</a></p></div></article><hr><div class="post-info"><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83.0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><path d="M7 7V7z"></path></svg><span class="tag"><a href="https://n4r1b.com/tags/wdfilter/">WdFilter</a></span>
<span class="tag"><a href="https://n4r1b.com/tags/minifilter/">MiniFilter</a></span>
<span class="tag"><a href="https://n4r1b.com/tags/windows-defender/">Windows Defender</a></span>
<span class="tag"><a href="https://n4r1b.com/tags/microsoft-security/">Microsoft Security</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg><span class="tag"><a href="https://n4r1b.com/categories/wdfilter/">WdFilter</a></span>
<span class="tag"><a href="https://n4r1b.com/categories/minifilter/">MiniFilter</a></span>
<span class="tag"><a href="https://n4r1b.com/categories/windows-defender/">Windows Defender</a></span>
<span class="tag"><a href="https://n4r1b.com/categories/microsoft-security/">Microsoft Security</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><path d="M14 2V8h6"></path><path d="M16 13H8z"></path><path d="M16 17H8z"></path><path d="M10 9H9 8"></path></svg>3997 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><path d="M16 2V6z"></path><path d="M8 2V6z"></path><path d="M3 10H21z"></path></svg>2020-02-06 00:00 +0000
(Last updated: 2020-04-18 20:44 +0000)</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-git-commit"><circle cx="12" cy="12" r="4"></circle><path d="M1.05 12H7z"></path><path d="M17.01 12H22.96z"></path></svg><a href="https://github.com/n4r1b/n4r1b-hugo/commit/ade56b98755bbb5a7a8e08dae9b3203beb5e7fc2" target="_blank" rel="noopener">ade56b9</a>
@ 2020-04-18</p></div><div class="pagination"><div class="pagination__buttons"><span class="button previous"><a href="https://n4r1b.com/posts/2020/03/dissecting-the-windows-defender-driver-wdfilter-part-3/"><span class="button__icon">‚Üê</span>
<span class="button__text">Dissecting the Windows Defender Driver - WdFilter (Part 3)</span></a></span>
<span class="button next"><a href="https://n4r1b.com/posts/2020/01/dissecting-the-windows-defender-driver-wdfilter-part-1/"><span class="button__text">Dissecting the Windows Defender Driver - WdFilter (Part 1)</span>
<span class="button__icon">‚Üí</span></a></span></div></div></main></div></div></body></html>