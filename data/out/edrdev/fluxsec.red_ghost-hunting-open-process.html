# https://fluxsec.red/ghost-hunting-open-process

<!DOCTYPE html><html lang="en">
<body>
    <div class="container">
        
          
        <main class="main-content">
            <h1>Ghost hunting OpenProcess</h1>
            <p class="description">A look at the Ghost Hunting technique for detecting stealthy malware that bypasses syscall hooks in EDR environments. This post focuses on detecting OpenProcess abuse by correlating syscall hooks and kernel events.</p>
            <hr>
            <h2 id="intro">Intro</h2>

<p>If you are not already following the project - you can check it out on <a href="https://github.com/0xflux/Sanctum/" target="_blank">GitHub</a>, and I would recommend you read my previous Ghost Hunting articles,
particularly <a href="https://fluxsec.red/edr-syscall-hooking" target="_blank">this one</a>.</p>

<p>So, up unto this point, we have managed to create <a href="https://fluxsec.red/implementing-syscall-hooking-rust" target="_blank">syscall stub hooks</a> in the EDR which alter execution flow to an injected DLL of our making to inspect arguments being passed into the
function. Ghost Hunting is my technique in which we look to spot malware evading syscall hooks in environments where EDR operate. We are
also able to communicate with the engine via <a href="https://fluxsec.red/communicating-from-hooked-syscall-rust" target="_blank">IPC</a> (interprocess communication), all with Rust.</p>

<p>Now we need to look at the logic for how Ghost Hunting works - as mentioned in my previous post, doing so in an OpenProcess hook is a little difficult and will not be <strong>0 ms</strong> detection speed, instead it will be within a predefined time window
which I have set (for now) as <code>600 ms</code>. This is quite slow in terms of execution speed - but OpenProcess is only at the <strong>start</strong> of the chain for process injection that we are trying to combat (as our first overall technique), and there
are better opportunities later down the line where I think Ghost Hunting will really shine as a technique (as mentioned <a href="https://fluxsec.red/edr-syscall-hooking#ghost-hunting" target="_blank">here</a>).</p>

<p><strong>One foreseeable problem</strong> with this by itself, is that a malware loader will have been and gone by the time 600 ms rolls around. I have two rebuttals to this; primarily - we can delay execution of CreateRemoteThread / APC Queue Hijacking techniques
until the ghost hunting technique has closed the 600 ms window; secondary - this technique is still valid in a sandbox environment where you can wait these time delays for the ghost hunting period to close.</p>

<h2 id="the-logic">The logic</h2>

<p>So for <strong>OpenProcess</strong>, we have the function <strong>ZwOpenProcess</strong> hooked (you can see it in action in my <a href="https://www.youtube.com/watch?v=I2krfjCsRp0" target="_blank">YouTube video</a>). We need to think about how Ghost Hunting can spring into
action to detect syscall abuse.</p>

<p>The current problem I see with this, if we were to move the logic into the driver so that we will <strong>only</strong> issue a handle when our DLL usermode syscall stub signals the <strong>syscall</strong>, we will enter a time where we are potentially
spinning system threads waiting for the ‘approval’ to come from usermode.</p>

<p>Alternatively, what if we sent an IOCTL from our syscall hook to the kernel before we call <strong>syscall</strong>; in principal this sounds okay - however, I can see this leading to race conditions - equally, when a driver gets a handle to something
via <strong>ObOpenObjectByPointer</strong>, our callback routine is triggered. In that case, no usermode “this pid is opening a handle” will be received and we may quickly enter undefined behaviour.</p>

<p>So, <strong>my approach</strong> here is to use this as a logging function for userland, raising the risk score if within a specified time period a handle (via driver interception) does not match up with a hooked syscall IPC message.</p>

<p>Given the risk score is raised by this behaviour, we have other opportunities slightly later to catch malware trying to do bad things, in places where we probably can justify a little delay in an action happening.
Catching handles is too noisy. There are simply too many, making it impractical to justify delaying system execution based solely on handle creation.</p>

<p>So, diagrammatically the <strong>ghost hunting</strong> process for OpenProcess will look like:</p>

<p><img class="wide-img" src="https://fluxsec.red/static/images/edr_ghost_open_proc.jpg" alt="Ghost Hunting EDR Technique Open Process diagram Rust Windows EDR Driver"></p>

<p>Ultimately, we have two inputs (one from the driver, one from the hooked syscall via our DLL) - event receivers are in place in the <strong>core</strong> module of the EDR, which then pass the data through to <strong>process_monitor</strong> which is responsible for
tracking process data.</p>

<p>Every loop (<strong>20 ms</strong>) the function <strong>poll_ghost_timer</strong> will be run, which determines whether there’s been too much time between one input and another; essentially
saying - <strong>if we do not receive both inputs within x amount of time, we are declaring that suspicious</strong>. This will likely require some tweaking, but currently the period is set to <strong>600 ms</strong>.</p>

<h2 id="rust-channels">Rust channels</h2>

<p>So, looking to the implementation of this; we first need a way of doing something with the IPC message from the hooked syscall (if this is foreign to you, check my <a href="https://fluxsec.red/communicating-from-hooked-syscall-rust" target="_blank">previous blog post</a>).</p>

<p>To do this, we will use channels, which we can use via Tokio, to pass messages between threads or Tokio tasks. An <strong>mpsc channel</strong> is basically a tuple containing a transmitter, and receiver, where we can send data from one task / thread via the
transmitter, to the receiver.</p>

<p>Let’s implementing this in the <strong>core</strong> module of the EDR. Before the main event loop, we create a new <code>mpsc::channel</code> like so:</p>

<pre><code class="language-rust hljs" data-highlighted="yes"><span class="hljs-keyword">let</span> (tx, <span class="hljs-keyword">mut</span> rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>(<span class="hljs-number">1000</span>);
</code></pre>

<p>So here we simply specify the transmitter, <strong>tx</strong>, and receiver <strong>rx</strong>, setting the channels capacity to 1000.</p>

<p>Next, we move the transmitter into the task like so:</p>

<pre><code class="language-Rust hljs" data-highlighted="yes">tokio::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> {
    <span class="hljs-title function_ invoke__">run_ipc_for_injected_dll</span>(tx).<span class="hljs-keyword">await</span>;
});
</code></pre>

<p>This function is going to loop waiting for IPC messages from our hooked syscalls in foreign processes. Inside of <code>run_ipc_for_injected_dll</code> we need to Arc and clone the transmitter (as it involves some move semantics across tokio tasks / threads),
and then we can use that (it will be called <strong>tx_cl</strong>) to send some received data from the IPC.</p>

<pre><code class="language-Rust hljs" data-highlighted="yes"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_ipc_for_injected_dll</span>(
    tx: Sender&lt;OpenProcessData&gt;
) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">tx_arc</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(tx);
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">tx_cl</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;tx_arc);
        
        <span class="hljs-comment">// ... got an IPC connection so make a new task to deal with it</span>
        tokio::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> {
            <span class="hljs-comment">// ... read the data as per the previous blog post, then send it out of the task / thread via mpsc</span>
            tx_cl.<span class="hljs-title function_ invoke__">send</span>(open_process_data).<span class="hljs-keyword">await</span>;
        }
    }
}
</code></pre>

<p>Once <code>tx_cl.send(open_process_data).await</code> completes, our receiver will be able to get the data and do something with it.</p>

<h3 id="receiver">Receiver</h3>

<p>So on the receiver, back in the core, in the event loop, we can try receive data. If there is no data to receive, it will simply continue execution to the next thing. If it does receive data, then we can do something with it. That looks like
so (we have to get a lock to <strong>self.process_monitor</strong> as it is wrapped in an <strong>RwLock</strong>):</p>

<pre><code class="language-rust hljs" data-highlighted="yes"><span class="hljs-comment">//</span>
<span class="hljs-comment">// Enter the polling &amp; decision making loop, this here is the core / engine of the usermode engine.</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">loop</span> {
    <span class="hljs-comment">// See if there is a message from the injected DLL</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(open_process_data) = rx.<span class="hljs-title function_ invoke__">try_recv</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lock</span> = <span class="hljs-keyword">self</span>.process_monitor.<span class="hljs-title function_ invoke__">write</span>().<span class="hljs-keyword">await</span>;
        lock.<span class="hljs-title function_ invoke__">ghost_hunt_open_process_add</span>(open_process_data.pid <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>, ApiOrigin::SyscallHook);
    }

    <span class="hljs-comment">// ...</span>
}
</code></pre>

<h2 id="receiving-the-event-from-the-driver">Receiving the event from the driver</h2>

<p>Equally, in the same event loop in <strong>core</strong>, we see if we have any new handle notifications from the driver, and if so, deal with those:</p>

<pre><code class="language-rust hljs" data-highlighted="yes"><span class="hljs-comment">// process all handles</span>
<span class="hljs-keyword">if</span> !driver_messages.handles.<span class="hljs-title function_ invoke__">is_empty</span>() {
    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> driver_messages.handles {
        <span class="hljs-keyword">self</span>.process_monitor.<span class="hljs-title function_ invoke__">write</span>().<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">add_handle_driver_notified</span>(
            item.source_pid, 
            item.dest_pid, 
            item.rights_given, 
            item.rights_desired,
        );
    }
}
</code></pre>

<h2 id="ghost-hunting">Ghost Hunting</h2>

<p>The actual logic for <strong>add_handle_driver_notified</strong> isn’t all that interesting, essentially it itself calls <strong>ghost_hunt_open_process_add</strong>; which will add the event to an internal structure
tracking the event, importantly with an enum identifying whether the event was emitted from the syscall hook, or the driver. This way we can make equal matches for the events; otherwise one easy
EDR bypass technique for this would be for malware to directly call the SSN for opening a process twice; cancelling out each other without proper integrity.</p>

<p>Note, we use <strong>SystemTime</strong> as this is serialisable via Serde, whereas <strong>Instant</strong> isn’t (if memory serves me correctly).</p>

<p>The implementation is as follows:</p>

<pre><code class="language-rust hljs" data-highlighted="yes"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ProcessMonitor</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ghost_hunt_open_process_add</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, pid: <span class="hljs-type">u64</span>, syscall_origin: ApiOrigin) {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(process) = <span class="hljs-keyword">self</span>.processes.<span class="hljs-title function_ invoke__">get_mut</span>(&amp;pid) {
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// If the timers are empty; then its the first in so we can add it to the list straight up.</span>
            <span class="hljs-comment">// Else, we will look for a match on the type; if we </span>
            <span class="hljs-comment">//</span>
            <span class="hljs-keyword">if</span> process.ghost_hunting_timers.<span class="hljs-title function_ invoke__">is_empty</span>() {
                process.ghost_hunting_timers.<span class="hljs-title function_ invoke__">push</span>(GhostHuntingTimers {
                    pid: pid <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>,
                    timer: SystemTime::<span class="hljs-title function_ invoke__">now</span>(),
                    syscall_type: SyscallType::OpenProcess,
                    origin: syscall_origin,
                });
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span>: <span class="hljs-type">usize</span> = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> <span class="hljs-variable">timer</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> process.ghost_hunting_timers {
                    <span class="hljs-keyword">match</span> syscall_origin {
                        <span class="hljs-comment">//</span>
                        <span class="hljs-comment">// If the origin was from the kernel, then we are looking to match on an inbound equivalent </span>
                        <span class="hljs-comment">// notification from a hooked syscall; and vice-versa for if the first notification came from a </span>
                        <span class="hljs-comment">// syscall.</span>
                        <span class="hljs-comment">// If that condition is true; then remove that item from the queue. If not - do not remove and add</span>
                        <span class="hljs-comment">// a new queued item. The timers will then catch any bad state.</span>
                        <span class="hljs-comment">// We want to return out of this operation once it has completed. If there was not a successful match</span>
                        <span class="hljs-comment">// then add it - the timer will take care of the ghost hunting process.</span>
                        <span class="hljs-comment">// </span>
                        ApiOrigin::Kernel =&gt; {
                            <span class="hljs-keyword">if</span> timer.origin == ApiOrigin::SyscallHook &amp;&amp; timer.syscall_type == SyscallType::OpenProcess {
                                <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = process.ghost_hunting_timers.<span class="hljs-title function_ invoke__">remove</span>(index);
                                <span class="hljs-keyword">return</span>;
                            }
                        },
                        ApiOrigin::SyscallHook =&gt; {
                            <span class="hljs-keyword">if</span> timer.origin == ApiOrigin::Kernel &amp;&amp; timer.syscall_type == SyscallType::OpenProcess {
                                <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = process.ghost_hunting_timers.<span class="hljs-title function_ invoke__">remove</span>(index);
                                <span class="hljs-keyword">return</span>;
                            }
                        },
                    }

                    index += <span class="hljs-number">1</span>;
                }

                <span class="hljs-comment">// we did not match, so add the element </span>
                process.ghost_hunting_timers.<span class="hljs-title function_ invoke__">push</span>(GhostHuntingTimers {
                    pid: pid <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>,
                    timer: SystemTime::<span class="hljs-title function_ invoke__">now</span>(),
                    syscall_type: SyscallType::OpenProcess,
                    origin: syscall_origin,
                });
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// todo ok something very wrong if this gets called!!</span>
            <span class="hljs-keyword">let</span> <span class="hljs-variable">log</span> = Log::<span class="hljs-title function_ invoke__">new</span>();
            log.<span class="hljs-title function_ invoke__">log</span>(LogLevel::NearFatal, <span class="hljs-string">"Open Process from DLL request made that can not be found in active process list."</span>);
        }

    }
}
</code></pre>

<h2 id="polling-for-the-ghost-hunting-technique">Polling for the Ghost Hunting technique</h2>

<p>As mentioned we do poll the Ghost Hunt timer; what we want to do is check both a signal from the driver and a signal from the hooked syscall
were received within some defined period of time. If not, this is a sign of badness.</p>

<p>We enumerate each process we track in the <strong>ProcessMonitor</strong>, and check for active timers.</p>

<pre><code class="language-rust hljs" data-highlighted="yes"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ProcessMonitor</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll_ghost_timer</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// For each process we are tracking; determine if any timers are active from syscall stubs. If no timers are active then</span>
        <span class="hljs-comment">// we can simply ignore them. If they are active, then we should have received a driver notification matching the event</span>
        <span class="hljs-comment">// the syscall hooked within that time frame. If no such event is received; something untoward is going on, and as such,</span>
        <span class="hljs-comment">// elevate the risk score of the process.</span>
        <span class="hljs-comment">//</span>

        <span class="hljs-keyword">const</span> MAX_WAIT: Duration = Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">600</span>);
        
        <span class="hljs-keyword">for</span> (_, process) <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.processes.<span class="hljs-title function_ invoke__">iter_mut</span>() {
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// In here process each hooked syscall where we expect an emission from the kernel</span>
            <span class="hljs-comment">//</span>
            <span class="hljs-keyword">if</span> !process.ghost_hunting_timers.<span class="hljs-title function_ invoke__">is_empty</span>() {
                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span>: <span class="hljs-type">usize</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// index of iterator over the ghost timers</span>
                <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;process.<span class="hljs-title function_ invoke__">clone</span>().ghost_hunting_timers {
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(t) = item.timer.<span class="hljs-title function_ invoke__">elapsed</span>() {
                        <span class="hljs-keyword">if</span> t &gt; MAX_WAIT {
                            process.<span class="hljs-title function_ invoke__">update_process_risk_score</span>(SyscallType::OpenProcess <span class="hljs-keyword">as</span> <span class="hljs-type">i16</span>);
                            process.ghost_hunting_timers.<span class="hljs-title function_ invoke__">remove</span>(index);
                            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"******* RISK SCORE RAISED AS TIMER EXCEEDED"</span>);
                            <span class="hljs-keyword">break</span>;
                        }
                    }

                    index += <span class="hljs-number">1</span>;
                }
            }
        }
    }
}
</code></pre>

<h2 id="challenge-to-other-security-researchers">Challenge to other security researchers</h2>

<p>If you are reading this as a security researcher / professional; I’d love you to try figure out a way around this detection mechanism. If you do experiment with this and find
a way around it, please get in touch via <a href="https://x.com/0xfluxsec" target="_blank">Twitter</a> or email me at <strong>fluxsec@proton.me</strong>, as I would love to see this mechanism bypassed so I can carry on
improving the detection logic / Ghost Hunting technique! (If accepting this challenge, either do it hypothetically, or if you want to run it against the EDR set a small sleep before
your payload runs as the DLL is mapped ~ 60 - 120 ms after a process called “malware.exe” starts - i need to hard map the DLL in earlier, that is todo soon. Also, if you are testing
against the edr, make sure your payload has “malware” in its file name).</p>

<p>This should detect hells gate, direct/indirect syscalls and remapping NTDLL.</p>


            

        </main>
        
        

    </div>



</body></html>