"title='[Research] Walking Through Windows Minifilter Drivers (EN) - hackyboiz' description='<p>Hello, this is banda. This is my first time greeting you with an article on Windows Minifilter Drivers. &#x1F917;</p>\\n<p>While studying Windows Kernel Drivers recently, I discovered that there are various types of drivers categorized by purpose, such as Bus Drivers, Filter Drivers, FSDs, and Minifilters. I became curious about the structural differences between Bus or Filter Drivers and traditional Function Drivers, as well as how vulnerabilities manifest in these different types.</p>\\n<p>Today, we will explore the structure and operation of Minifilter Drivers, examine their internal components, and analyze potential vulnerabilities.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image1.png\" alt></p>\\n<h1 id=\"1-About-Minifilter-Drivers\"><a href=\"#1-About-Minifilter-Drivers\" class=\"headerlink\" title=\"1. About Minifilter Drivers\"></a>1. About Minifilter Drivers</h1><hr>\\n<p>A Minifilter driver is a specialized type of driver in Windows designed to monitor, intercept, and modify file system I/O requests such as file creation, opening, reading, writing, and deletion. It is commonly used for precise monitoring of file system activity.</p>\\n<p>If you think about it in terms of <strong>&#x201C;monitoring, blocking, or modifying file access&#x201D;</strong>, it starts to sound familiar, doesn&#x2019;t it? Indeed &#x2014; this functionality is well-suited for products like <strong>antivirus software, EDR solutions, and backup programs</strong>. In fact, I&#x2019;ve personally confirmed that many such products rely on Minifilter drivers.</p>\\n<p>A Minifilter driver can intercept or manipulate the following three types of requests:</p>\\n<ol>\\n<li>IRP (I/O Request Packet)</li>\\n<li>Fast I/O</li>\\n<li>File System Filter Callbacks</li>\\n</ol>\\n<h2 id=\"1-1-Filter-Manager-&#x2192;-Minifilter-Flow\"><a href=\"#1-1-Filter-Manager-&#x2192;-Minifilter-Flow\" class=\"headerlink\" title=\"1.1 Filter Manager &#x2192; Minifilter Flow\"></a>1.1 Filter Manager &#x2192; Minifilter Flow</h2><p>A Minifilter operates on top of the Windows Filter Manager (<code>fltmgr.sys</code>). The Filter Manager receives file I/O requests from the I/O Manager and forwards them to the registered Minifilter drivers in the order determined by their <strong>altitude</strong>. In other words, the altitude controls the order in which filters are loaded and invoked.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image2.gif\" alt></p>\\n<p>Let&#x2019;s take a look at how file I/O requests are processed in Windows.</p>\\n<ol>\\n<li>An application issues an I/O operation by calling APIs such as <code>CreateFile</code>, <code>ReadFile</code>, or <code>WriteFile</code>.</li>\\n<li>The I/O Manager receives this request and forwards it to the Filter Manager (<code>fltmgr.sys</code>).</li>\\n<li>The Filter Manager checks the list of all registered Minifilter drivers and passes the request to each driver in the order of their altitude.</li>\\n<li>After the Minifilter completes its processing, the request is passed on to the file system filter driver.</li>\\n<li>Finally, the request is delivered to the disk driver (Storage Driver Stack), which accesses the physical disk or processes the data accordingly.</li>\\n</ol>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image3.png\" alt></p>\\n<p>You can check the list of Minifilter drivers loaded on the system by running the <code>fltmc</code> command in the Command Prompt.</p>\\n<p>The higher the altitude value, the higher the priority, meaning the Minifilter can intercept or modify I/O requests earlier. However, the processing order differs depending on whether it is a pre-operation or post-operation callback.</p>\\n<ul>\\n<li><strong>Pre-operation</strong>: Called in <strong>descending altitude order</strong> (high &#x2192; low)</li>\\n<li><strong>Post-operation</strong>: Called in <strong>ascending altitude order</strong> (low &#x2192; high)</li>\\n</ul>\\n<p>Looking back at the overall flow&#x2026; a Minifilter driver does not directly handle IRPs in the traditional way.</p>\\n<p>Instead, the Filter Manager receives I/O requests on its behalf and passes them to the Minifilter through callback functions.</p>\\n<p>In other words, a Minifilter driver does <strong>not</strong> need to set up the <strong>DispatchRoutine</strong> that we commonly associate with traditional drivers!</p>\\n<h2 id=\"1-2-Minifilter-Callback-Routine\"><a href=\"#1-2-Minifilter-Callback-Routine\" class=\"headerlink\" title=\"1.2 Minifilter Callback Routine\"></a>1.2 Minifilter Callback Routine</h2><p>How can a Minifilter driver operate only on specific file operations?</p>\\n<p>This is possible thanks to a mechanism called <strong>callbacks</strong>.</p>\\n<p>As mentioned earlier, a Minifilter driver does <strong>not</strong> directly process IRPs through a <code>DispatchRoutine</code>.</p>\\n<p>Instead, it can &#x201C;hook&#x201D; I/O requests delivered via the Filter Manager.</p>\\n<p>By registering <strong>pre-operation (<code>PreOperation Callback</code>)</strong> and <strong>post-operation (<code>PostOperation Callback</code>)</strong> callbacks, a Minifilter can monitor or control I/O operations at the system level when they occur.</p>\\n<ul>\\n<li><strong>Pre-operation callback (<code>PFLT_PRE_OPERATION_CALLBACK</code>)</strong></li>\\n</ul>\\n<pre><code class=\"hljs c\">PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;\\n\\n<span class=\"hljs-function\">FLT_PREOP_CALLBACK_STATUS <span class=\"hljs-title\">PfltPreOperationCallback</span><span class=\"hljs-params\">(</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in, out] PFLT_CALLBACK_DATA Data,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in]      PCFLT_RELATED_OBJECTS FltObjects,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [out]     PVOID *CompletionContext</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">)</span></span>\\n<span class=\"hljs-function\"></span>{...}</code></pre>\\n<p>Called before the I/O request is passed to the file system or lower drivers.</p>\\n<p>This is where the core logic of the Minifilter runs, with powerful capabilities such as returning</p>\\n<p><code>FLT_PREOP_COMPLETE</code>, <code>FLT_PREOP_SUCCESS_WITH_CALLBACK</code>, or <code>FLT_PREOP_SUCCESS_NO_CALLBACK</code>.</p>\\n<p><a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nc-fltkernel-pflt_pre_operation_callback\"><strong>PFLT_PRE_OPERATION_CALLBACK callback function (fltkernel.h)</strong></a></p>\\n<ul>\\n<li><strong>Post-operation callback (<code>PFLT_POST_OPERATION_CALLBACK</code>)</strong></li>\\n</ul>\\n<pre><code class=\"hljs c\">PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;\\n\\n<span class=\"hljs-function\">FLT_POSTOP_CALLBACK_STATUS <span class=\"hljs-title\">PfltPostOperationCallback</span><span class=\"hljs-params\">(</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in, out]      PFLT_CALLBACK_DATA Data,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in]           PCFLT_RELATED_OBJECTS FltObjects,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in, optional] PVOID CompletionContext,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in]           FLT_POST_OPERATION_FLAGS Flags</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">)</span></span>\\n<span class=\"hljs-function\"></span>{...}</code></pre>\\n<p>Called on the way back after the I/O request has been fully processed by lower drivers and the file system.</p>\\n<p>It is typically used to verify the success of the operation, log results, or modify the outcome if needed.</p>\\n<p><a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nc-fltkernel-pflt_post_operation_callback\"><strong>PFLT_POST_OPERATION_CALLBACK callback function (fltkernel.h)</strong></a></p>\\n<p>In short, these callbacks are registered in the <code>FLT_OPERATION_REGISTRATION</code> structure, which specifies <strong>which pre-/post-operation callbacks are associated with which I/O operations (MajorFunctions)</strong>.</p>\\n<hr>\\n<h2 id=\"1-3-Communication-Between-Minifilter-and-User-Mode\"><a href=\"#1-3-Communication-Between-Minifilter-and-User-Mode\" class=\"headerlink\" title=\"1.3 Communication Between Minifilter and User-Mode\"></a>1.3 Communication Between Minifilter and User-Mode</h2><p>Communication between a Minifilter driver and a User-Mode application is handled via a <strong>filter communication port</strong>.</p>\\n<p>This port acts as a dedicated high-speed communication channel between the Minifilter and the application, allowing safe message exchange between Kernel-Mode drivers and User-Mode processes.</p>\\n<p>Let&#x2019;s look into the code and explore the APIs provided by Microsoft for this purpose.</p>\\n<h3 id=\"Driver-Code\"><a href=\"#Driver-Code\" class=\"headerlink\" title=\"Driver Code\"></a>Driver Code</h3><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fltKernel.h&gt;</span></span>\\n\\nPFLT_FILTER gFilter = <span class=\"hljs-literal\">NULL</span>;\\nPFLT_PORT gServerPort = <span class=\"hljs-literal\">NULL</span>, gClientPort = <span class=\"hljs-literal\">NULL</span>;\\n\\n<span class=\"hljs-function\">VOID <span class=\"hljs-title\">OnDisconnect</span><span class=\"hljs-params\">(PVOID Cookie)</span> </span>{\\n    UNREFERENCED_PARAMETER(Cookie);\\n    FltCloseClientPort(gFilter, &amp;gClientPort);\\n    gClientPort = <span class=\"hljs-literal\">NULL</span>;\\n}\\n\\n<span class=\"hljs-function\">NTSTATUS <span class=\"hljs-title\">OnConnect</span><span class=\"hljs-params\">(PFLT_PORT ClientPort, PVOID SrvCookie, PVOID Ctx, ULONG Size, PVOID* ConnCookie)</span> </span>{\\n    UNREFERENCED_PARAMETER(SrvCookie);\\n    UNREFERENCED_PARAMETER(Ctx);\\n    UNREFERENCED_PARAMETER(Size);\\n    UNREFERENCED_PARAMETER(ConnCookie);\\n    gClientPort = ClientPort;\\n    <span class=\"hljs-keyword\">return</span> STATUS_SUCCESS;\\n}\\n\\n<span class=\"hljs-function\">FLT_PREOP_CALLBACK_STATUS <span class=\"hljs-title\">PreCreate</span><span class=\"hljs-params\">(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID* Buff)</span> </span>{\\n    UNREFERENCED_PARAMETER(FltObjects);\\n    UNREFERENCED_PARAMETER(Buff);\\n    PFLT_FILE_NAME_INFORMATION nameInfo;\\n\\n    <span class=\"hljs-keyword\">if</span> (gClientPort &amp;&amp; NT_SUCCESS(FltGetFileNameInformation(Data, FLT_FILE_NAME_NORMALIZED, &amp;nameInfo))) {\\n        FltSendMessage(gFilter, &amp;gClientPort, nameInfo-&gt;Name.Buffer, nameInfo-&gt;Name.Length, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>);\\n        FltReleaseFileNameInformation(nameInfo);\\n    }\\n    <span class=\"hljs-keyword\">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;\\n}\\n\\n<span class=\"hljs-function\">NTSTATUS <span class=\"hljs-title\">Unload</span><span class=\"hljs-params\">(FLT_FILTER_UNLOAD_FLAGS Flags)</span> </span>{\\n    UNREFERENCED_PARAMETER(Flags);\\n    FltCloseCommunicationPort(gServerPort);\\n    FltUnregisterFilter(gFilter);\\n    <span class=\"hljs-keyword\">return</span> STATUS_SUCCESS;\\n}\\n\\n<span class=\"hljs-function\">NTSTATUS <span class=\"hljs-title\">DriverEntry</span><span class=\"hljs-params\">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span> </span>{\\n    UNREFERENCED_PARAMETER(RegistryPath);\\n    NTSTATUS status;\\n\\n    <span class=\"hljs-keyword\">const</span> FLT_OPERATION_REGISTRATION Cbs[] = { { IRP_MJ_CREATE, <span class=\"hljs-number\">0</span>, PreCreate, <span class=\"hljs-literal\">NULL</span> }, { IRP_MJ_OPERATION_END } };\\n    <span class=\"hljs-keyword\">const</span> FLT_REGISTRATION Reg = { <span class=\"hljs-keyword\">sizeof</span>(FLT_REGISTRATION), FLT_REGISTRATION_VERSION, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">NULL</span>, Cbs, Unload };\\n\\n    status = FltRegisterFilter(DriverObject, &amp;Reg, &amp;gFilter);\\n    <span class=\"hljs-keyword\">if</span> (!NT_SUCCESS(status)) <span class=\"hljs-keyword\">return</span> status;\\n\\n    UNICODE_STRING portName = RTL_CONSTANT_STRING(<span class=\"hljs-string\">L&quot;\\\\\\\\FileActivityMonitorPort&quot;</span>);\\n    OBJECT_ATTRIBUTES oa = { <span class=\"hljs-keyword\">sizeof</span>(oa), <span class=\"hljs-literal\">NULL</span>, &amp;portName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class=\"hljs-literal\">NULL</span> };\\n\\n    status = FltCreateCommunicationPort(gFilter, &amp;gServerPort, &amp;oa, <span class=\"hljs-literal\">NULL</span>, OnConnect, OnDisconnect, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">1</span>);\\n    <span class=\"hljs-keyword\">if</span> (!NT_SUCCESS(status)) {\\n        FltUnregisterFilter(gFilter);\\n        <span class=\"hljs-keyword\">return</span> status;\\n    }\\n\\n    <span class=\"hljs-keyword\">return</span> FltStartFiltering(gFilter);\\n}</code></pre>\\n<p>Focusing on the representative driver code APIs <code>FltCreateCommunicationPort()</code>, <code>FltSendMessage()</code>, and <code>FltCloseCommunicationPort()</code>, I have implemented an example Minifilter driver code.</p>\\n<p>Let&#x2019;s walk through the flow together:</p>\\n<ol>\\n<li><p>The driver registers itself using <code>FltRegisterFilter()</code>.</p>\\n<p> At this stage, it specifies a <strong>PreCreateCallback</strong> function to monitor file creation and open (<code>IRP_MJ_CREATE</code>) requests, and starts I/O monitoring with <code>FltStartFiltering()</code>.</p>\\n</li>\\n<li><p>Using the <code>FltCreateCommunicationPort()</code> function, the driver can create a communication port.</p>\\n<p> In the code above, it creates the port <code>\\\\\\\\FileActivityMonitorPort</code>, which allows a User-Mode application to connect and receive notifications.</p>\\n</li>\\n<li><p>When a file create/open event occurs, <strong>PreCreateCallback</strong> is invoked, and the function collects information about which process accessed which file.</p>\\n</li>\\n<li>The driver then uses <code>FltSendMessage()</code> to immediately send the real-time file access information collected in <strong>PreCreateCallback</strong> to the connected User-Mode application.</li>\\n<li>Finally, in the <strong>FilterUnload</strong> routine, when the driver is unloaded, it closes the communication port with <code>FltCloseCommunicationPort()</code> and unregisters the filter.</li>\\n</ol>\\n<h3 id=\"User-Mode-Application-Code\"><a href=\"#User-Mode-Application-Code\" class=\"headerlink\" title=\"User-Mode Application Code\"></a>User-Mode Application Code</h3><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;windows.h&gt;</span></span>\\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fltuser.h&gt;</span></span>\\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span>\\n\\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> comment(lib, <span class=\"hljs-meta-string\">&quot;fltlib.lib&quot;</span>)</span>\\n\\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\\n    HANDLE port;\\n    HRESULT hr;\\n    \\n    BYTE buffer[<span class=\"hljs-keyword\">sizeof</span>(FILTER_MESSAGE_HEADER) + <span class=\"hljs-number\">1024</span>];\\n    PFILTER_MESSAGE_HEADER header = (PFILTER_MESSAGE_HEADER)buffer;\\n\\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connecting to driver...\\\\n&quot;</span>);\\n\\n    hr = FilterConnectCommunicationPort(<span class=\"hljs-string\">L&quot;\\\\\\\\FileActivityMonitorPort&quot;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">NULL</span>, &amp;port);\\n    <span class=\"hljs-keyword\">if</span> (IS_ERROR(hr)) {\\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connection failed. Error 0x%X\\\\n&quot;</span>, hr);\\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\\n    }\\n\\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connected. Waiting for file events...\\\\n&quot;</span>);\\n\\n    <span class=\"hljs-keyword\">while</span> (TRUE) {\\n        hr = FilterGetMessage(port, header, <span class=\"hljs-keyword\">sizeof</span>(buffer), <span class=\"hljs-literal\">NULL</span>);\\n        \\n        <span class=\"hljs-keyword\">if</span> (SUCCEEDED(hr)) {\\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;File Accessed: %S\\\\n&quot;</span>, (PWSTR)header-&gt;MessageBody);\\n        } <span class=\"hljs-keyword\">else</span> {\\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connection lost. Error 0x%X\\\\n&quot;</span>, hr);\\n            <span class=\"hljs-keyword\">break</span>;\\n        }\\n    }\\n\\n    CloseHandle(port);\\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\\n}</code></pre>\\n<p>Let&#x2019;s now look at the communication flow from the User-Mode application side.</p>\\n<p>Representative APIs include <code>FilterConnectCommunicationPort()</code> and <code>FilterSendMessage()</code>.</p>\\n<ol>\\n<li>First, the application uses <code>FilterConnectCommunicationPort()</code> to connect to the Minifilter driver&#x2019;s communication port in the kernel, <code>\\\\\\\\FileActivityMonitorPort</code>, and obtains a HANDLE for communication.</li>\\n<li><p>It then calls <code>FilterGetMessage()</code> to directly receive the file path string from the driver.</p>\\n<p> If the message is received successfully, the application outputs the file path to the screen.</p>\\n</li>\\n</ol>\\n<h1 id=\"2-CVE-2024-30085-1-Day-Analysis\"><a href=\"#2-CVE-2024-30085-1-Day-Analysis\" class=\"headerlink\" title=\"2. [CVE-2024-30085] 1-Day Analysis\"></a>2. [CVE-2024-30085] 1-Day Analysis</h1><hr>\\n<p>This is a Windows Minifilter Driver vulnerability that was also introduced in &#x201C;1day1line&#x201D; (<a href=\"https://hackyboiz.github.io/2025/01/11/OUYA77/2025-01-11/\">reference</a>).</p>\\n<p>Let&#x2019;s try to reproduce CVE-2024-30085 and, in the process, learn more about Minifilter drivers.</p>\\n<blockquote>\\n<p>&#x1FA9F; Environment: Windows 11 22H2/23H2 10.0.2261.3672</p>\\n</blockquote>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image4.png\" alt></p>\\n<p>The Windows Cloud Files Mini Filter driver is responsible for the Windows cloud sync feature.</p>\\n<p>For example, I&#x2019;ve taken a screenshot of one of my folders.</p>\\n<p>To understand this Minifilter driver vulnerability, we first need some background knowledge about Stub Files and Reparse Points.</p>\\n<h3 id=\"What-is-a-Stub-File\"><a href=\"#What-is-a-Stub-File\" class=\"headerlink\" title=\"What is a Stub File?\"></a>What is a Stub File?</h3><p>A stub file refers to a file that exists only as a placeholder locally, without containing any actual data.</p>\\n<p>As shown in the image above, the &#x201C;Pictures&#x201D; folder has a blue cloud icon in its status &#x2014; this indicates that the file is in a stub state.</p>\\n<p>On NTFS, its size, name, and icon are displayed, but its actual contents are not stored locally.</p>\\n<h3 id=\"Reparse-Point-Metadata\"><a href=\"#Reparse-Point-Metadata\" class=\"headerlink\" title=\"Reparse Point Metadata\"></a>Reparse Point Metadata</h3><p>So, what happens when a user tries to access such a file?</p>\\n<p>NTFS checks the Reparse Tag and determines, <strong>&#x201C;Oh&#x2026; this is a stub file!&#x201D;</strong>.</p>\\n<p>At this point, the Windows Cloud Files Minifilter (<code>cldflt.sys</code>) reads the <code>Reparse Point</code> metadata structure and decides how to handle the file.</p>\\n<p>After that, the Minifilter prepares for communication with the remote server.</p>\\n<p>However, <code>cldflt.sys</code> itself does not communicate directly with the server &#x2014; instead, it delegates the actual work to a User-Mode process.</p>\\n<p>This matches the concept we saw earlier: the Minifilter plays the role of an I/O interpreter, while the User-Mode client handles the actual data manipulation.</p>\\n<p>I&#x2019;ve added the Windows Cloud Files Minifilter&#x2019;s Reparse Point structure definitions to Local Types.</p>\\n<p>Let&#x2019;s take a look at the CldFlt structure set I defined.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> _<span class=\"hljs-title\">REPARSE_DATA_BUFFER</span> {</span>\\n    DWORD ReparseTag;\\n    WORD ReparseDataLength;\\n    WORD Reserved;\\n    WORD Flags;\\n    WORD UncompressedSize;\\n    REPARSE_CLD_BUFFER ReparseCldBuffer;\\n} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;</code></pre>\\n<p><code>REPARSE_DATA_BUFFER</code> is the standard header structure used to represent all Reparse Point data on NTFS.</p>\\n<p>Here, however, we use a redefined version to make analyzing Cloud Files easier.</p>\\n<p>This structure stores top-level metadata such as <code>ReparseTag</code> (to identify the owning driver), <code>ReparseDataLength</code>, and <code>Flags</code>, and then points to the actual data, which continues as an <code>HSM_REPARSE</code> structure.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_REPARSE</span> {</span>\\n    USHORT hsmFlags;\\n    USHORT hsmSize;\\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_DATA</span> <span class=\"hljs-title\">fileData</span>;</span>\\n};</code></pre>\\n<p><code>HSM_REPARSE</code> is the full container for a Cloud Files-specific Reparse Point.</p>\\n<p><code>hsmFlags</code> and <code>hsmSize</code> indicate whether compression is used and the total size of the HSM block.</p>\\n<p>The <code>fileData</code> field contains an <code>HSM_RP_DATA</code> structure.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_DATA</span> {</span>\\n    ULONG magic;\\n    ULONG crc32;\\n    ULONG totalSize;\\n    USHORT dataFlags;\\n    USHORT elemCount;\\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_ELEMENT</span> <span class=\"hljs-title\">elements</span>[5];</span>\\n};</code></pre>\\n<p><code>HSM_RP_DATA</code> is the main header, containing the layout and structure of the entire metadata block.</p>\\n<p><code>magic</code> identifies the data type, and if the CRC bit is set in <code>dataFlags</code>, <code>crc32</code> is validated using <code>RtlComputeCrc32</code>.</p>\\n<p>The <code>elements[]</code> array stores <code>HSM_RP_ELEMENT</code> structures that define the type, size, and offset of each metadata element.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_ELEMENT</span> {</span>\\n    USHORT elemType;\\n    USHORT elemSize;\\n    ULONG elemOffset;\\n};\\n\\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span> HSM_RP_ELEM_TYPE {\\n    HSM_RP_ELEMENT_NONE   = <span class=\"hljs-number\">0x00</span>,\\n    HSM_RP_ELEMENT_U64    = <span class=\"hljs-number\">0x06</span>,\\n    HSM_RP_ELEMENT_BYTE   = <span class=\"hljs-number\">0x07</span>,\\n    HSM_RP_ELEMENT_U32    = <span class=\"hljs-number\">0x0a</span>,\\n    HSM_RP_ELEMENT_BITMAP = <span class=\"hljs-number\">0x11</span>,\\n    HSM_RP_ELEMENT_MAX    = <span class=\"hljs-number\">0x12</span>\\n} HSM_RP_ELEMENT_TYPE;</code></pre>\\n<p><code>HSM_RP_ELEMENT</code> defines each individual metadata element&#x2019;s type, size, and offset.</p>\\n<p>The <code>HSM_RP_ELEMENT_TYPE</code> enumeration is used to classify element types.</p>\\n<h2 id=\"2-1-Root-Cause-Analysis\"><a href=\"#2-1-Root-Cause-Analysis\" class=\"headerlink\" title=\"2.1 Root Cause Analysis\"></a>2.1 Root Cause Analysis</h2><p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image5.png\" alt></p>\\n<p>The vulnerability occurs when a file is created and the <code>HsmFltPostCREATE</code> callback is executed to process the file&#x2019;s Reparse Point.</p>\\n<p>Within <code>HsmFltPostCREATE</code>, when handling the bitmap information stored in the Reparse Point, the function <code>HsmIBitmapNORMALOpen()</code> is called &#x2014; and this is where the flaw exists.</p>\\n<ul>\\n<li><code>bitmap_size</code> is read directly from the User-Mode request buffer.</li>\\n<li>A fixed-size buffer of 0x1000 bytes is allocated via <code>ExAllocatePoolWithTag</code>, but the user-controlled <code>bitmap_size</code> value is passed directly to <code>memmove</code> without any boundary checks.</li>\\n</ul>\\n<p>Therefore, if <code>bitmap_size</code> is greater than 0x1000, a Heap-based Buffer Overflow is expected to occur.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image6.png\" alt></p>\\n<p>Looking at the <code>HsmpBitmapIsReparseBufferSupported()</code> function, it returns an error if <code>hdr-&gt;elements[4].elemSize</code> is greater than <code>0x1000</code>.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image7.png\" alt></p>\\n<p>Looking a bit further up at the conditional statement code, we can see that <code>hdr-&gt;elements[2]</code> is being strictly validated. Checks such as <code>total &#x2265; 0x18</code> and <code>hdr-&gt;elemCount</code> boundary verification must all be passed in order to proceed. If these conditions are not met, it would return a failure, right?</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image8.png\" alt></p>\\n<p>However, in the same function, if <code>hasBuf</code> is set to <code>false</code>, the code returns <code>result = 0</code> (success) simply by checking the 1-byte flag of <code>element[1]</code>, without performing any separate bitmap length validation. In this path, there is no check to determine whether the bitmap length exceeds <code>0x1000</code>, so the validation is skipped and the data is treated as valid.</p>\\n<h2 id=\"2-2-Exploit\"><a href=\"#2-2-Exploit\" class=\"headerlink\" title=\"2.2 Exploit\"></a>2.2 Exploit</h2><p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image9.png\" alt></p>\\n<p>The <code>cldflt.sys</code> minifilter driver does not scan all file system I/O by default; instead, it only operates on paths within the Sync Root that are registered through the CfAPI. Therefore, the first step was to reach the root directory of a cloud sync folder by calling the <code>CfRegisterSyncRoot()</code> function.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image10.png\" alt></p>\\n<p>Once the Sync Root registration code is built and executed, such a folder is created. Inside this folder, cloud stub files and metadata may appear, and this becomes the point I can exploit.</p>\\n<pre><code class=\"hljs c\">-&gt; HsmFltPostCREATE()\\n-&gt; HsmiFltPostECPCREATE()\\n-&gt; HsmpSetupContexts()\\n-&gt; HsmpCtxCreateStreamContext()\\n-&gt; HsmIBitmapNORMALOpen()\\n</code></pre>\\n<p>Through dynamic analysis, it was confirmed that in order to reach the vulnerable function <code>HsmIBitmapNORMALOpen()</code>, the execution must sequentially pass through the above function chain and satisfy all conditional checks. My goal, therefore, is to fulfill all those conditions and reach the vulnerable <code>memmove</code> inside <code>HsmIBitmapNORMALOpen()</code>.</p>\\n<blockquote>\\n<p>Understanding the Flow as a Minifilter Driver</p>\\n</blockquote>\\n<p>Earlier, I mentioned that a minifilter driver calls specific callbacks depending on the IRP code when an I/O request occurs. To enter the vulnerable path, the process must begin at the <code>IRP_MJ_CREATE</code> Post-Create Callback (<code>HsmFltPostCREATE</code>) and proceed sequentially to the target function. These intermediate functions validate entry conditions based on file/stream attributes and Reparse Point information, so we can bypass them by crafting a special file structure.</p>\\n<ol>\\n<li>Use <code>MakeDataBuffer()</code> to create an <code>IO_REPARSE_TAG_CLOUD</code> structure &#x2192; The minifilter recognizes the file as a cloud stub file and enters the Reparse Point parsing logic.</li>\\n<li>Set Item Tag = <code>0x11</code> (Bitmap) &#x2192; Configure <code>Size</code> to <code>0x1000 + overSize</code> to trigger a heap overflow in <code>memmove()</code> by copying more than the allocated size. Ensure that other elements (Tags <code>0x7</code>, <code>0x6</code>, <code>0xA</code>, etc.) are also set to pass the minifilter&#x2019;s boundary checks.</li>\\n<li>Include a fake kernel object pointer in the overflow data &#x2192; Apply it with <code>FSCTL_SET_REPARSE_POINT</code>, then trigger <code>HsmIBitmapNORMALOpen()</code> by calling <code>CreateFile()</code>.</li>\\n</ol>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image11.png\" alt></p>\\n<p>When these conditions are met, we can confirm that the flow starts from <code>FltMgr</code> and reaches <code>HsmIBitmapNORMALOpen()</code>.</p>\\n<p>I&#x2019;d like to cover the full exploit process, but since today&#x2019;s focus is on explaining the minifilter and I&#x2019;ve already gone overboard with the length&#x2026; let&#x2019;s wrap up with a summary of the entire exploit scenario.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image12.png\" alt></p>\\n<blockquote>\\n<p>Proof of Concept Overview</p>\\n</blockquote>\\n<ol>\\n<li><p><strong>EPROCESS Structure Analysis and Token Field Offset Calculation</strong></p>\\n<p> Calculate the offset of the Token field within the EPROCESS structure to prepare for the subsequent SYSTEM token swap.</p>\\n</li>\\n<li><p><strong>First <code>WNF_STATE_DATA</code> Spray and Hole Creation</strong></p>\\n<p> Mass-allocate (<code>spray</code>) <code>WNF_STATE_DATA</code> objects of size 0x1000 (0xff0 data) and then free them to create heap holes in the kernel heap.</p>\\n</li>\\n<li><p><strong>Open Vulnerable Bitmap File and Trigger First Overflow</strong></p>\\n<p> Use <code>CfRegisterSyncRoot()</code> and manipulate the Reparse Point directory to prepare a vulnerable bitmap file within the Sync Root. Then, open the file with <code>CreateFile()</code> to reach the path:</p>\\n<p> <code>IRP_MJ_CREATE()</code> &#x2192; <code>HsmFltPostCREATE()</code> &#x2192; <code>HsmiFltPostECPCREATE()</code> &#x2192; <code>HsmpSetupContexts()</code> &#x2192; <code>HsmpCtxCreateStreamContext()</code> &#x2192; <code>HsmIBitmapNORMALOpen()</code></p>\\n<p> Trigger a heap overflow to modify the <code>DataSize</code> of an adjacent <code>WNF_STATE_DATA</code>, gaining OOB (Out-of-Bounds) read/write capability.</p>\\n</li>\\n<li><p><strong>Kernel Pointer Leak</strong></p>\\n<p> Use the modified <code>WNF_STATE_DATA</code> to read the <code>_KALPC_RESERVE</code> pointer and leak a kernel address.</p>\\n</li>\\n<li><p><strong>Second <code>WNF_STATE_DATA</code> Spray and Hole Creation</strong></p>\\n<p> Repeat the same spray-and-free process for <code>WNF_STATE_DATA</code> objects, but this time arrange for a <code>PipeAttribute</code> structure to be placed adjacent to the WNF object.</p>\\n</li>\\n<li><p><strong>Second Overflow to Manipulate <code>PipeAttribute</code></strong></p>\\n<p> Open a second bitmap file to trigger another heap overflow, overwriting the <code>Flink</code> pointer of the adjacent <code>PipeAttribute</code> with the address of a user-space fake <code>PipeAttribute</code> structure.</p>\\n</li>\\n<li><p><strong>Arbitrary Read to Retrieve EPROCESS/Token Addresses</strong></p>\\n<p> Use the fake <code>PipeAttribute</code> to access the ALPC Port structure, sequentially reading the EPROCESS address and Token address of the target process.</p>\\n</li>\\n<li><p><strong>Token Swapping and SYSTEM Privilege Escalation</strong></p>\\n<p> Perform an arbitrary write to replace the current process&#x2019;s Token value with the SYSTEM Token value, then launch <code>cmd.exe</code> with SYSTEM privileges.</p>\\n</li>\\n</ol>\\n<h3 id=\"ALPC-WNF\"><a href=\"#ALPC-WNF\" class=\"headerlink\" title=\"ALPC / WNF\"></a>ALPC / WNF</h3><p>The <code>_WNF_STATE_DATA</code> and <code>_ALPC_HANDLE_TABLE</code> structures are used to allocate arbitrary-sized kernel objects for heap holes and to leak kernel memory addresses. Since ALPC and WNF might be unfamiliar concepts, here is a brief explanation of the two subsystems relevant to this exploit:</p>\\n<blockquote>\\n<p><strong>ALPC (Asynchronous Local Procedure Call)</strong></p>\\n</blockquote>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image13.webp\" alt></p>\\n<p>ALPC is an inter-process communication (IPC) mechanism within the Windows kernel that uses client and server ports to exchange messages. By leveraging the <code>_ALPC_HANDLE_ENTRY</code> in the ALPC handle table, it is possible to store message buffer addresses. Since the size of this table is variable, it allows the creation of kernel objects of arbitrary size.</p>\\n<ul>\\n<li>When an ALPC port is created, an <code>_ALPC_HANDLE_TABLE</code> is allocated in the <strong>paged pool</strong> with a size of 0x80.</li>\\n<li>Each call to <code>NtAlpcCreateResourceReserve</code> creates a <code>_KALPC_RESERVE</code> object, and its address is added to the handle table.</li>\\n<li><p>By tampering with this structure, it becomes possible to obtain arbitrary kernel address read/write primitives.</p>\\n<p>  &#x2192; In the PoC, a fake <code>_KALPC_RESERVE</code> is injected to achieve arbitrary R/W.</p>\\n</li>\\n<li><p>ALPC handles can also be controlled from user mode, making them highly useful for exploitation.</p>\\n</li>\\n</ul>\\n<blockquote>\\n<p><strong>WNF (Windows Notification Facility)</strong></p>\\n</blockquote>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image14.webp\" alt></p>\\n<p>WNF is the Windows Notification Facility, and the <code>WNF_NAME_INSTANCE</code> kernel object contains an internal <code>_WNF_STATE_DATA</code> field whose size is variable. This allows direct control of the kernel object size from user mode using <code>NtCreateWnfStateName</code> + <code>NtUpdateWnfStateData</code>.</p>\\n<ul>\\n<li><code>_WNF_STATE_DATA</code> can be allocated with a size of 0x1000 (0x10 header + 0xFF0 data).</li>\\n<li>WNF objects can be mass-created for heap spraying, placing them adjacent to a target structure (e.g., an ALPC object).</li>\\n<li>In the PoC, WNF is used to create heap holes and then place them next to ALPC objects to trigger an overflow into the ALPC handle table.</li>\\n</ul>\\n<p>In particular, the PoC required registering a routine to create a pipe, which I found interesting.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PipeAttribute</span> {</span>\\n    LIST_ENTRY <span class=\"hljs-built_in\">list</span>;\\n    <span class=\"hljs-keyword\">char</span> *AttributeName;\\n    <span class=\"hljs-keyword\">uint64_t</span> AttributeValueSize;\\n    <span class=\"hljs-keyword\">char</span> *AttributeValue;\\n    <span class=\"hljs-keyword\">char</span> data[<span class=\"hljs-number\">0</span>];\\n};</code></pre>\\n<p>The pipe is configured so that the <code>AttributeValue</code> pointer in the modified <code>PipeAttribute</code> structure is set to a kernel memory address. This causes the kernel to read data from that address and return it to user mode. By combining the memory layout control achieved via ALPC with the WNF overflow, the pipe can be turned into an arbitrary read primitive, allowing leakage of kernel addresses.</p>\\n<h1 id=\"3-Conclusion\"><a href=\"#3-Conclusion\" class=\"headerlink\" title=\"3. Conclusion\"></a>3. Conclusion</h1><hr>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image15.gif\" alt></p>\\n<p>I&#x2019;ll wrap up by sharing the results of the LPE I implemented using the characteristics of the <code>cldflt.sys</code> Minifilter driver combined with the WNF + ALPC technique.</p>\\n<p>While studying Minifilters, I realized that although their operation, functions, and concepts may feel a bit unfamiliar, the way vulnerabilities are triggered and their root causes are, in the end, quite similar. So, there&#x2019;s no need to be too intimidated about diving into Minifilter exploitation!</p>\\n<p>If I get the chance, I&#x2019;d like to explore and study various other drivers I haven&#x2019;t looked into yet. I hope you&#x2019;ll look forward to my next write-up as well!</p>\\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a><strong>Reference</strong></h1><hr>\\n<p><a href=\"https://exploitreversing.com/2023/04/11/exploiting-reversing-er-series/\">https://exploitreversing.com/2023/04/11/exploiting-reversing-er-series/</a></p>\\n<p><a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts\">https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts</a></p>\\n<p><a href=\"https://starlabs.sg/blog/2024/all-i-want-for-christmas-is-a-cve-2024-30085-exploit/\">https://starlabs.sg/blog/2024/all-i-want-for-christmas-is-a-cve-2024-30085-exploit/</a></p>\\n<p><a href=\"https://ssd-disclosure.com/ssd-advisory-cldflt-heap-based-overflow-pe/\">https://ssd-disclosure.com/ssd-advisory-cldflt-heap-based-overflow-pe/</a></p>\\n<p><a href=\"https://reddogsecurity.substack.com/p/elevating-privileges-in-windows-insights?r=5awqb0&amp;utm_campaign=post&amp;utm_medium=web&amp;triedRedirect=true\">https://reddogsecurity.substack.com/p/elevating-privileges-in-windows-insights?r=5awqb0&amp;utm_campaign=post&amp;utm_medium=web&amp;triedRedirect=true</a></p>\\n<p><a href=\"https://medium.com/@WaterBucket/understanding-mini-filter-drivers-for-windows-vulnerability-research-exploit-development-391153c945d6\">https://medium.com/@WaterBucket/understanding-mini-filter-drivers-for-windows-vulnerability-research-exploit-development-391153c945d6</a></p>\\n - hack & life' url='https://hackyboiz.github.io/2025/08/15/banda/Minifilter-Driver/en/' language='ko-KR' keywords='' robots=None og_title='[Research] Walking Through Windows Minifilter Drivers (EN) - hackyboiz' og_description='<p>Hello, this is banda. This is my first time greeting you with an article on Windows Minifilter Drivers. &#x1F917;</p>\\n<p>While studying Windows Kernel Drivers recently, I discovered that there are various types of drivers categorized by purpose, such as Bus Drivers, Filter Drivers, FSDs, and Minifilters. I became curious about the structural differences between Bus or Filter Drivers and traditional Function Drivers, as well as how vulnerabilities manifest in these different types.</p>\\n<p>Today, we will explore the structure and operation of Minifilter Drivers, examine their internal components, and analyze potential vulnerabilities.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image1.png\" alt></p>\\n<h1 id=\"1-About-Minifilter-Drivers\"><a href=\"#1-About-Minifilter-Drivers\" class=\"headerlink\" title=\"1. About Minifilter Drivers\"></a>1. About Minifilter Drivers</h1><hr>\\n<p>A Minifilter driver is a specialized type of driver in Windows designed to monitor, intercept, and modify file system I/O requests such as file creation, opening, reading, writing, and deletion. It is commonly used for precise monitoring of file system activity.</p>\\n<p>If you think about it in terms of <strong>&#x201C;monitoring, blocking, or modifying file access&#x201D;</strong>, it starts to sound familiar, doesn&#x2019;t it? Indeed &#x2014; this functionality is well-suited for products like <strong>antivirus software, EDR solutions, and backup programs</strong>. In fact, I&#x2019;ve personally confirmed that many such products rely on Minifilter drivers.</p>\\n<p>A Minifilter driver can intercept or manipulate the following three types of requests:</p>\\n<ol>\\n<li>IRP (I/O Request Packet)</li>\\n<li>Fast I/O</li>\\n<li>File System Filter Callbacks</li>\\n</ol>\\n<h2 id=\"1-1-Filter-Manager-&#x2192;-Minifilter-Flow\"><a href=\"#1-1-Filter-Manager-&#x2192;-Minifilter-Flow\" class=\"headerlink\" title=\"1.1 Filter Manager &#x2192; Minifilter Flow\"></a>1.1 Filter Manager &#x2192; Minifilter Flow</h2><p>A Minifilter operates on top of the Windows Filter Manager (<code>fltmgr.sys</code>). The Filter Manager receives file I/O requests from the I/O Manager and forwards them to the registered Minifilter drivers in the order determined by their <strong>altitude</strong>. In other words, the altitude controls the order in which filters are loaded and invoked.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image2.gif\" alt></p>\\n<p>Let&#x2019;s take a look at how file I/O requests are processed in Windows.</p>\\n<ol>\\n<li>An application issues an I/O operation by calling APIs such as <code>CreateFile</code>, <code>ReadFile</code>, or <code>WriteFile</code>.</li>\\n<li>The I/O Manager receives this request and forwards it to the Filter Manager (<code>fltmgr.sys</code>).</li>\\n<li>The Filter Manager checks the list of all registered Minifilter drivers and passes the request to each driver in the order of their altitude.</li>\\n<li>After the Minifilter completes its processing, the request is passed on to the file system filter driver.</li>\\n<li>Finally, the request is delivered to the disk driver (Storage Driver Stack), which accesses the physical disk or processes the data accordingly.</li>\\n</ol>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image3.png\" alt></p>\\n<p>You can check the list of Minifilter drivers loaded on the system by running the <code>fltmc</code> command in the Command Prompt.</p>\\n<p>The higher the altitude value, the higher the priority, meaning the Minifilter can intercept or modify I/O requests earlier. However, the processing order differs depending on whether it is a pre-operation or post-operation callback.</p>\\n<ul>\\n<li><strong>Pre-operation</strong>: Called in <strong>descending altitude order</strong> (high &#x2192; low)</li>\\n<li><strong>Post-operation</strong>: Called in <strong>ascending altitude order</strong> (low &#x2192; high)</li>\\n</ul>\\n<p>Looking back at the overall flow&#x2026; a Minifilter driver does not directly handle IRPs in the traditional way.</p>\\n<p>Instead, the Filter Manager receives I/O requests on its behalf and passes them to the Minifilter through callback functions.</p>\\n<p>In other words, a Minifilter driver does <strong>not</strong> need to set up the <strong>DispatchRoutine</strong> that we commonly associate with traditional drivers!</p>\\n<h2 id=\"1-2-Minifilter-Callback-Routine\"><a href=\"#1-2-Minifilter-Callback-Routine\" class=\"headerlink\" title=\"1.2 Minifilter Callback Routine\"></a>1.2 Minifilter Callback Routine</h2><p>How can a Minifilter driver operate only on specific file operations?</p>\\n<p>This is possible thanks to a mechanism called <strong>callbacks</strong>.</p>\\n<p>As mentioned earlier, a Minifilter driver does <strong>not</strong> directly process IRPs through a <code>DispatchRoutine</code>.</p>\\n<p>Instead, it can &#x201C;hook&#x201D; I/O requests delivered via the Filter Manager.</p>\\n<p>By registering <strong>pre-operation (<code>PreOperation Callback</code>)</strong> and <strong>post-operation (<code>PostOperation Callback</code>)</strong> callbacks, a Minifilter can monitor or control I/O operations at the system level when they occur.</p>\\n<ul>\\n<li><strong>Pre-operation callback (<code>PFLT_PRE_OPERATION_CALLBACK</code>)</strong></li>\\n</ul>\\n<pre><code class=\"hljs c\">PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;\\n\\n<span class=\"hljs-function\">FLT_PREOP_CALLBACK_STATUS <span class=\"hljs-title\">PfltPreOperationCallback</span><span class=\"hljs-params\">(</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in, out] PFLT_CALLBACK_DATA Data,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in]      PCFLT_RELATED_OBJECTS FltObjects,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [out]     PVOID *CompletionContext</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">)</span></span>\\n<span class=\"hljs-function\"></span>{...}</code></pre>\\n<p>Called before the I/O request is passed to the file system or lower drivers.</p>\\n<p>This is where the core logic of the Minifilter runs, with powerful capabilities such as returning</p>\\n<p><code>FLT_PREOP_COMPLETE</code>, <code>FLT_PREOP_SUCCESS_WITH_CALLBACK</code>, or <code>FLT_PREOP_SUCCESS_NO_CALLBACK</code>.</p>\\n<p><a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nc-fltkernel-pflt_pre_operation_callback\"><strong>PFLT_PRE_OPERATION_CALLBACK callback function (fltkernel.h)</strong></a></p>\\n<ul>\\n<li><strong>Post-operation callback (<code>PFLT_POST_OPERATION_CALLBACK</code>)</strong></li>\\n</ul>\\n<pre><code class=\"hljs c\">PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;\\n\\n<span class=\"hljs-function\">FLT_POSTOP_CALLBACK_STATUS <span class=\"hljs-title\">PfltPostOperationCallback</span><span class=\"hljs-params\">(</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in, out]      PFLT_CALLBACK_DATA Data,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in]           PCFLT_RELATED_OBJECTS FltObjects,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in, optional] PVOID CompletionContext,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in]           FLT_POST_OPERATION_FLAGS Flags</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">)</span></span>\\n<span class=\"hljs-function\"></span>{...}</code></pre>\\n<p>Called on the way back after the I/O request has been fully processed by lower drivers and the file system.</p>\\n<p>It is typically used to verify the success of the operation, log results, or modify the outcome if needed.</p>\\n<p><a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nc-fltkernel-pflt_post_operation_callback\"><strong>PFLT_POST_OPERATION_CALLBACK callback function (fltkernel.h)</strong></a></p>\\n<p>In short, these callbacks are registered in the <code>FLT_OPERATION_REGISTRATION</code> structure, which specifies <strong>which pre-/post-operation callbacks are associated with which I/O operations (MajorFunctions)</strong>.</p>\\n<hr>\\n<h2 id=\"1-3-Communication-Between-Minifilter-and-User-Mode\"><a href=\"#1-3-Communication-Between-Minifilter-and-User-Mode\" class=\"headerlink\" title=\"1.3 Communication Between Minifilter and User-Mode\"></a>1.3 Communication Between Minifilter and User-Mode</h2><p>Communication between a Minifilter driver and a User-Mode application is handled via a <strong>filter communication port</strong>.</p>\\n<p>This port acts as a dedicated high-speed communication channel between the Minifilter and the application, allowing safe message exchange between Kernel-Mode drivers and User-Mode processes.</p>\\n<p>Let&#x2019;s look into the code and explore the APIs provided by Microsoft for this purpose.</p>\\n<h3 id=\"Driver-Code\"><a href=\"#Driver-Code\" class=\"headerlink\" title=\"Driver Code\"></a>Driver Code</h3><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fltKernel.h&gt;</span></span>\\n\\nPFLT_FILTER gFilter = <span class=\"hljs-literal\">NULL</span>;\\nPFLT_PORT gServerPort = <span class=\"hljs-literal\">NULL</span>, gClientPort = <span class=\"hljs-literal\">NULL</span>;\\n\\n<span class=\"hljs-function\">VOID <span class=\"hljs-title\">OnDisconnect</span><span class=\"hljs-params\">(PVOID Cookie)</span> </span>{\\n    UNREFERENCED_PARAMETER(Cookie);\\n    FltCloseClientPort(gFilter, &amp;gClientPort);\\n    gClientPort = <span class=\"hljs-literal\">NULL</span>;\\n}\\n\\n<span class=\"hljs-function\">NTSTATUS <span class=\"hljs-title\">OnConnect</span><span class=\"hljs-params\">(PFLT_PORT ClientPort, PVOID SrvCookie, PVOID Ctx, ULONG Size, PVOID* ConnCookie)</span> </span>{\\n    UNREFERENCED_PARAMETER(SrvCookie);\\n    UNREFERENCED_PARAMETER(Ctx);\\n    UNREFERENCED_PARAMETER(Size);\\n    UNREFERENCED_PARAMETER(ConnCookie);\\n    gClientPort = ClientPort;\\n    <span class=\"hljs-keyword\">return</span> STATUS_SUCCESS;\\n}\\n\\n<span class=\"hljs-function\">FLT_PREOP_CALLBACK_STATUS <span class=\"hljs-title\">PreCreate</span><span class=\"hljs-params\">(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID* Buff)</span> </span>{\\n    UNREFERENCED_PARAMETER(FltObjects);\\n    UNREFERENCED_PARAMETER(Buff);\\n    PFLT_FILE_NAME_INFORMATION nameInfo;\\n\\n    <span class=\"hljs-keyword\">if</span> (gClientPort &amp;&amp; NT_SUCCESS(FltGetFileNameInformation(Data, FLT_FILE_NAME_NORMALIZED, &amp;nameInfo))) {\\n        FltSendMessage(gFilter, &amp;gClientPort, nameInfo-&gt;Name.Buffer, nameInfo-&gt;Name.Length, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>);\\n        FltReleaseFileNameInformation(nameInfo);\\n    }\\n    <span class=\"hljs-keyword\">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;\\n}\\n\\n<span class=\"hljs-function\">NTSTATUS <span class=\"hljs-title\">Unload</span><span class=\"hljs-params\">(FLT_FILTER_UNLOAD_FLAGS Flags)</span> </span>{\\n    UNREFERENCED_PARAMETER(Flags);\\n    FltCloseCommunicationPort(gServerPort);\\n    FltUnregisterFilter(gFilter);\\n    <span class=\"hljs-keyword\">return</span> STATUS_SUCCESS;\\n}\\n\\n<span class=\"hljs-function\">NTSTATUS <span class=\"hljs-title\">DriverEntry</span><span class=\"hljs-params\">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span> </span>{\\n    UNREFERENCED_PARAMETER(RegistryPath);\\n    NTSTATUS status;\\n\\n    <span class=\"hljs-keyword\">const</span> FLT_OPERATION_REGISTRATION Cbs[] = { { IRP_MJ_CREATE, <span class=\"hljs-number\">0</span>, PreCreate, <span class=\"hljs-literal\">NULL</span> }, { IRP_MJ_OPERATION_END } };\\n    <span class=\"hljs-keyword\">const</span> FLT_REGISTRATION Reg = { <span class=\"hljs-keyword\">sizeof</span>(FLT_REGISTRATION), FLT_REGISTRATION_VERSION, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">NULL</span>, Cbs, Unload };\\n\\n    status = FltRegisterFilter(DriverObject, &amp;Reg, &amp;gFilter);\\n    <span class=\"hljs-keyword\">if</span> (!NT_SUCCESS(status)) <span class=\"hljs-keyword\">return</span> status;\\n\\n    UNICODE_STRING portName = RTL_CONSTANT_STRING(<span class=\"hljs-string\">L&quot;\\\\\\\\FileActivityMonitorPort&quot;</span>);\\n    OBJECT_ATTRIBUTES oa = { <span class=\"hljs-keyword\">sizeof</span>(oa), <span class=\"hljs-literal\">NULL</span>, &amp;portName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class=\"hljs-literal\">NULL</span> };\\n\\n    status = FltCreateCommunicationPort(gFilter, &amp;gServerPort, &amp;oa, <span class=\"hljs-literal\">NULL</span>, OnConnect, OnDisconnect, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">1</span>);\\n    <span class=\"hljs-keyword\">if</span> (!NT_SUCCESS(status)) {\\n        FltUnregisterFilter(gFilter);\\n        <span class=\"hljs-keyword\">return</span> status;\\n    }\\n\\n    <span class=\"hljs-keyword\">return</span> FltStartFiltering(gFilter);\\n}</code></pre>\\n<p>Focusing on the representative driver code APIs <code>FltCreateCommunicationPort()</code>, <code>FltSendMessage()</code>, and <code>FltCloseCommunicationPort()</code>, I have implemented an example Minifilter driver code.</p>\\n<p>Let&#x2019;s walk through the flow together:</p>\\n<ol>\\n<li><p>The driver registers itself using <code>FltRegisterFilter()</code>.</p>\\n<p> At this stage, it specifies a <strong>PreCreateCallback</strong> function to monitor file creation and open (<code>IRP_MJ_CREATE</code>) requests, and starts I/O monitoring with <code>FltStartFiltering()</code>.</p>\\n</li>\\n<li><p>Using the <code>FltCreateCommunicationPort()</code> function, the driver can create a communication port.</p>\\n<p> In the code above, it creates the port <code>\\\\\\\\FileActivityMonitorPort</code>, which allows a User-Mode application to connect and receive notifications.</p>\\n</li>\\n<li><p>When a file create/open event occurs, <strong>PreCreateCallback</strong> is invoked, and the function collects information about which process accessed which file.</p>\\n</li>\\n<li>The driver then uses <code>FltSendMessage()</code> to immediately send the real-time file access information collected in <strong>PreCreateCallback</strong> to the connected User-Mode application.</li>\\n<li>Finally, in the <strong>FilterUnload</strong> routine, when the driver is unloaded, it closes the communication port with <code>FltCloseCommunicationPort()</code> and unregisters the filter.</li>\\n</ol>\\n<h3 id=\"User-Mode-Application-Code\"><a href=\"#User-Mode-Application-Code\" class=\"headerlink\" title=\"User-Mode Application Code\"></a>User-Mode Application Code</h3><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;windows.h&gt;</span></span>\\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fltuser.h&gt;</span></span>\\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span>\\n\\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> comment(lib, <span class=\"hljs-meta-string\">&quot;fltlib.lib&quot;</span>)</span>\\n\\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\\n    HANDLE port;\\n    HRESULT hr;\\n    \\n    BYTE buffer[<span class=\"hljs-keyword\">sizeof</span>(FILTER_MESSAGE_HEADER) + <span class=\"hljs-number\">1024</span>];\\n    PFILTER_MESSAGE_HEADER header = (PFILTER_MESSAGE_HEADER)buffer;\\n\\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connecting to driver...\\\\n&quot;</span>);\\n\\n    hr = FilterConnectCommunicationPort(<span class=\"hljs-string\">L&quot;\\\\\\\\FileActivityMonitorPort&quot;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">NULL</span>, &amp;port);\\n    <span class=\"hljs-keyword\">if</span> (IS_ERROR(hr)) {\\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connection failed. Error 0x%X\\\\n&quot;</span>, hr);\\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\\n    }\\n\\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connected. Waiting for file events...\\\\n&quot;</span>);\\n\\n    <span class=\"hljs-keyword\">while</span> (TRUE) {\\n        hr = FilterGetMessage(port, header, <span class=\"hljs-keyword\">sizeof</span>(buffer), <span class=\"hljs-literal\">NULL</span>);\\n        \\n        <span class=\"hljs-keyword\">if</span> (SUCCEEDED(hr)) {\\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;File Accessed: %S\\\\n&quot;</span>, (PWSTR)header-&gt;MessageBody);\\n        } <span class=\"hljs-keyword\">else</span> {\\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connection lost. Error 0x%X\\\\n&quot;</span>, hr);\\n            <span class=\"hljs-keyword\">break</span>;\\n        }\\n    }\\n\\n    CloseHandle(port);\\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\\n}</code></pre>\\n<p>Let&#x2019;s now look at the communication flow from the User-Mode application side.</p>\\n<p>Representative APIs include <code>FilterConnectCommunicationPort()</code> and <code>FilterSendMessage()</code>.</p>\\n<ol>\\n<li>First, the application uses <code>FilterConnectCommunicationPort()</code> to connect to the Minifilter driver&#x2019;s communication port in the kernel, <code>\\\\\\\\FileActivityMonitorPort</code>, and obtains a HANDLE for communication.</li>\\n<li><p>It then calls <code>FilterGetMessage()</code> to directly receive the file path string from the driver.</p>\\n<p> If the message is received successfully, the application outputs the file path to the screen.</p>\\n</li>\\n</ol>\\n<h1 id=\"2-CVE-2024-30085-1-Day-Analysis\"><a href=\"#2-CVE-2024-30085-1-Day-Analysis\" class=\"headerlink\" title=\"2. [CVE-2024-30085] 1-Day Analysis\"></a>2. [CVE-2024-30085] 1-Day Analysis</h1><hr>\\n<p>This is a Windows Minifilter Driver vulnerability that was also introduced in &#x201C;1day1line&#x201D; (<a href=\"https://hackyboiz.github.io/2025/01/11/OUYA77/2025-01-11/\">reference</a>).</p>\\n<p>Let&#x2019;s try to reproduce CVE-2024-30085 and, in the process, learn more about Minifilter drivers.</p>\\n<blockquote>\\n<p>&#x1FA9F; Environment: Windows 11 22H2/23H2 10.0.2261.3672</p>\\n</blockquote>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image4.png\" alt></p>\\n<p>The Windows Cloud Files Mini Filter driver is responsible for the Windows cloud sync feature.</p>\\n<p>For example, I&#x2019;ve taken a screenshot of one of my folders.</p>\\n<p>To understand this Minifilter driver vulnerability, we first need some background knowledge about Stub Files and Reparse Points.</p>\\n<h3 id=\"What-is-a-Stub-File\"><a href=\"#What-is-a-Stub-File\" class=\"headerlink\" title=\"What is a Stub File?\"></a>What is a Stub File?</h3><p>A stub file refers to a file that exists only as a placeholder locally, without containing any actual data.</p>\\n<p>As shown in the image above, the &#x201C;Pictures&#x201D; folder has a blue cloud icon in its status &#x2014; this indicates that the file is in a stub state.</p>\\n<p>On NTFS, its size, name, and icon are displayed, but its actual contents are not stored locally.</p>\\n<h3 id=\"Reparse-Point-Metadata\"><a href=\"#Reparse-Point-Metadata\" class=\"headerlink\" title=\"Reparse Point Metadata\"></a>Reparse Point Metadata</h3><p>So, what happens when a user tries to access such a file?</p>\\n<p>NTFS checks the Reparse Tag and determines, <strong>&#x201C;Oh&#x2026; this is a stub file!&#x201D;</strong>.</p>\\n<p>At this point, the Windows Cloud Files Minifilter (<code>cldflt.sys</code>) reads the <code>Reparse Point</code> metadata structure and decides how to handle the file.</p>\\n<p>After that, the Minifilter prepares for communication with the remote server.</p>\\n<p>However, <code>cldflt.sys</code> itself does not communicate directly with the server &#x2014; instead, it delegates the actual work to a User-Mode process.</p>\\n<p>This matches the concept we saw earlier: the Minifilter plays the role of an I/O interpreter, while the User-Mode client handles the actual data manipulation.</p>\\n<p>I&#x2019;ve added the Windows Cloud Files Minifilter&#x2019;s Reparse Point structure definitions to Local Types.</p>\\n<p>Let&#x2019;s take a look at the CldFlt structure set I defined.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> _<span class=\"hljs-title\">REPARSE_DATA_BUFFER</span> {</span>\\n    DWORD ReparseTag;\\n    WORD ReparseDataLength;\\n    WORD Reserved;\\n    WORD Flags;\\n    WORD UncompressedSize;\\n    REPARSE_CLD_BUFFER ReparseCldBuffer;\\n} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;</code></pre>\\n<p><code>REPARSE_DATA_BUFFER</code> is the standard header structure used to represent all Reparse Point data on NTFS.</p>\\n<p>Here, however, we use a redefined version to make analyzing Cloud Files easier.</p>\\n<p>This structure stores top-level metadata such as <code>ReparseTag</code> (to identify the owning driver), <code>ReparseDataLength</code>, and <code>Flags</code>, and then points to the actual data, which continues as an <code>HSM_REPARSE</code> structure.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_REPARSE</span> {</span>\\n    USHORT hsmFlags;\\n    USHORT hsmSize;\\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_DATA</span> <span class=\"hljs-title\">fileData</span>;</span>\\n};</code></pre>\\n<p><code>HSM_REPARSE</code> is the full container for a Cloud Files-specific Reparse Point.</p>\\n<p><code>hsmFlags</code> and <code>hsmSize</code> indicate whether compression is used and the total size of the HSM block.</p>\\n<p>The <code>fileData</code> field contains an <code>HSM_RP_DATA</code> structure.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_DATA</span> {</span>\\n    ULONG magic;\\n    ULONG crc32;\\n    ULONG totalSize;\\n    USHORT dataFlags;\\n    USHORT elemCount;\\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_ELEMENT</span> <span class=\"hljs-title\">elements</span>[5];</span>\\n};</code></pre>\\n<p><code>HSM_RP_DATA</code> is the main header, containing the layout and structure of the entire metadata block.</p>\\n<p><code>magic</code> identifies the data type, and if the CRC bit is set in <code>dataFlags</code>, <code>crc32</code> is validated using <code>RtlComputeCrc32</code>.</p>\\n<p>The <code>elements[]</code> array stores <code>HSM_RP_ELEMENT</code> structures that define the type, size, and offset of each metadata element.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_ELEMENT</span> {</span>\\n    USHORT elemType;\\n    USHORT elemSize;\\n    ULONG elemOffset;\\n};\\n\\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span> HSM_RP_ELEM_TYPE {\\n    HSM_RP_ELEMENT_NONE   = <span class=\"hljs-number\">0x00</span>,\\n    HSM_RP_ELEMENT_U64    = <span class=\"hljs-number\">0x06</span>,\\n    HSM_RP_ELEMENT_BYTE   = <span class=\"hljs-number\">0x07</span>,\\n    HSM_RP_ELEMENT_U32    = <span class=\"hljs-number\">0x0a</span>,\\n    HSM_RP_ELEMENT_BITMAP = <span class=\"hljs-number\">0x11</span>,\\n    HSM_RP_ELEMENT_MAX    = <span class=\"hljs-number\">0x12</span>\\n} HSM_RP_ELEMENT_TYPE;</code></pre>\\n<p><code>HSM_RP_ELEMENT</code> defines each individual metadata element&#x2019;s type, size, and offset.</p>\\n<p>The <code>HSM_RP_ELEMENT_TYPE</code> enumeration is used to classify element types.</p>\\n<h2 id=\"2-1-Root-Cause-Analysis\"><a href=\"#2-1-Root-Cause-Analysis\" class=\"headerlink\" title=\"2.1 Root Cause Analysis\"></a>2.1 Root Cause Analysis</h2><p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image5.png\" alt></p>\\n<p>The vulnerability occurs when a file is created and the <code>HsmFltPostCREATE</code> callback is executed to process the file&#x2019;s Reparse Point.</p>\\n<p>Within <code>HsmFltPostCREATE</code>, when handling the bitmap information stored in the Reparse Point, the function <code>HsmIBitmapNORMALOpen()</code> is called &#x2014; and this is where the flaw exists.</p>\\n<ul>\\n<li><code>bitmap_size</code> is read directly from the User-Mode request buffer.</li>\\n<li>A fixed-size buffer of 0x1000 bytes is allocated via <code>ExAllocatePoolWithTag</code>, but the user-controlled <code>bitmap_size</code> value is passed directly to <code>memmove</code> without any boundary checks.</li>\\n</ul>\\n<p>Therefore, if <code>bitmap_size</code> is greater than 0x1000, a Heap-based Buffer Overflow is expected to occur.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image6.png\" alt></p>\\n<p>Looking at the <code>HsmpBitmapIsReparseBufferSupported()</code> function, it returns an error if <code>hdr-&gt;elements[4].elemSize</code> is greater than <code>0x1000</code>.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image7.png\" alt></p>\\n<p>Looking a bit further up at the conditional statement code, we can see that <code>hdr-&gt;elements[2]</code> is being strictly validated. Checks such as <code>total &#x2265; 0x18</code> and <code>hdr-&gt;elemCount</code> boundary verification must all be passed in order to proceed. If these conditions are not met, it would return a failure, right?</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image8.png\" alt></p>\\n<p>However, in the same function, if <code>hasBuf</code> is set to <code>false</code>, the code returns <code>result = 0</code> (success) simply by checking the 1-byte flag of <code>element[1]</code>, without performing any separate bitmap length validation. In this path, there is no check to determine whether the bitmap length exceeds <code>0x1000</code>, so the validation is skipped and the data is treated as valid.</p>\\n<h2 id=\"2-2-Exploit\"><a href=\"#2-2-Exploit\" class=\"headerlink\" title=\"2.2 Exploit\"></a>2.2 Exploit</h2><p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image9.png\" alt></p>\\n<p>The <code>cldflt.sys</code> minifilter driver does not scan all file system I/O by default; instead, it only operates on paths within the Sync Root that are registered through the CfAPI. Therefore, the first step was to reach the root directory of a cloud sync folder by calling the <code>CfRegisterSyncRoot()</code> function.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image10.png\" alt></p>\\n<p>Once the Sync Root registration code is built and executed, such a folder is created. Inside this folder, cloud stub files and metadata may appear, and this becomes the point I can exploit.</p>\\n<pre><code class=\"hljs c\">-&gt; HsmFltPostCREATE()\\n-&gt; HsmiFltPostECPCREATE()\\n-&gt; HsmpSetupContexts()\\n-&gt; HsmpCtxCreateStreamContext()\\n-&gt; HsmIBitmapNORMALOpen()\\n</code></pre>\\n<p>Through dynamic analysis, it was confirmed that in order to reach the vulnerable function <code>HsmIBitmapNORMALOpen()</code>, the execution must sequentially pass through the above function chain and satisfy all conditional checks. My goal, therefore, is to fulfill all those conditions and reach the vulnerable <code>memmove</code> inside <code>HsmIBitmapNORMALOpen()</code>.</p>\\n<blockquote>\\n<p>Understanding the Flow as a Minifilter Driver</p>\\n</blockquote>\\n<p>Earlier, I mentioned that a minifilter driver calls specific callbacks depending on the IRP code when an I/O request occurs. To enter the vulnerable path, the process must begin at the <code>IRP_MJ_CREATE</code> Post-Create Callback (<code>HsmFltPostCREATE</code>) and proceed sequentially to the target function. These intermediate functions validate entry conditions based on file/stream attributes and Reparse Point information, so we can bypass them by crafting a special file structure.</p>\\n<ol>\\n<li>Use <code>MakeDataBuffer()</code> to create an <code>IO_REPARSE_TAG_CLOUD</code> structure &#x2192; The minifilter recognizes the file as a cloud stub file and enters the Reparse Point parsing logic.</li>\\n<li>Set Item Tag = <code>0x11</code> (Bitmap) &#x2192; Configure <code>Size</code> to <code>0x1000 + overSize</code> to trigger a heap overflow in <code>memmove()</code> by copying more than the allocated size. Ensure that other elements (Tags <code>0x7</code>, <code>0x6</code>, <code>0xA</code>, etc.) are also set to pass the minifilter&#x2019;s boundary checks.</li>\\n<li>Include a fake kernel object pointer in the overflow data &#x2192; Apply it with <code>FSCTL_SET_REPARSE_POINT</code>, then trigger <code>HsmIBitmapNORMALOpen()</code> by calling <code>CreateFile()</code>.</li>\\n</ol>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image11.png\" alt></p>\\n<p>When these conditions are met, we can confirm that the flow starts from <code>FltMgr</code> and reaches <code>HsmIBitmapNORMALOpen()</code>.</p>\\n<p>I&#x2019;d like to cover the full exploit process, but since today&#x2019;s focus is on explaining the minifilter and I&#x2019;ve already gone overboard with the length&#x2026; let&#x2019;s wrap up with a summary of the entire exploit scenario.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image12.png\" alt></p>\\n<blockquote>\\n<p>Proof of Concept Overview</p>\\n</blockquote>\\n<ol>\\n<li><p><strong>EPROCESS Structure Analysis and Token Field Offset Calculation</strong></p>\\n<p> Calculate the offset of the Token field within the EPROCESS structure to prepare for the subsequent SYSTEM token swap.</p>\\n</li>\\n<li><p><strong>First <code>WNF_STATE_DATA</code> Spray and Hole Creation</strong></p>\\n<p> Mass-allocate (<code>spray</code>) <code>WNF_STATE_DATA</code> objects of size 0x1000 (0xff0 data) and then free them to create heap holes in the kernel heap.</p>\\n</li>\\n<li><p><strong>Open Vulnerable Bitmap File and Trigger First Overflow</strong></p>\\n<p> Use <code>CfRegisterSyncRoot()</code> and manipulate the Reparse Point directory to prepare a vulnerable bitmap file within the Sync Root. Then, open the file with <code>CreateFile()</code> to reach the path:</p>\\n<p> <code>IRP_MJ_CREATE()</code> &#x2192; <code>HsmFltPostCREATE()</code> &#x2192; <code>HsmiFltPostECPCREATE()</code> &#x2192; <code>HsmpSetupContexts()</code> &#x2192; <code>HsmpCtxCreateStreamContext()</code> &#x2192; <code>HsmIBitmapNORMALOpen()</code></p>\\n<p> Trigger a heap overflow to modify the <code>DataSize</code> of an adjacent <code>WNF_STATE_DATA</code>, gaining OOB (Out-of-Bounds) read/write capability.</p>\\n</li>\\n<li><p><strong>Kernel Pointer Leak</strong></p>\\n<p> Use the modified <code>WNF_STATE_DATA</code> to read the <code>_KALPC_RESERVE</code> pointer and leak a kernel address.</p>\\n</li>\\n<li><p><strong>Second <code>WNF_STATE_DATA</code> Spray and Hole Creation</strong></p>\\n<p> Repeat the same spray-and-free process for <code>WNF_STATE_DATA</code> objects, but this time arrange for a <code>PipeAttribute</code> structure to be placed adjacent to the WNF object.</p>\\n</li>\\n<li><p><strong>Second Overflow to Manipulate <code>PipeAttribute</code></strong></p>\\n<p> Open a second bitmap file to trigger another heap overflow, overwriting the <code>Flink</code> pointer of the adjacent <code>PipeAttribute</code> with the address of a user-space fake <code>PipeAttribute</code> structure.</p>\\n</li>\\n<li><p><strong>Arbitrary Read to Retrieve EPROCESS/Token Addresses</strong></p>\\n<p> Use the fake <code>PipeAttribute</code> to access the ALPC Port structure, sequentially reading the EPROCESS address and Token address of the target process.</p>\\n</li>\\n<li><p><strong>Token Swapping and SYSTEM Privilege Escalation</strong></p>\\n<p> Perform an arbitrary write to replace the current process&#x2019;s Token value with the SYSTEM Token value, then launch <code>cmd.exe</code> with SYSTEM privileges.</p>\\n</li>\\n</ol>\\n<h3 id=\"ALPC-WNF\"><a href=\"#ALPC-WNF\" class=\"headerlink\" title=\"ALPC / WNF\"></a>ALPC / WNF</h3><p>The <code>_WNF_STATE_DATA</code> and <code>_ALPC_HANDLE_TABLE</code> structures are used to allocate arbitrary-sized kernel objects for heap holes and to leak kernel memory addresses. Since ALPC and WNF might be unfamiliar concepts, here is a brief explanation of the two subsystems relevant to this exploit:</p>\\n<blockquote>\\n<p><strong>ALPC (Asynchronous Local Procedure Call)</strong></p>\\n</blockquote>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image13.webp\" alt></p>\\n<p>ALPC is an inter-process communication (IPC) mechanism within the Windows kernel that uses client and server ports to exchange messages. By leveraging the <code>_ALPC_HANDLE_ENTRY</code> in the ALPC handle table, it is possible to store message buffer addresses. Since the size of this table is variable, it allows the creation of kernel objects of arbitrary size.</p>\\n<ul>\\n<li>When an ALPC port is created, an <code>_ALPC_HANDLE_TABLE</code> is allocated in the <strong>paged pool</strong> with a size of 0x80.</li>\\n<li>Each call to <code>NtAlpcCreateResourceReserve</code> creates a <code>_KALPC_RESERVE</code> object, and its address is added to the handle table.</li>\\n<li><p>By tampering with this structure, it becomes possible to obtain arbitrary kernel address read/write primitives.</p>\\n<p>  &#x2192; In the PoC, a fake <code>_KALPC_RESERVE</code> is injected to achieve arbitrary R/W.</p>\\n</li>\\n<li><p>ALPC handles can also be controlled from user mode, making them highly useful for exploitation.</p>\\n</li>\\n</ul>\\n<blockquote>\\n<p><strong>WNF (Windows Notification Facility)</strong></p>\\n</blockquote>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image14.webp\" alt></p>\\n<p>WNF is the Windows Notification Facility, and the <code>WNF_NAME_INSTANCE</code> kernel object contains an internal <code>_WNF_STATE_DATA</code> field whose size is variable. This allows direct control of the kernel object size from user mode using <code>NtCreateWnfStateName</code> + <code>NtUpdateWnfStateData</code>.</p>\\n<ul>\\n<li><code>_WNF_STATE_DATA</code> can be allocated with a size of 0x1000 (0x10 header + 0xFF0 data).</li>\\n<li>WNF objects can be mass-created for heap spraying, placing them adjacent to a target structure (e.g., an ALPC object).</li>\\n<li>In the PoC, WNF is used to create heap holes and then place them next to ALPC objects to trigger an overflow into the ALPC handle table.</li>\\n</ul>\\n<p>In particular, the PoC required registering a routine to create a pipe, which I found interesting.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PipeAttribute</span> {</span>\\n    LIST_ENTRY <span class=\"hljs-built_in\">list</span>;\\n    <span class=\"hljs-keyword\">char</span> *AttributeName;\\n    <span class=\"hljs-keyword\">uint64_t</span> AttributeValueSize;\\n    <span class=\"hljs-keyword\">char</span> *AttributeValue;\\n    <span class=\"hljs-keyword\">char</span> data[<span class=\"hljs-number\">0</span>];\\n};</code></pre>\\n<p>The pipe is configured so that the <code>AttributeValue</code> pointer in the modified <code>PipeAttribute</code> structure is set to a kernel memory address. This causes the kernel to read data from that address and return it to user mode. By combining the memory layout control achieved via ALPC with the WNF overflow, the pipe can be turned into an arbitrary read primitive, allowing leakage of kernel addresses.</p>\\n<h1 id=\"3-Conclusion\"><a href=\"#3-Conclusion\" class=\"headerlink\" title=\"3. Conclusion\"></a>3. Conclusion</h1><hr>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image15.gif\" alt></p>\\n<p>I&#x2019;ll wrap up by sharing the results of the LPE I implemented using the characteristics of the <code>cldflt.sys</code> Minifilter driver combined with the WNF + ALPC technique.</p>\\n<p>While studying Minifilters, I realized that although their operation, functions, and concepts may feel a bit unfamiliar, the way vulnerabilities are triggered and their root causes are, in the end, quite similar. So, there&#x2019;s no need to be too intimidated about diving into Minifilter exploitation!</p>\\n<p>If I get the chance, I&#x2019;d like to explore and study various other drivers I haven&#x2019;t looked into yet. I hope you&#x2019;ll look forward to my next write-up as well!</p>\\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a><strong>Reference</strong></h1><hr>\\n<p><a href=\"https://exploitreversing.com/2023/04/11/exploiting-reversing-er-series/\">https://exploitreversing.com/2023/04/11/exploiting-reversing-er-series/</a></p>\\n<p><a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts\">https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts</a></p>\\n<p><a href=\"https://starlabs.sg/blog/2024/all-i-want-for-christmas-is-a-cve-2024-30085-exploit/\">https://starlabs.sg/blog/2024/all-i-want-for-christmas-is-a-cve-2024-30085-exploit/</a></p>\\n<p><a href=\"https://ssd-disclosure.com/ssd-advisory-cldflt-heap-based-overflow-pe/\">https://ssd-disclosure.com/ssd-advisory-cldflt-heap-based-overflow-pe/</a></p>\\n<p><a href=\"https://reddogsecurity.substack.com/p/elevating-privileges-in-windows-insights?r=5awqb0&amp;utm_campaign=post&amp;utm_medium=web&amp;triedRedirect=true\">https://reddogsecurity.substack.com/p/elevating-privileges-in-windows-insights?r=5awqb0&amp;utm_campaign=post&amp;utm_medium=web&amp;triedRedirect=true</a></p>\\n<p><a href=\"https://medium.com/@WaterBucket/understanding-mini-filter-drivers-for-windows-vulnerability-research-exploit-development-391153c945d6\">https://medium.com/@WaterBucket/understanding-mini-filter-drivers-for-windows-vulnerability-research-exploit-development-391153c945d6</a></p>\\n - hack & life' og_url='https://hackyboiz.github.io/' og_image='https://hackyboiz.github.io/2025/08/15/banda/Minifilter-Driver/en/minifilter.png' og_audio=None og_determiner=None og_locale=None og_locale_alternate=None og_site_name=None og_video=None favicon='https://hackyboiz.github.io/img/favicon.ico' dc_terms_created=None dc_date_created=None dc_date=None dc_terms_type=None dc_type=None dc_terms_audience=None dc_terms_subject=None dc_subject=None dc_description=None dc_terms_keywords=None modified_time=None published_time=None article_tag=None article_section=None source_url='https://hackyboiz.github.io/2025/08/15/banda/Minifilter-Driver/en/' status_code=200 scrape_id='019c7062-7f9d-7219-8bab-d78b9550d586' num_pages=None content_type='text/html; charset=utf-8' proxy_used='basic' timezone='America/New_York' cache_state='miss' cached_at=None credits_used=1 concurrency_limited=False concurrency_queue_duration_ms=None error=None og:type='website' og:description='<p>Hello, this is banda. This is my first time greeting you with an article on Windows Minifilter Drivers. &#x1F917;</p>\\n<p>While studying Windows Kernel Drivers recently, I discovered that there are various types of drivers categorized by purpose, such as Bus Drivers, Filter Drivers, FSDs, and Minifilters. I became curious about the structural differences between Bus or Filter Drivers and traditional Function Drivers, as well as how vulnerabilities manifest in these different types.</p>\\n<p>Today, we will explore the structure and operation of Minifilter Drivers, examine their internal components, and analyze potential vulnerabilities.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image1.png\" alt></p>\\n<h1 id=\"1-About-Minifilter-Drivers\"><a href=\"#1-About-Minifilter-Drivers\" class=\"headerlink\" title=\"1. About Minifilter Drivers\"></a>1. About Minifilter Drivers</h1><hr>\\n<p>A Minifilter driver is a specialized type of driver in Windows designed to monitor, intercept, and modify file system I/O requests such as file creation, opening, reading, writing, and deletion. It is commonly used for precise monitoring of file system activity.</p>\\n<p>If you think about it in terms of <strong>&#x201C;monitoring, blocking, or modifying file access&#x201D;</strong>, it starts to sound familiar, doesn&#x2019;t it? Indeed &#x2014; this functionality is well-suited for products like <strong>antivirus software, EDR solutions, and backup programs</strong>. In fact, I&#x2019;ve personally confirmed that many such products rely on Minifilter drivers.</p>\\n<p>A Minifilter driver can intercept or manipulate the following three types of requests:</p>\\n<ol>\\n<li>IRP (I/O Request Packet)</li>\\n<li>Fast I/O</li>\\n<li>File System Filter Callbacks</li>\\n</ol>\\n<h2 id=\"1-1-Filter-Manager-&#x2192;-Minifilter-Flow\"><a href=\"#1-1-Filter-Manager-&#x2192;-Minifilter-Flow\" class=\"headerlink\" title=\"1.1 Filter Manager &#x2192; Minifilter Flow\"></a>1.1 Filter Manager &#x2192; Minifilter Flow</h2><p>A Minifilter operates on top of the Windows Filter Manager (<code>fltmgr.sys</code>). The Filter Manager receives file I/O requests from the I/O Manager and forwards them to the registered Minifilter drivers in the order determined by their <strong>altitude</strong>. In other words, the altitude controls the order in which filters are loaded and invoked.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image2.gif\" alt></p>\\n<p>Let&#x2019;s take a look at how file I/O requests are processed in Windows.</p>\\n<ol>\\n<li>An application issues an I/O operation by calling APIs such as <code>CreateFile</code>, <code>ReadFile</code>, or <code>WriteFile</code>.</li>\\n<li>The I/O Manager receives this request and forwards it to the Filter Manager (<code>fltmgr.sys</code>).</li>\\n<li>The Filter Manager checks the list of all registered Minifilter drivers and passes the request to each driver in the order of their altitude.</li>\\n<li>After the Minifilter completes its processing, the request is passed on to the file system filter driver.</li>\\n<li>Finally, the request is delivered to the disk driver (Storage Driver Stack), which accesses the physical disk or processes the data accordingly.</li>\\n</ol>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image3.png\" alt></p>\\n<p>You can check the list of Minifilter drivers loaded on the system by running the <code>fltmc</code> command in the Command Prompt.</p>\\n<p>The higher the altitude value, the higher the priority, meaning the Minifilter can intercept or modify I/O requests earlier. However, the processing order differs depending on whether it is a pre-operation or post-operation callback.</p>\\n<ul>\\n<li><strong>Pre-operation</strong>: Called in <strong>descending altitude order</strong> (high &#x2192; low)</li>\\n<li><strong>Post-operation</strong>: Called in <strong>ascending altitude order</strong> (low &#x2192; high)</li>\\n</ul>\\n<p>Looking back at the overall flow&#x2026; a Minifilter driver does not directly handle IRPs in the traditional way.</p>\\n<p>Instead, the Filter Manager receives I/O requests on its behalf and passes them to the Minifilter through callback functions.</p>\\n<p>In other words, a Minifilter driver does <strong>not</strong> need to set up the <strong>DispatchRoutine</strong> that we commonly associate with traditional drivers!</p>\\n<h2 id=\"1-2-Minifilter-Callback-Routine\"><a href=\"#1-2-Minifilter-Callback-Routine\" class=\"headerlink\" title=\"1.2 Minifilter Callback Routine\"></a>1.2 Minifilter Callback Routine</h2><p>How can a Minifilter driver operate only on specific file operations?</p>\\n<p>This is possible thanks to a mechanism called <strong>callbacks</strong>.</p>\\n<p>As mentioned earlier, a Minifilter driver does <strong>not</strong> directly process IRPs through a <code>DispatchRoutine</code>.</p>\\n<p>Instead, it can &#x201C;hook&#x201D; I/O requests delivered via the Filter Manager.</p>\\n<p>By registering <strong>pre-operation (<code>PreOperation Callback</code>)</strong> and <strong>post-operation (<code>PostOperation Callback</code>)</strong> callbacks, a Minifilter can monitor or control I/O operations at the system level when they occur.</p>\\n<ul>\\n<li><strong>Pre-operation callback (<code>PFLT_PRE_OPERATION_CALLBACK</code>)</strong></li>\\n</ul>\\n<pre><code class=\"hljs c\">PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;\\n\\n<span class=\"hljs-function\">FLT_PREOP_CALLBACK_STATUS <span class=\"hljs-title\">PfltPreOperationCallback</span><span class=\"hljs-params\">(</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in, out] PFLT_CALLBACK_DATA Data,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in]      PCFLT_RELATED_OBJECTS FltObjects,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [out]     PVOID *CompletionContext</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">)</span></span>\\n<span class=\"hljs-function\"></span>{...}</code></pre>\\n<p>Called before the I/O request is passed to the file system or lower drivers.</p>\\n<p>This is where the core logic of the Minifilter runs, with powerful capabilities such as returning</p>\\n<p><code>FLT_PREOP_COMPLETE</code>, <code>FLT_PREOP_SUCCESS_WITH_CALLBACK</code>, or <code>FLT_PREOP_SUCCESS_NO_CALLBACK</code>.</p>\\n<p><a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nc-fltkernel-pflt_pre_operation_callback\"><strong>PFLT_PRE_OPERATION_CALLBACK callback function (fltkernel.h)</strong></a></p>\\n<ul>\\n<li><strong>Post-operation callback (<code>PFLT_POST_OPERATION_CALLBACK</code>)</strong></li>\\n</ul>\\n<pre><code class=\"hljs c\">PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;\\n\\n<span class=\"hljs-function\">FLT_POSTOP_CALLBACK_STATUS <span class=\"hljs-title\">PfltPostOperationCallback</span><span class=\"hljs-params\">(</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in, out]      PFLT_CALLBACK_DATA Data,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in]           PCFLT_RELATED_OBJECTS FltObjects,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in, optional] PVOID CompletionContext,</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">  [in]           FLT_POST_OPERATION_FLAGS Flags</span></span>\\n<span class=\"hljs-function\"><span class=\"hljs-params\">)</span></span>\\n<span class=\"hljs-function\"></span>{...}</code></pre>\\n<p>Called on the way back after the I/O request has been fully processed by lower drivers and the file system.</p>\\n<p>It is typically used to verify the success of the operation, log results, or modify the outcome if needed.</p>\\n<p><a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nc-fltkernel-pflt_post_operation_callback\"><strong>PFLT_POST_OPERATION_CALLBACK callback function (fltkernel.h)</strong></a></p>\\n<p>In short, these callbacks are registered in the <code>FLT_OPERATION_REGISTRATION</code> structure, which specifies <strong>which pre-/post-operation callbacks are associated with which I/O operations (MajorFunctions)</strong>.</p>\\n<hr>\\n<h2 id=\"1-3-Communication-Between-Minifilter-and-User-Mode\"><a href=\"#1-3-Communication-Between-Minifilter-and-User-Mode\" class=\"headerlink\" title=\"1.3 Communication Between Minifilter and User-Mode\"></a>1.3 Communication Between Minifilter and User-Mode</h2><p>Communication between a Minifilter driver and a User-Mode application is handled via a <strong>filter communication port</strong>.</p>\\n<p>This port acts as a dedicated high-speed communication channel between the Minifilter and the application, allowing safe message exchange between Kernel-Mode drivers and User-Mode processes.</p>\\n<p>Let&#x2019;s look into the code and explore the APIs provided by Microsoft for this purpose.</p>\\n<h3 id=\"Driver-Code\"><a href=\"#Driver-Code\" class=\"headerlink\" title=\"Driver Code\"></a>Driver Code</h3><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fltKernel.h&gt;</span></span>\\n\\nPFLT_FILTER gFilter = <span class=\"hljs-literal\">NULL</span>;\\nPFLT_PORT gServerPort = <span class=\"hljs-literal\">NULL</span>, gClientPort = <span class=\"hljs-literal\">NULL</span>;\\n\\n<span class=\"hljs-function\">VOID <span class=\"hljs-title\">OnDisconnect</span><span class=\"hljs-params\">(PVOID Cookie)</span> </span>{\\n    UNREFERENCED_PARAMETER(Cookie);\\n    FltCloseClientPort(gFilter, &amp;gClientPort);\\n    gClientPort = <span class=\"hljs-literal\">NULL</span>;\\n}\\n\\n<span class=\"hljs-function\">NTSTATUS <span class=\"hljs-title\">OnConnect</span><span class=\"hljs-params\">(PFLT_PORT ClientPort, PVOID SrvCookie, PVOID Ctx, ULONG Size, PVOID* ConnCookie)</span> </span>{\\n    UNREFERENCED_PARAMETER(SrvCookie);\\n    UNREFERENCED_PARAMETER(Ctx);\\n    UNREFERENCED_PARAMETER(Size);\\n    UNREFERENCED_PARAMETER(ConnCookie);\\n    gClientPort = ClientPort;\\n    <span class=\"hljs-keyword\">return</span> STATUS_SUCCESS;\\n}\\n\\n<span class=\"hljs-function\">FLT_PREOP_CALLBACK_STATUS <span class=\"hljs-title\">PreCreate</span><span class=\"hljs-params\">(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS FltObjects, PVOID* Buff)</span> </span>{\\n    UNREFERENCED_PARAMETER(FltObjects);\\n    UNREFERENCED_PARAMETER(Buff);\\n    PFLT_FILE_NAME_INFORMATION nameInfo;\\n\\n    <span class=\"hljs-keyword\">if</span> (gClientPort &amp;&amp; NT_SUCCESS(FltGetFileNameInformation(Data, FLT_FILE_NAME_NORMALIZED, &amp;nameInfo))) {\\n        FltSendMessage(gFilter, &amp;gClientPort, nameInfo-&gt;Name.Buffer, nameInfo-&gt;Name.Length, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>);\\n        FltReleaseFileNameInformation(nameInfo);\\n    }\\n    <span class=\"hljs-keyword\">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;\\n}\\n\\n<span class=\"hljs-function\">NTSTATUS <span class=\"hljs-title\">Unload</span><span class=\"hljs-params\">(FLT_FILTER_UNLOAD_FLAGS Flags)</span> </span>{\\n    UNREFERENCED_PARAMETER(Flags);\\n    FltCloseCommunicationPort(gServerPort);\\n    FltUnregisterFilter(gFilter);\\n    <span class=\"hljs-keyword\">return</span> STATUS_SUCCESS;\\n}\\n\\n<span class=\"hljs-function\">NTSTATUS <span class=\"hljs-title\">DriverEntry</span><span class=\"hljs-params\">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span> </span>{\\n    UNREFERENCED_PARAMETER(RegistryPath);\\n    NTSTATUS status;\\n\\n    <span class=\"hljs-keyword\">const</span> FLT_OPERATION_REGISTRATION Cbs[] = { { IRP_MJ_CREATE, <span class=\"hljs-number\">0</span>, PreCreate, <span class=\"hljs-literal\">NULL</span> }, { IRP_MJ_OPERATION_END } };\\n    <span class=\"hljs-keyword\">const</span> FLT_REGISTRATION Reg = { <span class=\"hljs-keyword\">sizeof</span>(FLT_REGISTRATION), FLT_REGISTRATION_VERSION, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">NULL</span>, Cbs, Unload };\\n\\n    status = FltRegisterFilter(DriverObject, &amp;Reg, &amp;gFilter);\\n    <span class=\"hljs-keyword\">if</span> (!NT_SUCCESS(status)) <span class=\"hljs-keyword\">return</span> status;\\n\\n    UNICODE_STRING portName = RTL_CONSTANT_STRING(<span class=\"hljs-string\">L&quot;\\\\\\\\FileActivityMonitorPort&quot;</span>);\\n    OBJECT_ATTRIBUTES oa = { <span class=\"hljs-keyword\">sizeof</span>(oa), <span class=\"hljs-literal\">NULL</span>, &amp;portName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class=\"hljs-literal\">NULL</span> };\\n\\n    status = FltCreateCommunicationPort(gFilter, &amp;gServerPort, &amp;oa, <span class=\"hljs-literal\">NULL</span>, OnConnect, OnDisconnect, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">1</span>);\\n    <span class=\"hljs-keyword\">if</span> (!NT_SUCCESS(status)) {\\n        FltUnregisterFilter(gFilter);\\n        <span class=\"hljs-keyword\">return</span> status;\\n    }\\n\\n    <span class=\"hljs-keyword\">return</span> FltStartFiltering(gFilter);\\n}</code></pre>\\n<p>Focusing on the representative driver code APIs <code>FltCreateCommunicationPort()</code>, <code>FltSendMessage()</code>, and <code>FltCloseCommunicationPort()</code>, I have implemented an example Minifilter driver code.</p>\\n<p>Let&#x2019;s walk through the flow together:</p>\\n<ol>\\n<li><p>The driver registers itself using <code>FltRegisterFilter()</code>.</p>\\n<p> At this stage, it specifies a <strong>PreCreateCallback</strong> function to monitor file creation and open (<code>IRP_MJ_CREATE</code>) requests, and starts I/O monitoring with <code>FltStartFiltering()</code>.</p>\\n</li>\\n<li><p>Using the <code>FltCreateCommunicationPort()</code> function, the driver can create a communication port.</p>\\n<p> In the code above, it creates the port <code>\\\\\\\\FileActivityMonitorPort</code>, which allows a User-Mode application to connect and receive notifications.</p>\\n</li>\\n<li><p>When a file create/open event occurs, <strong>PreCreateCallback</strong> is invoked, and the function collects information about which process accessed which file.</p>\\n</li>\\n<li>The driver then uses <code>FltSendMessage()</code> to immediately send the real-time file access information collected in <strong>PreCreateCallback</strong> to the connected User-Mode application.</li>\\n<li>Finally, in the <strong>FilterUnload</strong> routine, when the driver is unloaded, it closes the communication port with <code>FltCloseCommunicationPort()</code> and unregisters the filter.</li>\\n</ol>\\n<h3 id=\"User-Mode-Application-Code\"><a href=\"#User-Mode-Application-Code\" class=\"headerlink\" title=\"User-Mode Application Code\"></a>User-Mode Application Code</h3><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;windows.h&gt;</span></span>\\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;fltuser.h&gt;</span></span>\\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span>\\n\\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">pragma</span> comment(lib, <span class=\"hljs-meta-string\">&quot;fltlib.lib&quot;</span>)</span>\\n\\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\\n    HANDLE port;\\n    HRESULT hr;\\n    \\n    BYTE buffer[<span class=\"hljs-keyword\">sizeof</span>(FILTER_MESSAGE_HEADER) + <span class=\"hljs-number\">1024</span>];\\n    PFILTER_MESSAGE_HEADER header = (PFILTER_MESSAGE_HEADER)buffer;\\n\\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connecting to driver...\\\\n&quot;</span>);\\n\\n    hr = FilterConnectCommunicationPort(<span class=\"hljs-string\">L&quot;\\\\\\\\FileActivityMonitorPort&quot;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">NULL</span>, &amp;port);\\n    <span class=\"hljs-keyword\">if</span> (IS_ERROR(hr)) {\\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connection failed. Error 0x%X\\\\n&quot;</span>, hr);\\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\\n    }\\n\\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connected. Waiting for file events...\\\\n&quot;</span>);\\n\\n    <span class=\"hljs-keyword\">while</span> (TRUE) {\\n        hr = FilterGetMessage(port, header, <span class=\"hljs-keyword\">sizeof</span>(buffer), <span class=\"hljs-literal\">NULL</span>);\\n        \\n        <span class=\"hljs-keyword\">if</span> (SUCCEEDED(hr)) {\\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;File Accessed: %S\\\\n&quot;</span>, (PWSTR)header-&gt;MessageBody);\\n        } <span class=\"hljs-keyword\">else</span> {\\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Connection lost. Error 0x%X\\\\n&quot;</span>, hr);\\n            <span class=\"hljs-keyword\">break</span>;\\n        }\\n    }\\n\\n    CloseHandle(port);\\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\\n}</code></pre>\\n<p>Let&#x2019;s now look at the communication flow from the User-Mode application side.</p>\\n<p>Representative APIs include <code>FilterConnectCommunicationPort()</code> and <code>FilterSendMessage()</code>.</p>\\n<ol>\\n<li>First, the application uses <code>FilterConnectCommunicationPort()</code> to connect to the Minifilter driver&#x2019;s communication port in the kernel, <code>\\\\\\\\FileActivityMonitorPort</code>, and obtains a HANDLE for communication.</li>\\n<li><p>It then calls <code>FilterGetMessage()</code> to directly receive the file path string from the driver.</p>\\n<p> If the message is received successfully, the application outputs the file path to the screen.</p>\\n</li>\\n</ol>\\n<h1 id=\"2-CVE-2024-30085-1-Day-Analysis\"><a href=\"#2-CVE-2024-30085-1-Day-Analysis\" class=\"headerlink\" title=\"2. [CVE-2024-30085] 1-Day Analysis\"></a>2. [CVE-2024-30085] 1-Day Analysis</h1><hr>\\n<p>This is a Windows Minifilter Driver vulnerability that was also introduced in &#x201C;1day1line&#x201D; (<a href=\"https://hackyboiz.github.io/2025/01/11/OUYA77/2025-01-11/\">reference</a>).</p>\\n<p>Let&#x2019;s try to reproduce CVE-2024-30085 and, in the process, learn more about Minifilter drivers.</p>\\n<blockquote>\\n<p>&#x1FA9F; Environment: Windows 11 22H2/23H2 10.0.2261.3672</p>\\n</blockquote>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image4.png\" alt></p>\\n<p>The Windows Cloud Files Mini Filter driver is responsible for the Windows cloud sync feature.</p>\\n<p>For example, I&#x2019;ve taken a screenshot of one of my folders.</p>\\n<p>To understand this Minifilter driver vulnerability, we first need some background knowledge about Stub Files and Reparse Points.</p>\\n<h3 id=\"What-is-a-Stub-File\"><a href=\"#What-is-a-Stub-File\" class=\"headerlink\" title=\"What is a Stub File?\"></a>What is a Stub File?</h3><p>A stub file refers to a file that exists only as a placeholder locally, without containing any actual data.</p>\\n<p>As shown in the image above, the &#x201C;Pictures&#x201D; folder has a blue cloud icon in its status &#x2014; this indicates that the file is in a stub state.</p>\\n<p>On NTFS, its size, name, and icon are displayed, but its actual contents are not stored locally.</p>\\n<h3 id=\"Reparse-Point-Metadata\"><a href=\"#Reparse-Point-Metadata\" class=\"headerlink\" title=\"Reparse Point Metadata\"></a>Reparse Point Metadata</h3><p>So, what happens when a user tries to access such a file?</p>\\n<p>NTFS checks the Reparse Tag and determines, <strong>&#x201C;Oh&#x2026; this is a stub file!&#x201D;</strong>.</p>\\n<p>At this point, the Windows Cloud Files Minifilter (<code>cldflt.sys</code>) reads the <code>Reparse Point</code> metadata structure and decides how to handle the file.</p>\\n<p>After that, the Minifilter prepares for communication with the remote server.</p>\\n<p>However, <code>cldflt.sys</code> itself does not communicate directly with the server &#x2014; instead, it delegates the actual work to a User-Mode process.</p>\\n<p>This matches the concept we saw earlier: the Minifilter plays the role of an I/O interpreter, while the User-Mode client handles the actual data manipulation.</p>\\n<p>I&#x2019;ve added the Windows Cloud Files Minifilter&#x2019;s Reparse Point structure definitions to Local Types.</p>\\n<p>Let&#x2019;s take a look at the CldFlt structure set I defined.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> _<span class=\"hljs-title\">REPARSE_DATA_BUFFER</span> {</span>\\n    DWORD ReparseTag;\\n    WORD ReparseDataLength;\\n    WORD Reserved;\\n    WORD Flags;\\n    WORD UncompressedSize;\\n    REPARSE_CLD_BUFFER ReparseCldBuffer;\\n} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;</code></pre>\\n<p><code>REPARSE_DATA_BUFFER</code> is the standard header structure used to represent all Reparse Point data on NTFS.</p>\\n<p>Here, however, we use a redefined version to make analyzing Cloud Files easier.</p>\\n<p>This structure stores top-level metadata such as <code>ReparseTag</code> (to identify the owning driver), <code>ReparseDataLength</code>, and <code>Flags</code>, and then points to the actual data, which continues as an <code>HSM_REPARSE</code> structure.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_REPARSE</span> {</span>\\n    USHORT hsmFlags;\\n    USHORT hsmSize;\\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_DATA</span> <span class=\"hljs-title\">fileData</span>;</span>\\n};</code></pre>\\n<p><code>HSM_REPARSE</code> is the full container for a Cloud Files-specific Reparse Point.</p>\\n<p><code>hsmFlags</code> and <code>hsmSize</code> indicate whether compression is used and the total size of the HSM block.</p>\\n<p>The <code>fileData</code> field contains an <code>HSM_RP_DATA</code> structure.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_DATA</span> {</span>\\n    ULONG magic;\\n    ULONG crc32;\\n    ULONG totalSize;\\n    USHORT dataFlags;\\n    USHORT elemCount;\\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_ELEMENT</span> <span class=\"hljs-title\">elements</span>[5];</span>\\n};</code></pre>\\n<p><code>HSM_RP_DATA</code> is the main header, containing the layout and structure of the entire metadata block.</p>\\n<p><code>magic</code> identifies the data type, and if the CRC bit is set in <code>dataFlags</code>, <code>crc32</code> is validated using <code>RtlComputeCrc32</code>.</p>\\n<p>The <code>elements[]</code> array stores <code>HSM_RP_ELEMENT</code> structures that define the type, size, and offset of each metadata element.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">HSM_RP_ELEMENT</span> {</span>\\n    USHORT elemType;\\n    USHORT elemSize;\\n    ULONG elemOffset;\\n};\\n\\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span> HSM_RP_ELEM_TYPE {\\n    HSM_RP_ELEMENT_NONE   = <span class=\"hljs-number\">0x00</span>,\\n    HSM_RP_ELEMENT_U64    = <span class=\"hljs-number\">0x06</span>,\\n    HSM_RP_ELEMENT_BYTE   = <span class=\"hljs-number\">0x07</span>,\\n    HSM_RP_ELEMENT_U32    = <span class=\"hljs-number\">0x0a</span>,\\n    HSM_RP_ELEMENT_BITMAP = <span class=\"hljs-number\">0x11</span>,\\n    HSM_RP_ELEMENT_MAX    = <span class=\"hljs-number\">0x12</span>\\n} HSM_RP_ELEMENT_TYPE;</code></pre>\\n<p><code>HSM_RP_ELEMENT</code> defines each individual metadata element&#x2019;s type, size, and offset.</p>\\n<p>The <code>HSM_RP_ELEMENT_TYPE</code> enumeration is used to classify element types.</p>\\n<h2 id=\"2-1-Root-Cause-Analysis\"><a href=\"#2-1-Root-Cause-Analysis\" class=\"headerlink\" title=\"2.1 Root Cause Analysis\"></a>2.1 Root Cause Analysis</h2><p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image5.png\" alt></p>\\n<p>The vulnerability occurs when a file is created and the <code>HsmFltPostCREATE</code> callback is executed to process the file&#x2019;s Reparse Point.</p>\\n<p>Within <code>HsmFltPostCREATE</code>, when handling the bitmap information stored in the Reparse Point, the function <code>HsmIBitmapNORMALOpen()</code> is called &#x2014; and this is where the flaw exists.</p>\\n<ul>\\n<li><code>bitmap_size</code> is read directly from the User-Mode request buffer.</li>\\n<li>A fixed-size buffer of 0x1000 bytes is allocated via <code>ExAllocatePoolWithTag</code>, but the user-controlled <code>bitmap_size</code> value is passed directly to <code>memmove</code> without any boundary checks.</li>\\n</ul>\\n<p>Therefore, if <code>bitmap_size</code> is greater than 0x1000, a Heap-based Buffer Overflow is expected to occur.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image6.png\" alt></p>\\n<p>Looking at the <code>HsmpBitmapIsReparseBufferSupported()</code> function, it returns an error if <code>hdr-&gt;elements[4].elemSize</code> is greater than <code>0x1000</code>.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image7.png\" alt></p>\\n<p>Looking a bit further up at the conditional statement code, we can see that <code>hdr-&gt;elements[2]</code> is being strictly validated. Checks such as <code>total &#x2265; 0x18</code> and <code>hdr-&gt;elemCount</code> boundary verification must all be passed in order to proceed. If these conditions are not met, it would return a failure, right?</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image8.png\" alt></p>\\n<p>However, in the same function, if <code>hasBuf</code> is set to <code>false</code>, the code returns <code>result = 0</code> (success) simply by checking the 1-byte flag of <code>element[1]</code>, without performing any separate bitmap length validation. In this path, there is no check to determine whether the bitmap length exceeds <code>0x1000</code>, so the validation is skipped and the data is treated as valid.</p>\\n<h2 id=\"2-2-Exploit\"><a href=\"#2-2-Exploit\" class=\"headerlink\" title=\"2.2 Exploit\"></a>2.2 Exploit</h2><p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image9.png\" alt></p>\\n<p>The <code>cldflt.sys</code> minifilter driver does not scan all file system I/O by default; instead, it only operates on paths within the Sync Root that are registered through the CfAPI. Therefore, the first step was to reach the root directory of a cloud sync folder by calling the <code>CfRegisterSyncRoot()</code> function.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image10.png\" alt></p>\\n<p>Once the Sync Root registration code is built and executed, such a folder is created. Inside this folder, cloud stub files and metadata may appear, and this becomes the point I can exploit.</p>\\n<pre><code class=\"hljs c\">-&gt; HsmFltPostCREATE()\\n-&gt; HsmiFltPostECPCREATE()\\n-&gt; HsmpSetupContexts()\\n-&gt; HsmpCtxCreateStreamContext()\\n-&gt; HsmIBitmapNORMALOpen()\\n</code></pre>\\n<p>Through dynamic analysis, it was confirmed that in order to reach the vulnerable function <code>HsmIBitmapNORMALOpen()</code>, the execution must sequentially pass through the above function chain and satisfy all conditional checks. My goal, therefore, is to fulfill all those conditions and reach the vulnerable <code>memmove</code> inside <code>HsmIBitmapNORMALOpen()</code>.</p>\\n<blockquote>\\n<p>Understanding the Flow as a Minifilter Driver</p>\\n</blockquote>\\n<p>Earlier, I mentioned that a minifilter driver calls specific callbacks depending on the IRP code when an I/O request occurs. To enter the vulnerable path, the process must begin at the <code>IRP_MJ_CREATE</code> Post-Create Callback (<code>HsmFltPostCREATE</code>) and proceed sequentially to the target function. These intermediate functions validate entry conditions based on file/stream attributes and Reparse Point information, so we can bypass them by crafting a special file structure.</p>\\n<ol>\\n<li>Use <code>MakeDataBuffer()</code> to create an <code>IO_REPARSE_TAG_CLOUD</code> structure &#x2192; The minifilter recognizes the file as a cloud stub file and enters the Reparse Point parsing logic.</li>\\n<li>Set Item Tag = <code>0x11</code> (Bitmap) &#x2192; Configure <code>Size</code> to <code>0x1000 + overSize</code> to trigger a heap overflow in <code>memmove()</code> by copying more than the allocated size. Ensure that other elements (Tags <code>0x7</code>, <code>0x6</code>, <code>0xA</code>, etc.) are also set to pass the minifilter&#x2019;s boundary checks.</li>\\n<li>Include a fake kernel object pointer in the overflow data &#x2192; Apply it with <code>FSCTL_SET_REPARSE_POINT</code>, then trigger <code>HsmIBitmapNORMALOpen()</code> by calling <code>CreateFile()</code>.</li>\\n</ol>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image11.png\" alt></p>\\n<p>When these conditions are met, we can confirm that the flow starts from <code>FltMgr</code> and reaches <code>HsmIBitmapNORMALOpen()</code>.</p>\\n<p>I&#x2019;d like to cover the full exploit process, but since today&#x2019;s focus is on explaining the minifilter and I&#x2019;ve already gone overboard with the length&#x2026; let&#x2019;s wrap up with a summary of the entire exploit scenario.</p>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image12.png\" alt></p>\\n<blockquote>\\n<p>Proof of Concept Overview</p>\\n</blockquote>\\n<ol>\\n<li><p><strong>EPROCESS Structure Analysis and Token Field Offset Calculation</strong></p>\\n<p> Calculate the offset of the Token field within the EPROCESS structure to prepare for the subsequent SYSTEM token swap.</p>\\n</li>\\n<li><p><strong>First <code>WNF_STATE_DATA</code> Spray and Hole Creation</strong></p>\\n<p> Mass-allocate (<code>spray</code>) <code>WNF_STATE_DATA</code> objects of size 0x1000 (0xff0 data) and then free them to create heap holes in the kernel heap.</p>\\n</li>\\n<li><p><strong>Open Vulnerable Bitmap File and Trigger First Overflow</strong></p>\\n<p> Use <code>CfRegisterSyncRoot()</code> and manipulate the Reparse Point directory to prepare a vulnerable bitmap file within the Sync Root. Then, open the file with <code>CreateFile()</code> to reach the path:</p>\\n<p> <code>IRP_MJ_CREATE()</code> &#x2192; <code>HsmFltPostCREATE()</code> &#x2192; <code>HsmiFltPostECPCREATE()</code> &#x2192; <code>HsmpSetupContexts()</code> &#x2192; <code>HsmpCtxCreateStreamContext()</code> &#x2192; <code>HsmIBitmapNORMALOpen()</code></p>\\n<p> Trigger a heap overflow to modify the <code>DataSize</code> of an adjacent <code>WNF_STATE_DATA</code>, gaining OOB (Out-of-Bounds) read/write capability.</p>\\n</li>\\n<li><p><strong>Kernel Pointer Leak</strong></p>\\n<p> Use the modified <code>WNF_STATE_DATA</code> to read the <code>_KALPC_RESERVE</code> pointer and leak a kernel address.</p>\\n</li>\\n<li><p><strong>Second <code>WNF_STATE_DATA</code> Spray and Hole Creation</strong></p>\\n<p> Repeat the same spray-and-free process for <code>WNF_STATE_DATA</code> objects, but this time arrange for a <code>PipeAttribute</code> structure to be placed adjacent to the WNF object.</p>\\n</li>\\n<li><p><strong>Second Overflow to Manipulate <code>PipeAttribute</code></strong></p>\\n<p> Open a second bitmap file to trigger another heap overflow, overwriting the <code>Flink</code> pointer of the adjacent <code>PipeAttribute</code> with the address of a user-space fake <code>PipeAttribute</code> structure.</p>\\n</li>\\n<li><p><strong>Arbitrary Read to Retrieve EPROCESS/Token Addresses</strong></p>\\n<p> Use the fake <code>PipeAttribute</code> to access the ALPC Port structure, sequentially reading the EPROCESS address and Token address of the target process.</p>\\n</li>\\n<li><p><strong>Token Swapping and SYSTEM Privilege Escalation</strong></p>\\n<p> Perform an arbitrary write to replace the current process&#x2019;s Token value with the SYSTEM Token value, then launch <code>cmd.exe</code> with SYSTEM privileges.</p>\\n</li>\\n</ol>\\n<h3 id=\"ALPC-WNF\"><a href=\"#ALPC-WNF\" class=\"headerlink\" title=\"ALPC / WNF\"></a>ALPC / WNF</h3><p>The <code>_WNF_STATE_DATA</code> and <code>_ALPC_HANDLE_TABLE</code> structures are used to allocate arbitrary-sized kernel objects for heap holes and to leak kernel memory addresses. Since ALPC and WNF might be unfamiliar concepts, here is a brief explanation of the two subsystems relevant to this exploit:</p>\\n<blockquote>\\n<p><strong>ALPC (Asynchronous Local Procedure Call)</strong></p>\\n</blockquote>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image13.webp\" alt></p>\\n<p>ALPC is an inter-process communication (IPC) mechanism within the Windows kernel that uses client and server ports to exchange messages. By leveraging the <code>_ALPC_HANDLE_ENTRY</code> in the ALPC handle table, it is possible to store message buffer addresses. Since the size of this table is variable, it allows the creation of kernel objects of arbitrary size.</p>\\n<ul>\\n<li>When an ALPC port is created, an <code>_ALPC_HANDLE_TABLE</code> is allocated in the <strong>paged pool</strong> with a size of 0x80.</li>\\n<li>Each call to <code>NtAlpcCreateResourceReserve</code> creates a <code>_KALPC_RESERVE</code> object, and its address is added to the handle table.</li>\\n<li><p>By tampering with this structure, it becomes possible to obtain arbitrary kernel address read/write primitives.</p>\\n<p>  &#x2192; In the PoC, a fake <code>_KALPC_RESERVE</code> is injected to achieve arbitrary R/W.</p>\\n</li>\\n<li><p>ALPC handles can also be controlled from user mode, making them highly useful for exploitation.</p>\\n</li>\\n</ul>\\n<blockquote>\\n<p><strong>WNF (Windows Notification Facility)</strong></p>\\n</blockquote>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image14.webp\" alt></p>\\n<p>WNF is the Windows Notification Facility, and the <code>WNF_NAME_INSTANCE</code> kernel object contains an internal <code>_WNF_STATE_DATA</code> field whose size is variable. This allows direct control of the kernel object size from user mode using <code>NtCreateWnfStateName</code> + <code>NtUpdateWnfStateData</code>.</p>\\n<ul>\\n<li><code>_WNF_STATE_DATA</code> can be allocated with a size of 0x1000 (0x10 header + 0xFF0 data).</li>\\n<li>WNF objects can be mass-created for heap spraying, placing them adjacent to a target structure (e.g., an ALPC object).</li>\\n<li>In the PoC, WNF is used to create heap holes and then place them next to ALPC objects to trigger an overflow into the ALPC handle table.</li>\\n</ul>\\n<p>In particular, the PoC required registering a routine to create a pipe, which I found interesting.</p>\\n<pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PipeAttribute</span> {</span>\\n    LIST_ENTRY <span class=\"hljs-built_in\">list</span>;\\n    <span class=\"hljs-keyword\">char</span> *AttributeName;\\n    <span class=\"hljs-keyword\">uint64_t</span> AttributeValueSize;\\n    <span class=\"hljs-keyword\">char</span> *AttributeValue;\\n    <span class=\"hljs-keyword\">char</span> data[<span class=\"hljs-number\">0</span>];\\n};</code></pre>\\n<p>The pipe is configured so that the <code>AttributeValue</code> pointer in the modified <code>PipeAttribute</code> structure is set to a kernel memory address. This causes the kernel to read data from that address and return it to user mode. By combining the memory layout control achieved via ALPC with the WNF overflow, the pipe can be turned into an arbitrary read primitive, allowing leakage of kernel addresses.</p>\\n<h1 id=\"3-Conclusion\"><a href=\"#3-Conclusion\" class=\"headerlink\" title=\"3. Conclusion\"></a>3. Conclusion</h1><hr>\\n<p><img src=\"/2025/08/15/banda/Minifilter-Driver/en/image15.gif\" alt></p>\\n<p>I&#x2019;ll wrap up by sharing the results of the LPE I implemented using the characteristics of the <code>cldflt.sys</code> Minifilter driver combined with the WNF + ALPC technique.</p>\\n<p>While studying Minifilters, I realized that although their operation, functions, and concepts may feel a bit unfamiliar, the way vulnerabilities are triggered and their root causes are, in the end, quite similar. So, there&#x2019;s no need to be too intimidated about diving into Minifilter exploitation!</p>\\n<p>If I get the chance, I&#x2019;d like to explore and study various other drivers I haven&#x2019;t looked into yet. I hope you&#x2019;ll look forward to my next write-up as well!</p>\\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a><strong>Reference</strong></h1><hr>\\n<p><a href=\"https://exploitreversing.com/2023/04/11/exploiting-reversing-er-series/\">https://exploitreversing.com/2023/04/11/exploiting-reversing-er-series/</a></p>\\n<p><a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts\">https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/filter-manager-concepts</a></p>\\n<p><a href=\"https://starlabs.sg/blog/2024/all-i-want-for-christmas-is-a-cve-2024-30085-exploit/\">https://starlabs.sg/blog/2024/all-i-want-for-christmas-is-a-cve-2024-30085-exploit/</a></p>\\n<p><a href=\"https://ssd-disclosure.com/ssd-advisory-cldflt-heap-based-overflow-pe/\">https://ssd-disclosure.com/ssd-advisory-cldflt-heap-based-overflow-pe/</a></p>\\n<p><a href=\"https://reddogsecurity.substack.com/p/elevating-privileges-in-windows-insights?r=5awqb0&amp;utm_campaign=post&amp;utm_medium=web&amp;triedRedirect=true\">https://reddogsecurity.substack.com/p/elevating-privileges-in-windows-insights?r=5awqb0&amp;utm_campaign=post&amp;utm_medium=web&amp;triedRedirect=true</a></p>\\n<p><a href=\"https://medium.com/@WaterBucket/understanding-mini-filter-drivers-for-windows-vulnerability-research-exploit-development-391153c945d6\">https://medium.com/@WaterBucket/understanding-mini-filter-drivers-for-windows-vulnerability-research-exploit-development-391153c945d6</a></p>\\n - hack & life' og:image='https://hackyboiz.github.io/2025/08/15/banda/Minifilter-Driver/en/minifilter.png' theme-color='#2f4154' og:url='https://hackyboiz.github.io/' naver-site-verification='0b4fea742ed293b82621684e466d9f26c3ccee06' author='j0dev, y2sman' og:title='[Research] Walking Through Windows Minifilter Drivers (EN) - hackyboiz' generator='Hexo 5.1.1' viewport='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no' google-site-verification='DXkyiaX95-ws53Tyt0m91_umRf4gfV2qJIQZ5zQDIO4' indexId='673a8342-e45d-4243-acf9-964b98f8e7f9'"