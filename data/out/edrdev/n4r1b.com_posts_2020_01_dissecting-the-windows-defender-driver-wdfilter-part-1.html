# https://n4r1b.com/posts/2020/01/dissecting-the-windows-defender-driver-wdfilter-part-1/

<!DOCTYPE html><html lang="en" data-theme="light"><body><div class="container"><div class="content"><main class="post"><div class="post-info"><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><path d="M12 6v6l4 2"></path></svg>23 minutes</p></div><article><h1 class="post-title"><a href="https://n4r1b.com/posts/2020/01/dissecting-the-windows-defender-driver-wdfilter-part-1/">Dissecting the Windows Defender Driver - WdFilter (Part 1)</a></h1><div class="post-excerpt">In this series of posts I'll be explaining how the Windows Defender main Driver works, in this first post we will look into the initialization and the Process creation notifications among other things</div><div class="post-content"><p>I‚Äôm back again! For the next couple (Or maybe more) posts I‚Äôll be explaining how WdFilter works. I‚Äôve always been very interested on how AVs work (Nowadays I would say EDRs though) and their development at kernel level. And since, unfortunately I don‚Äôt have access to the source code of any, my only chance is to reverse them (Or to write my own üòÜ). And of course what a better product to check than the one written by the company who developed the OS.</p><p>For those who don‚Äôt know, WdFilter is the main kernel component of Windows Defender. Roughly, this Driver works as a Minifilter from the load order group ‚ÄúFSFilter Anti-Virus‚Äù, this means that is attached to the File System stack (Actually, quite high - Big Altitude) and handles I/O operations in some Pre/Post callbacks. Not only that, this driver also implements other techniques to get information of what‚Äôs going on in the system. The goal of this series of post is to have a solid understanding on how this works under the hood.</p><blockquote><p>A couple of remarks before moving forward. I‚Äôll try to put together all the posts in a way that it makes sense, but since there are many components, flags and structures involved in many places some things may not be clear at first. Also since I‚Äôm still working on reversing the driver so I apologize in advance for not having all the structures fully reversed and same applies to flags I‚Äôll try to post some header files on my Github and keep them updated :)</p></blockquote><h1 id="initialization">Initialization</h1><blockquote><p>For this research I‚Äôm looking at <strong>WdFilter</strong> version 4.18.1910.4, <strong>WdFilter</strong> gets updated a lot, thou changes are not huge so this research should be at least of some help for future versions :)</p><p>SHA256: <code>52D2A7A085896AC8A4FF92201FC87587EDF86B930825840974C6BC09BFB27E5B</code></p></blockquote><p>So without further ado, let‚Äôs get into the <code>DriverEntry</code>. As we saw with <strong>WdBoot</strong> first steps are to check if running on <code>SafeBootMode</code> and initialize the WPP tracing. With this behind, we get into the allocation of the main structure, <strong>MpData</strong>. In the version of the driver we are studying it has a size of <code>0xCC0</code> bytes and is allocated in a NonPaged Pool with tag <code>MPfd</code>. Once we have the Pool allocated for the structure the code will proceed to call <code>MpInitializeGlobals</code> which will initialize some structures inside <strong>MpData</strong> (PagedLookasideLists, EResources, Timer among others) also this function will be in charge of computing a mask which determines the OS version running on the system, this can be seen in the following image ‚Äì <code>MpVerifyWindowsVersion</code> receives the MajorVersion, MinorVersion, ServicePack and BuildNumber and end up calling <code>RtlVerifyVersionInfo</code> to verify if the running OS version is higher.</p><p><img src="https://n4r1b.com/images/wdFilter/part1/OsVersion.png" alt="alt image" title="OS Version Mask" class="medium-zoom-image"></p><p>Also inside this function some pointers to function will be obtained, specifically inside <code>MpGetSystemRoutines</code>, this function will use <code>MmGetSystemRoutineAddress</code> and save the returned address into <strong>MpData</strong>. ‚Äì The <em>OsVersionMask</em> field comes into play here, because some pointers will only be obtained in certain OS versions, for example <code>FltRequestFileInfoOnCreateCompletion</code> will only be retrieved if running Windows 10 build 17726 or higher ‚Äì Going back to the initialization function, one last thing it will do is to create the following SIDs:</p><ul><li>MpServiceSID</li><li>NriServiceSID</li><li>TrustedInstallerSID</li></ul><p>After this, the initialization of <strong>MpData</strong> is completed, even though there‚Äôs still plenty of members that will be filled in other functions, here you can see this <strong>Huge</strong> structure ‚Äì Still missing <strong>A LOT</strong> of fields.</p><div class="highlight-wrapper" style="max-height: 350px; overflow: hidden;"><div class="highlight" style="margin: 0px auto;"><pre style="color: rgb(248, 248, 242); background-color: rgb(40, 42, 54); tab-size: 4; margin-top: 0px; margin-bottom: 0px;"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_DATA
{
  SHORT Magic;      <span style="color:#6272a4">// Set to 0xDA00
</span><span style="color:#6272a4"></span>  SHORT StructSize; <span style="color:#6272a4">// Sizeof 0xCC0
</span><span style="color:#6272a4"></span>  PDRIVER_OBJECT pDriverObject;
  PFLT_FILTER MpFilter;
  NTSTATUS (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pPsSetCreateProcessNotifyRoutineEx)(PCREATE_PROCESS_NOTIFY_ROUTINE_EX, BOOLEAN);
  NTSTATUS (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pPsSetCreateProcessNotifyRoutineEx2)(PSCREATEPROCESSNOTIFYTYPE, PVOID, BOOLEAN);
  NTSTATUS (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pPsSetCreateThreadNotifyRoutineEx)(PSCREATETHREADNOTIFYTYPE, PVOID);
  NTSTATUS (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pObRegisterCallbacks)(POB_CALLBACK_REGISTRATION, PVOID <span style="color:#ff79c6">*</span>);
  <span style="color:#8be9fd">void</span> (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pObUnRegisterCallbacks)(PVOID);
  NTSTATUS (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pFltRegisterForDataScan)(<span style="color:#ff79c6">const</span> PFLT_INSTANCE);
  NTSTATUS (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pFltCreateSectionForDataScan)(PFLT_INSTANCE Instance, PFILE_OBJECT FileObject, PFLT_CONTEXT SectionContext, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, ULONG Flags, PHANDLE SectionHandle, PVOID <span style="color:#ff79c6">*</span>SectionObject, PLARGE_INTEGER SectionFileSize);
  NTSTATUS (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pFltCloseSectionForDataScan)(PFLT_CONTEXT);
  NTSTATUS (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pFltRequestFileInfoOnCreateCompletion)(PFLT_FILTER, PFLT_CALLBACK_DATA, ULONG);
  PVOID (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pFltRetrieveFileInfoOnCreateCompletion)(PFLT_FILTER Filter, PFLT_CALLBACK_DATA Data, ULONG InfoClass, PULONG Size);
  NTSTATUS (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pFsRtlQueryCachedVdl)(PFILE_OBJECT FileObject, PLONGLONG Vdl);
  PVOID pIoBoostThreadIo;
  PVOID pKeSetActualBasePriorityThread;
  PVOID pSeGetCachedSigningLevel;
  PIO_FOEXT_SILO_PARAMETERS (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pIoGetSiloParameters)(<span style="color:#ff79c6">const</span> PFILE_OBJECT);
  BYTE field_90;
  BYTE PanicModeFlag;
  BYTE field_92;
  BYTE field_93;
  INT ScannedFilesCount;
  INT field_98;
  INT field_9C;
  PEPROCESS MsMpEngProcess;
  HANDLE MsMpEngProcessId;
  INT ConnectionPortCookieSet;
  PFLT_PORT FltProtectionControlPort;
  PFLT_PORT ProtectionControlPortServerCookie;
  PFLT_PORT FltProtectionPort;
  PFLT_PORT ProtectionPortServerCookie;
  PFLT_PORT FltProtectionVeryLowIoPort;
  PFLT_PORT ProtectionVeryLowIoServerCookie;
  PFLT_PORT FltProtectionRemoteIoPort;
  PFLT_PORT ProtectionRemoteIoServerCookie;
  PFLT_PORT FltProtectionAsyncPort;
  PFLT_PORT ProtectionAsyncServerCookie;
  INT SomeScanFileFlag;
  INT SendSyncNotificationFlag;
  KSEMAPHORE ScanFileSemaphore1;
  KSEMAPHORE ScanFileSempahore2;
  KSEMAPHORE SendingSyncSemaphore;
  PVOID pBootSectorCache;
  LIST_ENTRY FltInstanceCtxList;
  LIST_ENTRY FltStreamCtxList;
  PCWSTR RegistryParametersPath;
  BYTE DriverVerifiedFlag;
  BYTE field_1A1;
  BYTE field_1A2;
  BYTE field_1A3;
  INT VerifyDriverLevelValue;
  INT64 ResetTimer;
  INT FileScanConsecutiveTimeoutsCount;
  INT field_1B4;
  KDPC WdFilterDPC;
  KTIMER WdFilterTimer;
  ERESOURCE MpDataResource;
  INT64 AsyncNotificationCount;
  INT OsVersionMask;
  INT MonitorFlags;
  INT64 field_2B0;
  INT64 field_2B8;
  PAGED_LOOKASIDE_LIST CompletionContextLookaside;
  NPAGED_LOOKASIDE_LIST WriteContextLookaside;
  NPAGED_LOOKASIDE_LIST field_3C0;
  PAGED_LOOKASIDE_LIST InstanceContextLookaside;
  PAGED_LOOKASIDE_LIST FltInputMessagesLookaside;
  PAGED_LOOKASIDE_LIST FltOutputMessagesLookaside;
  ULONG MpFilterEcpSize;
  INT64 field_5C8;
  INT64 field_5D0;
  INT64 field_5D8;
  INT64 field_5E0;
  INT64 field_5E8;
  INT64 field_5F0;
  INT64 field_5F8;
  NPAGED_LOOKASIDE_LIST ExtraCreateParamsLookaside;
  PVOID ObRegistrationHandle;
  PSID MpServiceSID;
  PSID NriServiceSID;
  PSID TrustedInstallerSID;
  INT MaxLocalScanTimeout;
  INT MaxNetworkScanTimeout;
  INT field_6A8;
  INT UnsetObAndRegCallback;
  BYTE RawVolumeWriteFlag;
  BYTE MpOrWdFlag;
  BYTE field_6B2;
  BYTE field_6B3;
  INT field_6B4;
  PVOID PowerSettingCbHandle;
  BYTE LowPowerEpochOn;
  BYTE field_6C1;
  BYTE field_6C2;
  BYTE field_6C3;
  <span style="color:#8be9fd">int</span> field_6C4;
  INT64 MachineUptime;
  MP_CSRSS_HOOK_DATA <span style="color:#ff79c6">*</span>pCsrssHookData;
  PCALLBACK_OBJECT pProcessNotificationCallback;
  PCALLBACK_OBJECT pNriNotificationCallback;
  INT64 NriNotificationCallbackHandle;
  INT64 field_6F0;
  INT64 field_6F8;
  LIST_ENTRY field_700;
  FAST_MUTEX MpDataFastMutex;
  INT64 field_748;
  INT64 field_750;
  INT64 field_758;
  INT64 field_760;
  INT64 field_768;
  INT64 field_770;
  INT64 field_778;
  PAGED_LOOKASIDE_LIST PagedLookasideMPbc;
  INT field_800;
  INT field_804;
  INT64 field_808;
  INT64 field_810;
  INT64 field_818;
  INT64 field_820;
  INT64 field_828;
  INT64 field_830;
  INT64 field_838;
  INT64 field_840;
  INT64 field_848;
  INT64 field_850;
  INT64 field_858;
  INT64 field_860;
  INT CsvFileStateCacheType;
  INT FileStateCachePolicy;
  INT64 field_870;
  INT field_878;
  INT field_87C;
  INT CounterFileSystemTypeCSVFS;
  INT field_884;
  INT field_888;
  INT RefsFileStateCacheType;
  INT FileStateCachePolicy1;
  INT64 field_898;
  INT field_8A0;
  INT field_8A4;
  INT CounterFileSystemTypeREFS;
  INT field_8AC;
  INT field_8B0;
  INT64 FltSendMessageTimeStamp;
  INT FltSendMessageCount;
  INT field_8C4;
  INT SomethingWithSettingProcessInfo;
  INT FltSendMessageError;
  INT FltSendMessageErrorCode;
  INT FltSendMessageStatusTimeout;
  INT FltSendMessageReplyBufferMismatch;
  INT AllowFilterManualDetach;
  LIST_ENTRY BootScanCtxList;
  ERESOURCE ExResource1;
  ERESOURCE ExResource2;
  INT field_9C0;
  INT field_9C4;
  PUNICODE_STRING SystemRootPath;
  INT field_9D0;
  INT field_9D4;
  BYTE OpenWithoutReadNotificationFlag;
  RTL_GENERIC_TABLE RtlGenericTable;
  FAST_MUTEX WdFilterGenericTableMutex;
  MP_SYNC_NOTIFICATIONS_STATUS SyncNotifications[<span style="color:#bd93f9">8</span>];
  INT SyncNotificationRecvCount[<span style="color:#bd93f9">8</span>];
  INT SyncNotificationsCount[<span style="color:#bd93f9">8</span>];
  INT SyncNotificationsStatus[<span style="color:#bd93f9">8</span>];
  INT SyncNotificationsIoTimeoutCount[<span style="color:#bd93f9">8</span>];
  INT SyncNotificationsRecvErrorCount[<span style="color:#bd93f9">8</span>];
  INT MonitorNotificationFlag;
  INT field_B84;
  INT64 SyncMonitorNotificationTimeout;
  INT64 RandNumber;
  BYTE MpEaString[<span style="color:#bd93f9">256</span>];
  INT AsyncDirectoryNotificationFlag;
  BYTE DataLossPreventionFlag;
  BYTE field_C9D;
  BYTE field_C9E;
  BYTE field_C9F;
  INT64 field_CA0;
  INT64 field_CA8;
  INT64 field_CB0;
  INT64 field_CB8;
} MP_DATA, <span style="color:#ff79c6">*</span>PMP_DATA;</code></pre></div><div class="highlight-link"><a href="https://n4r1b.com/posts/2020/01/dissecting-the-windows-defender-driver-wdfilter-part-1/">Show More</a></div></div><p>Next step is to setup the parameters/config of the the driver, this will be done inside <code>MpLoadRegistryParameters</code>. This function will setup a <code>RTL_REGISTRY_QUERY_TABLE</code> by iterating over an array of structures that I coined <code>MP_CONFIG_PARAMS</code>:</p><div class="highlight-wrapper"><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_CONFIG_PARAMS
{
  PCWSTR Name;
  PMP_CONFIG <span style="color:#ff79c6">*</span>pMpConfig;
  INT64 DefaultData;
} MP_CONFIG_PARAMS, <span style="color:#ff79c6">*</span>PMP_CONFIG_PARAMS</code></pre></div></div><p>the following image shows some entries of this array:</p><p><img src="https://n4r1b.com/images/wdFilter/part1/MpConfigParams.png" alt="alt image" title="MP_CONFIG_PARAMS array" class="medium-zoom-image"></p><p>As you can see the second member of this structure is a pointer inside the structure <code>MP_CONFIG</code>, this address is the one that‚Äôs gonna be set as the <code>EntryContext</code> in the <code>QueryTable</code>. Finally, the function will call <code>RtlQueryRegistryValuesEx</code> with the registry path being <code>HKLM\System\CurrentControlSet\Services\WdFilter\Parameters</code> after this call has been made the values returned in the <code>EntryContext</code> will be check to see if they match some criteria, if they don‚Äôt match they will be set to their default value. The <code>MP_CONFIG</code> has the following definition:</p><div class="highlight-wrapper" style="max-height: 350px; overflow: hidden;"><div class="highlight" style="margin: 0px auto;"><pre style="color: rgb(248, 248, 242); background-color: rgb(40, 42, 54); tab-size: 4; margin-top: 0px; margin-bottom: 0px;"><code class="language-C" data-lang="C"><span style="color:#6272a4">// Sizeof 0x5C
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_CONFIG
{
  INT   ResetToUnknownTimer;
  INT   MaxLocalScanTimeout;
  INT   MaxNetworkScanTimeout;
  INT   MaxProcessCreationMessageTimeout;
  INT   MaxConsecutiveTimeoutsUntilPassThrough;
  INT   StartScanningAgainTimer;
  INT   DebugPassthroughEnabled;
  INT   MaxAsyncNotificationCount;
  INT   AsyncStarvationLimit;
  INT   AsyncTimeout;
  INT   AllowManualDetach;
  INT   MaxCopyCacheSize;
  INT   KnownBadHashSize;
  BYTE  DirectionalScanningNonNTFS;
  BYTE  DisableQueryNameNormalize;
  BYTE  ThreadBoostingFlag;
  INT   CsvFileStateCacheType;
  INT   RefsFileStateCacheType;
  INT   FileStateCachePolicy;
  INT   DisableReadHooking;
  INT   FolderGuardDispatchTimer;
  INT   FolderGuardDispatchLimit;
  INT   DisableTransactionCallback;
} MP_CONFIG, <span style="color:#ff79c6">*</span>PMP_CONFIG;</code></pre></div><div class="highlight-link"><a href="https://n4r1b.com/posts/2020/01/dissecting-the-windows-defender-driver-wdfilter-part-1/">Show More</a></div></div><p>With the <strong>MpConfig</strong> structure populated, some default values will be copied into <strong>MpData</strong> inside <code>MpSetDefaultConfigs</code>, then function <code>MpSetBufferLimits</code> will set the different limits both for Input and Output messages that will be used for the communication with the UserSpace process ‚Äì <strong>MsMpEng.exe</strong>.</p><blockquote><p>I will leave how this communication works for another post, since is a big part of the driver and I believe it deserves it‚Äôs own part. But basically the driver can receive different messages through a communication port and each of this message has his own data and size, and of course, each one executes a different operation.</p></blockquote><p>Last thing regarding initialization of <strong>MpData</strong> is to initialize things related to thread boosting, this will be done inside <code>MpInitializeBoostManager</code>, for now is not relevant we will see more about this thread boosting in other posts.</p><p>From now on, the code will start initializing <strong>a lot</strong> of different structures, each one meant for something different, I‚Äôll mention all of them but for this post I‚Äôll focus only on some of them. First function is <code>MpInitializeProcessTable</code>, as the name implies this function will initialize a structure that will keep track of the process in the system, to do this it will allocate a pool of size <code>0x800</code> that will contain an array of <code>LIST_ENTRY</code> ‚Äì Each list entry is of size <code>0x10</code> so we have <code>0x80</code> entries in the array ‚Äì this <code>LIST_ENTRY</code> is actually a shifted pointer into the structure I named <code>ProcessCtx</code> that contains the information regarding a process. The definition of the process table looks something like this:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_PROCESS_TABLE
{
  SHORT Magic;  <span style="color:#6272a4">// Set to 0xDA13
</span><span style="color:#6272a4"></span>  SHORT Size;   <span style="color:#6272a4">// Sizeof 0x1C0
</span><span style="color:#6272a4"></span>  ERESOURCE ProcessTableResource;
  PAGED_LOOKASIDE_LIST ProcessCtxLookaside;
  PAGED_LOOKASIDE_LIST ProcessCtxListLookaside;
  LIST_ENTRY <span style="color:#ff79c6">*</span><span style="color:#50fa7b">__shifted</span>(ProcessCtx,<span style="color:#bd93f9">8</span>) (<span style="color:#ff79c6">*</span>ProcessCtxArray)[<span style="color:#bd93f9">0x80</span>];
  KEVENT ProcessTableEvent;
  _DWORD BeingAccessed;
  INT TrustedProcessCtxCounter;
  INT UntrustedProcessCtxCounter;
  INT Unk;
  INT CreateThreadNotifyLock;
} MP_PROCESS_TABLE, <span style="color:#ff79c6">*</span>PMP_PROCESS_TABLE;</code></pre></div><p>After this, the <code>DriverEntry</code> will call <code>MpInitBootSectorCache</code> which will allocate a pool of size <code>0x64</code> and tag <code>MPgb</code> and save a pointer in <code>MpData-&gt;pBootSectorCache</code> ‚Äì We‚Äôll see more about the checks of the Boot sector in another post.</p><p>Then, based on the value saved on <code>MpConfig.MaxCopyCacheSize</code> another pool will be allocated and this time the pointer to the pool will be saved in the global variable <code>MpCopyCacheData</code> ‚Äì The value of <code>MaxCopyCacheSize</code> cannot be higher than <code>0x200</code> and in order to allocate the pool this value is left shifted 6 times, so the max size would be <code>0x8000</code> ‚Äì With this done, the next step is to initialize the following strucures and callbacks:</p><ul><li><p>Process Exclusion structure, initialized inside <code>MpInitializeProcessExclusions</code> with a size of <code>0x78</code>, tag <code>MPps</code> and saved in the global <code>MpProcessExclusion</code>.</p></li><li><p>Power setting callback, this is done inside <code>MpPowerStatusInitialize</code>, which receives as parameter the address of <code>MpData-&gt;PowerSettingCbHandle</code> and this function will use <code>PoRegisterPowerSettingCallback</code> to set up a callback on the power setting <code>GUID_LOW_POWER_EPOCH</code> upon successful registration of the callback the Handle will be saved in the parameter ‚Äì We will see the actual callback function in the end of this article.</p></li><li><p>The transactional NTFS structure, which will be initialized inside <code>MpTxfInitialize</code> with a size of <code>0x140</code>, tag <code>MPtd</code> and saved in a global I named <code>MpTxfData</code>.</p></li><li><p>Async worker thread alongside the Async structure, this will be initialized inside <code>MpAsyncInitialize</code> and the structure will mainly keep two list entries of messages that are enqueued to be sent by the async worker thread. This thread is initialized inside this function too, and the function <code>MpAsyncpWorkerThread</code> is set as the StartRoutine of it.</p></li><li><p>The registry data structure, which will be initialized inside <code>MpRegInitialize</code>, of size <code>0x500</code> and tag <code>MPrD</code>. This is another big and important structure that will be used mainly in the RegistryCallback ‚Äì We will get into this callback in the next post.</p></li><li><p>Document rules structure, initialized inside <code>MpInitializeDocOpenRules</code> with a size of <code>0x100</code>, tag <code>MPdo</code> and saved in the global <code>MpBmDocOpenRules</code> ‚Äì A bit further down we‚Äôll see more about this quite interesting structure.</p></li><li><p>Folder Guard structure, which is initialized inside <code>MpFgInitialize</code> only on systems running Windows 10 build 16000 or higher has a size of <code>0x240</code>, tag <code>MPFg</code> and saved in the global <code>MpFolderGuard</code>. The structure will keep a pointer to a <strong>RTL_AVL_TABLE</strong> table and a <strong>RTL_GENERIC_TABLE</strong> and it will be used mainly to allow or revoke access to files/folders.</p></li><li><p>Lastly, the drivers info structure, which is initialized inside <code>MpInitializeDriverInfo</code>, this structure is tied to the ELAM driver, and is the one that will be used mainly on the function registered for the callback <code>\Callback\WdEbNotificationCallback</code>. When we get into how this function and this structure is used we will be able to intertwine what we saw in the post about the <a href="https://n4r1b.com/en/posts/2019/11/understanding-wdboot-windows-defender-elam/" target="_blank"><strong>WdBoot</strong></a> with what <strong>WdFilter</strong> does with that data.</p></li></ul><p>Reached this point we will find ourselves with a good amount of allocated pools and initialized structures:</p><p><img src="https://n4r1b.com/images/wdFilter/part1/PoolUsed.png" alt="alt image" title="Pools Used" class="medium-zoom-image"></p><p>The next step in the <code>DriverEntry</code> is to initialize both the minifilter, inside <code>MpInitializeFltMgr</code>, and the communication ports, inside <code>MpCreateCommPorts</code>. The former will choose a specific <code>OperationRegistration</code> for the <code>FLT_REGISTRATION</code> structure based on the configuration and the <code>OsVersionMask</code>, with this <code>FilterRegistration</code> it will register the minifilter (<code>FltRegisterFilter</code>). The latter will first set up a security descriptor using the <strong>MpServiceSID</strong> and this security descriptor will be used in the <code>ObjectAttributes</code> given as argument to <code>FltCreateCommunicationPort</code>. Four different ports will be created:</p><ul><li>MicrosoftMalwareProtectionControlPort (This is the only port that will registers a MessageNotifyCallback)</li><li>MicrosoftMalwareProtectionPort</li><li>MicrosoftMalwareProtectionVeryLowIoPort</li><li>MicrosoftMalwareProtectionRemoteIoPort</li></ul><p>From this point, roughly, the <code>DriverEntry</code> will register callbacks for the following events:</p><ul><li>Process Creation</li><li>Image Load</li><li>Thread Creation</li><li>Image Verification</li><li>Object Operations (ProcessType and DesktopObjectType)</li><li>Registry Operations</li></ul><blockquote><p>Since the post is already quite long, for this part I will only focus on the first two</p></blockquote><p>After setting the the Image Verification callback the driver will start filtering (<code>FltStartFiltering</code>) and after registering the last two callbacks the driver initialization would be done. Of course, if at any point any of the aforementioned steps fail the driver will cleanup everything.</p><h2 id="mpsetprocessnotifyroutine">MpSetProcessNotifyRoutine</h2><p>The first callback registration we will dig into is the process creation, this callback is register inside <code>MpSetProcessNotifyRoutine</code>. First thing this function will do is check if <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutineex2" target="_blank"><code>PsSetCreateProcessNotifyRoutineEx2</code></a> is available (Windows 10 build 14980 - <code>OsVersionMask &amp; 0x80</code>), in case it is then it will use this function to register the callback, if is not available then it will check <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutineex" target="_blank"><code>PsSetCreateProcessNotifyRoutineEx</code></a> lastly if this one isn‚Äôt available either then it will resort in <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-pssetcreateprocessnotifyroutine" target="_blank"><code>PsSetCreateProcessNotifyRoutine</code></a>. Once one of the callback routine has been registered, the code will then proceed to create two callback objects <code>\Callback\WdProcessNotificationCallback</code> and <code>\Callback\WdNriNotificationCallback</code>. For the latter, the code will also register a callback function ‚Äì <code>MpNriNotificationCallback</code></p><blockquote><p>To get more information on this Callback Objects and others, make sure to check the research <a href="https://twitter.com/0xcpu" target="_blank">0xcpu</a> and I have been conducting on them <a href="https://github.com/0xcpu/ExecutiveCallbackObjects" target="_blank">https://github.com/0xcpu/ExecutiveCallbackObjects</a></p></blockquote><h3 id="mpcreateprocessnotifyroutineex-mpcreateprocessnotifyroutine">MpCreateProcessNotifyRoutineEx - MpCreateProcessNotifyRoutine</h3><p>In this section I will explain what does the callback routine registered for the process creation does. As can be seen on the section title, there can be two routines, the first one is registered by the <code>..Ex2</code> and <code>..Ex</code> while the second one is registered by <code>PsSetCreateProcessNotifyRoutine</code>.</p><blockquote><p>The difference between the <code>..Ex</code> and the <code>..Ex2</code> functions is basically that the latter allows to provide a <code>PSCREATEPROCESSNOTIFYTYPE</code> and even though this value can only be set to <code>PsCreateProcessNotifySubsystems</code> maybe in the future they will add more value for example one to get only notifications from the WSL subsystem. On the other hand, the difference from this two against <code>PsSetCreateProcessNotifyRoutine</code> is that in the latter the register routine protoype is <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nc-ntddk-pcreate_process_notify_routine" target="_blank"><code>CREATE_PROCESS_NOTIFY_ROUTINE</code></a> while for the other two the prototype is <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nc-ntddk-pcreate_process_notify_routine_ex" target="_blank">CREATE_PROCESS_NOTIFY_ROUTINE_EX</a></p></blockquote><p>Both functions are pretty similar, moreover, they share a lot of the code. There‚Äôs only a couple of difference between them, the main differences being:</p><ul><li>MpCreateProcessNotifyRoutineEx can take advantage of having the structure <code>PS_CREATE_NOTIFY_INFO</code>, for example if the flag <strong>FileOpenNameAvailable</strong> is set then it can retrieve the ImageFileName without the need of getting a handle to the process.</li><li>MpCreateProcessNotifyRoutineEx can deny the creation of the process setting the value <strong>CreationStatus</strong> to an error.</li><li>The last difference is that function MpCreateProcessNotifyRoutineEx has also the ability to add processes to the boot process list entry, by calling <code>MpAddBootProcessEntry</code></li></ul><p>Getting into the actual code, as I mentioned above, in case we don‚Äôt have the flag <strong>FileOpenNameAvailable</strong> or the case we don‚Äôt have <code>PS_CREATE_NOTIFY_INFO</code> the code will proceed to obtain a handle to the process (<code>ZwOpenProcess</code>) and with this handle it will call <code>MpGetProcessNameByHandle</code>, which basically calls <code>ZwQueryInformationProcess</code> with <code>ProcessImageFileName</code> as the ProcessInformationClass. Once the callback routine has the ImageFileName it will proceed to obtain the normalized name, to do this it will call the function <code>MpGetImageNormalizedName</code>, this function will mainly call <code>FltGetFileNameInformationUnsafe</code> with NameOptions <code>FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT</code>. Finally, the callback routine will end up calling <code>MpHandleProcessNotification</code>, which is the main function of this callback.</p><h4 id="mphandleprocessnotification">MpHandleProcessNotification</h4><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#8be9fd">void</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">MpHandleProcessNotification</span>(
  _In_  PEPROCESS       Process, 
  _In_  HANDLE          ParentId, 
  _In_  HANDLE          ProcessId, 
  _In_  BOOLEAN         Create, 
  _In_  BOOLEAN         IsTransacted, 
  _In_  PUNICODE_STRING ImageFileName, 
  _In_  PUNICODE_STRING CommandLine, 
  _Out_ PBYTE           AccessDenied
);</code></pre></div><p>This function has two very clear code paths, which are defined by the <strong>Create</strong> flag. In the case where the process is being created the first, and probably one of the most important steps in the filter, is to create the ProcessContext structure. This is done inside <code>MpCreateProcessContext</code></p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">NTSTATUS <span style="color:#ff79c6">__fastcall</span> MpCreateProcessContext(
  _In_  HANDLE          ProcessId, 
  _In_  LONGLONG        CreationTime, 
  _In_  PUNICODE_STRING FileNameAndCmdLine[<span style="color:#bd93f9">2</span>], <span style="color:#6272a4">// This is probably a struct with two UNICODE_STRING
</span><span style="color:#6272a4"></span>  _Out_ PProcessCtx     <span style="color:#ff79c6">*</span>ProcessCtx
)</code></pre></div><p>this function will mainly allocate memory from the Lookaside <code>MpProcessTable-&gt;ProcessCtxLookaside</code> to hold one Process Context ‚Äì Size <code>0xC0</code> - Tag <code>MPpX</code> ‚Äì after the memory is allocated it will start filling the members of the Process Context structure, this structure looks something like this:</p><div class="highlight-wrapper" style="max-height: 350px; overflow: hidden;"><div class="highlight" style="margin: 0px auto;"><pre style="color: rgb(248, 248, 242); background-color: rgb(40, 42, 54); tab-size: 4; margin-top: 0px; margin-bottom: 0px;"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _ProcessCtx
{
  SHORT Magic;        <span style="color:#6272a4">// Set to 0xDA0F
</span><span style="color:#6272a4"></span>  SHORT StructSize;   <span style="color:#6272a4">// Sizeof 0xC0
</span><span style="color:#6272a4"></span>  LIST_ENTRY ProcessCtxList ;
  HANDLE ProcessId;
  QWORD CreationTime;
  PUNICODE_STRING ProcessCmdLine;
  INT RefCount;
  DWORD ProcessFlags;
  DWORD ProcessRules;
  QWORD SthWithCodeInjection;   <span style="color:#6272a4">// Requires further investigation 
</span><span style="color:#6272a4"></span>  QWORD SthWithCodeInjection1;  <span style="color:#6272a4">// Both fields used in MpAllowCodeInjection
</span><span style="color:#6272a4"></span>  PMP_DOC_RULE pDocRule;
  BOOLEAN (<span style="color:#ff79c6">__fastcall</span> <span style="color:#ff79c6">*</span>pCsrssPreScanHook)(PFLT_CALLBACK_DATA, FltStreamCtx <span style="color:#ff79c6">*</span>);
  INT field_60;
  INT NotificationsSent;
  INT InjectionsHandlesCount;
  INT field_6C;
  PVOID Wow64CpuImageBase;
  INT ProcessSubsystemInformation;
  PUNICODE_STRING ImageFileName;
  BYTE HipRules[<span style="color:#bd93f9">16</span>];
  BYTE HipRules1[<span style="color:#bd93f9">16</span>];
  QWORD field_A8;
  QWORD field_B0;
  _PS_PROTECTION ProcessProtection;
  INT StreamHandleCtxCount;
} ProcessCtx, <span style="color:#ff79c6">*</span>PProcessCtx;</code></pre></div><div class="highlight-link"><a href="https://n4r1b.com/posts/2020/01/dissecting-the-windows-defender-driver-wdfilter-part-1/">Show More</a></div></div><p>Once the Process Context (ProcessCtx from now on) has been retrieved or created, the function will proceed to see if a doc rule should be attached to this Process. This is done inside <code>MpSetProcessDocOpenRule</code> and there are two structures involved. One that keeps a list of all the documents rules and one for each rule.</p><div class="highlight-wrapper"><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_DOC_OPEN_RULES
{
  SHORT Magic;        <span style="color:#6272a4">// Set to 0xDA14
</span><span style="color:#6272a4"></span>  SHORT StructSize;   <span style="color:#6272a4">// Sizeof 0x100 
</span><span style="color:#6272a4"></span>  SINGLE_LIST_ENTRY <span style="color:#ff79c6">*</span><span style="color:#50fa7b">__shifted</span>(MP_DOC_RULE,<span style="color:#bd93f9">8</span>) DocObjectsList;
  ERESOURCE DocRulesResource;
  <span style="color:#ff79c6">struct</span> _PAGED_LOOKASIDE_LIST DocObjectsLookasideList;
} MP_DOC_OPEN_RULES, <span style="color:#ff79c6">*</span>PMP_DOC_OPEN_RULES;

<span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_DOC_RULE
{
  SHORT Magic;        <span style="color:#6272a4">// Set to 0xDA15
</span><span style="color:#6272a4"></span>  SHORT StructSize;   <span style="color:#6272a4">// Sizeof 0x228
</span><span style="color:#6272a4"></span>  INT RefCount;
  SINGLE_LIST_ENTRY SingleListEntryDocRules;
  WCHAR DocProcessName[<span style="color:#bd93f9">261</span>];
  PCWSTR RuleExtension;
} MP_DOC_RULE, <span style="color:#ff79c6">*</span>PMP_DOC_RULE;</code></pre></div></div><p>The code will basically iterate the single list entry comparing the ImageFileName with the DocProcessName, if any of the rules matches, then that a pointer the <code>MP_DOC_RULE</code> structure will be saved in the <code>ProcessCtx-&gt;pDocRule</code>.</p><p>Next step is to check if the process which context has been created is <code>csrss.exe</code> ‚Äì <code>MpSetProcessPreScanHook</code> ‚Äì in case it is, a pointer to <code>CsrssPreScanHook</code> will be saved in <code>ProcessCtx.pCsrssPreScanHook</code> and the flag <code>MpData-&gt;pCsrssHookData-&gt;HookSetFlag</code> will be set. This is only done for the ProcessCtx of <code>csrss.exe</code></p><p><img src="https://n4r1b.com/images/wdFilter/part1/CsrssHook.png" alt="alt image" title="Csrss Hook" class="medium-zoom-image"></p><p>The last step before notifying the creation of the process is to check if the process matches some exceptions and set the <code>ProcessCtx.ProcessFlags</code> accordingly. To do this check there are three functions:</p><ul><li>MpSetProcessExempt</li><li>MpSetProcessHardening</li><li>MpSetProcessHardeningExclusion</li></ul><p>The first one will iterate over the single list entry of the following structure ‚Äì I know, there‚Äôs <strong>A LOT</strong> of structures.</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#6272a4">// Sizeof 0x20
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_PROCESS_EXCLUDED
{
  SINGLE_LIST_ENTRY ExcludedProcessList;
  UNICODE_STRING ProcessPath;
  BYTE NoBackslashFlag;
  BYTE WildcardPathFlag;
} MP_PROCESS_EXCLUDED, <span style="color:#ff79c6">*</span>PMP_PROCESS_EXCLUDED;</code></pre></div><p>and it will check <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltparsefilename" target="_blank">FinalComponent</a> of the ImageFileName is either prefix or equal to any of the ones from the list, in case it matches it will set the ProcessFlags by applying an OR with <code>0x1</code>. The driver has the capabilitie to add Process/Paths to the <code>MP_PROCESS_EXCLUDED</code> list based on a message received from user space ‚Äì <strong>MsMpEng.exe</strong> ‚Äì Here we can see a list of process excluded using this criteria</p><p><img src="https://n4r1b.com/images/wdFilter/part1/ProcessExcluded.png" alt="alt image" title="Process excluded" class="medium-zoom-image"></p><blockquote><p>There‚Äôs one special case in this check, when the process is <strong>MsMpEng</strong> in this case the ProcessFlags will be ORed with <code>0x9</code></p></blockquote><p>The second check will first check if the FinalComponent matches <strong>mpcmdrun.exe</strong> or <strong>msmpeng.exe</strong>, in case it does using the previously created <strong>MpServiceSID</strong> it will check if the access token of the process matches that SID. If none of those process name match then it will check against <strong>nissrv.exe</strong> and <strong>NriServiceSID</strong>. If any of this situations is matched succesfully the ProcessFlags will be ORed with <code>0x10</code>.</p><blockquote><p>There‚Äôs another possible situation if we are running MpFilter instead of WdFilter, in this case process name will be compared agains <strong>msseces.exe</strong> and if it matches the ProcessFlag will be ORed against <code>0x80</code></p></blockquote><p>The last check will first create, if needed, a list entry of hardened excluded process. The values for this list entry are hardcoded in <strong>WdFilter</strong> in an structure that keeps the name, a flag that indicates to what system does it applies and lastly the mask value that will be applied to the ProcessFlags</p><p><img src="https://n4r1b.com/images/wdFilter/part1/HardenedExcludedProcess.png" alt="alt image" title="Hardened Process excluded" class="medium-zoom-image"></p><p>with those values the following structure will be filled</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#6272a4">// Sizeof 0x20
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_PROCESS_HARDENING_EXCLUDED
{
  LIST_ENTRY ProcessExcludedList;
  PUNICODE_STRING ProcessPath;
  INT ProcessHardeningExcludedMask;
} MP_PROCESS_HARDENING_EXCLUDED, <span style="color:#ff79c6">*</span>PMP_PROCESS_HARDENING_EXCLUDED;</code></pre></div><p>once the structure is filled the procedure of the check is quite standard, the code compares the name and if it matches then it applies the ProcessHardeningExcludedFlag to the <code>ProcessCtx.ProcessFlags</code>. In the following image we can see the list of process in the <code>MP_PROCESS_HARDENING_EXCLUDED</code> of my system</p><p><img src="https://n4r1b.com/images/wdFilter/part1/ProcessHardeningExclusion.png" alt="alt image" title="Hardened Process" class="medium-zoom-image"></p><p>One last detail regarding the process exclusion, is that a reference to both structures we just saw is kept in another structure ‚Äì Yep, since there are not many structures already‚Ä¶ there‚Äôs one more üòÜ.</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#6272a4">// Sizeof 0x78
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_PROCESS_EXCLUSION
{
  ERESOURCE ProcessExclusionResource;
  MP_PROCESS_EXCLUDED <span style="color:#ff79c6">*</span>ProcessExclusionList;
  MP_PROCESS_HARDENING_EXCLUDED <span style="color:#ff79c6">*</span>ProcessHardenedExclusionList;
} MP_PROCESS_EXCLUSION, <span style="color:#ff79c6">*</span>PMP_PROCESS_EXCLUSION;</code></pre></div><p>After all this, the ‚Äúdefault‚Äù ProcessCtx is ready and now is time to notify the callback <code>\Callback\WdProcessNotificationCallback</code>. <strong>Argument1</strong> will contain the following structure</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">typdef <span style="color:#ff79c6">struct</span> _MP_PROCESS_CB_NOTIFY
{
  HANDLE ProcessId;
  HANDLE ParentId;
  PUNICODE_STRING ImageFileName;
  INT OperationType;  <span style="color:#6272a4">// ProcessCreation = 1; ProcessTermination = 2; SetProcessInfo = 3
</span><span style="color:#6272a4"></span>  BYTE ProcessFlags;
} MP_PROCESS_CB_NOTIFY, <span style="color:#ff79c6">*</span>PMP_PROCESS_CB_NOTIFY;</code></pre></div><blockquote><p>For the sake of brevity, I won‚Äôt explain more details about this. Please refer to the <a href="https://github.com/0xcpu/ExecutiveCallbackObjects/tree/master/WdProcessNotificationCallback" target="_blank">Github</a> to learn more about this callback.</p></blockquote><p>After notifying the callback we just need one last step to finish the ProcessNotification callback, this step is to send a message to the user space process listening to port <code>ProtectionPortServerCookie</code>.</p><p>Before getting into the function that creates and send the message, I‚Äôll explain quickly the case when the flag <strong>Create</strong> is not set, which means the process is exiting. In this case the ProcessCtx will be obtained by the process Id, and with this ProcessCtx the structure <code>MP_PROCESS_CB_NOTIFY</code> will be populated and the callback notified. After this <code>MpSendProcessMessage</code> will be called to create and send the message.</p><p>One last detail is the call to <code>MpCopyCacheProcessTerminate</code> which will iterate over an array of <code>MP_COPY_CACHE_ENTRY</code></p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _MP_COPY_CACHE_ENTRY
{
  DWORD Flags;
  HANDLE ProcessId;
  HANDLE ThreadId;
  UNICODE_STRING FileName;
  QWORD FileSize;
  QWORD TimeStamp;
  INT64 qword38;
} MP_COPY_CACHE_ENTRY, <span style="color:#ff79c6">*</span>PMP_COPY_CACHE_ENTRY;</code></pre></div><h4 id="mpsendprocessmessage">MpSendProcessMessage</h4><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">NTSTATUS <span style="color:#ff79c6">__fastcall</span> MpSendProcessMessage(
  _In_  BYTE                CreateFlag,
  _In_  PEPROCESS           Process, 
  _In_  HANDLE              ProcessId, 
  _In_  BOOLEAN             IsTransacted, 
  _In_  HANDLE              ParentId, 
  _In_  PAuxPidCreationTime ParentPidAndCreationTime, 
  _In_  PUNICODE_STRING     ImageFileName, 
  _In_  PProcessCtx         ProcessCtx, 
  _In_  PUNICODE_STRING     CommandLine, 
  _Out_ PBYTE               AccessDenied
)</code></pre></div><p>This function, and a lot of other functions we will see during this series of posts, handle the creation of a message with some specific data that will be sent to <strong>MsMpEng</strong>. This data can be send synchronously or asynchronously (Using the worker thread I mentioned above) ‚Äì The message will be created differently, even though sometimes they use the async method but then send that message synchronously.</p><p>In the case of this function both message will be created using the asynchronous structure but if the parameter CreateFlag is <code>0x1</code> then the message will be sent synchronously (<code>FltSendMessage</code>), in case is <code>0x0</code> it will be enqueued and the worker thread will take care of it.</p><p>I‚Äôll try to explain this as short and simple as possible. All async messages will be created with a function called <code>MpAsyncCreateNotification</code>. This function receives two parameters, first one is an outparam that will return a shifted pointer inside the allocated buffer that‚Äôs gonna be send as message, while the second parameter is the size to allocate.</p><p>So after that call we will end up with a buffer that needs to be filled with the specific data. And again, this buffer is shifted 8 bytes into the structure I named <code>AsyncMessageData</code>. This structure will look something like this</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _AsyncMessageData
{
  INT Magic;
  INT Size;
  INT64 NotificationNumber;
  DWORD SizeOfData;
  INT RefCount;
  INT TypeOfOperation;
  <span style="color:#ff79c6">union</span> {
    <span style="color:#6272a4">// This are the ones I have for now
</span><span style="color:#6272a4"></span>    ImageLoadAndProcessNotifyMessage ImageLoadAndProcessNotify;
    TrustedOrUntrustedProcessMessage TrustedProcess;
    ThreadNotifyMessage ThreadNotify;
    CheckJournalMessage CheckJournal;
  };
} AsyncMessageData, <span style="color:#ff79c6">*</span>PAsyncMessageData;</code></pre></div><p>As we can see, this struct contains a union where the specific data for each type of different message will start. In this case we will focus on the data regarding ProcessNotify, this structure looks something like this:</p><div class="highlight-wrapper"><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"> 
<span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> _ImageLoadAndProcessNotifyMessage
{
  AuxPidCreationTime ParentProcess;   <span style="color:#6272a4">// ZwOpenProcess -&gt; PsGetProcessCreateTimeQuadPart
</span><span style="color:#6272a4"></span>  AuxPidCreationTime CurrentProcess;  <span style="color:#6272a4">// ZwOpenProcess -&gt; PsGetProcessCreateTimeQuadPart
</span><span style="color:#6272a4"></span>  BYTE CreateFlag;
  BYTE ProcessFlags;
  BYTE UnkGap[<span style="color:#bd93f9">10</span>];  <span style="color:#6272a4">// Weird alignment :S 
</span><span style="color:#6272a4"></span>  DWORD FileNameLength;
  DWORD OffsetToImageFileName;
  DWORD SessionId;
  DWORD CommandLineLenght;
  DWORD OffsetToCommandLine;
  DWORD TokenElevationType;
  DWORD TokenElevation;
  DWORD TokenIntegrityLevel;
  DWORD Unk;
  AuxPidCreationTime CreatorProcess;  <span style="color:#6272a4">// Parameter -&gt; ParentPidAndCreationTime
</span><span style="color:#6272a4"></span>} ImageLoadAndProcessNotifyMessage, <span style="color:#ff79c6">*</span>PImageLoadAndProcessNotifyMessage;</code></pre></div></div><p>This would be the structure without a ImageFileName and without CommandLine, in case there is any of those or even both, the strings would be after this data and the members <code>OffsetToImageFileName</code> and <code>OffsetToCommandLine</code> would contain the relative offset to the start of each string (Relative from the start of the inner structure).</p><blockquote><p>The structure AuxPidCreationTime you can see inside the struct is just an strucutre containing the PID as a ULONG and the CreationTime as ULONG64. If anyone knows an already defined structure with that data please let me know and I‚Äôll change it.</p></blockquote><p><img src="https://n4r1b.com/images/wdFilter/part1/SendProcessMessage.png" alt="alt image" title="Send Process Message" class="medium-zoom-image"></p><p>Once the message is sent, in the case of using <code>FltSendMessage</code>, the function will proceed to check the status of the call and proceed to fill some fields of <strong>MpData</strong> accordingly</p><ul><li>FltSendMessageCount</li><li>FltSendMessageError - In case it failed</li><li>FltSendMessageStatusTimeout - In case the status was <code>STATUS_TIMEOUT</code></li></ul><p>If everything went well, the code will check the <code>ReplyBuffer</code> (First byte should be <code>0x5D</code> and Second Word should be <code>0x60</code>, Size of the reply message). Among the things this reply buffer can contain is wheter the creation of the process is allowed or not (Byte <code>0x48</code>)</p><p>And finally the last step before finishing is to set up the process info (Mainly with the information received from the <code>ReplyBuffer</code>) after doing that it will test the ProcessFlags ‚Äì <code>ProcessFlags &amp; 0x20 || ProcessFlags &amp; 0x18</code> ‚Äì to add the process either to the Trusted or Untrusted process list. This is done inside <code>MpSetTrustedProcess</code> or <code>MpSetUntrustedProcess</code> respectively, but the post is already long enought so we will see those functions in the next part!</p><h3 id="mppowerstatuscallback">MpPowerStatusCallback</h3><p>One last thing before finishing, I said before I was going to talk a bit about the power-setting callback routine registered during the initialization.</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">NTSTATUS <span style="color:#50fa7b">MpPowerStatusCallback</span>(
  LPCGUID SettingGuid, 
  PVOID Value, 
  ULONG ValueLength, 
  PVOID Context
  )
{
  <span style="color:#ff79c6">if</span> (Value <span style="color:#ff79c6">&amp;&amp;</span> Value <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">4</span> <span style="color:#ff79c6">&amp;&amp;</span> IsEqualGUID(SettingGuid, GUID_LOW_POWER_EPOCH)) {
    <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">*</span>(ULONG <span style="color:#ff79c6">*</span>) Value ) {
      <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">*</span>(ULONG <span style="color:#ff79c6">*</span>) Value <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span> ) {
        MpData<span style="color:#ff79c6">-&gt;</span>LowPowerEpochOn <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>;
        MpData<span style="color:#ff79c6">-&gt;</span>MachineUptime <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
      }
    } <span style="color:#ff79c6">else</span> {
      MpData<span style="color:#ff79c6">-&gt;</span>MachineUptime <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(ULONG64 <span style="color:#ff79c6">*</span>) <span style="color:#bd93f9">0xFFFFF78000000014</span>;
    }
  }
  <span style="color:#ff79c6">return</span> STATUS_SUCCESS;
}</code></pre></div><p>Because of my lack of knowledge on Power Management plus the fact that there‚Äôs practically non-info on that GUID and the only thing related to Microsoft and low power epoch I managed to find is this strucutre: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/pepfx/ns-pepfx-_pep_low_power_epoch" target="_blank">PEP_LOW_POWER_EPOCH</a> in the documentation, but actually it doesn‚Äôt explain much, just that is used for a deprecated notification. I‚Äôm not comfortable saying anything in regard to this function, I just put it here and if somebody knows more about this <strong>Please</strong> reach out to me! I would love to hear more about this.</p><h3 id="conclusion">Conclusion</h3><p>That‚Äôs gonna be all for this part, sorry for the <strong>Super</strong> long post I really tried to be as clear and concise as possible but there‚Äôs plenty of things going on in the driver, so things may seem a bit messy for now, but bear with me throughout all the posts things will start to make sense and I hope in the end we can glue everything together. As always, I hope you guys liked the post! We still have a long way ahead, this is just the tip of the iceberg, but slowly we‚Äôll get to the end! In the next post I‚Äôll be talking about the image load and thread creation callbacks, so I hope I‚Äôll see you there!</p><p>If there‚Äôs any mistake or something not clear, please don‚Äôt hesitate to reach out to me on twitter <a href="https://twitter.com/n4r1B" target="_blank">@n4r1b</a></p><h3 id="bonus">Bonus</h3><p>This little windbg script let us print whatever data we want from all the ProcessCtx in the system. We just need the symbols of WdFilter and tweak the command <code>!list</code> however we like.</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">r @$t0 <span style="color:#ff79c6">=</span> poi(poi(WdFilter<span style="color:#ff79c6">!</span>MpProcessTable)<span style="color:#ff79c6">+</span><span style="color:#bd93f9">180</span>); <span style="color:#6272a4">// Pointer to MpProcessTable-&gt;ProcessCtxArray
</span><span style="color:#6272a4"></span>.<span style="color:#ff79c6">for</span> (r $t1 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; @$t1 <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0x80</span>; r $t1 <span style="color:#ff79c6">=</span> @$t1<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>)  <span style="color:#6272a4">// Array size 0x80
</span><span style="color:#6272a4"></span>{  
  r @$t2 <span style="color:#ff79c6">=</span> @$t0<span style="color:#ff79c6">+</span><span style="color:#bd93f9">10</span><span style="color:#ff79c6">*</span>@$t1;                        <span style="color:#6272a4">// Move pointer to next LIST_ENTRY
</span><span style="color:#6272a4"></span>  .<span style="color:#ff79c6">if</span> ( @$t2 <span style="color:#ff79c6">==</span> poi(@$t2) ) {                   <span style="color:#6272a4">// Check if our pointer value is the same as Blink
</span><span style="color:#6272a4"></span>    .<span style="color:#ff79c6">continue</span>                                   
  } 
  .<span style="color:#ff79c6">else</span> {                                       <span style="color:#6272a4">// We walk the LIST_ENTRY and print whatever
</span><span style="color:#6272a4"></span>                                                <span style="color:#6272a4">// member we want from ProcessCtx in this case
</span><span style="color:#6272a4"></span>                                                <span style="color:#6272a4">// ProcessCtx.ProcessId and ProcessCtx.ProcessCmdLine 
</span><span style="color:#6272a4"></span>   <span style="color:#ff79c6">!</span>list <span style="color:#ff79c6">-</span>t nt<span style="color:#ff79c6">!</span>_LIST_ENTRY.Flink <span style="color:#ff79c6">-</span>x <span style="color:#f1fa8c">"dd @$extret+10 L1; dS /c100 poi(@$extret+20)"</span> <span style="color:#ff79c6">-</span>a <span style="color:#f1fa8c">"L1"</span> poi(@$t2) 
  } 
}
</code></pre></div><p>If you run the above script you should see something like this:</p><p><img src="https://n4r1b.com/images/wdFilter/part1/ListProcess.png" alt="alt image" title="List ProcessCtx" class="medium-zoom-image"></p></div></article><hr><div class="post-info"><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83.0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><path d="M7 7V7z"></path></svg><span class="tag"><a href="https://n4r1b.com/tags/wdfilter/">WdFilter</a></span>
<span class="tag"><a href="https://n4r1b.com/tags/minifilter/">MiniFilter</a></span>
<span class="tag"><a href="https://n4r1b.com/tags/windows-defender/">Windows Defender</a></span>
<span class="tag"><a href="https://n4r1b.com/tags/microsoft-security/">Microsoft Security</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg><span class="tag"><a href="https://n4r1b.com/categories/wdfilter/">WdFilter</a></span>
<span class="tag"><a href="https://n4r1b.com/categories/minifilter/">MiniFilter</a></span>
<span class="tag"><a href="https://n4r1b.com/categories/windows-defender/">Windows Defender</a></span>
<span class="tag"><a href="https://n4r1b.com/categories/microsoft-security/">Microsoft Security</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><path d="M14 2V8h6"></path><path d="M16 13H8z"></path><path d="M16 17H8z"></path><path d="M10 9H9 8"></path></svg>4793 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><path d="M16 2V6z"></path><path d="M8 2V6z"></path><path d="M3 10H21z"></path></svg>2020-01-29 00:00 +0000
(Last updated: 2020-04-18 20:44 +0000)</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-git-commit"><circle cx="12" cy="12" r="4"></circle><path d="M1.05 12H7z"></path><path d="M17.01 12H22.96z"></path></svg><a href="https://github.com/n4r1b/n4r1b-hugo/commit/ade56b98755bbb5a7a8e08dae9b3203beb5e7fc2" target="_blank" rel="noopener">ade56b9</a>
@ 2020-04-18</p></div><div class="pagination"><div class="pagination__buttons"><span class="button previous"><a href="https://n4r1b.com/posts/2020/02/dissecting-the-windows-defender-driver-wdfilter-part-2/"><span class="button__icon">‚Üê</span>
<span class="button__text">Dissecting the Windows Defender Driver - WdFilter (Part 2)</span></a></span>
<span class="button next"><a href="https://n4r1b.com/posts/2019/11/understanding-wdboot-windows-defender-elam/"><span class="button__text">Understanding WdBoot (Windows Defender ELAM)</span>
<span class="button__icon">‚Üí</span></a></span></div></div></main></div></div></body></html>